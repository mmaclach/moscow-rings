(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports={
  "api_token": "pk.eyJ1IjoidzhyIiwiYSI6InBWVUZaSDAifQ.lQUJXO6rqqAiKRR6VW8TEg",
  "mapquest_api_key": "tGrfqih5TzzcVSG8s1Vm282F8QrZ8Q8x",
  "l10n": {
    "ru-RU": {
      "search": "Поиск",
      "names": ["Красная Площадь", "Кремль", "Бульварное кольцо", "Садовое кольцо", "Третье Кольцо", "МКАД"]
    },
    "all": {
      "search": "Search",
      "names": ["Red square", "Kremlin", "Boulevard ring", "Garden Ring", "Third Transport Ring", "Moscow Ring Road (MKAD)"]
    }
  }
}

},{}],2:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/define-property"), __esModule: true };
},{"core-js/library/fn/object/define-property":7}],3:[function(require,module,exports){
"use strict";

exports["default"] = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

exports.__esModule = true;
},{}],4:[function(require,module,exports){
"use strict";

var _Object$defineProperty = require("babel-runtime/core-js/object/define-property")["default"];

exports["default"] = (function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;

      _Object$defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
})();

exports.__esModule = true;
},{"babel-runtime/core-js/object/define-property":2}],5:[function(require,module,exports){
"use strict";

exports["default"] = function (obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
};

exports.__esModule = true;
},{}],6:[function(require,module,exports){
"use strict";

exports["default"] = function (obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }

    newObj["default"] = obj;
    return newObj;
  }
};

exports.__esModule = true;
},{}],7:[function(require,module,exports){
var $ = require('../../modules/$');
module.exports = function defineProperty(it, key, desc){
  return $.setDesc(it, key, desc);
};
},{"../../modules/$":8}],8:[function(require,module,exports){
var $Object = Object;
module.exports = {
  create:     $Object.create,
  getProto:   $Object.getPrototypeOf,
  isEnum:     {}.propertyIsEnumerable,
  getDesc:    $Object.getOwnPropertyDescriptor,
  setDesc:    $Object.defineProperty,
  setDescs:   $Object.defineProperties,
  getKeys:    $Object.keys,
  getNames:   $Object.getOwnPropertyNames,
  getSymbols: $Object.getOwnPropertySymbols,
  each:       [].forEach
};
},{}],9:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
 *     on objects.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

function typedArraySupport () {
  function Bar () {}
  try {
    var arr = new Uint8Array(1)
    arr.foo = function () { return 42 }
    arr.constructor = Bar
    return arr.foo() === 42 && // typed array instances can be augmented
        arr.constructor === Bar && // constructor can be set
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (arg) {
  if (!(this instanceof Buffer)) {
    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
    if (arguments.length > 1) return new Buffer(arg, arguments[1])
    return new Buffer(arg)
  }

  this.length = 0
  this.parent = undefined

  // Common case.
  if (typeof arg === 'number') {
    return fromNumber(this, arg)
  }

  // Slightly less common case.
  if (typeof arg === 'string') {
    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
  }

  // Unusual.
  return fromObject(this, arg)
}

function fromNumber (that, length) {
  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < length; i++) {
      that[i] = 0
    }
  }
  return that
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

  // Assumption: byteLength() return value is always < kMaxLength.
  var length = byteLength(string, encoding) | 0
  that = allocate(that, length)

  that.write(string, encoding)
  return that
}

function fromObject (that, object) {
  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

  if (isArray(object)) return fromArray(that, object)

  if (object == null) {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (typeof ArrayBuffer !== 'undefined') {
    if (object.buffer instanceof ArrayBuffer) {
      return fromTypedArray(that, object)
    }
    if (object instanceof ArrayBuffer) {
      return fromArrayBuffer(that, object)
    }
  }

  if (object.length) return fromArrayLike(that, object)

  return fromJsonObject(that, object)
}

function fromBuffer (that, buffer) {
  var length = checked(buffer.length) | 0
  that = allocate(that, length)
  buffer.copy(that, 0, 0, length)
  return that
}

function fromArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Duplicate of fromArray() to keep fromArray() monomorphic.
function fromTypedArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  // Truncating the elements is probably not what people expect from typed
  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
  // of the old Buffer constructor.
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    array.byteLength
    that = Buffer._augment(new Uint8Array(array))
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromTypedArray(that, new Uint8Array(array))
  }
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
// Returns a zero-length buffer for inputs that don't conform to the spec.
function fromJsonObject (that, object) {
  var array
  var length = 0

  if (object.type === 'Buffer' && isArray(object.data)) {
    array = object.data
    length = checked(array.length) | 0
  }
  that = allocate(that, length)

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
}

function allocate (that, length) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = Buffer._augment(new Uint8Array(length))
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that.length = length
    that._isBuffer = true
  }

  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
  if (fromPool) that.parent = rootParent

  return that
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  var i = 0
  var len = Math.min(x, y)
  while (i < len) {
    if (a[i] !== b[i]) break

    ++i
  }

  if (i !== len) {
    x = a[i]
    y = b[i]
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buf = new Buffer(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

function byteLength (string, encoding) {
  if (typeof string !== 'string') string = '' + string

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'binary':
      // Deprecated
      case 'raw':
      case 'raws':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

function slowToString (encoding, start, end) {
  var loweredCase = false

  start = start | 0
  end = end === undefined || end === Infinity ? this.length : end | 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` is deprecated
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` is deprecated
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    var swap = encoding
    encoding = offset
    offset = length | 0
    length = swap
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; i--) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), targetStart)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":10,"ieee754":11,"is-array":12}],10:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],11:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],12:[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],13:[function(require,module,exports){
!function() {
  var d3 = {
    version: "3.5.6"
  };
  var d3_arraySlice = [].slice, d3_array = function(list) {
    return d3_arraySlice.call(list);
  };
  var d3_document = this.document;
  function d3_documentElement(node) {
    return node && (node.ownerDocument || node.document || node).documentElement;
  }
  function d3_window(node) {
    return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
  }
  if (d3_document) {
    try {
      d3_array(d3_document.documentElement.childNodes)[0].nodeType;
    } catch (e) {
      d3_array = function(list) {
        var i = list.length, array = new Array(i);
        while (i--) array[i] = list[i];
        return array;
      };
    }
  }
  if (!Date.now) Date.now = function() {
    return +new Date();
  };
  if (d3_document) {
    try {
      d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
    } catch (error) {
      var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
      d3_element_prototype.setAttribute = function(name, value) {
        d3_element_setAttribute.call(this, name, value + "");
      };
      d3_element_prototype.setAttributeNS = function(space, local, value) {
        d3_element_setAttributeNS.call(this, space, local, value + "");
      };
      d3_style_prototype.setProperty = function(name, value, priority) {
        d3_style_setProperty.call(this, name, value + "", priority);
      };
    }
  }
  d3.ascending = d3_ascending;
  function d3_ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }
  d3.descending = function(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  };
  d3.min = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
    }
    return a;
  };
  d3.max = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
    }
    return a;
  };
  d3.extent = function(array, f) {
    var i = -1, n = array.length, a, b, c;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = c = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = c = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    }
    return [ a, c ];
  };
  function d3_number(x) {
    return x === null ? NaN : +x;
  }
  function d3_numeric(x) {
    return !isNaN(x);
  }
  d3.sum = function(array, f) {
    var s = 0, n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = +array[i])) s += a;
    } else {
      while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
    }
    return s;
  };
  d3.mean = function(array, f) {
    var s = 0, n = array.length, a, i = -1, j = n;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;
    } else {
      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;
    }
    if (j) return s / j;
  };
  d3.quantile = function(values, p) {
    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
    return e ? v + e * (values[h] - v) : v;
  };
  d3.median = function(array, f) {
    var numbers = [], n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
    } else {
      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
    }
    if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);
  };
  d3.variance = function(array, f) {
    var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
    if (arguments.length === 1) {
      while (++i < n) {
        if (d3_numeric(a = d3_number(array[i]))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    } else {
      while (++i < n) {
        if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    }
    if (j > 1) return s / (j - 1);
  };
  d3.deviation = function() {
    var v = d3.variance.apply(this, arguments);
    return v ? Math.sqrt(v) : v;
  };
  function d3_bisector(compare) {
    return {
      left: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;
        }
        return lo;
      },
      right: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;
        }
        return lo;
      }
    };
  }
  var d3_bisect = d3_bisector(d3_ascending);
  d3.bisectLeft = d3_bisect.left;
  d3.bisect = d3.bisectRight = d3_bisect.right;
  d3.bisector = function(f) {
    return d3_bisector(f.length === 1 ? function(d, x) {
      return d3_ascending(f(d), x);
    } : f);
  };
  d3.shuffle = function(array, i0, i1) {
    if ((m = arguments.length) < 3) {
      i1 = array.length;
      if (m < 2) i0 = 0;
    }
    var m = i1 - i0, t, i;
    while (m) {
      i = Math.random() * m-- | 0;
      t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
    }
    return array;
  };
  d3.permute = function(array, indexes) {
    var i = indexes.length, permutes = new Array(i);
    while (i--) permutes[i] = array[indexes[i]];
    return permutes;
  };
  d3.pairs = function(array) {
    var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
    while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];
    return pairs;
  };
  d3.zip = function() {
    if (!(n = arguments.length)) return [];
    for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m; ) {
      for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n; ) {
        zip[j] = arguments[j][i];
      }
    }
    return zips;
  };
  function d3_zipLength(d) {
    return d.length;
  }
  d3.transpose = function(matrix) {
    return d3.zip.apply(d3, matrix);
  };
  d3.keys = function(map) {
    var keys = [];
    for (var key in map) keys.push(key);
    return keys;
  };
  d3.values = function(map) {
    var values = [];
    for (var key in map) values.push(map[key]);
    return values;
  };
  d3.entries = function(map) {
    var entries = [];
    for (var key in map) entries.push({
      key: key,
      value: map[key]
    });
    return entries;
  };
  d3.merge = function(arrays) {
    var n = arrays.length, m, i = -1, j = 0, merged, array;
    while (++i < n) j += arrays[i].length;
    merged = new Array(j);
    while (--n >= 0) {
      array = arrays[n];
      m = array.length;
      while (--m >= 0) {
        merged[--j] = array[m];
      }
    }
    return merged;
  };
  var abs = Math.abs;
  d3.range = function(start, stop, step) {
    if (arguments.length < 3) {
      step = 1;
      if (arguments.length < 2) {
        stop = start;
        start = 0;
      }
    }
    if ((stop - start) / step === Infinity) throw new Error("infinite range");
    var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
    start *= k, stop *= k, step *= k;
    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
    return range;
  };
  function d3_range_integerScale(x) {
    var k = 1;
    while (x * k % 1) k *= 10;
    return k;
  }
  function d3_class(ctor, properties) {
    for (var key in properties) {
      Object.defineProperty(ctor.prototype, key, {
        value: properties[key],
        enumerable: false
      });
    }
  }
  d3.map = function(object, f) {
    var map = new d3_Map();
    if (object instanceof d3_Map) {
      object.forEach(function(key, value) {
        map.set(key, value);
      });
    } else if (Array.isArray(object)) {
      var i = -1, n = object.length, o;
      if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);
    } else {
      for (var key in object) map.set(key, object[key]);
    }
    return map;
  };
  function d3_Map() {
    this._ = Object.create(null);
  }
  var d3_map_proto = "__proto__", d3_map_zero = "\x00";
  d3_class(d3_Map, {
    has: d3_map_has,
    get: function(key) {
      return this._[d3_map_escape(key)];
    },
    set: function(key, value) {
      return this._[d3_map_escape(key)] = value;
    },
    remove: d3_map_remove,
    keys: d3_map_keys,
    values: function() {
      var values = [];
      for (var key in this._) values.push(this._[key]);
      return values;
    },
    entries: function() {
      var entries = [];
      for (var key in this._) entries.push({
        key: d3_map_unescape(key),
        value: this._[key]
      });
      return entries;
    },
    size: d3_map_size,
    empty: d3_map_empty,
    forEach: function(f) {
      for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
    }
  });
  function d3_map_escape(key) {
    return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
  }
  function d3_map_unescape(key) {
    return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
  }
  function d3_map_has(key) {
    return d3_map_escape(key) in this._;
  }
  function d3_map_remove(key) {
    return (key = d3_map_escape(key)) in this._ && delete this._[key];
  }
  function d3_map_keys() {
    var keys = [];
    for (var key in this._) keys.push(d3_map_unescape(key));
    return keys;
  }
  function d3_map_size() {
    var size = 0;
    for (var key in this._) ++size;
    return size;
  }
  function d3_map_empty() {
    for (var key in this._) return false;
    return true;
  }
  d3.nest = function() {
    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
    function map(mapType, array, depth) {
      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
      var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
      while (++i < n) {
        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
          values.push(object);
        } else {
          valuesByKey.set(keyValue, [ object ]);
        }
      }
      if (mapType) {
        object = mapType();
        setter = function(keyValue, values) {
          object.set(keyValue, map(mapType, values, depth));
        };
      } else {
        object = {};
        setter = function(keyValue, values) {
          object[keyValue] = map(mapType, values, depth);
        };
      }
      valuesByKey.forEach(setter);
      return object;
    }
    function entries(map, depth) {
      if (depth >= keys.length) return map;
      var array = [], sortKey = sortKeys[depth++];
      map.forEach(function(key, keyMap) {
        array.push({
          key: key,
          values: entries(keyMap, depth)
        });
      });
      return sortKey ? array.sort(function(a, b) {
        return sortKey(a.key, b.key);
      }) : array;
    }
    nest.map = function(array, mapType) {
      return map(mapType, array, 0);
    };
    nest.entries = function(array) {
      return entries(map(d3.map, array, 0), 0);
    };
    nest.key = function(d) {
      keys.push(d);
      return nest;
    };
    nest.sortKeys = function(order) {
      sortKeys[keys.length - 1] = order;
      return nest;
    };
    nest.sortValues = function(order) {
      sortValues = order;
      return nest;
    };
    nest.rollup = function(f) {
      rollup = f;
      return nest;
    };
    return nest;
  };
  d3.set = function(array) {
    var set = new d3_Set();
    if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
    return set;
  };
  function d3_Set() {
    this._ = Object.create(null);
  }
  d3_class(d3_Set, {
    has: d3_map_has,
    add: function(key) {
      this._[d3_map_escape(key += "")] = true;
      return key;
    },
    remove: d3_map_remove,
    values: d3_map_keys,
    size: d3_map_size,
    empty: d3_map_empty,
    forEach: function(f) {
      for (var key in this._) f.call(this, d3_map_unescape(key));
    }
  });
  d3.behavior = {};
  function d3_identity(d) {
    return d;
  }
  d3.rebind = function(target, source) {
    var i = 1, n = arguments.length, method;
    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
    return target;
  };
  function d3_rebind(target, source, method) {
    return function() {
      var value = method.apply(source, arguments);
      return value === source ? target : value;
    };
  }
  function d3_vendorSymbol(object, name) {
    if (name in object) return name;
    name = name.charAt(0).toUpperCase() + name.slice(1);
    for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
      var prefixName = d3_vendorPrefixes[i] + name;
      if (prefixName in object) return prefixName;
    }
  }
  var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ];
  function d3_noop() {}
  d3.dispatch = function() {
    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    return dispatch;
  };
  function d3_dispatch() {}
  d3_dispatch.prototype.on = function(type, listener) {
    var i = type.indexOf("."), name = "";
    if (i >= 0) {
      name = type.slice(i + 1);
      type = type.slice(0, i);
    }
    if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
    if (arguments.length === 2) {
      if (listener == null) for (type in this) {
        if (this.hasOwnProperty(type)) this[type].on(name, null);
      }
      return this;
    }
  };
  function d3_dispatch_event(dispatch) {
    var listeners = [], listenerByName = new d3_Map();
    function event() {
      var z = listeners, i = -1, n = z.length, l;
      while (++i < n) if (l = z[i].on) l.apply(this, arguments);
      return dispatch;
    }
    event.on = function(name, listener) {
      var l = listenerByName.get(name), i;
      if (arguments.length < 2) return l && l.on;
      if (l) {
        l.on = null;
        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
        listenerByName.remove(name);
      }
      if (listener) listeners.push(listenerByName.set(name, {
        on: listener
      }));
      return dispatch;
    };
    return event;
  }
  d3.event = null;
  function d3_eventPreventDefault() {
    d3.event.preventDefault();
  }
  function d3_eventSource() {
    var e = d3.event, s;
    while (s = e.sourceEvent) e = s;
    return e;
  }
  function d3_eventDispatch(target) {
    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    dispatch.of = function(thiz, argumentz) {
      return function(e1) {
        try {
          var e0 = e1.sourceEvent = d3.event;
          e1.target = target;
          d3.event = e1;
          dispatch[e1.type].apply(thiz, argumentz);
        } finally {
          d3.event = e0;
        }
      };
    };
    return dispatch;
  }
  d3.requote = function(s) {
    return s.replace(d3_requote_re, "\\$&");
  };
  var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
  var d3_subclass = {}.__proto__ ? function(object, prototype) {
    object.__proto__ = prototype;
  } : function(object, prototype) {
    for (var property in prototype) object[property] = prototype[property];
  };
  function d3_selection(groups) {
    d3_subclass(groups, d3_selectionPrototype);
    return groups;
  }
  var d3_select = function(s, n) {
    return n.querySelector(s);
  }, d3_selectAll = function(s, n) {
    return n.querySelectorAll(s);
  }, d3_selectMatches = function(n, s) {
    var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
    d3_selectMatches = function(n, s) {
      return d3_selectMatcher.call(n, s);
    };
    return d3_selectMatches(n, s);
  };
  if (typeof Sizzle === "function") {
    d3_select = function(s, n) {
      return Sizzle(s, n)[0] || null;
    };
    d3_selectAll = Sizzle;
    d3_selectMatches = Sizzle.matchesSelector;
  }
  d3.selection = function() {
    return d3.select(d3_document.documentElement);
  };
  var d3_selectionPrototype = d3.selection.prototype = [];
  d3_selectionPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, group, node;
    selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(subnode = selector.call(node, node.__data__, i, j));
          if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selector(selector) {
    return typeof selector === "function" ? selector : function() {
      return d3_select(selector, this);
    };
  }
  d3_selectionPrototype.selectAll = function(selector) {
    var subgroups = [], subgroup, node;
    selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
          subgroup.parentNode = node;
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selectorAll(selector) {
    return typeof selector === "function" ? selector : function() {
      return d3_selectAll(selector, this);
    };
  }
  var d3_nsPrefix = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: "http://www.w3.org/1999/xhtml",
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };
  d3.ns = {
    prefix: d3_nsPrefix,
    qualify: function(name) {
      var i = name.indexOf(":"), prefix = name;
      if (i >= 0) {
        prefix = name.slice(0, i);
        name = name.slice(i + 1);
      }
      return d3_nsPrefix.hasOwnProperty(prefix) ? {
        space: d3_nsPrefix[prefix],
        local: name
      } : name;
    }
  };
  d3_selectionPrototype.attr = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node();
        name = d3.ns.qualify(name);
        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
      }
      for (value in name) this.each(d3_selection_attr(value, name[value]));
      return this;
    }
    return this.each(d3_selection_attr(name, value));
  };
  function d3_selection_attr(name, value) {
    name = d3.ns.qualify(name);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrConstant() {
      this.setAttribute(name, value);
    }
    function attrConstantNS() {
      this.setAttributeNS(name.space, name.local, value);
    }
    function attrFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
    }
    function attrFunctionNS() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
    }
    return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
  }
  function d3_collapse(s) {
    return s.trim().replace(/\s+/g, " ");
  }
  d3_selectionPrototype.classed = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
        if (value = node.classList) {
          while (++i < n) if (!value.contains(name[i])) return false;
        } else {
          value = node.getAttribute("class");
          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
        }
        return true;
      }
      for (value in name) this.each(d3_selection_classed(value, name[value]));
      return this;
    }
    return this.each(d3_selection_classed(name, value));
  };
  function d3_selection_classedRe(name) {
    return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
  }
  function d3_selection_classes(name) {
    return (name + "").trim().split(/^|\s+/);
  }
  function d3_selection_classed(name, value) {
    name = d3_selection_classes(name).map(d3_selection_classedName);
    var n = name.length;
    function classedConstant() {
      var i = -1;
      while (++i < n) name[i](this, value);
    }
    function classedFunction() {
      var i = -1, x = value.apply(this, arguments);
      while (++i < n) name[i](this, x);
    }
    return typeof value === "function" ? classedFunction : classedConstant;
  }
  function d3_selection_classedName(name) {
    var re = d3_selection_classedRe(name);
    return function(node, value) {
      if (c = node.classList) return value ? c.add(name) : c.remove(name);
      var c = node.getAttribute("class") || "";
      if (value) {
        re.lastIndex = 0;
        if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
      } else {
        node.setAttribute("class", d3_collapse(c.replace(re, " ")));
      }
    };
  }
  d3_selectionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
        return this;
      }
      if (n < 2) {
        var node = this.node();
        return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
      }
      priority = "";
    }
    return this.each(d3_selection_style(name, value, priority));
  };
  function d3_selection_style(name, value, priority) {
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleConstant() {
      this.style.setProperty(name, value, priority);
    }
    function styleFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
    }
    return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
  }
  d3_selectionPrototype.property = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") return this.node()[name];
      for (value in name) this.each(d3_selection_property(value, name[value]));
      return this;
    }
    return this.each(d3_selection_property(name, value));
  };
  function d3_selection_property(name, value) {
    function propertyNull() {
      delete this[name];
    }
    function propertyConstant() {
      this[name] = value;
    }
    function propertyFunction() {
      var x = value.apply(this, arguments);
      if (x == null) delete this[name]; else this[name] = x;
    }
    return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
  }
  d3_selectionPrototype.text = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    } : value == null ? function() {
      this.textContent = "";
    } : function() {
      this.textContent = value;
    }) : this.node().textContent;
  };
  d3_selectionPrototype.html = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    } : value == null ? function() {
      this.innerHTML = "";
    } : function() {
      this.innerHTML = value;
    }) : this.node().innerHTML;
  };
  d3_selectionPrototype.append = function(name) {
    name = d3_selection_creator(name);
    return this.select(function() {
      return this.appendChild(name.apply(this, arguments));
    });
  };
  function d3_selection_creator(name) {
    function create() {
      var document = this.ownerDocument, namespace = this.namespaceURI;
      return namespace ? document.createElementNS(namespace, name) : document.createElement(name);
    }
    function createNS() {
      return this.ownerDocument.createElementNS(name.space, name.local);
    }
    return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
  }
  d3_selectionPrototype.insert = function(name, before) {
    name = d3_selection_creator(name);
    before = d3_selection_selector(before);
    return this.select(function() {
      return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
    });
  };
  d3_selectionPrototype.remove = function() {
    return this.each(d3_selectionRemove);
  };
  function d3_selectionRemove() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  }
  d3_selectionPrototype.data = function(value, key) {
    var i = -1, n = this.length, group, node;
    if (!arguments.length) {
      value = new Array(n = (group = this[0]).length);
      while (++i < n) {
        if (node = group[i]) {
          value[i] = node.__data__;
        }
      }
      return value;
    }
    function bind(group, groupData) {
      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
      if (key) {
        var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
        for (i = -1; ++i < n; ) {
          if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {
            exitNodes[i] = node;
          } else {
            nodeByKeyValue.set(keyValue, node);
          }
          keyValues[i] = keyValue;
        }
        for (i = -1; ++i < m; ) {
          if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          } else if (node !== true) {
            updateNodes[i] = node;
            node.__data__ = nodeData;
          }
          nodeByKeyValue.set(keyValue, true);
        }
        for (i = -1; ++i < n; ) {
          if (nodeByKeyValue.get(keyValues[i]) !== true) {
            exitNodes[i] = group[i];
          }
        }
      } else {
        for (i = -1; ++i < n0; ) {
          node = group[i];
          nodeData = groupData[i];
          if (node) {
            node.__data__ = nodeData;
            updateNodes[i] = node;
          } else {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          }
        }
        for (;i < m; ++i) {
          enterNodes[i] = d3_selection_dataNode(groupData[i]);
        }
        for (;i < n; ++i) {
          exitNodes[i] = group[i];
        }
      }
      enterNodes.update = updateNodes;
      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
      enter.push(enterNodes);
      update.push(updateNodes);
      exit.push(exitNodes);
    }
    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
    if (typeof value === "function") {
      while (++i < n) {
        bind(group = this[i], value.call(group, group.parentNode.__data__, i));
      }
    } else {
      while (++i < n) {
        bind(group = this[i], value);
      }
    }
    update.enter = function() {
      return enter;
    };
    update.exit = function() {
      return exit;
    };
    return update;
  };
  function d3_selection_dataNode(data) {
    return {
      __data__: data
    };
  }
  d3_selectionPrototype.datum = function(value) {
    return arguments.length ? this.property("__data__", value) : this.property("__data__");
  };
  d3_selectionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
          subgroup.push(node);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_filter(selector) {
    return function() {
      return d3_selectMatches(this, selector);
    };
  }
  d3_selectionPrototype.order = function() {
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
        if (node = group[i]) {
          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }
    return this;
  };
  d3_selectionPrototype.sort = function(comparator) {
    comparator = d3_selection_sortComparator.apply(this, arguments);
    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
    return this.order();
  };
  function d3_selection_sortComparator(comparator) {
    if (!arguments.length) comparator = d3_ascending;
    return function(a, b) {
      return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
    };
  }
  d3_selectionPrototype.each = function(callback) {
    return d3_selection_each(this, function(node, i, j) {
      callback.call(node, node.__data__, i, j);
    });
  };
  function d3_selection_each(groups, callback) {
    for (var j = 0, m = groups.length; j < m; j++) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
        if (node = group[i]) callback(node, i, j);
      }
    }
    return groups;
  }
  d3_selectionPrototype.call = function(callback) {
    var args = d3_array(arguments);
    callback.apply(args[0] = this, args);
    return this;
  };
  d3_selectionPrototype.empty = function() {
    return !this.node();
  };
  d3_selectionPrototype.node = function() {
    for (var j = 0, m = this.length; j < m; j++) {
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        var node = group[i];
        if (node) return node;
      }
    }
    return null;
  };
  d3_selectionPrototype.size = function() {
    var n = 0;
    d3_selection_each(this, function() {
      ++n;
    });
    return n;
  };
  function d3_selection_enter(selection) {
    d3_subclass(selection, d3_selection_enterPrototype);
    return selection;
  }
  var d3_selection_enterPrototype = [];
  d3.selection.enter = d3_selection_enter;
  d3.selection.enter.prototype = d3_selection_enterPrototype;
  d3_selection_enterPrototype.append = d3_selectionPrototype.append;
  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
  d3_selection_enterPrototype.node = d3_selectionPrototype.node;
  d3_selection_enterPrototype.call = d3_selectionPrototype.call;
  d3_selection_enterPrototype.size = d3_selectionPrototype.size;
  d3_selection_enterPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, upgroup, group, node;
    for (var j = -1, m = this.length; ++j < m; ) {
      upgroup = (group = this[j]).update;
      subgroups.push(subgroup = []);
      subgroup.parentNode = group.parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
          subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  d3_selection_enterPrototype.insert = function(name, before) {
    if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
    return d3_selectionPrototype.insert.call(this, name, before);
  };
  function d3_selection_enterInsertBefore(enter) {
    var i0, j0;
    return function(d, i, j) {
      var group = enter[j].update, n = group.length, node;
      if (j != j0) j0 = j, i0 = 0;
      if (i >= i0) i0 = i + 1;
      while (!(node = group[i0]) && ++i0 < n) ;
      return node;
    };
  }
  d3.select = function(node) {
    var group;
    if (typeof node === "string") {
      group = [ d3_select(node, d3_document) ];
      group.parentNode = d3_document.documentElement;
    } else {
      group = [ node ];
      group.parentNode = d3_documentElement(node);
    }
    return d3_selection([ group ]);
  };
  d3.selectAll = function(nodes) {
    var group;
    if (typeof nodes === "string") {
      group = d3_array(d3_selectAll(nodes, d3_document));
      group.parentNode = d3_document.documentElement;
    } else {
      group = nodes;
      group.parentNode = null;
    }
    return d3_selection([ group ]);
  };
  d3_selectionPrototype.on = function(type, listener, capture) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof type !== "string") {
        if (n < 2) listener = false;
        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
        return this;
      }
      if (n < 2) return (n = this.node()["__on" + type]) && n._;
      capture = false;
    }
    return this.each(d3_selection_on(type, listener, capture));
  };
  function d3_selection_on(type, listener, capture) {
    var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
    if (i > 0) type = type.slice(0, i);
    var filter = d3_selection_onFilters.get(type);
    if (filter) type = filter, wrap = d3_selection_onFilter;
    function onRemove() {
      var l = this[name];
      if (l) {
        this.removeEventListener(type, l, l.$);
        delete this[name];
      }
    }
    function onAdd() {
      var l = wrap(listener, d3_array(arguments));
      onRemove.call(this);
      this.addEventListener(type, this[name] = l, l.$ = capture);
      l._ = listener;
    }
    function removeAll() {
      var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
      for (var name in this) {
        if (match = name.match(re)) {
          var l = this[name];
          this.removeEventListener(match[1], l, l.$);
          delete this[name];
        }
      }
    }
    return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
  }
  var d3_selection_onFilters = d3.map({
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  });
  if (d3_document) {
    d3_selection_onFilters.forEach(function(k) {
      if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
    });
  }
  function d3_selection_onListener(listener, argumentz) {
    return function(e) {
      var o = d3.event;
      d3.event = e;
      argumentz[0] = this.__data__;
      try {
        listener.apply(this, argumentz);
      } finally {
        d3.event = o;
      }
    };
  }
  function d3_selection_onFilter(listener, argumentz) {
    var l = d3_selection_onListener(listener, argumentz);
    return function(e) {
      var target = this, related = e.relatedTarget;
      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
        l.call(target, e);
      }
    };
  }
  var d3_event_dragSelect, d3_event_dragId = 0;
  function d3_event_dragSuppress(node) {
    var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
    if (d3_event_dragSelect == null) {
      d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
    }
    if (d3_event_dragSelect) {
      var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
      style[d3_event_dragSelect] = "none";
    }
    return function(suppressClick) {
      w.on(name, null);
      if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
      if (suppressClick) {
        var off = function() {
          w.on(click, null);
        };
        w.on(click, function() {
          d3_eventPreventDefault();
          off();
        }, true);
        setTimeout(off, 0);
      }
    };
  }
  d3.mouse = function(container) {
    return d3_mousePoint(container, d3_eventSource());
  };
  var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
  function d3_mousePoint(container, e) {
    if (e.changedTouches) e = e.changedTouches[0];
    var svg = container.ownerSVGElement || container;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      if (d3_mouse_bug44083 < 0) {
        var window = d3_window(container);
        if (window.scrollX || window.scrollY) {
          svg = d3.select("body").append("svg").style({
            position: "absolute",
            top: 0,
            left: 0,
            margin: 0,
            padding: 0,
            border: "none"
          }, "important");
          var ctm = svg[0][0].getScreenCTM();
          d3_mouse_bug44083 = !(ctm.f || ctm.e);
          svg.remove();
        }
      }
      if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, 
      point.y = e.clientY;
      point = point.matrixTransform(container.getScreenCTM().inverse());
      return [ point.x, point.y ];
    }
    var rect = container.getBoundingClientRect();
    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
  }
  d3.touch = function(container, touches, identifier) {
    if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
    if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
      if ((touch = touches[i]).identifier === identifier) {
        return d3_mousePoint(container, touch);
      }
    }
  };
  d3.behavior.drag = function() {
    var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
    function drag() {
      this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
    }
    function dragstart(id, position, subject, move, end) {
      return function() {
        var that = this, target = d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
        if (origin) {
          dragOffset = origin.apply(that, arguments);
          dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];
        } else {
          dragOffset = [ 0, 0 ];
        }
        dispatch({
          type: "dragstart"
        });
        function moved() {
          var position1 = position(parent, dragId), dx, dy;
          if (!position1) return;
          dx = position1[0] - position0[0];
          dy = position1[1] - position0[1];
          dragged |= dx | dy;
          position0 = position1;
          dispatch({
            type: "drag",
            x: position1[0] + dragOffset[0],
            y: position1[1] + dragOffset[1],
            dx: dx,
            dy: dy
          });
        }
        function ended() {
          if (!position(parent, dragId)) return;
          dragSubject.on(move + dragName, null).on(end + dragName, null);
          dragRestore(dragged && d3.event.target === target);
          dispatch({
            type: "dragend"
          });
        }
      };
    }
    drag.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return drag;
    };
    return d3.rebind(drag, event, "on");
  };
  function d3_behavior_dragTouchId() {
    return d3.event.changedTouches[0].identifier;
  }
  d3.touches = function(container, touches) {
    if (arguments.length < 2) touches = d3_eventSource().touches;
    return touches ? d3_array(touches).map(function(touch) {
      var point = d3_mousePoint(container, touch);
      point.identifier = touch.identifier;
      return point;
    }) : [];
  };
  var ε = 1e-6, ε2 = ε * ε, π = Math.PI, τ = 2 * π, τε = τ - ε, halfπ = π / 2, d3_radians = π / 180, d3_degrees = 180 / π;
  function d3_sgn(x) {
    return x > 0 ? 1 : x < 0 ? -1 : 0;
  }
  function d3_cross2d(a, b, c) {
    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
  }
  function d3_acos(x) {
    return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
  }
  function d3_asin(x) {
    return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
  }
  function d3_sinh(x) {
    return ((x = Math.exp(x)) - 1 / x) / 2;
  }
  function d3_cosh(x) {
    return ((x = Math.exp(x)) + 1 / x) / 2;
  }
  function d3_tanh(x) {
    return ((x = Math.exp(2 * x)) - 1) / (x + 1);
  }
  function d3_haversin(x) {
    return (x = Math.sin(x / 2)) * x;
  }
  var ρ = Math.SQRT2, ρ2 = 2, ρ4 = 4;
  d3.interpolateZoom = function(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2];
    var dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1), b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1), dr = r1 - r0, S = (dr || Math.log(w1 / w0)) / ρ;
    function interpolate(t) {
      var s = t * S;
      if (dr) {
        var coshr0 = d3_cosh(r0), u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));
        return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0) ];
      }
      return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * s) ];
    }
    interpolate.duration = S * 1e3;
    return interpolate;
  };
  d3.behavior.zoom = function() {
    var view = {
      x: 0,
      y: 0,
      k: 1
    }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
    if (!d3_behavior_zoomWheel) {
      d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
        return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
      }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
        return d3.event.wheelDelta;
      }, "mousewheel") : (d3_behavior_zoomDelta = function() {
        return -d3.event.detail;
      }, "MozMousePixelScroll");
    }
    function zoom(g) {
      g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
    }
    zoom.event = function(g) {
      g.each(function() {
        var dispatch = event.of(this, arguments), view1 = view;
        if (d3_transitionInheritId) {
          d3.select(this).transition().each("start.zoom", function() {
            view = this.__chart__ || {
              x: 0,
              y: 0,
              k: 1
            };
            zoomstarted(dispatch);
          }).tween("zoom:zoom", function() {
            var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);
            return function(t) {
              var l = i(t), k = dx / l[2];
              this.__chart__ = view = {
                x: cx - l[0] * k,
                y: cy - l[1] * k,
                k: k
              };
              zoomed(dispatch);
            };
          }).each("interrupt.zoom", function() {
            zoomended(dispatch);
          }).each("end.zoom", function() {
            zoomended(dispatch);
          });
        } else {
          this.__chart__ = view;
          zoomstarted(dispatch);
          zoomed(dispatch);
          zoomended(dispatch);
        }
      });
    };
    zoom.translate = function(_) {
      if (!arguments.length) return [ view.x, view.y ];
      view = {
        x: +_[0],
        y: +_[1],
        k: view.k
      };
      rescale();
      return zoom;
    };
    zoom.scale = function(_) {
      if (!arguments.length) return view.k;
      view = {
        x: view.x,
        y: view.y,
        k: +_
      };
      rescale();
      return zoom;
    };
    zoom.scaleExtent = function(_) {
      if (!arguments.length) return scaleExtent;
      scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.center = function(_) {
      if (!arguments.length) return center;
      center = _ && [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.size = function(_) {
      if (!arguments.length) return size;
      size = _ && [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.duration = function(_) {
      if (!arguments.length) return duration;
      duration = +_;
      return zoom;
    };
    zoom.x = function(z) {
      if (!arguments.length) return x1;
      x1 = z;
      x0 = z.copy();
      view = {
        x: 0,
        y: 0,
        k: 1
      };
      return zoom;
    };
    zoom.y = function(z) {
      if (!arguments.length) return y1;
      y1 = z;
      y0 = z.copy();
      view = {
        x: 0,
        y: 0,
        k: 1
      };
      return zoom;
    };
    function location(p) {
      return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];
    }
    function point(l) {
      return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];
    }
    function scaleTo(s) {
      view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
    }
    function translateTo(p, l) {
      l = point(l);
      view.x += p[0] - l[0];
      view.y += p[1] - l[1];
    }
    function zoomTo(that, p, l, k) {
      that.__chart__ = {
        x: view.x,
        y: view.y,
        k: view.k
      };
      scaleTo(Math.pow(2, k));
      translateTo(center0 = p, l);
      that = d3.select(that);
      if (duration > 0) that = that.transition().duration(duration);
      that.call(zoom.event);
    }
    function rescale() {
      if (x1) x1.domain(x0.range().map(function(x) {
        return (x - view.x) / view.k;
      }).map(x0.invert));
      if (y1) y1.domain(y0.range().map(function(y) {
        return (y - view.y) / view.k;
      }).map(y0.invert));
    }
    function zoomstarted(dispatch) {
      if (!zooming++) dispatch({
        type: "zoomstart"
      });
    }
    function zoomed(dispatch) {
      rescale();
      dispatch({
        type: "zoom",
        scale: view.k,
        translate: [ view.x, view.y ]
      });
    }
    function zoomended(dispatch) {
      if (!--zooming) dispatch({
        type: "zoomend"
      }), center0 = null;
    }
    function mousedowned() {
      var that = this, target = d3.event.target, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);
      d3_selection_interrupt.call(that);
      zoomstarted(dispatch);
      function moved() {
        dragged = 1;
        translateTo(d3.mouse(that), location0);
        zoomed(dispatch);
      }
      function ended() {
        subject.on(mousemove, null).on(mouseup, null);
        dragRestore(dragged && d3.event.target === target);
        zoomended(dispatch);
      }
    }
    function touchstarted() {
      var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
      started();
      zoomstarted(dispatch);
      subject.on(mousedown, null).on(touchstart, started);
      function relocate() {
        var touches = d3.touches(that);
        scale0 = view.k;
        touches.forEach(function(t) {
          if (t.identifier in locations0) locations0[t.identifier] = location(t);
        });
        return touches;
      }
      function started() {
        var target = d3.event.target;
        d3.select(target).on(touchmove, moved).on(touchend, ended);
        targets.push(target);
        var changed = d3.event.changedTouches;
        for (var i = 0, n = changed.length; i < n; ++i) {
          locations0[changed[i].identifier] = null;
        }
        var touches = relocate(), now = Date.now();
        if (touches.length === 1) {
          if (now - touchtime < 500) {
            var p = touches[0];
            zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
            d3_eventPreventDefault();
          }
          touchtime = now;
        } else if (touches.length > 1) {
          var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
          distance0 = dx * dx + dy * dy;
        }
      }
      function moved() {
        var touches = d3.touches(that), p0, l0, p1, l1;
        d3_selection_interrupt.call(that);
        for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
          p1 = touches[i];
          if (l1 = locations0[p1.identifier]) {
            if (l0) break;
            p0 = p1, l0 = l1;
          }
        }
        if (l1) {
          var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
          p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
          l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
          scaleTo(scale1 * scale0);
        }
        touchtime = null;
        translateTo(p0, l0);
        zoomed(dispatch);
      }
      function ended() {
        if (d3.event.touches.length) {
          var changed = d3.event.changedTouches;
          for (var i = 0, n = changed.length; i < n; ++i) {
            delete locations0[changed[i].identifier];
          }
          for (var identifier in locations0) {
            return void relocate();
          }
        }
        d3.selectAll(targets).on(zoomName, null);
        subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
        dragRestore();
        zoomended(dispatch);
      }
    }
    function mousewheeled() {
      var dispatch = event.of(this, arguments);
      if (mousewheelTimer) clearTimeout(mousewheelTimer); else d3_selection_interrupt.call(this), 
      translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);
      mousewheelTimer = setTimeout(function() {
        mousewheelTimer = null;
        zoomended(dispatch);
      }, 50);
      d3_eventPreventDefault();
      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
      translateTo(center0, translate0);
      zoomed(dispatch);
    }
    function dblclicked() {
      var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
      zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
    }
    return d3.rebind(zoom, event, "on");
  };
  var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
  d3.color = d3_color;
  function d3_color() {}
  d3_color.prototype.toString = function() {
    return this.rgb() + "";
  };
  d3.hsl = d3_hsl;
  function d3_hsl(h, s, l) {
    return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
  }
  var d3_hslPrototype = d3_hsl.prototype = new d3_color();
  d3_hslPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_hsl(this.h, this.s, this.l / k);
  };
  d3_hslPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_hsl(this.h, this.s, k * this.l);
  };
  d3_hslPrototype.rgb = function() {
    return d3_hsl_rgb(this.h, this.s, this.l);
  };
  function d3_hsl_rgb(h, s, l) {
    var m1, m2;
    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
    l = l < 0 ? 0 : l > 1 ? 1 : l;
    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
    m1 = 2 * l - m2;
    function v(h) {
      if (h > 360) h -= 360; else if (h < 0) h += 360;
      if (h < 60) return m1 + (m2 - m1) * h / 60;
      if (h < 180) return m2;
      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
      return m1;
    }
    function vv(h) {
      return Math.round(v(h) * 255);
    }
    return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
  }
  d3.hcl = d3_hcl;
  function d3_hcl(h, c, l) {
    return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
  }
  var d3_hclPrototype = d3_hcl.prototype = new d3_color();
  d3_hclPrototype.brighter = function(k) {
    return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.darker = function(k) {
    return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.rgb = function() {
    return d3_hcl_lab(this.h, this.c, this.l).rgb();
  };
  function d3_hcl_lab(h, c, l) {
    if (isNaN(h)) h = 0;
    if (isNaN(c)) c = 0;
    return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
  }
  d3.lab = d3_lab;
  function d3_lab(l, a, b) {
    return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
  }
  var d3_lab_K = 18;
  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
  var d3_labPrototype = d3_lab.prototype = new d3_color();
  d3_labPrototype.brighter = function(k) {
    return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.darker = function(k) {
    return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.rgb = function() {
    return d3_lab_rgb(this.l, this.a, this.b);
  };
  function d3_lab_rgb(l, a, b) {
    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
    x = d3_lab_xyz(x) * d3_lab_X;
    y = d3_lab_xyz(y) * d3_lab_Y;
    z = d3_lab_xyz(z) * d3_lab_Z;
    return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
  }
  function d3_lab_hcl(l, a, b) {
    return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
  }
  function d3_lab_xyz(x) {
    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
  }
  function d3_xyz_lab(x) {
    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
  }
  function d3_xyz_rgb(r) {
    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
  }
  d3.rgb = d3_rgb;
  function d3_rgb(r, g, b) {
    return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
  }
  function d3_rgbNumber(value) {
    return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
  }
  function d3_rgbString(value) {
    return d3_rgbNumber(value) + "";
  }
  var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
  d3_rgbPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    var r = this.r, g = this.g, b = this.b, i = 30;
    if (!r && !g && !b) return new d3_rgb(i, i, i);
    if (r && r < i) r = i;
    if (g && g < i) g = i;
    if (b && b < i) b = i;
    return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
  };
  d3_rgbPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_rgb(k * this.r, k * this.g, k * this.b);
  };
  d3_rgbPrototype.hsl = function() {
    return d3_rgb_hsl(this.r, this.g, this.b);
  };
  d3_rgbPrototype.toString = function() {
    return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
  };
  function d3_rgb_hex(v) {
    return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
  }
  function d3_rgb_parse(format, rgb, hsl) {
    format = format.toLowerCase();
    var r = 0, g = 0, b = 0, m1, m2, color;
    m1 = /([a-z]+)\((.*)\)/.exec(format);
    if (m1) {
      m2 = m1[2].split(",");
      switch (m1[1]) {
       case "hsl":
        {
          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
        }

       case "rgb":
        {
          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
        }
      }
    }
    if (color = d3_rgb_names.get(format)) {
      return rgb(color.r, color.g, color.b);
    }
    if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
      if (format.length === 4) {
        r = (color & 3840) >> 4;
        r = r >> 4 | r;
        g = color & 240;
        g = g >> 4 | g;
        b = color & 15;
        b = b << 4 | b;
      } else if (format.length === 7) {
        r = (color & 16711680) >> 16;
        g = (color & 65280) >> 8;
        b = color & 255;
      }
    }
    return rgb(r, g, b);
  }
  function d3_rgb_hsl(r, g, b) {
    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
    if (d) {
      s = l < .5 ? d / (max + min) : d / (2 - max - min);
      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
      h *= 60;
    } else {
      h = NaN;
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new d3_hsl(h, s, l);
  }
  function d3_rgb_lab(r, g, b) {
    r = d3_rgb_xyz(r);
    g = d3_rgb_xyz(g);
    b = d3_rgb_xyz(b);
    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
  }
  function d3_rgb_xyz(r) {
    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
  }
  function d3_rgb_parseNumber(c) {
    var f = parseFloat(c);
    return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
  }
  var d3_rgb_names = d3.map({
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  });
  d3_rgb_names.forEach(function(key, value) {
    d3_rgb_names.set(key, d3_rgbNumber(value));
  });
  function d3_functor(v) {
    return typeof v === "function" ? v : function() {
      return v;
    };
  }
  d3.functor = d3_functor;
  d3.xhr = d3_xhrType(d3_identity);
  function d3_xhrType(response) {
    return function(url, mimeType, callback) {
      if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, 
      mimeType = null;
      return d3_xhr(url, mimeType, response, callback);
    };
  }
  function d3_xhr(url, mimeType, response, callback) {
    var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
    if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
    "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
      request.readyState > 3 && respond();
    };
    function respond() {
      var status = request.status, result;
      if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
        try {
          result = response.call(xhr, request);
        } catch (e) {
          dispatch.error.call(xhr, e);
          return;
        }
        dispatch.load.call(xhr, result);
      } else {
        dispatch.error.call(xhr, request);
      }
    }
    request.onprogress = function(event) {
      var o = d3.event;
      d3.event = event;
      try {
        dispatch.progress.call(xhr, request);
      } finally {
        d3.event = o;
      }
    };
    xhr.header = function(name, value) {
      name = (name + "").toLowerCase();
      if (arguments.length < 2) return headers[name];
      if (value == null) delete headers[name]; else headers[name] = value + "";
      return xhr;
    };
    xhr.mimeType = function(value) {
      if (!arguments.length) return mimeType;
      mimeType = value == null ? null : value + "";
      return xhr;
    };
    xhr.responseType = function(value) {
      if (!arguments.length) return responseType;
      responseType = value;
      return xhr;
    };
    xhr.response = function(value) {
      response = value;
      return xhr;
    };
    [ "get", "post" ].forEach(function(method) {
      xhr[method] = function() {
        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
      };
    });
    xhr.send = function(method, data, callback) {
      if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
      request.open(method, url, true);
      if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
      if (responseType != null) request.responseType = responseType;
      if (callback != null) xhr.on("error", callback).on("load", function(request) {
        callback(null, request);
      });
      dispatch.beforesend.call(xhr, request);
      request.send(data == null ? null : data);
      return xhr;
    };
    xhr.abort = function() {
      request.abort();
      return xhr;
    };
    d3.rebind(xhr, dispatch, "on");
    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
  }
  function d3_xhr_fixCallback(callback) {
    return callback.length === 1 ? function(error, request) {
      callback(error == null ? request : null);
    } : callback;
  }
  function d3_xhrHasResponse(request) {
    var type = request.responseType;
    return type && type !== "text" ? request.response : request.responseText;
  }
  d3.dsv = function(delimiter, mimeType) {
    var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
    function dsv(url, row, callback) {
      if (arguments.length < 3) callback = row, row = null;
      var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
      xhr.row = function(_) {
        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
      };
      return xhr;
    }
    function response(request) {
      return dsv.parse(request.responseText);
    }
    function typedResponse(f) {
      return function(request) {
        return dsv.parse(request.responseText, f);
      };
    }
    dsv.parse = function(text, f) {
      var o;
      return dsv.parseRows(text, function(row, i) {
        if (o) return o(row, i - 1);
        var a = new Function("d", "return {" + row.map(function(name, i) {
          return JSON.stringify(name) + ": d[" + i + "]";
        }).join(",") + "}");
        o = f ? function(row, i) {
          return f(a(row), i);
        } : a;
      });
    };
    dsv.parseRows = function(text, f) {
      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
      function token() {
        if (I >= N) return EOF;
        if (eol) return eol = false, EOL;
        var j = I;
        if (text.charCodeAt(j) === 34) {
          var i = j;
          while (i++ < N) {
            if (text.charCodeAt(i) === 34) {
              if (text.charCodeAt(i + 1) !== 34) break;
              ++i;
            }
          }
          I = i + 2;
          var c = text.charCodeAt(i + 1);
          if (c === 13) {
            eol = true;
            if (text.charCodeAt(i + 2) === 10) ++I;
          } else if (c === 10) {
            eol = true;
          }
          return text.slice(j + 1, i).replace(/""/g, '"');
        }
        while (I < N) {
          var c = text.charCodeAt(I++), k = 1;
          if (c === 10) eol = true; else if (c === 13) {
            eol = true;
            if (text.charCodeAt(I) === 10) ++I, ++k;
          } else if (c !== delimiterCode) continue;
          return text.slice(j, I - k);
        }
        return text.slice(j);
      }
      while ((t = token()) !== EOF) {
        var a = [];
        while (t !== EOL && t !== EOF) {
          a.push(t);
          t = token();
        }
        if (f && (a = f(a, n++)) == null) continue;
        rows.push(a);
      }
      return rows;
    };
    dsv.format = function(rows) {
      if (Array.isArray(rows[0])) return dsv.formatRows(rows);
      var fieldSet = new d3_Set(), fields = [];
      rows.forEach(function(row) {
        for (var field in row) {
          if (!fieldSet.has(field)) {
            fields.push(fieldSet.add(field));
          }
        }
      });
      return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
        return fields.map(function(field) {
          return formatValue(row[field]);
        }).join(delimiter);
      })).join("\n");
    };
    dsv.formatRows = function(rows) {
      return rows.map(formatRow).join("\n");
    };
    function formatRow(row) {
      return row.map(formatValue).join(delimiter);
    }
    function formatValue(text) {
      return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
    }
    return dsv;
  };
  d3.csv = d3.dsv(",", "text/csv");
  d3.tsv = d3.dsv("	", "text/tab-separated-values");
  var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_active, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) {
    setTimeout(callback, 17);
  };
  d3.timer = function(callback, delay, then) {
    var n = arguments.length;
    if (n < 2) delay = 0;
    if (n < 3) then = Date.now();
    var time = then + delay, timer = {
      c: callback,
      t: time,
      f: false,
      n: null
    };
    if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;
    d3_timer_queueTail = timer;
    if (!d3_timer_interval) {
      d3_timer_timeout = clearTimeout(d3_timer_timeout);
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
  };
  function d3_timer_step() {
    var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
    if (delay > 24) {
      if (isFinite(delay)) {
        clearTimeout(d3_timer_timeout);
        d3_timer_timeout = setTimeout(d3_timer_step, delay);
      }
      d3_timer_interval = 0;
    } else {
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
  }
  d3.timer.flush = function() {
    d3_timer_mark();
    d3_timer_sweep();
  };
  function d3_timer_mark() {
    var now = Date.now();
    d3_timer_active = d3_timer_queueHead;
    while (d3_timer_active) {
      if (now >= d3_timer_active.t) d3_timer_active.f = d3_timer_active.c(now - d3_timer_active.t);
      d3_timer_active = d3_timer_active.n;
    }
    return now;
  }
  function d3_timer_sweep() {
    var t0, t1 = d3_timer_queueHead, time = Infinity;
    while (t1) {
      if (t1.f) {
        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
      } else {
        if (t1.t < time) time = t1.t;
        t1 = (t0 = t1).n;
      }
    }
    d3_timer_queueTail = t0;
    return time;
  }
  function d3_format_precision(x, p) {
    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
  }
  d3.round = function(x, n) {
    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
  };
  var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
  d3.formatPrefix = function(value, precision) {
    var i = 0;
    if (value) {
      if (value < 0) value *= -1;
      if (precision) value = d3.round(value, d3_format_precision(value, precision));
      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
      i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
    }
    return d3_formatPrefixes[8 + i / 3];
  };
  function d3_formatPrefix(d, i) {
    var k = Math.pow(10, abs(8 - i) * 3);
    return {
      scale: i > 8 ? function(d) {
        return d / k;
      } : function(d) {
        return d * k;
      },
      symbol: d
    };
  }
  function d3_locale_numberFormat(locale) {
    var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {
      var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;
      while (i > 0 && g > 0) {
        if (length + g + 1 > width) g = Math.max(1, width - length);
        t.push(value.substring(i -= g, i + g));
        if ((length += g + 1) > width) break;
        g = locale_grouping[j = (j + 1) % locale_grouping.length];
      }
      return t.reverse().join(locale_thousands);
    } : d3_identity;
    return function(specifier) {
      var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = false, exponent = true;
      if (precision) precision = +precision.substring(1);
      if (zfill || fill === "0" && align === "=") {
        zfill = fill = "0";
        align = "=";
      }
      switch (type) {
       case "n":
        comma = true;
        type = "g";
        break;

       case "%":
        scale = 100;
        suffix = "%";
        type = "f";
        break;

       case "p":
        scale = 100;
        suffix = "%";
        type = "r";
        break;

       case "b":
       case "o":
       case "x":
       case "X":
        if (symbol === "#") prefix = "0" + type.toLowerCase();

       case "c":
        exponent = false;

       case "d":
        integer = true;
        precision = 0;
        break;

       case "s":
        scale = -1;
        type = "r";
        break;
      }
      if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1];
      if (type == "r" && !precision) type = "g";
      if (precision != null) {
        if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
      }
      type = d3_format_types.get(type) || d3_format_typeDefault;
      var zcomma = zfill && comma;
      return function(value) {
        var fullSuffix = suffix;
        if (integer && value % 1) return "";
        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
        if (scale < 0) {
          var unit = d3.formatPrefix(value, precision);
          value = unit.scale(value);
          fullSuffix = unit.symbol + suffix;
        } else {
          value *= scale;
        }
        value = type(value, precision);
        var i = value.lastIndexOf("."), before, after;
        if (i < 0) {
          var j = exponent ? value.lastIndexOf("e") : -1;
          if (j < 0) before = value, after = ""; else before = value.substring(0, j), after = value.substring(j);
        } else {
          before = value.substring(0, i);
          after = locale_decimal + value.substring(i + 1);
        }
        if (!zfill && comma) before = formatGroup(before, Infinity);
        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
        if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
        negative += prefix;
        value = before + after;
        return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
      };
    };
  }
  var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
  var d3_format_types = d3.map({
    b: function(x) {
      return x.toString(2);
    },
    c: function(x) {
      return String.fromCharCode(x);
    },
    o: function(x) {
      return x.toString(8);
    },
    x: function(x) {
      return x.toString(16);
    },
    X: function(x) {
      return x.toString(16).toUpperCase();
    },
    g: function(x, p) {
      return x.toPrecision(p);
    },
    e: function(x, p) {
      return x.toExponential(p);
    },
    f: function(x, p) {
      return x.toFixed(p);
    },
    r: function(x, p) {
      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
    }
  });
  function d3_format_typeDefault(x) {
    return x + "";
  }
  var d3_time = d3.time = {}, d3_date = Date;
  function d3_date_utc() {
    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
  }
  d3_date_utc.prototype = {
    getDate: function() {
      return this._.getUTCDate();
    },
    getDay: function() {
      return this._.getUTCDay();
    },
    getFullYear: function() {
      return this._.getUTCFullYear();
    },
    getHours: function() {
      return this._.getUTCHours();
    },
    getMilliseconds: function() {
      return this._.getUTCMilliseconds();
    },
    getMinutes: function() {
      return this._.getUTCMinutes();
    },
    getMonth: function() {
      return this._.getUTCMonth();
    },
    getSeconds: function() {
      return this._.getUTCSeconds();
    },
    getTime: function() {
      return this._.getTime();
    },
    getTimezoneOffset: function() {
      return 0;
    },
    valueOf: function() {
      return this._.valueOf();
    },
    setDate: function() {
      d3_time_prototype.setUTCDate.apply(this._, arguments);
    },
    setDay: function() {
      d3_time_prototype.setUTCDay.apply(this._, arguments);
    },
    setFullYear: function() {
      d3_time_prototype.setUTCFullYear.apply(this._, arguments);
    },
    setHours: function() {
      d3_time_prototype.setUTCHours.apply(this._, arguments);
    },
    setMilliseconds: function() {
      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
    },
    setMinutes: function() {
      d3_time_prototype.setUTCMinutes.apply(this._, arguments);
    },
    setMonth: function() {
      d3_time_prototype.setUTCMonth.apply(this._, arguments);
    },
    setSeconds: function() {
      d3_time_prototype.setUTCSeconds.apply(this._, arguments);
    },
    setTime: function() {
      d3_time_prototype.setTime.apply(this._, arguments);
    }
  };
  var d3_time_prototype = Date.prototype;
  function d3_time_interval(local, step, number) {
    function round(date) {
      var d0 = local(date), d1 = offset(d0, 1);
      return date - d0 < d1 - date ? d0 : d1;
    }
    function ceil(date) {
      step(date = local(new d3_date(date - 1)), 1);
      return date;
    }
    function offset(date, k) {
      step(date = new d3_date(+date), k);
      return date;
    }
    function range(t0, t1, dt) {
      var time = ceil(t0), times = [];
      if (dt > 1) {
        while (time < t1) {
          if (!(number(time) % dt)) times.push(new Date(+time));
          step(time, 1);
        }
      } else {
        while (time < t1) times.push(new Date(+time)), step(time, 1);
      }
      return times;
    }
    function range_utc(t0, t1, dt) {
      try {
        d3_date = d3_date_utc;
        var utc = new d3_date_utc();
        utc._ = t0;
        return range(utc, t1, dt);
      } finally {
        d3_date = Date;
      }
    }
    local.floor = local;
    local.round = round;
    local.ceil = ceil;
    local.offset = offset;
    local.range = range;
    var utc = local.utc = d3_time_interval_utc(local);
    utc.floor = utc;
    utc.round = d3_time_interval_utc(round);
    utc.ceil = d3_time_interval_utc(ceil);
    utc.offset = d3_time_interval_utc(offset);
    utc.range = range_utc;
    return local;
  }
  function d3_time_interval_utc(method) {
    return function(date, k) {
      try {
        d3_date = d3_date_utc;
        var utc = new d3_date_utc();
        utc._ = date;
        return method(utc, k)._;
      } finally {
        d3_date = Date;
      }
    };
  }
  d3_time.year = d3_time_interval(function(date) {
    date = d3_time.day(date);
    date.setMonth(0, 1);
    return date;
  }, function(date, offset) {
    date.setFullYear(date.getFullYear() + offset);
  }, function(date) {
    return date.getFullYear();
  });
  d3_time.years = d3_time.year.range;
  d3_time.years.utc = d3_time.year.utc.range;
  d3_time.day = d3_time_interval(function(date) {
    var day = new d3_date(2e3, 0);
    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
    return day;
  }, function(date, offset) {
    date.setDate(date.getDate() + offset);
  }, function(date) {
    return date.getDate() - 1;
  });
  d3_time.days = d3_time.day.range;
  d3_time.days.utc = d3_time.day.utc.range;
  d3_time.dayOfYear = function(date) {
    var year = d3_time.year(date);
    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
  };
  [ "sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday" ].forEach(function(day, i) {
    i = 7 - i;
    var interval = d3_time[day] = d3_time_interval(function(date) {
      (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
      return date;
    }, function(date, offset) {
      date.setDate(date.getDate() + Math.floor(offset) * 7);
    }, function(date) {
      var day = d3_time.year(date).getDay();
      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
    });
    d3_time[day + "s"] = interval.range;
    d3_time[day + "s"].utc = interval.utc.range;
    d3_time[day + "OfYear"] = function(date) {
      var day = d3_time.year(date).getDay();
      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
    };
  });
  d3_time.week = d3_time.sunday;
  d3_time.weeks = d3_time.sunday.range;
  d3_time.weeks.utc = d3_time.sunday.utc.range;
  d3_time.weekOfYear = d3_time.sundayOfYear;
  function d3_locale_timeFormat(locale) {
    var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
    function d3_time_format(template) {
      var n = template.length;
      function format(date) {
        var string = [], i = -1, j = 0, c, p, f;
        while (++i < n) {
          if (template.charCodeAt(i) === 37) {
            string.push(template.slice(j, i));
            if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
            if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
            string.push(c);
            j = i + 1;
          }
        }
        string.push(template.slice(j, i));
        return string.join("");
      }
      format.parse = function(string) {
        var d = {
          y: 1900,
          m: 0,
          d: 1,
          H: 0,
          M: 0,
          S: 0,
          L: 0,
          Z: null
        }, i = d3_time_parse(d, template, string, 0);
        if (i != string.length) return null;
        if ("p" in d) d.H = d.H % 12 + d.p * 12;
        var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
        if ("j" in d) date.setFullYear(d.y, 0, d.j); else if ("w" in d && ("W" in d || "U" in d)) {
          date.setFullYear(d.y, 0, 1);
          date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
        } else date.setFullYear(d.y, d.m, d.d);
        date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
        return localZ ? date._ : date;
      };
      format.toString = function() {
        return template;
      };
      return format;
    }
    function d3_time_parse(date, template, string, j) {
      var c, p, t, i = 0, n = template.length, m = string.length;
      while (i < n) {
        if (j >= m) return -1;
        c = template.charCodeAt(i++);
        if (c === 37) {
          t = template.charAt(i++);
          p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
          if (!p || (j = p(date, string, j)) < 0) return -1;
        } else if (c != string.charCodeAt(j++)) {
          return -1;
        }
      }
      return j;
    }
    d3_time_format.utc = function(template) {
      var local = d3_time_format(template);
      function format(date) {
        try {
          d3_date = d3_date_utc;
          var utc = new d3_date();
          utc._ = date;
          return local(utc);
        } finally {
          d3_date = Date;
        }
      }
      format.parse = function(string) {
        try {
          d3_date = d3_date_utc;
          var date = local.parse(string);
          return date && date._;
        } finally {
          d3_date = Date;
        }
      };
      format.toString = local.toString;
      return format;
    };
    d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
    var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
    locale_periods.forEach(function(p, i) {
      d3_time_periodLookup.set(p.toLowerCase(), i);
    });
    var d3_time_formats = {
      a: function(d) {
        return locale_shortDays[d.getDay()];
      },
      A: function(d) {
        return locale_days[d.getDay()];
      },
      b: function(d) {
        return locale_shortMonths[d.getMonth()];
      },
      B: function(d) {
        return locale_months[d.getMonth()];
      },
      c: d3_time_format(locale_dateTime),
      d: function(d, p) {
        return d3_time_formatPad(d.getDate(), p, 2);
      },
      e: function(d, p) {
        return d3_time_formatPad(d.getDate(), p, 2);
      },
      H: function(d, p) {
        return d3_time_formatPad(d.getHours(), p, 2);
      },
      I: function(d, p) {
        return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
      },
      j: function(d, p) {
        return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
      },
      L: function(d, p) {
        return d3_time_formatPad(d.getMilliseconds(), p, 3);
      },
      m: function(d, p) {
        return d3_time_formatPad(d.getMonth() + 1, p, 2);
      },
      M: function(d, p) {
        return d3_time_formatPad(d.getMinutes(), p, 2);
      },
      p: function(d) {
        return locale_periods[+(d.getHours() >= 12)];
      },
      S: function(d, p) {
        return d3_time_formatPad(d.getSeconds(), p, 2);
      },
      U: function(d, p) {
        return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
      },
      w: function(d) {
        return d.getDay();
      },
      W: function(d, p) {
        return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
      },
      x: d3_time_format(locale_date),
      X: d3_time_format(locale_time),
      y: function(d, p) {
        return d3_time_formatPad(d.getFullYear() % 100, p, 2);
      },
      Y: function(d, p) {
        return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
      },
      Z: d3_time_zone,
      "%": function() {
        return "%";
      }
    };
    var d3_time_parsers = {
      a: d3_time_parseWeekdayAbbrev,
      A: d3_time_parseWeekday,
      b: d3_time_parseMonthAbbrev,
      B: d3_time_parseMonth,
      c: d3_time_parseLocaleFull,
      d: d3_time_parseDay,
      e: d3_time_parseDay,
      H: d3_time_parseHour24,
      I: d3_time_parseHour24,
      j: d3_time_parseDayOfYear,
      L: d3_time_parseMilliseconds,
      m: d3_time_parseMonthNumber,
      M: d3_time_parseMinutes,
      p: d3_time_parseAmPm,
      S: d3_time_parseSeconds,
      U: d3_time_parseWeekNumberSunday,
      w: d3_time_parseWeekdayNumber,
      W: d3_time_parseWeekNumberMonday,
      x: d3_time_parseLocaleDate,
      X: d3_time_parseLocaleTime,
      y: d3_time_parseYear,
      Y: d3_time_parseFullYear,
      Z: d3_time_parseZone,
      "%": d3_time_parseLiteralPercent
    };
    function d3_time_parseWeekdayAbbrev(date, string, i) {
      d3_time_dayAbbrevRe.lastIndex = 0;
      var n = d3_time_dayAbbrevRe.exec(string.slice(i));
      return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseWeekday(date, string, i) {
      d3_time_dayRe.lastIndex = 0;
      var n = d3_time_dayRe.exec(string.slice(i));
      return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseMonthAbbrev(date, string, i) {
      d3_time_monthAbbrevRe.lastIndex = 0;
      var n = d3_time_monthAbbrevRe.exec(string.slice(i));
      return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseMonth(date, string, i) {
      d3_time_monthRe.lastIndex = 0;
      var n = d3_time_monthRe.exec(string.slice(i));
      return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseLocaleFull(date, string, i) {
      return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
    }
    function d3_time_parseLocaleDate(date, string, i) {
      return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
    }
    function d3_time_parseLocaleTime(date, string, i) {
      return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
    }
    function d3_time_parseAmPm(date, string, i) {
      var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
      return n == null ? -1 : (date.p = n, i);
    }
    return d3_time_format;
  }
  var d3_time_formatPads = {
    "-": "",
    _: " ",
    "0": "0"
  }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
  function d3_time_formatPad(value, fill, width) {
    var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
  }
  function d3_time_formatRe(names) {
    return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
  }
  function d3_time_formatLookup(names) {
    var map = new d3_Map(), i = -1, n = names.length;
    while (++i < n) map.set(names[i].toLowerCase(), i);
    return map;
  }
  function d3_time_parseWeekdayNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 1));
    return n ? (date.w = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseWeekNumberSunday(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i));
    return n ? (date.U = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseWeekNumberMonday(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i));
    return n ? (date.W = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseFullYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 4));
    return n ? (date.y = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
  }
  function d3_time_parseZone(date, string, i) {
    return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, 
    i + 5) : -1;
  }
  function d3_time_expandYear(d) {
    return d + (d > 68 ? 1900 : 2e3);
  }
  function d3_time_parseMonthNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
  }
  function d3_time_parseDay(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.d = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseDayOfYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
    return n ? (date.j = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseHour24(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.H = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseMinutes(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.M = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseSeconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.S = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseMilliseconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
    return n ? (date.L = +n[0], i + n[0].length) : -1;
  }
  function d3_time_zone(d) {
    var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = abs(z) / 60 | 0, zm = abs(z) % 60;
    return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
  }
  function d3_time_parseLiteralPercent(date, string, i) {
    d3_time_percentRe.lastIndex = 0;
    var n = d3_time_percentRe.exec(string.slice(i, i + 1));
    return n ? i + n[0].length : -1;
  }
  function d3_time_formatMulti(formats) {
    var n = formats.length, i = -1;
    while (++i < n) formats[i][0] = this(formats[i][0]);
    return function(date) {
      var i = 0, f = formats[i];
      while (!f[1](date)) f = formats[++i];
      return f[0](date);
    };
  }
  d3.locale = function(locale) {
    return {
      numberFormat: d3_locale_numberFormat(locale),
      timeFormat: d3_locale_timeFormat(locale)
    };
  };
  var d3_locale_enUS = d3.locale({
    decimal: ".",
    thousands: ",",
    grouping: [ 3 ],
    currency: [ "$", "" ],
    dateTime: "%a %b %e %X %Y",
    date: "%m/%d/%Y",
    time: "%H:%M:%S",
    periods: [ "AM", "PM" ],
    days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
    shortDays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
    months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
    shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ]
  });
  d3.format = d3_locale_enUS.numberFormat;
  d3.geo = {};
  function d3_adder() {}
  d3_adder.prototype = {
    s: 0,
    t: 0,
    add: function(y) {
      d3_adderSum(y, this.t, d3_adderTemp);
      d3_adderSum(d3_adderTemp.s, this.s, this);
      if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;
    },
    reset: function() {
      this.s = this.t = 0;
    },
    valueOf: function() {
      return this.s;
    }
  };
  var d3_adderTemp = new d3_adder();
  function d3_adderSum(a, b, o) {
    var x = o.s = a + b, bv = x - a, av = x - bv;
    o.t = a - av + (b - bv);
  }
  d3.geo.stream = function(object, listener) {
    if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
      d3_geo_streamObjectType[object.type](object, listener);
    } else {
      d3_geo_streamGeometry(object, listener);
    }
  };
  function d3_geo_streamGeometry(geometry, listener) {
    if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
      d3_geo_streamGeometryType[geometry.type](geometry, listener);
    }
  }
  var d3_geo_streamObjectType = {
    Feature: function(feature, listener) {
      d3_geo_streamGeometry(feature.geometry, listener);
    },
    FeatureCollection: function(object, listener) {
      var features = object.features, i = -1, n = features.length;
      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
    }
  };
  var d3_geo_streamGeometryType = {
    Sphere: function(object, listener) {
      listener.sphere();
    },
    Point: function(object, listener) {
      object = object.coordinates;
      listener.point(object[0], object[1], object[2]);
    },
    MultiPoint: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);
    },
    LineString: function(object, listener) {
      d3_geo_streamLine(object.coordinates, listener, 0);
    },
    MultiLineString: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
    },
    Polygon: function(object, listener) {
      d3_geo_streamPolygon(object.coordinates, listener);
    },
    MultiPolygon: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
    },
    GeometryCollection: function(object, listener) {
      var geometries = object.geometries, i = -1, n = geometries.length;
      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
    }
  };
  function d3_geo_streamLine(coordinates, listener, closed) {
    var i = -1, n = coordinates.length - closed, coordinate;
    listener.lineStart();
    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
    listener.lineEnd();
  }
  function d3_geo_streamPolygon(coordinates, listener) {
    var i = -1, n = coordinates.length;
    listener.polygonStart();
    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
    listener.polygonEnd();
  }
  d3.geo.area = function(object) {
    d3_geo_areaSum = 0;
    d3.geo.stream(object, d3_geo_area);
    return d3_geo_areaSum;
  };
  var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
  var d3_geo_area = {
    sphere: function() {
      d3_geo_areaSum += 4 * π;
    },
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_areaRingSum.reset();
      d3_geo_area.lineStart = d3_geo_areaRingStart;
    },
    polygonEnd: function() {
      var area = 2 * d3_geo_areaRingSum;
      d3_geo_areaSum += area < 0 ? 4 * π + area : area;
      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
    }
  };
  function d3_geo_areaRingStart() {
    var λ00, φ00, λ0, cosφ0, sinφ0;
    d3_geo_area.point = function(λ, φ) {
      d3_geo_area.point = nextPoint;
      λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), 
      sinφ0 = Math.sin(φ);
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      φ = φ * d3_radians / 2 + π / 4;
      var dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u = cosφ0 * cosφ + k * Math.cos(adλ), v = k * sdλ * Math.sin(adλ);
      d3_geo_areaRingSum.add(Math.atan2(v, u));
      λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
    }
    d3_geo_area.lineEnd = function() {
      nextPoint(λ00, φ00);
    };
  }
  function d3_geo_cartesian(spherical) {
    var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);
    return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ];
  }
  function d3_geo_cartesianDot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  function d3_geo_cartesianCross(a, b) {
    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
  }
  function d3_geo_cartesianAdd(a, b) {
    a[0] += b[0];
    a[1] += b[1];
    a[2] += b[2];
  }
  function d3_geo_cartesianScale(vector, k) {
    return [ vector[0] * k, vector[1] * k, vector[2] * k ];
  }
  function d3_geo_cartesianNormalize(d) {
    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
    d[0] /= l;
    d[1] /= l;
    d[2] /= l;
  }
  function d3_geo_spherical(cartesian) {
    return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];
  }
  function d3_geo_sphericalEqual(a, b) {
    return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;
  }
  d3.geo.bounds = function() {
    var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range;
    var bound = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() {
        bound.point = ringPoint;
        bound.lineStart = ringStart;
        bound.lineEnd = ringEnd;
        dλSum = 0;
        d3_geo_area.polygonStart();
      },
      polygonEnd: function() {
        d3_geo_area.polygonEnd();
        bound.point = point;
        bound.lineStart = lineStart;
        bound.lineEnd = lineEnd;
        if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90); else if (dλSum > ε) φ1 = 90; else if (dλSum < -ε) φ0 = -90;
        range[0] = λ0, range[1] = λ1;
      }
    };
    function point(λ, φ) {
      ranges.push(range = [ λ0 = λ, λ1 = λ ]);
      if (φ < φ0) φ0 = φ;
      if (φ > φ1) φ1 = φ;
    }
    function linePoint(λ, φ) {
      var p = d3_geo_cartesian([ λ * d3_radians, φ * d3_radians ]);
      if (p0) {
        var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);
        d3_geo_cartesianNormalize(inflection);
        inflection = d3_geo_spherical(inflection);
        var dλ = λ - λ_, s = dλ > 0 ? 1 : -1, λi = inflection[0] * d3_degrees * s, antimeridian = abs(dλ) > 180;
        if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
          var φi = inflection[1] * d3_degrees;
          if (φi > φ1) φ1 = φi;
        } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
          var φi = -inflection[1] * d3_degrees;
          if (φi < φ0) φ0 = φi;
        } else {
          if (φ < φ0) φ0 = φ;
          if (φ > φ1) φ1 = φ;
        }
        if (antimeridian) {
          if (λ < λ_) {
            if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
          } else {
            if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
          }
        } else {
          if (λ1 >= λ0) {
            if (λ < λ0) λ0 = λ;
            if (λ > λ1) λ1 = λ;
          } else {
            if (λ > λ_) {
              if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
            } else {
              if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
            }
          }
        }
      } else {
        point(λ, φ);
      }
      p0 = p, λ_ = λ;
    }
    function lineStart() {
      bound.point = linePoint;
    }
    function lineEnd() {
      range[0] = λ0, range[1] = λ1;
      bound.point = point;
      p0 = null;
    }
    function ringPoint(λ, φ) {
      if (p0) {
        var dλ = λ - λ_;
        dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;
      } else λ__ = λ, φ__ = φ;
      d3_geo_area.point(λ, φ);
      linePoint(λ, φ);
    }
    function ringStart() {
      d3_geo_area.lineStart();
    }
    function ringEnd() {
      ringPoint(λ__, φ__);
      d3_geo_area.lineEnd();
      if (abs(dλSum) > ε) λ0 = -(λ1 = 180);
      range[0] = λ0, range[1] = λ1;
      p0 = null;
    }
    function angle(λ0, λ1) {
      return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;
    }
    function compareRanges(a, b) {
      return a[0] - b[0];
    }
    function withinRange(x, range) {
      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
    }
    return function(feature) {
      φ1 = λ1 = -(λ0 = φ0 = Infinity);
      ranges = [];
      d3.geo.stream(feature, bound);
      var n = ranges.length;
      if (n) {
        ranges.sort(compareRanges);
        for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {
          b = ranges[i];
          if (withinRange(b[0], a) || withinRange(b[1], a)) {
            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
          } else {
            merged.push(a = b);
          }
        }
        var best = -Infinity, dλ;
        for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
          b = merged[i];
          if ((dλ = angle(a[1], b[0])) > best) best = dλ, λ0 = b[0], λ1 = a[1];
        }
      }
      ranges = range = null;
      return λ0 === Infinity || φ0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ λ0, φ0 ], [ λ1, φ1 ] ];
    };
  }();
  d3.geo.centroid = function(object) {
    d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
    d3.geo.stream(object, d3_geo_centroid);
    var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
    if (m < ε2) {
      x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
      if (d3_geo_centroidW1 < ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
      m = x * x + y * y + z * z;
      if (m < ε2) return [ NaN, NaN ];
    }
    return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];
  };
  var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
  var d3_geo_centroid = {
    sphere: d3_noop,
    point: d3_geo_centroidPoint,
    lineStart: d3_geo_centroidLineStart,
    lineEnd: d3_geo_centroidLineEnd,
    polygonStart: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
    }
  };
  function d3_geo_centroidPoint(λ, φ) {
    λ *= d3_radians;
    var cosφ = Math.cos(φ *= d3_radians);
    d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));
  }
  function d3_geo_centroidPointXYZ(x, y, z) {
    ++d3_geo_centroidW0;
    d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
    d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
    d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
  }
  function d3_geo_centroidLineStart() {
    var x0, y0, z0;
    d3_geo_centroid.point = function(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians);
      x0 = cosφ * Math.cos(λ);
      y0 = cosφ * Math.sin(λ);
      z0 = Math.sin(φ);
      d3_geo_centroid.point = nextPoint;
      d3_geo_centroidPointXYZ(x0, y0, z0);
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
      d3_geo_centroidW1 += w;
      d3_geo_centroidX1 += w * (x0 + (x0 = x));
      d3_geo_centroidY1 += w * (y0 + (y0 = y));
      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
      d3_geo_centroidPointXYZ(x0, y0, z0);
    }
  }
  function d3_geo_centroidLineEnd() {
    d3_geo_centroid.point = d3_geo_centroidPoint;
  }
  function d3_geo_centroidRingStart() {
    var λ00, φ00, x0, y0, z0;
    d3_geo_centroid.point = function(λ, φ) {
      λ00 = λ, φ00 = φ;
      d3_geo_centroid.point = nextPoint;
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians);
      x0 = cosφ * Math.cos(λ);
      y0 = cosφ * Math.sin(λ);
      z0 = Math.sin(φ);
      d3_geo_centroidPointXYZ(x0, y0, z0);
    };
    d3_geo_centroid.lineEnd = function() {
      nextPoint(λ00, φ00);
      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
      d3_geo_centroid.point = d3_geo_centroidPoint;
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
      d3_geo_centroidX2 += v * cx;
      d3_geo_centroidY2 += v * cy;
      d3_geo_centroidZ2 += v * cz;
      d3_geo_centroidW1 += w;
      d3_geo_centroidX1 += w * (x0 + (x0 = x));
      d3_geo_centroidY1 += w * (y0 + (y0 = y));
      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
      d3_geo_centroidPointXYZ(x0, y0, z0);
    }
  }
  function d3_geo_compose(a, b) {
    function compose(x, y) {
      return x = a(x, y), b(x[0], x[1]);
    }
    if (a.invert && b.invert) compose.invert = function(x, y) {
      return x = b.invert(x, y), x && a.invert(x[0], x[1]);
    };
    return compose;
  }
  function d3_true() {
    return true;
  }
  function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
    var subject = [], clip = [];
    segments.forEach(function(segment) {
      if ((n = segment.length - 1) <= 0) return;
      var n, p0 = segment[0], p1 = segment[n];
      if (d3_geo_sphericalEqual(p0, p1)) {
        listener.lineStart();
        for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
        listener.lineEnd();
        return;
      }
      var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
      a.o = b;
      subject.push(a);
      clip.push(b);
      a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
      b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
      a.o = b;
      subject.push(a);
      clip.push(b);
    });
    clip.sort(compare);
    d3_geo_clipPolygonLinkCircular(subject);
    d3_geo_clipPolygonLinkCircular(clip);
    if (!subject.length) return;
    for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
      clip[i].e = entry = !entry;
    }
    var start = subject[0], points, point;
    while (1) {
      var current = start, isSubject = true;
      while (current.v) if ((current = current.n) === start) return;
      points = current.z;
      listener.lineStart();
      do {
        current.v = current.o.v = true;
        if (current.e) {
          if (isSubject) {
            for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.n.x, 1, listener);
          }
          current = current.n;
        } else {
          if (isSubject) {
            points = current.p.z;
            for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.p.x, -1, listener);
          }
          current = current.p;
        }
        current = current.o;
        points = current.z;
        isSubject = !isSubject;
      } while (!current.v);
      listener.lineEnd();
    }
  }
  function d3_geo_clipPolygonLinkCircular(array) {
    if (!(n = array.length)) return;
    var n, i = 0, a = array[0], b;
    while (++i < n) {
      a.n = b = array[i];
      b.p = a;
      a = b;
    }
    a.n = b = array[0];
    b.p = a;
  }
  function d3_geo_clipPolygonIntersection(point, points, other, entry) {
    this.x = point;
    this.z = points;
    this.o = other;
    this.e = entry;
    this.v = false;
    this.n = this.p = null;
  }
  function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
    return function(rotate, listener) {
      var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          clip.point = pointRing;
          clip.lineStart = ringStart;
          clip.lineEnd = ringEnd;
          segments = [];
          polygon = [];
        },
        polygonEnd: function() {
          clip.point = point;
          clip.lineStart = lineStart;
          clip.lineEnd = lineEnd;
          segments = d3.merge(segments);
          var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
          if (segments.length) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
          } else if (clipStartInside) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            listener.lineStart();
            interpolate(null, null, 1, listener);
            listener.lineEnd();
          }
          if (polygonStarted) listener.polygonEnd(), polygonStarted = false;
          segments = polygon = null;
        },
        sphere: function() {
          listener.polygonStart();
          listener.lineStart();
          interpolate(null, null, 1, listener);
          listener.lineEnd();
          listener.polygonEnd();
        }
      };
      function point(λ, φ) {
        var point = rotate(λ, φ);
        if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ);
      }
      function pointLine(λ, φ) {
        var point = rotate(λ, φ);
        line.point(point[0], point[1]);
      }
      function lineStart() {
        clip.point = pointLine;
        line.lineStart();
      }
      function lineEnd() {
        clip.point = point;
        line.lineEnd();
      }
      var segments;
      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
      function pointRing(λ, φ) {
        ring.push([ λ, φ ]);
        var point = rotate(λ, φ);
        ringListener.point(point[0], point[1]);
      }
      function ringStart() {
        ringListener.lineStart();
        ring = [];
      }
      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringListener.lineEnd();
        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
        ring.pop();
        polygon.push(ring);
        ring = null;
        if (!n) return;
        if (clean & 1) {
          segment = ringSegments[0];
          var n = segment.length - 1, i = -1, point;
          if (n > 0) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            listener.lineStart();
            while (++i < n) listener.point((point = segment[i])[0], point[1]);
            listener.lineEnd();
          }
          return;
        }
        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
      }
      return clip;
    };
  }
  function d3_geo_clipSegmentLength1(segment) {
    return segment.length > 1;
  }
  function d3_geo_clipBufferListener() {
    var lines = [], line;
    return {
      lineStart: function() {
        lines.push(line = []);
      },
      point: function(λ, φ) {
        line.push([ λ, φ ]);
      },
      lineEnd: d3_noop,
      buffer: function() {
        var buffer = lines;
        lines = [];
        line = null;
        return buffer;
      },
      rejoin: function() {
        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
      }
    };
  }
  function d3_geo_clipSort(a, b) {
    return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);
  }
  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -π, -π / 2 ]);
  function d3_geo_clipAntimeridianLine(listener) {
    var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;
    return {
      lineStart: function() {
        listener.lineStart();
        clean = 1;
      },
      point: function(λ1, φ1) {
        var sλ1 = λ1 > 0 ? π : -π, dλ = abs(λ1 - λ0);
        if (abs(dλ - π) < ε) {
          listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);
          listener.point(sλ0, φ0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(sλ1, φ0);
          listener.point(λ1, φ0);
          clean = 0;
        } else if (sλ0 !== sλ1 && dλ >= π) {
          if (abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;
          if (abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;
          φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
          listener.point(sλ0, φ0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(sλ1, φ0);
          clean = 0;
        }
        listener.point(λ0 = λ1, φ0 = φ1);
        sλ0 = sλ1;
      },
      lineEnd: function() {
        listener.lineEnd();
        λ0 = φ0 = NaN;
      },
      clean: function() {
        return 2 - clean;
      }
    };
  }
  function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
    var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);
    return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
  }
  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
    var φ;
    if (from == null) {
      φ = direction * halfπ;
      listener.point(-π, φ);
      listener.point(0, φ);
      listener.point(π, φ);
      listener.point(π, 0);
      listener.point(π, -φ);
      listener.point(0, -φ);
      listener.point(-π, -φ);
      listener.point(-π, 0);
      listener.point(-π, φ);
    } else if (abs(from[0] - to[0]) > ε) {
      var s = from[0] < to[0] ? π : -π;
      φ = direction * s / 2;
      listener.point(-s, φ);
      listener.point(0, φ);
      listener.point(s, φ);
    } else {
      listener.point(to[0], to[1]);
    }
  }
  function d3_geo_pointInPolygon(point, polygon) {
    var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;
    d3_geo_areaRingSum.reset();
    for (var i = 0, n = polygon.length; i < n; ++i) {
      var ring = polygon[i], m = ring.length;
      if (!m) continue;
      var point0 = ring[0], λ0 = point0[0], φ0 = point0[1] / 2 + π / 4, sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), j = 1;
      while (true) {
        if (j === m) j = 0;
        point = ring[j];
        var λ = point[0], φ = point[1] / 2 + π / 4, sinφ = Math.sin(φ), cosφ = Math.cos(φ), dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, antimeridian = adλ > π, k = sinφ0 * sinφ;
        d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));
        polarAngle += antimeridian ? dλ + sdλ * τ : dλ;
        if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {
          var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
          d3_geo_cartesianNormalize(arc);
          var intersection = d3_geo_cartesianCross(meridianNormal, arc);
          d3_geo_cartesianNormalize(intersection);
          var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);
          if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {
            winding += antimeridian ^ dλ >= 0 ? 1 : -1;
          }
        }
        if (!j++) break;
        λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;
      }
    }
    return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < 0) ^ winding & 1;
  }
  function d3_geo_clipCircle(radius) {
    var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > ε, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
    return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -π, radius - π ]);
    function visible(λ, φ) {
      return Math.cos(λ) * Math.cos(φ) > cr;
    }
    function clipLine(listener) {
      var point0, c0, v0, v00, clean;
      return {
        lineStart: function() {
          v00 = v0 = false;
          clean = 1;
        },
        point: function(λ, φ) {
          var point1 = [ λ, φ ], point2, v = visible(λ, φ), c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;
          if (!point0 && (v00 = v0 = v)) listener.lineStart();
          if (v !== v0) {
            point2 = intersect(point0, point1);
            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
              point1[0] += ε;
              point1[1] += ε;
              v = visible(point1[0], point1[1]);
            }
          }
          if (v !== v0) {
            clean = 0;
            if (v) {
              listener.lineStart();
              point2 = intersect(point1, point0);
              listener.point(point2[0], point2[1]);
            } else {
              point2 = intersect(point0, point1);
              listener.point(point2[0], point2[1]);
              listener.lineEnd();
            }
            point0 = point2;
          } else if (notHemisphere && point0 && smallRadius ^ v) {
            var t;
            if (!(c & c0) && (t = intersect(point1, point0, true))) {
              clean = 0;
              if (smallRadius) {
                listener.lineStart();
                listener.point(t[0][0], t[0][1]);
                listener.point(t[1][0], t[1][1]);
                listener.lineEnd();
              } else {
                listener.point(t[1][0], t[1][1]);
                listener.lineEnd();
                listener.lineStart();
                listener.point(t[0][0], t[0][1]);
              }
            }
          }
          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
            listener.point(point1[0], point1[1]);
          }
          point0 = point1, v0 = v, c0 = c;
        },
        lineEnd: function() {
          if (v0) listener.lineEnd();
          point0 = null;
        },
        clean: function() {
          return clean | (v00 && v0) << 1;
        }
      };
    }
    function intersect(a, b, two) {
      var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
      if (!determinant) return !two && a;
      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
      d3_geo_cartesianAdd(A, B);
      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
      if (t2 < 0) return;
      var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
      d3_geo_cartesianAdd(q, A);
      q = d3_geo_spherical(q);
      if (!two) return q;
      var λ0 = a[0], λ1 = b[0], φ0 = a[1], φ1 = b[1], z;
      if (λ1 < λ0) z = λ0, λ0 = λ1, λ1 = z;
      var δλ = λ1 - λ0, polar = abs(δλ - π) < ε, meridian = polar || δλ < ε;
      if (!polar && φ1 < φ0) z = φ0, φ0 = φ1, φ1 = z;
      if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {
        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
        d3_geo_cartesianAdd(q1, A);
        return [ q, d3_geo_spherical(q1) ];
      }
    }
    function code(λ, φ) {
      var r = smallRadius ? radius : π - radius, code = 0;
      if (λ < -r) code |= 1; else if (λ > r) code |= 2;
      if (φ < -r) code |= 4; else if (φ > r) code |= 8;
      return code;
    }
  }
  function d3_geom_clipLine(x0, y0, x1, y1) {
    return function(line) {
      var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
      r = x0 - ax;
      if (!dx && r > 0) return;
      r /= dx;
      if (dx < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dx > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }
      r = x1 - ax;
      if (!dx && r < 0) return;
      r /= dx;
      if (dx < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dx > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }
      r = y0 - ay;
      if (!dy && r > 0) return;
      r /= dy;
      if (dy < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dy > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }
      r = y1 - ay;
      if (!dy && r < 0) return;
      r /= dy;
      if (dy < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dy > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }
      if (t0 > 0) line.a = {
        x: ax + t0 * dx,
        y: ay + t0 * dy
      };
      if (t1 < 1) line.b = {
        x: ax + t1 * dx,
        y: ay + t1 * dy
      };
      return line;
    };
  }
  var d3_geo_clipExtentMAX = 1e9;
  d3.geo.clipExtent = function() {
    var x0, y0, x1, y1, stream, clip, clipExtent = {
      stream: function(output) {
        if (stream) stream.valid = false;
        stream = clip(output);
        stream.valid = true;
        return stream;
      },
      extent: function(_) {
        if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
        clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
        if (stream) stream.valid = false, stream = null;
        return clipExtent;
      }
    };
    return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);
  };
  function d3_geo_clipExtent(x0, y0, x1, y1) {
    return function(listener) {
      var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          listener = bufferListener;
          segments = [];
          polygon = [];
          clean = true;
        },
        polygonEnd: function() {
          listener = listener_;
          segments = d3.merge(segments);
          var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;
          if (inside || visible) {
            listener.polygonStart();
            if (inside) {
              listener.lineStart();
              interpolate(null, null, 1, listener);
              listener.lineEnd();
            }
            if (visible) {
              d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
            }
            listener.polygonEnd();
          }
          segments = polygon = ring = null;
        }
      };
      function insidePolygon(p) {
        var wn = 0, n = polygon.length, y = p[1];
        for (var i = 0; i < n; ++i) {
          for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
            b = v[j];
            if (a[1] <= y) {
              if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;
            } else {
              if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;
            }
            a = b;
          }
        }
        return wn !== 0;
      }
      function interpolate(from, to, direction, listener) {
        var a = 0, a1 = 0;
        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
          do {
            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
          } while ((a = (a + direction + 4) % 4) !== a1);
        } else {
          listener.point(to[0], to[1]);
        }
      }
      function pointVisible(x, y) {
        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
      }
      function point(x, y) {
        if (pointVisible(x, y)) listener.point(x, y);
      }
      var x__, y__, v__, x_, y_, v_, first, clean;
      function lineStart() {
        clip.point = linePoint;
        if (polygon) polygon.push(ring = []);
        first = true;
        v_ = false;
        x_ = y_ = NaN;
      }
      function lineEnd() {
        if (segments) {
          linePoint(x__, y__);
          if (v__ && v_) bufferListener.rejoin();
          segments.push(bufferListener.buffer());
        }
        clip.point = point;
        if (v_) listener.lineEnd();
      }
      function linePoint(x, y) {
        x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
        y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
        var v = pointVisible(x, y);
        if (polygon) ring.push([ x, y ]);
        if (first) {
          x__ = x, y__ = y, v__ = v;
          first = false;
          if (v) {
            listener.lineStart();
            listener.point(x, y);
          }
        } else {
          if (v && v_) listener.point(x, y); else {
            var l = {
              a: {
                x: x_,
                y: y_
              },
              b: {
                x: x,
                y: y
              }
            };
            if (clipLine(l)) {
              if (!v_) {
                listener.lineStart();
                listener.point(l.a.x, l.a.y);
              }
              listener.point(l.b.x, l.b.y);
              if (!v) listener.lineEnd();
              clean = false;
            } else if (v) {
              listener.lineStart();
              listener.point(x, y);
              clean = false;
            }
          }
        }
        x_ = x, y_ = y, v_ = v;
      }
      return clip;
    };
    function corner(p, direction) {
      return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
    }
    function compare(a, b) {
      return comparePoints(a.x, b.x);
    }
    function comparePoints(a, b) {
      var ca = corner(a, 1), cb = corner(b, 1);
      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
    }
  }
  function d3_geo_conic(projectAt) {
    var φ0 = 0, φ1 = π / 3, m = d3_geo_projectionMutator(projectAt), p = m(φ0, φ1);
    p.parallels = function(_) {
      if (!arguments.length) return [ φ0 / π * 180, φ1 / π * 180 ];
      return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);
    };
    return p;
  }
  function d3_geo_conicEqualArea(φ0, φ1) {
    var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;
    function forward(λ, φ) {
      var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
      return [ ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ) ];
    }
    forward.invert = function(x, y) {
      var ρ0_y = ρ0 - y;
      return [ Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n)) ];
    };
    return forward;
  }
  (d3.geo.conicEqualArea = function() {
    return d3_geo_conic(d3_geo_conicEqualArea);
  }).raw = d3_geo_conicEqualArea;
  d3.geo.albers = function() {
    return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);
  };
  d3.geo.albersUsa = function() {
    var lower48 = d3.geo.albers();
    var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);
    var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);
    var point, pointStream = {
      point: function(x, y) {
        point = [ x, y ];
      }
    }, lower48Point, alaskaPoint, hawaiiPoint;
    function albersUsa(coordinates) {
      var x = coordinates[0], y = coordinates[1];
      point = null;
      (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
      return point;
    }
    albersUsa.invert = function(coordinates) {
      var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
      return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
    };
    albersUsa.stream = function(stream) {
      var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
      return {
        point: function(x, y) {
          lower48Stream.point(x, y);
          alaskaStream.point(x, y);
          hawaiiStream.point(x, y);
        },
        sphere: function() {
          lower48Stream.sphere();
          alaskaStream.sphere();
          hawaiiStream.sphere();
        },
        lineStart: function() {
          lower48Stream.lineStart();
          alaskaStream.lineStart();
          hawaiiStream.lineStart();
        },
        lineEnd: function() {
          lower48Stream.lineEnd();
          alaskaStream.lineEnd();
          hawaiiStream.lineEnd();
        },
        polygonStart: function() {
          lower48Stream.polygonStart();
          alaskaStream.polygonStart();
          hawaiiStream.polygonStart();
        },
        polygonEnd: function() {
          lower48Stream.polygonEnd();
          alaskaStream.polygonEnd();
          hawaiiStream.polygonEnd();
        }
      };
    };
    albersUsa.precision = function(_) {
      if (!arguments.length) return lower48.precision();
      lower48.precision(_);
      alaska.precision(_);
      hawaii.precision(_);
      return albersUsa;
    };
    albersUsa.scale = function(_) {
      if (!arguments.length) return lower48.scale();
      lower48.scale(_);
      alaska.scale(_ * .35);
      hawaii.scale(_);
      return albersUsa.translate(lower48.translate());
    };
    albersUsa.translate = function(_) {
      if (!arguments.length) return lower48.translate();
      var k = lower48.scale(), x = +_[0], y = +_[1];
      lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;
      alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + ε, y + .12 * k + ε ], [ x - .214 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
      hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + ε, y + .166 * k + ε ], [ x - .115 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
      return albersUsa;
    };
    return albersUsa.scale(1070);
  };
  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_pathAreaPolygon = 0;
      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
      d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
    }
  };
  function d3_geo_pathAreaRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathArea.point = function(x, y) {
      d3_geo_pathArea.point = nextPoint;
      x00 = x0 = x, y00 = y0 = y;
    };
    function nextPoint(x, y) {
      d3_geo_pathAreaPolygon += y0 * x - x0 * y;
      x0 = x, y0 = y;
    }
    d3_geo_pathArea.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
  var d3_geo_pathBounds = {
    point: d3_geo_pathBoundsPoint,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: d3_noop,
    polygonEnd: d3_noop
  };
  function d3_geo_pathBoundsPoint(x, y) {
    if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
    if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
    if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
    if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
  }
  function d3_geo_pathBuffer() {
    var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointCircle = d3_geo_pathBufferCircle(_);
        return stream;
      },
      result: function() {
        if (buffer.length) {
          var result = buffer.join("");
          buffer = [];
          return result;
        }
      }
    };
    function point(x, y) {
      buffer.push("M", x, ",", y, pointCircle);
    }
    function pointLineStart(x, y) {
      buffer.push("M", x, ",", y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      buffer.push("L", x, ",", y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      buffer.push("Z");
    }
    return stream;
  }
  function d3_geo_pathBufferCircle(radius) {
    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
  }
  var d3_geo_pathCentroid = {
    point: d3_geo_pathCentroidPoint,
    lineStart: d3_geo_pathCentroidLineStart,
    lineEnd: d3_geo_pathCentroidLineEnd,
    polygonStart: function() {
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
    }
  };
  function d3_geo_pathCentroidPoint(x, y) {
    d3_geo_centroidX0 += x;
    d3_geo_centroidY0 += y;
    ++d3_geo_centroidZ0;
  }
  function d3_geo_pathCentroidLineStart() {
    var x0, y0;
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX1 += z * (x0 + x) / 2;
      d3_geo_centroidY1 += z * (y0 + y) / 2;
      d3_geo_centroidZ1 += z;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    }
  }
  function d3_geo_pathCentroidLineEnd() {
    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
  }
  function d3_geo_pathCentroidRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX1 += z * (x0 + x) / 2;
      d3_geo_centroidY1 += z * (y0 + y) / 2;
      d3_geo_centroidZ1 += z;
      z = y0 * x - x0 * y;
      d3_geo_centroidX2 += z * (x0 + x);
      d3_geo_centroidY2 += z * (y0 + y);
      d3_geo_centroidZ2 += z * 3;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    }
    d3_geo_pathCentroid.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  function d3_geo_pathContext(context) {
    var pointRadius = 4.5;
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointRadius = _;
        return stream;
      },
      result: d3_noop
    };
    function point(x, y) {
      context.moveTo(x + pointRadius, y);
      context.arc(x, y, pointRadius, 0, τ);
    }
    function pointLineStart(x, y) {
      context.moveTo(x, y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      context.lineTo(x, y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      context.closePath();
    }
    return stream;
  }
  function d3_geo_resample(project) {
    var δ2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
    function resample(stream) {
      return (maxDepth ? resampleRecursive : resampleNone)(stream);
    }
    function resampleNone(stream) {
      return d3_geo_transformPoint(stream, function(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      });
    }
    function resampleRecursive(stream) {
      var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0;
      var resample = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          stream.polygonStart();
          resample.lineStart = ringStart;
        },
        polygonEnd: function() {
          stream.polygonEnd();
          resample.lineStart = lineStart;
        }
      };
      function point(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      }
      function lineStart() {
        x0 = NaN;
        resample.point = linePoint;
        stream.lineStart();
      }
      function linePoint(λ, φ) {
        var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ);
        resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
        stream.point(x0, y0);
      }
      function lineEnd() {
        resample.point = point;
        stream.lineEnd();
      }
      function ringStart() {
        lineStart();
        resample.point = ringPoint;
        resample.lineEnd = ringEnd;
      }
      function ringPoint(λ, φ) {
        linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
        resample.point = linePoint;
      }
      function ringEnd() {
        resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
        resample.lineEnd = lineEnd;
        lineEnd();
      }
      return resample;
    }
    function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
      if (d2 > 4 * δ2 && depth--) {
        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
        if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
          resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
          stream.point(x2, y2);
          resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
        }
      }
    }
    resample.precision = function(_) {
      if (!arguments.length) return Math.sqrt(δ2);
      maxDepth = (δ2 = _ * _) > 0 && 16;
      return resample;
    };
    return resample;
  }
  d3.geo.path = function() {
    var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
    function path(object) {
      if (object) {
        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
        if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
        d3.geo.stream(object, cacheStream);
      }
      return contextStream.result();
    }
    path.area = function(object) {
      d3_geo_pathAreaSum = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathArea));
      return d3_geo_pathAreaSum;
    };
    path.centroid = function(object) {
      d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
      return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];
    };
    path.bounds = function(object) {
      d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
      d3.geo.stream(object, projectStream(d3_geo_pathBounds));
      return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];
    };
    path.projection = function(_) {
      if (!arguments.length) return projection;
      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
      return reset();
    };
    path.context = function(_) {
      if (!arguments.length) return context;
      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
      return reset();
    };
    path.pointRadius = function(_) {
      if (!arguments.length) return pointRadius;
      pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
      return path;
    };
    function reset() {
      cacheStream = null;
      return path;
    }
    return path.projection(d3.geo.albersUsa()).context(null);
  };
  function d3_geo_pathProjectStream(project) {
    var resample = d3_geo_resample(function(x, y) {
      return project([ x * d3_degrees, y * d3_degrees ]);
    });
    return function(stream) {
      return d3_geo_projectionRadians(resample(stream));
    };
  }
  d3.geo.transform = function(methods) {
    return {
      stream: function(stream) {
        var transform = new d3_geo_transform(stream);
        for (var k in methods) transform[k] = methods[k];
        return transform;
      }
    };
  };
  function d3_geo_transform(stream) {
    this.stream = stream;
  }
  d3_geo_transform.prototype = {
    point: function(x, y) {
      this.stream.point(x, y);
    },
    sphere: function() {
      this.stream.sphere();
    },
    lineStart: function() {
      this.stream.lineStart();
    },
    lineEnd: function() {
      this.stream.lineEnd();
    },
    polygonStart: function() {
      this.stream.polygonStart();
    },
    polygonEnd: function() {
      this.stream.polygonEnd();
    }
  };
  function d3_geo_transformPoint(stream, point) {
    return {
      point: point,
      sphere: function() {
        stream.sphere();
      },
      lineStart: function() {
        stream.lineStart();
      },
      lineEnd: function() {
        stream.lineEnd();
      },
      polygonStart: function() {
        stream.polygonStart();
      },
      polygonEnd: function() {
        stream.polygonEnd();
      }
    };
  }
  d3.geo.projection = d3_geo_projection;
  d3.geo.projectionMutator = d3_geo_projectionMutator;
  function d3_geo_projection(project) {
    return d3_geo_projectionMutator(function() {
      return project;
    })();
  }
  function d3_geo_projectionMutator(projectAt) {
    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
      x = project(x, y);
      return [ x[0] * k + δx, δy - x[1] * k ];
    }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
    function projection(point) {
      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
      return [ point[0] * k + δx, δy - point[1] * k ];
    }
    function invert(point) {
      point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
    }
    projection.stream = function(output) {
      if (stream) stream.valid = false;
      stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
      stream.valid = true;
      return stream;
    };
    projection.clipAngle = function(_) {
      if (!arguments.length) return clipAngle;
      preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
      return invalidate();
    };
    projection.clipExtent = function(_) {
      if (!arguments.length) return clipExtent;
      clipExtent = _;
      postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
      return invalidate();
    };
    projection.scale = function(_) {
      if (!arguments.length) return k;
      k = +_;
      return reset();
    };
    projection.translate = function(_) {
      if (!arguments.length) return [ x, y ];
      x = +_[0];
      y = +_[1];
      return reset();
    };
    projection.center = function(_) {
      if (!arguments.length) return [ λ * d3_degrees, φ * d3_degrees ];
      λ = _[0] % 360 * d3_radians;
      φ = _[1] % 360 * d3_radians;
      return reset();
    };
    projection.rotate = function(_) {
      if (!arguments.length) return [ δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees ];
      δλ = _[0] % 360 * d3_radians;
      δφ = _[1] % 360 * d3_radians;
      δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
      return reset();
    };
    d3.rebind(projection, projectResample, "precision");
    function reset() {
      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
      var center = project(λ, φ);
      δx = x - center[0] * k;
      δy = y + center[1] * k;
      return invalidate();
    }
    function invalidate() {
      if (stream) stream.valid = false, stream = null;
      return projection;
    }
    return function() {
      project = projectAt.apply(this, arguments);
      projection.invert = project.invert && invert;
      return reset();
    };
  }
  function d3_geo_projectionRadians(stream) {
    return d3_geo_transformPoint(stream, function(x, y) {
      stream.point(x * d3_radians, y * d3_radians);
    });
  }
  function d3_geo_equirectangular(λ, φ) {
    return [ λ, φ ];
  }
  (d3.geo.equirectangular = function() {
    return d3_geo_projection(d3_geo_equirectangular);
  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
  d3.geo.rotation = function(rotate) {
    rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
    function forward(coordinates) {
      coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
    }
    forward.invert = function(coordinates) {
      coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
    };
    return forward;
  };
  function d3_geo_identityRotation(λ, φ) {
    return [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
  }
  d3_geo_identityRotation.invert = d3_geo_equirectangular;
  function d3_geo_rotation(δλ, δφ, δγ) {
    return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;
  }
  function d3_geo_forwardRotationλ(δλ) {
    return function(λ, φ) {
      return λ += δλ, [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
    };
  }
  function d3_geo_rotationλ(δλ) {
    var rotation = d3_geo_forwardRotationλ(δλ);
    rotation.invert = d3_geo_forwardRotationλ(-δλ);
    return rotation;
  }
  function d3_geo_rotationφγ(δφ, δγ) {
    var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);
    function rotation(λ, φ) {
      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;
      return [ Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ) ];
    }
    rotation.invert = function(λ, φ) {
      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;
      return [ Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ) ];
    };
    return rotation;
  }
  d3.geo.circle = function() {
    var origin = [ 0, 0 ], angle, precision = 6, interpolate;
    function circle() {
      var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
      interpolate(null, null, 1, {
        point: function(x, y) {
          ring.push(x = rotate(x, y));
          x[0] *= d3_degrees, x[1] *= d3_degrees;
        }
      });
      return {
        type: "Polygon",
        coordinates: [ ring ]
      };
    }
    circle.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return circle;
    };
    circle.angle = function(x) {
      if (!arguments.length) return angle;
      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
      return circle;
    };
    circle.precision = function(_) {
      if (!arguments.length) return precision;
      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
      return circle;
    };
    return circle.angle(90);
  };
  function d3_geo_circleInterpolate(radius, precision) {
    var cr = Math.cos(radius), sr = Math.sin(radius);
    return function(from, to, direction, listener) {
      var step = direction * precision;
      if (from != null) {
        from = d3_geo_circleAngle(cr, from);
        to = d3_geo_circleAngle(cr, to);
        if (direction > 0 ? from < to : from > to) from += direction * τ;
      } else {
        from = radius + direction * τ;
        to = radius - .5 * step;
      }
      for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
      }
    };
  }
  function d3_geo_circleAngle(cr, point) {
    var a = d3_geo_cartesian(point);
    a[0] -= cr;
    d3_geo_cartesianNormalize(a);
    var angle = d3_acos(-a[1]);
    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
  }
  d3.geo.distance = function(a, b) {
    var Δλ = (b[0] - a[0]) * d3_radians, φ0 = a[1] * d3_radians, φ1 = b[1] * d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t;
    return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
  };
  d3.geo.graticule = function() {
    var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
    function graticule() {
      return {
        type: "MultiLineString",
        coordinates: lines()
      };
    }
    function lines() {
      return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
        return abs(x % DX) > ε;
      }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
        return abs(y % DY) > ε;
      }).map(y));
    }
    graticule.lines = function() {
      return lines().map(function(coordinates) {
        return {
          type: "LineString",
          coordinates: coordinates
        };
      });
    };
    graticule.outline = function() {
      return {
        type: "Polygon",
        coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]
      };
    };
    graticule.extent = function(_) {
      if (!arguments.length) return graticule.minorExtent();
      return graticule.majorExtent(_).minorExtent(_);
    };
    graticule.majorExtent = function(_) {
      if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];
      X0 = +_[0][0], X1 = +_[1][0];
      Y0 = +_[0][1], Y1 = +_[1][1];
      if (X0 > X1) _ = X0, X0 = X1, X1 = _;
      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
      return graticule.precision(precision);
    };
    graticule.minorExtent = function(_) {
      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
      x0 = +_[0][0], x1 = +_[1][0];
      y0 = +_[0][1], y1 = +_[1][1];
      if (x0 > x1) _ = x0, x0 = x1, x1 = _;
      if (y0 > y1) _ = y0, y0 = y1, y1 = _;
      return graticule.precision(precision);
    };
    graticule.step = function(_) {
      if (!arguments.length) return graticule.minorStep();
      return graticule.majorStep(_).minorStep(_);
    };
    graticule.majorStep = function(_) {
      if (!arguments.length) return [ DX, DY ];
      DX = +_[0], DY = +_[1];
      return graticule;
    };
    graticule.minorStep = function(_) {
      if (!arguments.length) return [ dx, dy ];
      dx = +_[0], dy = +_[1];
      return graticule;
    };
    graticule.precision = function(_) {
      if (!arguments.length) return precision;
      precision = +_;
      x = d3_geo_graticuleX(y0, y1, 90);
      y = d3_geo_graticuleY(x0, x1, precision);
      X = d3_geo_graticuleX(Y0, Y1, 90);
      Y = d3_geo_graticuleY(X0, X1, precision);
      return graticule;
    };
    return graticule.majorExtent([ [ -180, -90 + ε ], [ 180, 90 - ε ] ]).minorExtent([ [ -180, -80 - ε ], [ 180, 80 + ε ] ]);
  };
  function d3_geo_graticuleX(y0, y1, dy) {
    var y = d3.range(y0, y1 - ε, dy).concat(y1);
    return function(x) {
      return y.map(function(y) {
        return [ x, y ];
      });
    };
  }
  function d3_geo_graticuleY(x0, x1, dx) {
    var x = d3.range(x0, x1 - ε, dx).concat(x1);
    return function(y) {
      return x.map(function(x) {
        return [ x, y ];
      });
    };
  }
  function d3_source(d) {
    return d.source;
  }
  function d3_target(d) {
    return d.target;
  }
  d3.geo.greatArc = function() {
    var source = d3_source, source_, target = d3_target, target_;
    function greatArc() {
      return {
        type: "LineString",
        coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]
      };
    }
    greatArc.distance = function() {
      return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
    };
    greatArc.source = function(_) {
      if (!arguments.length) return source;
      source = _, source_ = typeof _ === "function" ? null : _;
      return greatArc;
    };
    greatArc.target = function(_) {
      if (!arguments.length) return target;
      target = _, target_ = typeof _ === "function" ? null : _;
      return greatArc;
    };
    greatArc.precision = function() {
      return arguments.length ? greatArc : 0;
    };
    return greatArc;
  };
  d3.geo.interpolate = function(source, target) {
    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
  };
  function d3_geo_interpolate(x0, y0, x1, y1) {
    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
    var interpolate = d ? function(t) {
      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
      return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];
    } : function() {
      return [ x0 * d3_degrees, y0 * d3_degrees ];
    };
    interpolate.distance = d;
    return interpolate;
  }
  d3.geo.length = function(object) {
    d3_geo_lengthSum = 0;
    d3.geo.stream(object, d3_geo_length);
    return d3_geo_lengthSum;
  };
  var d3_geo_lengthSum;
  var d3_geo_length = {
    sphere: d3_noop,
    point: d3_noop,
    lineStart: d3_geo_lengthLineStart,
    lineEnd: d3_noop,
    polygonStart: d3_noop,
    polygonEnd: d3_noop
  };
  function d3_geo_lengthLineStart() {
    var λ0, sinφ0, cosφ0;
    d3_geo_length.point = function(λ, φ) {
      λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);
      d3_geo_length.point = nextPoint;
    };
    d3_geo_length.lineEnd = function() {
      d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
    };
    function nextPoint(λ, φ) {
      var sinφ = Math.sin(φ *= d3_radians), cosφ = Math.cos(φ), t = abs((λ *= d3_radians) - λ0), cosΔλ = Math.cos(t);
      d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);
      λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;
    }
  }
  function d3_geo_azimuthal(scale, angle) {
    function azimuthal(λ, φ) {
      var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);
      return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];
    }
    azimuthal.invert = function(x, y) {
      var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);
      return [ Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ) ];
    };
    return azimuthal;
  }
  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {
    return Math.sqrt(2 / (1 + cosλcosφ));
  }, function(ρ) {
    return 2 * Math.asin(ρ / 2);
  });
  (d3.geo.azimuthalEqualArea = function() {
    return d3_geo_projection(d3_geo_azimuthalEqualArea);
  }).raw = d3_geo_azimuthalEqualArea;
  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {
    var c = Math.acos(cosλcosφ);
    return c && c / Math.sin(c);
  }, d3_identity);
  (d3.geo.azimuthalEquidistant = function() {
    return d3_geo_projection(d3_geo_azimuthalEquidistant);
  }).raw = d3_geo_azimuthalEquidistant;
  function d3_geo_conicConformal(φ0, φ1) {
    var cosφ0 = Math.cos(φ0), t = function(φ) {
      return Math.tan(π / 4 + φ / 2);
    }, n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)), F = cosφ0 * Math.pow(t(φ0), n) / n;
    if (!n) return d3_geo_mercator;
    function forward(λ, φ) {
      if (F > 0) {
        if (φ < -halfπ + ε) φ = -halfπ + ε;
      } else {
        if (φ > halfπ - ε) φ = halfπ - ε;
      }
      var ρ = F / Math.pow(t(φ), n);
      return [ ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ) ];
    }
    forward.invert = function(x, y) {
      var ρ0_y = F - y, ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
      return [ Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ ];
    };
    return forward;
  }
  (d3.geo.conicConformal = function() {
    return d3_geo_conic(d3_geo_conicConformal);
  }).raw = d3_geo_conicConformal;
  function d3_geo_conicEquidistant(φ0, φ1) {
    var cosφ0 = Math.cos(φ0), n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0), G = cosφ0 / n + φ0;
    if (abs(n) < ε) return d3_geo_equirectangular;
    function forward(λ, φ) {
      var ρ = G - φ;
      return [ ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ) ];
    }
    forward.invert = function(x, y) {
      var ρ0_y = G - y;
      return [ Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y) ];
    };
    return forward;
  }
  (d3.geo.conicEquidistant = function() {
    return d3_geo_conic(d3_geo_conicEquidistant);
  }).raw = d3_geo_conicEquidistant;
  var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {
    return 1 / cosλcosφ;
  }, Math.atan);
  (d3.geo.gnomonic = function() {
    return d3_geo_projection(d3_geo_gnomonic);
  }).raw = d3_geo_gnomonic;
  function d3_geo_mercator(λ, φ) {
    return [ λ, Math.log(Math.tan(π / 4 + φ / 2)) ];
  }
  d3_geo_mercator.invert = function(x, y) {
    return [ x, 2 * Math.atan(Math.exp(y)) - halfπ ];
  };
  function d3_geo_mercatorProjection(project) {
    var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
    m.scale = function() {
      var v = scale.apply(m, arguments);
      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
    };
    m.translate = function() {
      var v = translate.apply(m, arguments);
      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
    };
    m.clipExtent = function(_) {
      var v = clipExtent.apply(m, arguments);
      if (v === m) {
        if (clipAuto = _ == null) {
          var k = π * scale(), t = translate();
          clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);
        }
      } else if (clipAuto) {
        v = null;
      }
      return v;
    };
    return m.clipExtent(null);
  }
  (d3.geo.mercator = function() {
    return d3_geo_mercatorProjection(d3_geo_mercator);
  }).raw = d3_geo_mercator;
  var d3_geo_orthographic = d3_geo_azimuthal(function() {
    return 1;
  }, Math.asin);
  (d3.geo.orthographic = function() {
    return d3_geo_projection(d3_geo_orthographic);
  }).raw = d3_geo_orthographic;
  var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {
    return 1 / (1 + cosλcosφ);
  }, function(ρ) {
    return 2 * Math.atan(ρ);
  });
  (d3.geo.stereographic = function() {
    return d3_geo_projection(d3_geo_stereographic);
  }).raw = d3_geo_stereographic;
  function d3_geo_transverseMercator(λ, φ) {
    return [ Math.log(Math.tan(π / 4 + φ / 2)), -λ ];
  }
  d3_geo_transverseMercator.invert = function(x, y) {
    return [ -y, 2 * Math.atan(Math.exp(x)) - halfπ ];
  };
  (d3.geo.transverseMercator = function() {
    var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
    projection.center = function(_) {
      return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);
    };
    projection.rotate = function(_) {
      return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), 
      [ _[0], _[1], _[2] - 90 ]);
    };
    return rotate([ 0, 0, 90 ]);
  }).raw = d3_geo_transverseMercator;
  d3.geom = {};
  function d3_geom_pointX(d) {
    return d[0];
  }
  function d3_geom_pointY(d) {
    return d[1];
  }
  d3.geom.hull = function(vertices) {
    var x = d3_geom_pointX, y = d3_geom_pointY;
    if (arguments.length) return hull(vertices);
    function hull(data) {
      if (data.length < 3) return [];
      var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
      for (i = 0; i < n; i++) {
        points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);
      }
      points.sort(d3_geom_hullOrder);
      for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);
      var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
      var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
      for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
      for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
      return polygon;
    }
    hull.x = function(_) {
      return arguments.length ? (x = _, hull) : x;
    };
    hull.y = function(_) {
      return arguments.length ? (y = _, hull) : y;
    };
    return hull;
  };
  function d3_geom_hullUpper(points) {
    var n = points.length, hull = [ 0, 1 ], hs = 2;
    for (var i = 2; i < n; i++) {
      while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
      hull[hs++] = i;
    }
    return hull.slice(0, hs);
  }
  function d3_geom_hullOrder(a, b) {
    return a[0] - b[0] || a[1] - b[1];
  }
  d3.geom.polygon = function(coordinates) {
    d3_subclass(coordinates, d3_geom_polygonPrototype);
    return coordinates;
  };
  var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
  d3_geom_polygonPrototype.area = function() {
    var i = -1, n = this.length, a, b = this[n - 1], area = 0;
    while (++i < n) {
      a = b;
      b = this[i];
      area += a[1] * b[0] - a[0] * b[1];
    }
    return area * .5;
  };
  d3_geom_polygonPrototype.centroid = function(k) {
    var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
    if (!arguments.length) k = -1 / (6 * this.area());
    while (++i < n) {
      a = b;
      b = this[i];
      c = a[0] * b[1] - b[0] * a[1];
      x += (a[0] + b[0]) * c;
      y += (a[1] + b[1]) * c;
    }
    return [ x * k, y * k ];
  };
  d3_geom_polygonPrototype.clip = function(subject) {
    var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
    while (++i < n) {
      input = subject.slice();
      subject.length = 0;
      b = this[i];
      c = input[(m = input.length - closed) - 1];
      j = -1;
      while (++j < m) {
        d = input[j];
        if (d3_geom_polygonInside(d, a, b)) {
          if (!d3_geom_polygonInside(c, a, b)) {
            subject.push(d3_geom_polygonIntersect(c, d, a, b));
          }
          subject.push(d);
        } else if (d3_geom_polygonInside(c, a, b)) {
          subject.push(d3_geom_polygonIntersect(c, d, a, b));
        }
        c = d;
      }
      if (closed) subject.push(subject[0]);
      a = b;
    }
    return subject;
  };
  function d3_geom_polygonInside(p, a, b) {
    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
  }
  function d3_geom_polygonIntersect(c, d, a, b) {
    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
    return [ x1 + ua * x21, y1 + ua * y21 ];
  }
  function d3_geom_polygonClosed(coordinates) {
    var a = coordinates[0], b = coordinates[coordinates.length - 1];
    return !(a[0] - b[0] || a[1] - b[1]);
  }
  var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
  function d3_geom_voronoiBeach() {
    d3_geom_voronoiRedBlackNode(this);
    this.edge = this.site = this.circle = null;
  }
  function d3_geom_voronoiCreateBeach(site) {
    var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
    beach.site = site;
    return beach;
  }
  function d3_geom_voronoiDetachBeach(beach) {
    d3_geom_voronoiDetachCircle(beach);
    d3_geom_voronoiBeaches.remove(beach);
    d3_geom_voronoiBeachPool.push(beach);
    d3_geom_voronoiRedBlackNode(beach);
  }
  function d3_geom_voronoiRemoveBeach(beach) {
    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
      x: x,
      y: y
    }, previous = beach.P, next = beach.N, disappearing = [ beach ];
    d3_geom_voronoiDetachBeach(beach);
    var lArc = previous;
    while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {
      previous = lArc.P;
      disappearing.unshift(lArc);
      d3_geom_voronoiDetachBeach(lArc);
      lArc = previous;
    }
    disappearing.unshift(lArc);
    d3_geom_voronoiDetachCircle(lArc);
    var rArc = next;
    while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {
      next = rArc.N;
      disappearing.push(rArc);
      d3_geom_voronoiDetachBeach(rArc);
      rArc = next;
    }
    disappearing.push(rArc);
    d3_geom_voronoiDetachCircle(rArc);
    var nArcs = disappearing.length, iArc;
    for (iArc = 1; iArc < nArcs; ++iArc) {
      rArc = disappearing[iArc];
      lArc = disappearing[iArc - 1];
      d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
    }
    lArc = disappearing[0];
    rArc = disappearing[nArcs - 1];
    rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
    d3_geom_voronoiAttachCircle(lArc);
    d3_geom_voronoiAttachCircle(rArc);
  }
  function d3_geom_voronoiAddBeach(site) {
    var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
    while (node) {
      dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
      if (dxl > ε) node = node.L; else {
        dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
        if (dxr > ε) {
          if (!node.R) {
            lArc = node;
            break;
          }
          node = node.R;
        } else {
          if (dxl > -ε) {
            lArc = node.P;
            rArc = node;
          } else if (dxr > -ε) {
            lArc = node;
            rArc = node.N;
          } else {
            lArc = rArc = node;
          }
          break;
        }
      }
    }
    var newArc = d3_geom_voronoiCreateBeach(site);
    d3_geom_voronoiBeaches.insert(lArc, newArc);
    if (!lArc && !rArc) return;
    if (lArc === rArc) {
      d3_geom_voronoiDetachCircle(lArc);
      rArc = d3_geom_voronoiCreateBeach(lArc.site);
      d3_geom_voronoiBeaches.insert(newArc, rArc);
      newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
      d3_geom_voronoiAttachCircle(lArc);
      d3_geom_voronoiAttachCircle(rArc);
      return;
    }
    if (!rArc) {
      newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
      return;
    }
    d3_geom_voronoiDetachCircle(lArc);
    d3_geom_voronoiDetachCircle(rArc);
    var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
      x: (cy * hb - by * hc) / d + ax,
      y: (bx * hc - cx * hb) / d + ay
    };
    d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
    newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
    rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
    d3_geom_voronoiAttachCircle(lArc);
    d3_geom_voronoiAttachCircle(rArc);
  }
  function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
    var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
    if (!pby2) return rfocx;
    var lArc = arc.P;
    if (!lArc) return -Infinity;
    site = lArc.site;
    var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
    if (!plby2) return lfocx;
    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
    return (rfocx + lfocx) / 2;
  }
  function d3_geom_voronoiRightBreakPoint(arc, directrix) {
    var rArc = arc.N;
    if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
    var site = arc.site;
    return site.y === directrix ? site.x : Infinity;
  }
  function d3_geom_voronoiCell(site) {
    this.site = site;
    this.edges = [];
  }
  d3_geom_voronoiCell.prototype.prepare = function() {
    var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
    while (iHalfEdge--) {
      edge = halfEdges[iHalfEdge].edge;
      if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
    }
    halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
    return halfEdges.length;
  };
  function d3_geom_voronoiCloseCells(extent) {
    var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
    while (iCell--) {
      cell = cells[iCell];
      if (!cell || !cell.prepare()) continue;
      halfEdges = cell.edges;
      nHalfEdges = halfEdges.length;
      iHalfEdge = 0;
      while (iHalfEdge < nHalfEdges) {
        end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
        start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
        if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {
          halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {
            x: x0,
            y: abs(x2 - x0) < ε ? y2 : y1
          } : abs(y3 - y1) < ε && x1 - x3 > ε ? {
            x: abs(y2 - y1) < ε ? x2 : x1,
            y: y1
          } : abs(x3 - x1) < ε && y3 - y0 > ε ? {
            x: x1,
            y: abs(x2 - x1) < ε ? y2 : y0
          } : abs(y3 - y0) < ε && x3 - x0 > ε ? {
            x: abs(y2 - y0) < ε ? x2 : x0,
            y: y0
          } : null), cell.site, null));
          ++nHalfEdges;
        }
      }
    }
  }
  function d3_geom_voronoiHalfEdgeOrder(a, b) {
    return b.angle - a.angle;
  }
  function d3_geom_voronoiCircle() {
    d3_geom_voronoiRedBlackNode(this);
    this.x = this.y = this.arc = this.site = this.cy = null;
  }
  function d3_geom_voronoiAttachCircle(arc) {
    var lArc = arc.P, rArc = arc.N;
    if (!lArc || !rArc) return;
    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
    if (lSite === rSite) return;
    var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
    var d = 2 * (ax * cy - ay * cx);
    if (d >= -ε2) return;
    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
    var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
    circle.arc = arc;
    circle.site = cSite;
    circle.x = x + bx;
    circle.y = cy + Math.sqrt(x * x + y * y);
    circle.cy = cy;
    arc.circle = circle;
    var before = null, node = d3_geom_voronoiCircles._;
    while (node) {
      if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
        if (node.L) node = node.L; else {
          before = node.P;
          break;
        }
      } else {
        if (node.R) node = node.R; else {
          before = node;
          break;
        }
      }
    }
    d3_geom_voronoiCircles.insert(before, circle);
    if (!before) d3_geom_voronoiFirstCircle = circle;
  }
  function d3_geom_voronoiDetachCircle(arc) {
    var circle = arc.circle;
    if (circle) {
      if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
      d3_geom_voronoiCircles.remove(circle);
      d3_geom_voronoiCirclePool.push(circle);
      d3_geom_voronoiRedBlackNode(circle);
      arc.circle = null;
    }
  }
  function d3_geom_voronoiClipEdges(extent) {
    var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
    while (i--) {
      e = edges[i];
      if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {
        e.a = e.b = null;
        edges.splice(i, 1);
      }
    }
  }
  function d3_geom_voronoiConnectEdge(edge, extent) {
    var vb = edge.b;
    if (vb) return true;
    var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
    if (ry === ly) {
      if (fx < x0 || fx >= x1) return;
      if (lx > rx) {
        if (!va) va = {
          x: fx,
          y: y0
        }; else if (va.y >= y1) return;
        vb = {
          x: fx,
          y: y1
        };
      } else {
        if (!va) va = {
          x: fx,
          y: y1
        }; else if (va.y < y0) return;
        vb = {
          x: fx,
          y: y0
        };
      }
    } else {
      fm = (lx - rx) / (ry - ly);
      fb = fy - fm * fx;
      if (fm < -1 || fm > 1) {
        if (lx > rx) {
          if (!va) va = {
            x: (y0 - fb) / fm,
            y: y0
          }; else if (va.y >= y1) return;
          vb = {
            x: (y1 - fb) / fm,
            y: y1
          };
        } else {
          if (!va) va = {
            x: (y1 - fb) / fm,
            y: y1
          }; else if (va.y < y0) return;
          vb = {
            x: (y0 - fb) / fm,
            y: y0
          };
        }
      } else {
        if (ly < ry) {
          if (!va) va = {
            x: x0,
            y: fm * x0 + fb
          }; else if (va.x >= x1) return;
          vb = {
            x: x1,
            y: fm * x1 + fb
          };
        } else {
          if (!va) va = {
            x: x1,
            y: fm * x1 + fb
          }; else if (va.x < x0) return;
          vb = {
            x: x0,
            y: fm * x0 + fb
          };
        }
      }
    }
    edge.a = va;
    edge.b = vb;
    return true;
  }
  function d3_geom_voronoiEdge(lSite, rSite) {
    this.l = lSite;
    this.r = rSite;
    this.a = this.b = null;
  }
  function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
    var edge = new d3_geom_voronoiEdge(lSite, rSite);
    d3_geom_voronoiEdges.push(edge);
    if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
    if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
    d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
    d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
    return edge;
  }
  function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
    var edge = new d3_geom_voronoiEdge(lSite, null);
    edge.a = va;
    edge.b = vb;
    d3_geom_voronoiEdges.push(edge);
    return edge;
  }
  function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
    if (!edge.a && !edge.b) {
      edge.a = vertex;
      edge.l = lSite;
      edge.r = rSite;
    } else if (edge.l === rSite) {
      edge.b = vertex;
    } else {
      edge.a = vertex;
    }
  }
  function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
    var va = edge.a, vb = edge.b;
    this.edge = edge;
    this.site = lSite;
    this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
  }
  d3_geom_voronoiHalfEdge.prototype = {
    start: function() {
      return this.edge.l === this.site ? this.edge.a : this.edge.b;
    },
    end: function() {
      return this.edge.l === this.site ? this.edge.b : this.edge.a;
    }
  };
  function d3_geom_voronoiRedBlackTree() {
    this._ = null;
  }
  function d3_geom_voronoiRedBlackNode(node) {
    node.U = node.C = node.L = node.R = node.P = node.N = null;
  }
  d3_geom_voronoiRedBlackTree.prototype = {
    insert: function(after, node) {
      var parent, grandpa, uncle;
      if (after) {
        node.P = after;
        node.N = after.N;
        if (after.N) after.N.P = node;
        after.N = node;
        if (after.R) {
          after = after.R;
          while (after.L) after = after.L;
          after.L = node;
        } else {
          after.R = node;
        }
        parent = after;
      } else if (this._) {
        after = d3_geom_voronoiRedBlackFirst(this._);
        node.P = null;
        node.N = after;
        after.P = after.L = node;
        parent = after;
      } else {
        node.P = node.N = null;
        this._ = node;
        parent = null;
      }
      node.L = node.R = null;
      node.U = parent;
      node.C = true;
      after = node;
      while (parent && parent.C) {
        grandpa = parent.U;
        if (parent === grandpa.L) {
          uncle = grandpa.R;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.R) {
              d3_geom_voronoiRedBlackRotateLeft(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            d3_geom_voronoiRedBlackRotateRight(this, grandpa);
          }
        } else {
          uncle = grandpa.L;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.L) {
              d3_geom_voronoiRedBlackRotateRight(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
          }
        }
        parent = after.U;
      }
      this._.C = false;
    },
    remove: function(node) {
      if (node.N) node.N.P = node.P;
      if (node.P) node.P.N = node.N;
      node.N = node.P = null;
      var parent = node.U, sibling, left = node.L, right = node.R, next, red;
      if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);
      if (parent) {
        if (parent.L === node) parent.L = next; else parent.R = next;
      } else {
        this._ = next;
      }
      if (left && right) {
        red = next.C;
        next.C = node.C;
        next.L = left;
        left.U = next;
        if (next !== right) {
          parent = next.U;
          next.U = node.U;
          node = next.R;
          parent.L = node;
          next.R = right;
          right.U = next;
        } else {
          next.U = parent;
          parent = next;
          node = next.R;
        }
      } else {
        red = node.C;
        node = next;
      }
      if (node) node.U = parent;
      if (red) return;
      if (node && node.C) {
        node.C = false;
        return;
      }
      do {
        if (node === this._) break;
        if (node === parent.L) {
          sibling = parent.R;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            d3_geom_voronoiRedBlackRotateLeft(this, parent);
            sibling = parent.R;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.R || !sibling.R.C) {
              sibling.L.C = false;
              sibling.C = true;
              d3_geom_voronoiRedBlackRotateRight(this, sibling);
              sibling = parent.R;
            }
            sibling.C = parent.C;
            parent.C = sibling.R.C = false;
            d3_geom_voronoiRedBlackRotateLeft(this, parent);
            node = this._;
            break;
          }
        } else {
          sibling = parent.L;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            d3_geom_voronoiRedBlackRotateRight(this, parent);
            sibling = parent.L;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.L || !sibling.L.C) {
              sibling.R.C = false;
              sibling.C = true;
              d3_geom_voronoiRedBlackRotateLeft(this, sibling);
              sibling = parent.L;
            }
            sibling.C = parent.C;
            parent.C = sibling.L.C = false;
            d3_geom_voronoiRedBlackRotateRight(this, parent);
            node = this._;
            break;
          }
        }
        sibling.C = true;
        node = parent;
        parent = parent.U;
      } while (!node.C);
      if (node) node.C = false;
    }
  };
  function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
    var p = node, q = node.R, parent = p.U;
    if (parent) {
      if (parent.L === p) parent.L = q; else parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.R = q.L;
    if (p.R) p.R.U = p;
    q.L = p;
  }
  function d3_geom_voronoiRedBlackRotateRight(tree, node) {
    var p = node, q = node.L, parent = p.U;
    if (parent) {
      if (parent.L === p) parent.L = q; else parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.L = q.R;
    if (p.L) p.L.U = p;
    q.R = p;
  }
  function d3_geom_voronoiRedBlackFirst(node) {
    while (node.L) node = node.L;
    return node;
  }
  function d3_geom_voronoi(sites, bbox) {
    var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
    d3_geom_voronoiEdges = [];
    d3_geom_voronoiCells = new Array(sites.length);
    d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
    d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
    while (true) {
      circle = d3_geom_voronoiFirstCircle;
      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
        if (site.x !== x0 || site.y !== y0) {
          d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
          d3_geom_voronoiAddBeach(site);
          x0 = site.x, y0 = site.y;
        }
        site = sites.pop();
      } else if (circle) {
        d3_geom_voronoiRemoveBeach(circle.arc);
      } else {
        break;
      }
    }
    if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
    var diagram = {
      cells: d3_geom_voronoiCells,
      edges: d3_geom_voronoiEdges
    };
    d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
    return diagram;
  }
  function d3_geom_voronoiVertexOrder(a, b) {
    return b.y - a.y || b.x - a.x;
  }
  d3.geom.voronoi = function(points) {
    var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
    if (points) return voronoi(points);
    function voronoi(data) {
      var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
      d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
        var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
          var s = e.start();
          return [ s.x, s.y ];
        }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];
        polygon.point = data[i];
      });
      return polygons;
    }
    function sites(data) {
      return data.map(function(d, i) {
        return {
          x: Math.round(fx(d, i) / ε) * ε,
          y: Math.round(fy(d, i) / ε) * ε,
          i: i
        };
      });
    }
    voronoi.links = function(data) {
      return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
        return edge.l && edge.r;
      }).map(function(edge) {
        return {
          source: data[edge.l.i],
          target: data[edge.r.i]
        };
      });
    };
    voronoi.triangles = function(data) {
      var triangles = [];
      d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
        var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
        while (++j < m) {
          e0 = e1;
          s0 = s1;
          e1 = edges[j].edge;
          s1 = e1.l === site ? e1.r : e1.l;
          if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
            triangles.push([ data[i], data[s0.i], data[s1.i] ]);
          }
        }
      });
      return triangles;
    };
    voronoi.x = function(_) {
      return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
    };
    voronoi.y = function(_) {
      return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
    };
    voronoi.clipExtent = function(_) {
      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
      clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
      return voronoi;
    };
    voronoi.size = function(_) {
      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
      return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);
    };
    return voronoi;
  };
  var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];
  function d3_geom_voronoiTriangleArea(a, b, c) {
    return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
  }
  d3.geom.delaunay = function(vertices) {
    return d3.geom.voronoi().triangles(vertices);
  };
  d3.geom.quadtree = function(points, x1, y1, x2, y2) {
    var x = d3_geom_pointX, y = d3_geom_pointY, compat;
    if (compat = arguments.length) {
      x = d3_geom_quadtreeCompatX;
      y = d3_geom_quadtreeCompatY;
      if (compat === 3) {
        y2 = y1;
        x2 = x1;
        y1 = x1 = 0;
      }
      return quadtree(points);
    }
    function quadtree(data) {
      var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
      if (x1 != null) {
        x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
      } else {
        x2_ = y2_ = -(x1_ = y1_ = Infinity);
        xs = [], ys = [];
        n = data.length;
        if (compat) for (i = 0; i < n; ++i) {
          d = data[i];
          if (d.x < x1_) x1_ = d.x;
          if (d.y < y1_) y1_ = d.y;
          if (d.x > x2_) x2_ = d.x;
          if (d.y > y2_) y2_ = d.y;
          xs.push(d.x);
          ys.push(d.y);
        } else for (i = 0; i < n; ++i) {
          var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
          if (x_ < x1_) x1_ = x_;
          if (y_ < y1_) y1_ = y_;
          if (x_ > x2_) x2_ = x_;
          if (y_ > y2_) y2_ = y_;
          xs.push(x_);
          ys.push(y_);
        }
      }
      var dx = x2_ - x1_, dy = y2_ - y1_;
      if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;
      function insert(n, d, x, y, x1, y1, x2, y2) {
        if (isNaN(x) || isNaN(y)) return;
        if (n.leaf) {
          var nx = n.x, ny = n.y;
          if (nx != null) {
            if (abs(nx - x) + abs(ny - y) < .01) {
              insertChild(n, d, x, y, x1, y1, x2, y2);
            } else {
              var nPoint = n.point;
              n.x = n.y = n.point = null;
              insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
              insertChild(n, d, x, y, x1, y1, x2, y2);
            }
          } else {
            n.x = x, n.y = y, n.point = d;
          }
        } else {
          insertChild(n, d, x, y, x1, y1, x2, y2);
        }
      }
      function insertChild(n, d, x, y, x1, y1, x2, y2) {
        var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;
        n.leaf = false;
        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
        if (right) x1 = xm; else x2 = xm;
        if (below) y1 = ym; else y2 = ym;
        insert(n, d, x, y, x1, y1, x2, y2);
      }
      var root = d3_geom_quadtreeNode();
      root.add = function(d) {
        insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
      };
      root.visit = function(f) {
        d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
      };
      root.find = function(point) {
        return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
      };
      i = -1;
      if (x1 == null) {
        while (++i < n) {
          insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
        }
        --i;
      } else data.forEach(root.add);
      xs = ys = data = d = null;
      return root;
    }
    quadtree.x = function(_) {
      return arguments.length ? (x = _, quadtree) : x;
    };
    quadtree.y = function(_) {
      return arguments.length ? (y = _, quadtree) : y;
    };
    quadtree.extent = function(_) {
      if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];
      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], 
      y2 = +_[1][1];
      return quadtree;
    };
    quadtree.size = function(_) {
      if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];
      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
      return quadtree;
    };
    return quadtree;
  };
  function d3_geom_quadtreeCompatX(d) {
    return d.x;
  }
  function d3_geom_quadtreeCompatY(d) {
    return d.y;
  }
  function d3_geom_quadtreeNode() {
    return {
      leaf: true,
      nodes: [],
      point: null,
      x: null,
      y: null
    };
  }
  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
    if (!f(node, x1, y1, x2, y2)) {
      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
    }
  }
  function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
    var minDistance2 = Infinity, closestPoint;
    (function find(node, x1, y1, x2, y2) {
      if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;
      if (point = node.point) {
        var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
        if (distance2 < minDistance2) {
          var distance = Math.sqrt(minDistance2 = distance2);
          x0 = x - distance, y0 = y - distance;
          x3 = x + distance, y3 = y + distance;
          closestPoint = point;
        }
      }
      var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;
      for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
        if (node = children[i & 3]) switch (i & 3) {
         case 0:
          find(node, x1, y1, xm, ym);
          break;

         case 1:
          find(node, xm, y1, x2, ym);
          break;

         case 2:
          find(node, x1, ym, xm, y2);
          break;

         case 3:
          find(node, xm, ym, x2, y2);
          break;
        }
      }
    })(root, x0, y0, x3, y3);
    return closestPoint;
  }
  d3.interpolateRgb = d3_interpolateRgb;
  function d3_interpolateRgb(a, b) {
    a = d3.rgb(a);
    b = d3.rgb(b);
    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
    return function(t) {
      return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
    };
  }
  d3.interpolateObject = d3_interpolateObject;
  function d3_interpolateObject(a, b) {
    var i = {}, c = {}, k;
    for (k in a) {
      if (k in b) {
        i[k] = d3_interpolate(a[k], b[k]);
      } else {
        c[k] = a[k];
      }
    }
    for (k in b) {
      if (!(k in a)) {
        c[k] = b[k];
      }
    }
    return function(t) {
      for (k in i) c[k] = i[k](t);
      return c;
    };
  }
  d3.interpolateNumber = d3_interpolateNumber;
  function d3_interpolateNumber(a, b) {
    a = +a, b = +b;
    return function(t) {
      return a * (1 - t) + b * t;
    };
  }
  d3.interpolateString = d3_interpolateString;
  function d3_interpolateString(a, b) {
    var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
    a = a + "", b = b + "";
    while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
      if ((bs = bm.index) > bi) {
        bs = b.slice(bi, bs);
        if (s[i]) s[i] += bs; else s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s[i]) s[i] += bm; else s[++i] = bm;
      } else {
        s[++i] = null;
        q.push({
          i: i,
          x: d3_interpolateNumber(am, bm)
        });
      }
      bi = d3_interpolate_numberB.lastIndex;
    }
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i]) s[i] += bs; else s[++i] = bs;
    }
    return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
      return b(t) + "";
    }) : function() {
      return b;
    } : (b = q.length, function(t) {
      for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    });
  }
  var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
  d3.interpolate = d3_interpolate;
  function d3_interpolate(a, b) {
    var i = d3.interpolators.length, f;
    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
    return f;
  }
  d3.interpolators = [ function(a, b) {
    var t = typeof b;
    return (t === "string" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
  } ];
  d3.interpolateArray = d3_interpolateArray;
  function d3_interpolateArray(a, b) {
    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
    for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
    for (;i < na; ++i) c[i] = a[i];
    for (;i < nb; ++i) c[i] = b[i];
    return function(t) {
      for (i = 0; i < n0; ++i) c[i] = x[i](t);
      return c;
    };
  }
  var d3_ease_default = function() {
    return d3_identity;
  };
  var d3_ease = d3.map({
    linear: d3_ease_default,
    poly: d3_ease_poly,
    quad: function() {
      return d3_ease_quad;
    },
    cubic: function() {
      return d3_ease_cubic;
    },
    sin: function() {
      return d3_ease_sin;
    },
    exp: function() {
      return d3_ease_exp;
    },
    circle: function() {
      return d3_ease_circle;
    },
    elastic: d3_ease_elastic,
    back: d3_ease_back,
    bounce: function() {
      return d3_ease_bounce;
    }
  });
  var d3_ease_mode = d3.map({
    "in": d3_identity,
    out: d3_ease_reverse,
    "in-out": d3_ease_reflect,
    "out-in": function(f) {
      return d3_ease_reflect(d3_ease_reverse(f));
    }
  });
  d3.ease = function(name) {
    var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
    t = d3_ease.get(t) || d3_ease_default;
    m = d3_ease_mode.get(m) || d3_identity;
    return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
  };
  function d3_ease_clamp(f) {
    return function(t) {
      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
    };
  }
  function d3_ease_reverse(f) {
    return function(t) {
      return 1 - f(1 - t);
    };
  }
  function d3_ease_reflect(f) {
    return function(t) {
      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
    };
  }
  function d3_ease_quad(t) {
    return t * t;
  }
  function d3_ease_cubic(t) {
    return t * t * t;
  }
  function d3_ease_cubicInOut(t) {
    if (t <= 0) return 0;
    if (t >= 1) return 1;
    var t2 = t * t, t3 = t2 * t;
    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
  }
  function d3_ease_poly(e) {
    return function(t) {
      return Math.pow(t, e);
    };
  }
  function d3_ease_sin(t) {
    return 1 - Math.cos(t * halfπ);
  }
  function d3_ease_exp(t) {
    return Math.pow(2, 10 * (t - 1));
  }
  function d3_ease_circle(t) {
    return 1 - Math.sqrt(1 - t * t);
  }
  function d3_ease_elastic(a, p) {
    var s;
    if (arguments.length < 2) p = .45;
    if (arguments.length) s = p / τ * Math.asin(1 / a); else a = 1, s = p / 4;
    return function(t) {
      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);
    };
  }
  function d3_ease_back(s) {
    if (!s) s = 1.70158;
    return function(t) {
      return t * t * ((s + 1) * t - s);
    };
  }
  function d3_ease_bounce(t) {
    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
  }
  d3.interpolateHcl = d3_interpolateHcl;
  function d3_interpolateHcl(a, b) {
    a = d3.hcl(a);
    b = d3.hcl(b);
    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
    if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
    };
  }
  d3.interpolateHsl = d3_interpolateHsl;
  function d3_interpolateHsl(a, b) {
    a = d3.hsl(a);
    b = d3.hsl(b);
    var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
    if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
    };
  }
  d3.interpolateLab = d3_interpolateLab;
  function d3_interpolateLab(a, b) {
    a = d3.lab(a);
    b = d3.lab(b);
    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
    return function(t) {
      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
    };
  }
  d3.interpolateRound = d3_interpolateRound;
  function d3_interpolateRound(a, b) {
    b -= a;
    return function(t) {
      return Math.round(a + b * t);
    };
  }
  d3.transform = function(string) {
    var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
    return (d3.transform = function(string) {
      if (string != null) {
        g.setAttribute("transform", string);
        var t = g.transform.baseVal.consolidate();
      }
      return new d3_transform(t ? t.matrix : d3_transformIdentity);
    })(string);
  };
  function d3_transform(m) {
    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
    if (r0[0] * r1[1] < r1[0] * r0[1]) {
      r0[0] *= -1;
      r0[1] *= -1;
      kx *= -1;
      kz *= -1;
    }
    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
    this.translate = [ m.e, m.f ];
    this.scale = [ kx, ky ];
    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
  }
  d3_transform.prototype.toString = function() {
    return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
  };
  function d3_transformDot(a, b) {
    return a[0] * b[0] + a[1] * b[1];
  }
  function d3_transformNormalize(a) {
    var k = Math.sqrt(d3_transformDot(a, a));
    if (k) {
      a[0] /= k;
      a[1] /= k;
    }
    return k;
  }
  function d3_transformCombine(a, b, k) {
    a[0] += k * b[0];
    a[1] += k * b[1];
    return a;
  }
  var d3_transformIdentity = {
    a: 1,
    b: 0,
    c: 0,
    d: 1,
    e: 0,
    f: 0
  };
  d3.interpolateTransform = d3_interpolateTransform;
  function d3_interpolateTransform(a, b) {
    var s = [], q = [], n, A = d3.transform(a), B = d3.transform(b), ta = A.translate, tb = B.translate, ra = A.rotate, rb = B.rotate, wa = A.skew, wb = B.skew, ka = A.scale, kb = B.scale;
    if (ta[0] != tb[0] || ta[1] != tb[1]) {
      s.push("translate(", null, ",", null, ")");
      q.push({
        i: 1,
        x: d3_interpolateNumber(ta[0], tb[0])
      }, {
        i: 3,
        x: d3_interpolateNumber(ta[1], tb[1])
      });
    } else if (tb[0] || tb[1]) {
      s.push("translate(" + tb + ")");
    } else {
      s.push("");
    }
    if (ra != rb) {
      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
      q.push({
        i: s.push(s.pop() + "rotate(", null, ")") - 2,
        x: d3_interpolateNumber(ra, rb)
      });
    } else if (rb) {
      s.push(s.pop() + "rotate(" + rb + ")");
    }
    if (wa != wb) {
      q.push({
        i: s.push(s.pop() + "skewX(", null, ")") - 2,
        x: d3_interpolateNumber(wa, wb)
      });
    } else if (wb) {
      s.push(s.pop() + "skewX(" + wb + ")");
    }
    if (ka[0] != kb[0] || ka[1] != kb[1]) {
      n = s.push(s.pop() + "scale(", null, ",", null, ")");
      q.push({
        i: n - 4,
        x: d3_interpolateNumber(ka[0], kb[0])
      }, {
        i: n - 2,
        x: d3_interpolateNumber(ka[1], kb[1])
      });
    } else if (kb[0] != 1 || kb[1] != 1) {
      s.push(s.pop() + "scale(" + kb + ")");
    }
    n = q.length;
    return function(t) {
      var i = -1, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  }
  function d3_uninterpolateNumber(a, b) {
    b = (b -= a = +a) || 1 / b;
    return function(x) {
      return (x - a) / b;
    };
  }
  function d3_uninterpolateClamp(a, b) {
    b = (b -= a = +a) || 1 / b;
    return function(x) {
      return Math.max(0, Math.min(1, (x - a) / b));
    };
  }
  d3.layout = {};
  d3.layout.bundle = function() {
    return function(links) {
      var paths = [], i = -1, n = links.length;
      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
      return paths;
    };
  };
  function d3_layout_bundlePath(link) {
    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
    while (start !== lca) {
      start = start.parent;
      points.push(start);
    }
    var k = points.length;
    while (end !== lca) {
      points.splice(k, 0, end);
      end = end.parent;
    }
    return points;
  }
  function d3_layout_bundleAncestors(node) {
    var ancestors = [], parent = node.parent;
    while (parent != null) {
      ancestors.push(node);
      node = parent;
      parent = parent.parent;
    }
    ancestors.push(node);
    return ancestors;
  }
  function d3_layout_bundleLeastCommonAncestor(a, b) {
    if (a === b) return a;
    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
    while (aNode === bNode) {
      sharedNode = aNode;
      aNode = aNodes.pop();
      bNode = bNodes.pop();
    }
    return sharedNode;
  }
  d3.layout.chord = function() {
    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
    function relayout() {
      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
      chords = [];
      groups = [];
      k = 0, i = -1;
      while (++i < n) {
        x = 0, j = -1;
        while (++j < n) {
          x += matrix[i][j];
        }
        groupSums.push(x);
        subgroupIndex.push(d3.range(n));
        k += x;
      }
      if (sortGroups) {
        groupIndex.sort(function(a, b) {
          return sortGroups(groupSums[a], groupSums[b]);
        });
      }
      if (sortSubgroups) {
        subgroupIndex.forEach(function(d, i) {
          d.sort(function(a, b) {
            return sortSubgroups(matrix[i][a], matrix[i][b]);
          });
        });
      }
      k = (τ - padding * n) / k;
      x = 0, i = -1;
      while (++i < n) {
        x0 = x, j = -1;
        while (++j < n) {
          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
          subgroups[di + "-" + dj] = {
            index: di,
            subindex: dj,
            startAngle: a0,
            endAngle: a1,
            value: v
          };
        }
        groups[di] = {
          index: di,
          startAngle: x0,
          endAngle: x,
          value: (x - x0) / k
        };
        x += padding;
      }
      i = -1;
      while (++i < n) {
        j = i - 1;
        while (++j < n) {
          var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
          if (source.value || target.value) {
            chords.push(source.value < target.value ? {
              source: target,
              target: source
            } : {
              source: source,
              target: target
            });
          }
        }
      }
      if (sortChords) resort();
    }
    function resort() {
      chords.sort(function(a, b) {
        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
      });
    }
    chord.matrix = function(x) {
      if (!arguments.length) return matrix;
      n = (matrix = x) && matrix.length;
      chords = groups = null;
      return chord;
    };
    chord.padding = function(x) {
      if (!arguments.length) return padding;
      padding = x;
      chords = groups = null;
      return chord;
    };
    chord.sortGroups = function(x) {
      if (!arguments.length) return sortGroups;
      sortGroups = x;
      chords = groups = null;
      return chord;
    };
    chord.sortSubgroups = function(x) {
      if (!arguments.length) return sortSubgroups;
      sortSubgroups = x;
      chords = null;
      return chord;
    };
    chord.sortChords = function(x) {
      if (!arguments.length) return sortChords;
      sortChords = x;
      if (chords) resort();
      return chord;
    };
    chord.chords = function() {
      if (!chords) relayout();
      return chords;
    };
    chord.groups = function() {
      if (!groups) relayout();
      return groups;
    };
    return chord;
  };
  d3.layout.force = function() {
    var force = {}, event = d3.dispatch("start", "tick", "end"), size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;
    function repulse(node) {
      return function(quad, x1, _, x2) {
        if (quad.point !== node) {
          var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
          if (dw * dw / theta2 < dn) {
            if (dn < chargeDistance2) {
              var k = quad.charge / dn;
              node.px -= dx * k;
              node.py -= dy * k;
            }
            return true;
          }
          if (quad.point && dn && dn < chargeDistance2) {
            var k = quad.pointCharge / dn;
            node.px -= dx * k;
            node.py -= dy * k;
          }
        }
        return !quad.charge;
      };
    }
    force.tick = function() {
      if ((alpha *= .99) < .005) {
        event.end({
          type: "end",
          alpha: alpha = 0
        });
        return true;
      }
      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
      for (i = 0; i < m; ++i) {
        o = links[i];
        s = o.source;
        t = o.target;
        x = t.x - s.x;
        y = t.y - s.y;
        if (l = x * x + y * y) {
          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
          x *= l;
          y *= l;
          t.x -= x * (k = s.weight / (t.weight + s.weight));
          t.y -= y * k;
          s.x += x * (k = 1 - k);
          s.y += y * k;
        }
      }
      if (k = alpha * gravity) {
        x = size[0] / 2;
        y = size[1] / 2;
        i = -1;
        if (k) while (++i < n) {
          o = nodes[i];
          o.x += (x - o.x) * k;
          o.y += (y - o.y) * k;
        }
      }
      if (charge) {
        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
        i = -1;
        while (++i < n) {
          if (!(o = nodes[i]).fixed) {
            q.visit(repulse(o));
          }
        }
      }
      i = -1;
      while (++i < n) {
        o = nodes[i];
        if (o.fixed) {
          o.x = o.px;
          o.y = o.py;
        } else {
          o.x -= (o.px - (o.px = o.x)) * friction;
          o.y -= (o.py - (o.py = o.y)) * friction;
        }
      }
      event.tick({
        type: "tick",
        alpha: alpha
      });
    };
    force.nodes = function(x) {
      if (!arguments.length) return nodes;
      nodes = x;
      return force;
    };
    force.links = function(x) {
      if (!arguments.length) return links;
      links = x;
      return force;
    };
    force.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return force;
    };
    force.linkDistance = function(x) {
      if (!arguments.length) return linkDistance;
      linkDistance = typeof x === "function" ? x : +x;
      return force;
    };
    force.distance = force.linkDistance;
    force.linkStrength = function(x) {
      if (!arguments.length) return linkStrength;
      linkStrength = typeof x === "function" ? x : +x;
      return force;
    };
    force.friction = function(x) {
      if (!arguments.length) return friction;
      friction = +x;
      return force;
    };
    force.charge = function(x) {
      if (!arguments.length) return charge;
      charge = typeof x === "function" ? x : +x;
      return force;
    };
    force.chargeDistance = function(x) {
      if (!arguments.length) return Math.sqrt(chargeDistance2);
      chargeDistance2 = x * x;
      return force;
    };
    force.gravity = function(x) {
      if (!arguments.length) return gravity;
      gravity = +x;
      return force;
    };
    force.theta = function(x) {
      if (!arguments.length) return Math.sqrt(theta2);
      theta2 = x * x;
      return force;
    };
    force.alpha = function(x) {
      if (!arguments.length) return alpha;
      x = +x;
      if (alpha) {
        if (x > 0) alpha = x; else alpha = 0;
      } else if (x > 0) {
        event.start({
          type: "start",
          alpha: alpha = x
        });
        d3.timer(force.tick);
      }
      return force;
    };
    force.start = function() {
      var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
      for (i = 0; i < n; ++i) {
        (o = nodes[i]).index = i;
        o.weight = 0;
      }
      for (i = 0; i < m; ++i) {
        o = links[i];
        if (typeof o.source == "number") o.source = nodes[o.source];
        if (typeof o.target == "number") o.target = nodes[o.target];
        ++o.source.weight;
        ++o.target.weight;
      }
      for (i = 0; i < n; ++i) {
        o = nodes[i];
        if (isNaN(o.x)) o.x = position("x", w);
        if (isNaN(o.y)) o.y = position("y", h);
        if (isNaN(o.px)) o.px = o.x;
        if (isNaN(o.py)) o.py = o.y;
      }
      distances = [];
      if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
      strengths = [];
      if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
      charges = [];
      if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
      function position(dimension, size) {
        if (!neighbors) {
          neighbors = new Array(n);
          for (j = 0; j < n; ++j) {
            neighbors[j] = [];
          }
          for (j = 0; j < m; ++j) {
            var o = links[j];
            neighbors[o.source.index].push(o.target);
            neighbors[o.target.index].push(o.source);
          }
        }
        var candidates = neighbors[i], j = -1, l = candidates.length, x;
        while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;
        return Math.random() * size;
      }
      return force.resume();
    };
    force.resume = function() {
      return force.alpha(.1);
    };
    force.stop = function() {
      return force.alpha(0);
    };
    force.drag = function() {
      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
      if (!arguments.length) return drag;
      this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
    };
    function dragmove(d) {
      d.px = d3.event.x, d.py = d3.event.y;
      force.resume();
    }
    return d3.rebind(force, event, "on");
  };
  function d3_layout_forceDragstart(d) {
    d.fixed |= 2;
  }
  function d3_layout_forceDragend(d) {
    d.fixed &= ~6;
  }
  function d3_layout_forceMouseover(d) {
    d.fixed |= 4;
    d.px = d.x, d.py = d.y;
  }
  function d3_layout_forceMouseout(d) {
    d.fixed &= ~4;
  }
  function d3_layout_forceAccumulate(quad, alpha, charges) {
    var cx = 0, cy = 0;
    quad.charge = 0;
    if (!quad.leaf) {
      var nodes = quad.nodes, n = nodes.length, i = -1, c;
      while (++i < n) {
        c = nodes[i];
        if (c == null) continue;
        d3_layout_forceAccumulate(c, alpha, charges);
        quad.charge += c.charge;
        cx += c.charge * c.cx;
        cy += c.charge * c.cy;
      }
    }
    if (quad.point) {
      if (!quad.leaf) {
        quad.point.x += Math.random() - .5;
        quad.point.y += Math.random() - .5;
      }
      var k = alpha * charges[quad.point.index];
      quad.charge += quad.pointCharge = k;
      cx += k * quad.point.x;
      cy += k * quad.point.y;
    }
    quad.cx = cx / quad.charge;
    quad.cy = cy / quad.charge;
  }
  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
  d3.layout.hierarchy = function() {
    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
    function hierarchy(root) {
      var stack = [ root ], nodes = [], node;
      root.depth = 0;
      while ((node = stack.pop()) != null) {
        nodes.push(node);
        if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
          var n, childs, child;
          while (--n >= 0) {
            stack.push(child = childs[n]);
            child.parent = node;
            child.depth = node.depth + 1;
          }
          if (value) node.value = 0;
          node.children = childs;
        } else {
          if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
          delete node.children;
        }
      }
      d3_layout_hierarchyVisitAfter(root, function(node) {
        var childs, parent;
        if (sort && (childs = node.children)) childs.sort(sort);
        if (value && (parent = node.parent)) parent.value += node.value;
      });
      return nodes;
    }
    hierarchy.sort = function(x) {
      if (!arguments.length) return sort;
      sort = x;
      return hierarchy;
    };
    hierarchy.children = function(x) {
      if (!arguments.length) return children;
      children = x;
      return hierarchy;
    };
    hierarchy.value = function(x) {
      if (!arguments.length) return value;
      value = x;
      return hierarchy;
    };
    hierarchy.revalue = function(root) {
      if (value) {
        d3_layout_hierarchyVisitBefore(root, function(node) {
          if (node.children) node.value = 0;
        });
        d3_layout_hierarchyVisitAfter(root, function(node) {
          var parent;
          if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
          if (parent = node.parent) parent.value += node.value;
        });
      }
      return root;
    };
    return hierarchy;
  };
  function d3_layout_hierarchyRebind(object, hierarchy) {
    d3.rebind(object, hierarchy, "sort", "children", "value");
    object.nodes = object;
    object.links = d3_layout_hierarchyLinks;
    return object;
  }
  function d3_layout_hierarchyVisitBefore(node, callback) {
    var nodes = [ node ];
    while ((node = nodes.pop()) != null) {
      callback(node);
      if ((children = node.children) && (n = children.length)) {
        var n, children;
        while (--n >= 0) nodes.push(children[n]);
      }
    }
  }
  function d3_layout_hierarchyVisitAfter(node, callback) {
    var nodes = [ node ], nodes2 = [];
    while ((node = nodes.pop()) != null) {
      nodes2.push(node);
      if ((children = node.children) && (n = children.length)) {
        var i = -1, n, children;
        while (++i < n) nodes.push(children[i]);
      }
    }
    while ((node = nodes2.pop()) != null) {
      callback(node);
    }
  }
  function d3_layout_hierarchyChildren(d) {
    return d.children;
  }
  function d3_layout_hierarchyValue(d) {
    return d.value;
  }
  function d3_layout_hierarchySort(a, b) {
    return b.value - a.value;
  }
  function d3_layout_hierarchyLinks(nodes) {
    return d3.merge(nodes.map(function(parent) {
      return (parent.children || []).map(function(child) {
        return {
          source: parent,
          target: child
        };
      });
    }));
  }
  d3.layout.partition = function() {
    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
    function position(node, x, dx, dy) {
      var children = node.children;
      node.x = x;
      node.y = node.depth * dy;
      node.dx = dx;
      node.dy = dy;
      if (children && (n = children.length)) {
        var i = -1, n, c, d;
        dx = node.value ? dx / node.value : 0;
        while (++i < n) {
          position(c = children[i], x, d = c.value * dx, dy);
          x += d;
        }
      }
    }
    function depth(node) {
      var children = node.children, d = 0;
      if (children && (n = children.length)) {
        var i = -1, n;
        while (++i < n) d = Math.max(d, depth(children[i]));
      }
      return 1 + d;
    }
    function partition(d, i) {
      var nodes = hierarchy.call(this, d, i);
      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
      return nodes;
    }
    partition.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return partition;
    };
    return d3_layout_hierarchyRebind(partition, hierarchy);
  };
  d3.layout.pie = function() {
    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = τ, padAngle = 0;
    function pie(data) {
      var n = data.length, values = data.map(function(d, i) {
        return +value.call(pie, d, i);
      }), a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), k = (da - n * pa) / d3.sum(values), index = d3.range(n), arcs = [], v;
      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
        return values[j] - values[i];
      } : function(i, j) {
        return sort(data[i], data[j]);
      });
      index.forEach(function(i) {
        arcs[i] = {
          data: data[i],
          value: v = values[i],
          startAngle: a,
          endAngle: a += v * k + pa,
          padAngle: p
        };
      });
      return arcs;
    }
    pie.value = function(_) {
      if (!arguments.length) return value;
      value = _;
      return pie;
    };
    pie.sort = function(_) {
      if (!arguments.length) return sort;
      sort = _;
      return pie;
    };
    pie.startAngle = function(_) {
      if (!arguments.length) return startAngle;
      startAngle = _;
      return pie;
    };
    pie.endAngle = function(_) {
      if (!arguments.length) return endAngle;
      endAngle = _;
      return pie;
    };
    pie.padAngle = function(_) {
      if (!arguments.length) return padAngle;
      padAngle = _;
      return pie;
    };
    return pie;
  };
  var d3_layout_pieSortByValue = {};
  d3.layout.stack = function() {
    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
    function stack(data, index) {
      if (!(n = data.length)) return data;
      var series = data.map(function(d, i) {
        return values.call(stack, d, i);
      });
      var points = series.map(function(d) {
        return d.map(function(v, i) {
          return [ x.call(stack, v, i), y.call(stack, v, i) ];
        });
      });
      var orders = order.call(stack, points, index);
      series = d3.permute(series, orders);
      points = d3.permute(points, orders);
      var offsets = offset.call(stack, points, index);
      var m = series[0].length, n, i, j, o;
      for (j = 0; j < m; ++j) {
        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
        for (i = 1; i < n; ++i) {
          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
        }
      }
      return data;
    }
    stack.values = function(x) {
      if (!arguments.length) return values;
      values = x;
      return stack;
    };
    stack.order = function(x) {
      if (!arguments.length) return order;
      order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
      return stack;
    };
    stack.offset = function(x) {
      if (!arguments.length) return offset;
      offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
      return stack;
    };
    stack.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      return stack;
    };
    stack.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      return stack;
    };
    stack.out = function(z) {
      if (!arguments.length) return out;
      out = z;
      return stack;
    };
    return stack;
  };
  function d3_layout_stackX(d) {
    return d.x;
  }
  function d3_layout_stackY(d) {
    return d.y;
  }
  function d3_layout_stackOut(d, y0, y) {
    d.y0 = y0;
    d.y = y;
  }
  var d3_layout_stackOrders = d3.map({
    "inside-out": function(data) {
      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
        return max[a] - max[b];
      }), top = 0, bottom = 0, tops = [], bottoms = [];
      for (i = 0; i < n; ++i) {
        j = index[i];
        if (top < bottom) {
          top += sums[j];
          tops.push(j);
        } else {
          bottom += sums[j];
          bottoms.push(j);
        }
      }
      return bottoms.reverse().concat(tops);
    },
    reverse: function(data) {
      return d3.range(data.length).reverse();
    },
    "default": d3_layout_stackOrderDefault
  });
  var d3_layout_stackOffsets = d3.map({
    silhouette: function(data) {
      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o > max) max = o;
        sums.push(o);
      }
      for (j = 0; j < m; ++j) {
        y0[j] = (max - sums[j]) / 2;
      }
      return y0;
    },
    wiggle: function(data) {
      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
      y0[0] = o = o0 = 0;
      for (j = 1; j < m; ++j) {
        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
          }
          s2 += s3 * data[i][j][1];
        }
        y0[j] = o -= s1 ? s2 / s1 * dx : 0;
        if (o < o0) o0 = o;
      }
      for (j = 0; j < m; ++j) y0[j] -= o0;
      return y0;
    },
    expand: function(data) {
      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
      }
      for (j = 0; j < m; ++j) y0[j] = 0;
      return y0;
    },
    zero: d3_layout_stackOffsetZero
  });
  function d3_layout_stackOrderDefault(data) {
    return d3.range(data.length);
  }
  function d3_layout_stackOffsetZero(data) {
    var j = -1, m = data[0].length, y0 = [];
    while (++j < m) y0[j] = 0;
    return y0;
  }
  function d3_layout_stackMaxIndex(array) {
    var i = 1, j = 0, v = array[0][1], k, n = array.length;
    for (;i < n; ++i) {
      if ((k = array[i][1]) > v) {
        j = i;
        v = k;
      }
    }
    return j;
  }
  function d3_layout_stackReduceSum(d) {
    return d.reduce(d3_layout_stackSum, 0);
  }
  function d3_layout_stackSum(p, d) {
    return p + d[1];
  }
  d3.layout.histogram = function() {
    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
    function histogram(data, i) {
      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
      while (++i < m) {
        bin = bins[i] = [];
        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
        bin.y = 0;
      }
      if (m > 0) {
        i = -1;
        while (++i < n) {
          x = values[i];
          if (x >= range[0] && x <= range[1]) {
            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
            bin.y += k;
            bin.push(data[i]);
          }
        }
      }
      return bins;
    }
    histogram.value = function(x) {
      if (!arguments.length) return valuer;
      valuer = x;
      return histogram;
    };
    histogram.range = function(x) {
      if (!arguments.length) return ranger;
      ranger = d3_functor(x);
      return histogram;
    };
    histogram.bins = function(x) {
      if (!arguments.length) return binner;
      binner = typeof x === "number" ? function(range) {
        return d3_layout_histogramBinFixed(range, x);
      } : d3_functor(x);
      return histogram;
    };
    histogram.frequency = function(x) {
      if (!arguments.length) return frequency;
      frequency = !!x;
      return histogram;
    };
    return histogram;
  };
  function d3_layout_histogramBinSturges(range, values) {
    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
  }
  function d3_layout_histogramBinFixed(range, n) {
    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
    while (++x <= n) f[x] = m * x + b;
    return f;
  }
  function d3_layout_histogramRange(values) {
    return [ d3.min(values), d3.max(values) ];
  }
  d3.layout.pack = function() {
    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;
    function pack(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
        return radius;
      };
      root.x = root.y = 0;
      d3_layout_hierarchyVisitAfter(root, function(d) {
        d.r = +r(d.value);
      });
      d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
      if (padding) {
        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
        d3_layout_hierarchyVisitAfter(root, function(d) {
          d.r += dr;
        });
        d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
        d3_layout_hierarchyVisitAfter(root, function(d) {
          d.r -= dr;
        });
      }
      d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
      return nodes;
    }
    pack.size = function(_) {
      if (!arguments.length) return size;
      size = _;
      return pack;
    };
    pack.radius = function(_) {
      if (!arguments.length) return radius;
      radius = _ == null || typeof _ === "function" ? _ : +_;
      return pack;
    };
    pack.padding = function(_) {
      if (!arguments.length) return padding;
      padding = +_;
      return pack;
    };
    return d3_layout_hierarchyRebind(pack, hierarchy);
  };
  function d3_layout_packSort(a, b) {
    return a.value - b.value;
  }
  function d3_layout_packInsert(a, b) {
    var c = a._pack_next;
    a._pack_next = b;
    b._pack_prev = a;
    b._pack_next = c;
    c._pack_prev = b;
  }
  function d3_layout_packSplice(a, b) {
    a._pack_next = b;
    b._pack_prev = a;
  }
  function d3_layout_packIntersects(a, b) {
    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
    return .999 * dr * dr > dx * dx + dy * dy;
  }
  function d3_layout_packSiblings(node) {
    if (!(nodes = node.children) || !(n = nodes.length)) return;
    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
    function bound(node) {
      xMin = Math.min(node.x - node.r, xMin);
      xMax = Math.max(node.x + node.r, xMax);
      yMin = Math.min(node.y - node.r, yMin);
      yMax = Math.max(node.y + node.r, yMax);
    }
    nodes.forEach(d3_layout_packLink);
    a = nodes[0];
    a.x = -a.r;
    a.y = 0;
    bound(a);
    if (n > 1) {
      b = nodes[1];
      b.x = b.r;
      b.y = 0;
      bound(b);
      if (n > 2) {
        c = nodes[2];
        d3_layout_packPlace(a, b, c);
        bound(c);
        d3_layout_packInsert(a, c);
        a._pack_prev = c;
        d3_layout_packInsert(c, b);
        b = a._pack_next;
        for (i = 3; i < n; i++) {
          d3_layout_packPlace(a, b, c = nodes[i]);
          var isect = 0, s1 = 1, s2 = 1;
          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
            if (d3_layout_packIntersects(j, c)) {
              isect = 1;
              break;
            }
          }
          if (isect == 1) {
            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
              if (d3_layout_packIntersects(k, c)) {
                break;
              }
            }
          }
          if (isect) {
            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
            i--;
          } else {
            d3_layout_packInsert(a, c);
            b = c;
            bound(c);
          }
        }
      }
    }
    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
    for (i = 0; i < n; i++) {
      c = nodes[i];
      c.x -= cx;
      c.y -= cy;
      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
    }
    node.r = cr;
    nodes.forEach(d3_layout_packUnlink);
  }
  function d3_layout_packLink(node) {
    node._pack_next = node._pack_prev = node;
  }
  function d3_layout_packUnlink(node) {
    delete node._pack_next;
    delete node._pack_prev;
  }
  function d3_layout_packTransform(node, x, y, k) {
    var children = node.children;
    node.x = x += k * node.x;
    node.y = y += k * node.y;
    node.r *= k;
    if (children) {
      var i = -1, n = children.length;
      while (++i < n) d3_layout_packTransform(children[i], x, y, k);
    }
  }
  function d3_layout_packPlace(a, b, c) {
    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
    if (db && (dx || dy)) {
      var da = b.r + c.r, dc = dx * dx + dy * dy;
      da *= da;
      db *= db;
      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
      c.x = a.x + x * dx + y * dy;
      c.y = a.y + x * dy - y * dx;
    } else {
      c.x = a.x + db;
      c.y = a.y;
    }
  }
  d3.layout.tree = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;
    function tree(d, i) {
      var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
      d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
      d3_layout_hierarchyVisitBefore(root1, secondWalk);
      if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {
        var left = root0, right = root0, bottom = root0;
        d3_layout_hierarchyVisitBefore(root0, function(node) {
          if (node.x < left.x) left = node;
          if (node.x > right.x) right = node;
          if (node.depth > bottom.depth) bottom = node;
        });
        var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
        d3_layout_hierarchyVisitBefore(root0, function(node) {
          node.x = (node.x + tx) * kx;
          node.y = node.depth * ky;
        });
      }
      return nodes;
    }
    function wrapTree(root0) {
      var root1 = {
        A: null,
        children: [ root0 ]
      }, queue = [ root1 ], node1;
      while ((node1 = queue.pop()) != null) {
        for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
          queue.push((children[i] = child = {
            _: children[i],
            parent: node1,
            children: (child = children[i].children) && child.slice() || [],
            A: null,
            a: null,
            z: 0,
            m: 0,
            c: 0,
            s: 0,
            t: null,
            i: i
          }).a = child);
        }
      }
      return root1.children[0];
    }
    function firstWalk(v) {
      var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
      if (children.length) {
        d3_layout_treeShift(v);
        var midpoint = (children[0].z + children[children.length - 1].z) / 2;
        if (w) {
          v.z = w.z + separation(v._, w._);
          v.m = v.z - midpoint;
        } else {
          v.z = midpoint;
        }
      } else if (w) {
        v.z = w.z + separation(v._, w._);
      }
      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
    }
    function secondWalk(v) {
      v._.x = v.z + v.parent.m;
      v.m += v.parent.m;
    }
    function apportion(v, w, ancestor) {
      if (w) {
        var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
          vom = d3_layout_treeLeft(vom);
          vop = d3_layout_treeRight(vop);
          vop.a = v;
          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
          if (shift > 0) {
            d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
            sip += shift;
            sop += shift;
          }
          sim += vim.m;
          sip += vip.m;
          som += vom.m;
          sop += vop.m;
        }
        if (vim && !d3_layout_treeRight(vop)) {
          vop.t = vim;
          vop.m += sim - sop;
        }
        if (vip && !d3_layout_treeLeft(vom)) {
          vom.t = vip;
          vom.m += sip - som;
          ancestor = v;
        }
      }
      return ancestor;
    }
    function sizeNode(node) {
      node.x *= size[0];
      node.y = node.depth * size[1];
    }
    tree.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return tree;
    };
    tree.size = function(x) {
      if (!arguments.length) return nodeSize ? null : size;
      nodeSize = (size = x) == null ? sizeNode : null;
      return tree;
    };
    tree.nodeSize = function(x) {
      if (!arguments.length) return nodeSize ? size : null;
      nodeSize = (size = x) == null ? null : sizeNode;
      return tree;
    };
    return d3_layout_hierarchyRebind(tree, hierarchy);
  };
  function d3_layout_treeSeparation(a, b) {
    return a.parent == b.parent ? 1 : 2;
  }
  function d3_layout_treeLeft(v) {
    var children = v.children;
    return children.length ? children[0] : v.t;
  }
  function d3_layout_treeRight(v) {
    var children = v.children, n;
    return (n = children.length) ? children[n - 1] : v.t;
  }
  function d3_layout_treeMove(wm, wp, shift) {
    var change = shift / (wp.i - wm.i);
    wp.c -= change;
    wp.s += shift;
    wm.c += change;
    wp.z += shift;
    wp.m += shift;
  }
  function d3_layout_treeShift(v) {
    var shift = 0, change = 0, children = v.children, i = children.length, w;
    while (--i >= 0) {
      w = children[i];
      w.z += shift;
      w.m += shift;
      shift += w.s + (change += w.c);
    }
  }
  function d3_layout_treeAncestor(vim, v, ancestor) {
    return vim.a.parent === v.parent ? vim.a : ancestor;
  }
  d3.layout.cluster = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;
    function cluster(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
      d3_layout_hierarchyVisitAfter(root, function(node) {
        var children = node.children;
        if (children && children.length) {
          node.x = d3_layout_clusterX(children);
          node.y = d3_layout_clusterY(children);
        } else {
          node.x = previousNode ? x += separation(node, previousNode) : 0;
          node.y = 0;
          previousNode = node;
        }
      });
      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
      d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
        node.x = (node.x - root.x) * size[0];
        node.y = (root.y - node.y) * size[1];
      } : function(node) {
        node.x = (node.x - x0) / (x1 - x0) * size[0];
        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
      });
      return nodes;
    }
    cluster.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return cluster;
    };
    cluster.size = function(x) {
      if (!arguments.length) return nodeSize ? null : size;
      nodeSize = (size = x) == null;
      return cluster;
    };
    cluster.nodeSize = function(x) {
      if (!arguments.length) return nodeSize ? size : null;
      nodeSize = (size = x) != null;
      return cluster;
    };
    return d3_layout_hierarchyRebind(cluster, hierarchy);
  };
  function d3_layout_clusterY(children) {
    return 1 + d3.max(children, function(child) {
      return child.y;
    });
  }
  function d3_layout_clusterX(children) {
    return children.reduce(function(x, child) {
      return x + child.x;
    }, 0) / children.length;
  }
  function d3_layout_clusterLeft(node) {
    var children = node.children;
    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
  }
  function d3_layout_clusterRight(node) {
    var children = node.children, n;
    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
  }
  d3.layout.treemap = function() {
    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
    function scale(children, k) {
      var i = -1, n = children.length, child, area;
      while (++i < n) {
        area = (child = children[i]).value * (k < 0 ? 0 : k);
        child.area = isNaN(area) || area <= 0 ? 0 : area;
      }
    }
    function squarify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while ((n = remaining.length) > 0) {
          row.push(child = remaining[n - 1]);
          row.area += child.area;
          if (mode !== "squarify" || (score = worst(row, u)) <= best) {
            remaining.pop();
            best = score;
          } else {
            row.area -= row.pop().area;
            position(row, u, rect, false);
            u = Math.min(rect.dx, rect.dy);
            row.length = row.area = 0;
            best = Infinity;
          }
        }
        if (row.length) {
          position(row, u, rect, true);
          row.length = row.area = 0;
        }
        children.forEach(squarify);
      }
    }
    function stickify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), remaining = children.slice(), child, row = [];
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while (child = remaining.pop()) {
          row.push(child);
          row.area += child.area;
          if (child.z != null) {
            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
            row.length = row.area = 0;
          }
        }
        children.forEach(stickify);
      }
    }
    function worst(row, u) {
      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
      while (++i < n) {
        if (!(r = row[i].area)) continue;
        if (r < rmin) rmin = r;
        if (r > rmax) rmax = r;
      }
      s *= s;
      u *= u;
      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
    }
    function position(row, u, rect, flush) {
      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
      if (u == rect.dx) {
        if (flush || v > rect.dy) v = rect.dy;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dy = v;
          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
        }
        o.z = true;
        o.dx += rect.x + rect.dx - x;
        rect.y += v;
        rect.dy -= v;
      } else {
        if (flush || v > rect.dx) v = rect.dx;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dx = v;
          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
        }
        o.z = false;
        o.dy += rect.y + rect.dy - y;
        rect.x += v;
        rect.dx -= v;
      }
    }
    function treemap(d) {
      var nodes = stickies || hierarchy(d), root = nodes[0];
      root.x = 0;
      root.y = 0;
      root.dx = size[0];
      root.dy = size[1];
      if (stickies) hierarchy.revalue(root);
      scale([ root ], root.dx * root.dy / root.value);
      (stickies ? stickify : squarify)(root);
      if (sticky) stickies = nodes;
      return nodes;
    }
    treemap.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return treemap;
    };
    treemap.padding = function(x) {
      if (!arguments.length) return padding;
      function padFunction(node) {
        var p = x.call(treemap, node, node.depth);
        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
      }
      function padConstant(node) {
        return d3_layout_treemapPad(node, x);
      }
      var type;
      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], 
      padConstant) : padConstant;
      return treemap;
    };
    treemap.round = function(x) {
      if (!arguments.length) return round != Number;
      round = x ? Math.round : Number;
      return treemap;
    };
    treemap.sticky = function(x) {
      if (!arguments.length) return sticky;
      sticky = x;
      stickies = null;
      return treemap;
    };
    treemap.ratio = function(x) {
      if (!arguments.length) return ratio;
      ratio = x;
      return treemap;
    };
    treemap.mode = function(x) {
      if (!arguments.length) return mode;
      mode = x + "";
      return treemap;
    };
    return d3_layout_hierarchyRebind(treemap, hierarchy);
  };
  function d3_layout_treemapPadNull(node) {
    return {
      x: node.x,
      y: node.y,
      dx: node.dx,
      dy: node.dy
    };
  }
  function d3_layout_treemapPad(node, padding) {
    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
    if (dx < 0) {
      x += dx / 2;
      dx = 0;
    }
    if (dy < 0) {
      y += dy / 2;
      dy = 0;
    }
    return {
      x: x,
      y: y,
      dx: dx,
      dy: dy
    };
  }
  d3.random = {
    normal: function(µ, σ) {
      var n = arguments.length;
      if (n < 2) σ = 1;
      if (n < 1) µ = 0;
      return function() {
        var x, y, r;
        do {
          x = Math.random() * 2 - 1;
          y = Math.random() * 2 - 1;
          r = x * x + y * y;
        } while (!r || r > 1);
        return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
      };
    },
    logNormal: function() {
      var random = d3.random.normal.apply(d3, arguments);
      return function() {
        return Math.exp(random());
      };
    },
    bates: function(m) {
      var random = d3.random.irwinHall(m);
      return function() {
        return random() / m;
      };
    },
    irwinHall: function(m) {
      return function() {
        for (var s = 0, j = 0; j < m; j++) s += Math.random();
        return s;
      };
    }
  };
  d3.scale = {};
  function d3_scaleExtent(domain) {
    var start = domain[0], stop = domain[domain.length - 1];
    return start < stop ? [ start, stop ] : [ stop, start ];
  }
  function d3_scaleRange(scale) {
    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
  }
  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
    return function(x) {
      return i(u(x));
    };
  }
  function d3_scale_nice(domain, nice) {
    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
    if (x1 < x0) {
      dx = i0, i0 = i1, i1 = dx;
      dx = x0, x0 = x1, x1 = dx;
    }
    domain[i0] = nice.floor(x0);
    domain[i1] = nice.ceil(x1);
    return domain;
  }
  function d3_scale_niceStep(step) {
    return step ? {
      floor: function(x) {
        return Math.floor(x / step) * step;
      },
      ceil: function(x) {
        return Math.ceil(x / step) * step;
      }
    } : d3_scale_niceIdentity;
  }
  var d3_scale_niceIdentity = {
    floor: d3_identity,
    ceil: d3_identity
  };
  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
    if (domain[k] < domain[0]) {
      domain = domain.slice().reverse();
      range = range.slice().reverse();
    }
    while (++j <= k) {
      u.push(uninterpolate(domain[j - 1], domain[j]));
      i.push(interpolate(range[j - 1], range[j]));
    }
    return function(x) {
      var j = d3.bisect(domain, x, 1, k) - 1;
      return i[j](u[j](x));
    };
  }
  d3.scale.linear = function() {
    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);
  };
  function d3_scale_linear(domain, range, interpolate, clamp) {
    var output, input;
    function rescale() {
      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
      output = linear(domain, range, uninterpolate, interpolate);
      input = linear(range, domain, uninterpolate, d3_interpolate);
      return scale;
    }
    function scale(x) {
      return output(x);
    }
    scale.invert = function(y) {
      return input(y);
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(Number);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.rangeRound = function(x) {
      return scale.range(x).interpolate(d3_interpolateRound);
    };
    scale.clamp = function(x) {
      if (!arguments.length) return clamp;
      clamp = x;
      return rescale();
    };
    scale.interpolate = function(x) {
      if (!arguments.length) return interpolate;
      interpolate = x;
      return rescale();
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    scale.nice = function(m) {
      d3_scale_linearNice(domain, m);
      return rescale();
    };
    scale.copy = function() {
      return d3_scale_linear(domain, range, interpolate, clamp);
    };
    return rescale();
  }
  function d3_scale_linearRebind(scale, linear) {
    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
  }
  function d3_scale_linearNice(domain, m) {
    return d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
  }
  function d3_scale_linearTickRange(domain, m) {
    if (m == null) m = 10;
    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
    extent[0] = Math.ceil(extent[0] / step) * step;
    extent[1] = Math.floor(extent[1] / step) * step + step * .5;
    extent[2] = step;
    return extent;
  }
  function d3_scale_linearTicks(domain, m) {
    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
  }
  function d3_scale_linearTickFormat(domain, m, format) {
    var range = d3_scale_linearTickRange(domain, m);
    if (format) {
      var match = d3_format_re.exec(format);
      match.shift();
      if (match[8] === "s") {
        var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
        if (!match[7]) match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
        match[8] = "f";
        format = d3.format(match.join(""));
        return function(d) {
          return format(prefix.scale(d)) + prefix.symbol;
        };
      }
      if (!match[7]) match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
      format = match.join("");
    } else {
      format = ",." + d3_scale_linearPrecision(range[2]) + "f";
    }
    return d3.format(format);
  }
  var d3_scale_linearFormatSignificant = {
    s: 1,
    g: 1,
    p: 1,
    r: 1,
    e: 1
  };
  function d3_scale_linearPrecision(value) {
    return -Math.floor(Math.log(value) / Math.LN10 + .01);
  }
  function d3_scale_linearFormatPrecision(type, range) {
    var p = d3_scale_linearPrecision(range[2]);
    return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
  }
  d3.scale.log = function() {
    return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);
  };
  function d3_scale_log(linear, base, positive, domain) {
    function log(x) {
      return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
    }
    function pow(x) {
      return positive ? Math.pow(base, x) : -Math.pow(base, -x);
    }
    function scale(x) {
      return linear(log(x));
    }
    scale.invert = function(x) {
      return pow(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      positive = x[0] >= 0;
      linear.domain((domain = x.map(Number)).map(log));
      return scale;
    };
    scale.base = function(_) {
      if (!arguments.length) return base;
      base = +_;
      linear.domain(domain.map(log));
      return scale;
    };
    scale.nice = function() {
      var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
      linear.domain(niced);
      domain = niced.map(pow);
      return scale;
    };
    scale.ticks = function() {
      var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
      if (isFinite(j - i)) {
        if (positive) {
          for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
          ticks.push(pow(i));
        } else {
          ticks.push(pow(i));
          for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
        }
        for (i = 0; ticks[i] < u; i++) {}
        for (j = ticks.length; ticks[j - 1] > v; j--) {}
        ticks = ticks.slice(i, j);
      }
      return ticks;
    };
    scale.tickFormat = function(n, format) {
      if (!arguments.length) return d3_scale_logFormat;
      if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== "function") format = d3.format(format);
      var k = Math.max(.1, n / scale.ticks().length), f = positive ? (e = 1e-12, Math.ceil) : (e = -1e-12, 
      Math.floor), e;
      return function(d) {
        return d / pow(f(log(d) + e)) <= k ? format(d) : "";
      };
    };
    scale.copy = function() {
      return d3_scale_log(linear.copy(), base, positive, domain);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {
    floor: function(x) {
      return -Math.ceil(-x);
    },
    ceil: function(x) {
      return -Math.floor(-x);
    }
  };
  d3.scale.pow = function() {
    return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);
  };
  function d3_scale_pow(linear, exponent, domain) {
    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
    function scale(x) {
      return linear(powp(x));
    }
    scale.invert = function(x) {
      return powb(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      linear.domain((domain = x.map(Number)).map(powp));
      return scale;
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    scale.nice = function(m) {
      return scale.domain(d3_scale_linearNice(domain, m));
    };
    scale.exponent = function(x) {
      if (!arguments.length) return exponent;
      powp = d3_scale_powPow(exponent = x);
      powb = d3_scale_powPow(1 / exponent);
      linear.domain(domain.map(powp));
      return scale;
    };
    scale.copy = function() {
      return d3_scale_pow(linear.copy(), exponent, domain);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_scale_powPow(e) {
    return function(x) {
      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
    };
  }
  d3.scale.sqrt = function() {
    return d3.scale.pow().exponent(.5);
  };
  d3.scale.ordinal = function() {
    return d3_scale_ordinal([], {
      t: "range",
      a: [ [] ]
    });
  };
  function d3_scale_ordinal(domain, ranger) {
    var index, range, rangeBand;
    function scale(x) {
      return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
    }
    function steps(start, step) {
      return d3.range(domain.length).map(function(i) {
        return start + step * i;
      });
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = [];
      index = new d3_Map();
      var i = -1, n = x.length, xi;
      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
      return scale[ranger.t].apply(scale, ranger.a);
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      rangeBand = 0;
      ranger = {
        t: "range",
        a: arguments
      };
      return scale;
    };
    scale.rangePoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, 
      0) : (stop - start) / (domain.length - 1 + padding);
      range = steps(start + step * padding / 2, step);
      rangeBand = 0;
      ranger = {
        t: "rangePoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundPoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 
      0) : (stop - start) / (domain.length - 1 + padding) | 0;
      range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
      rangeBand = 0;
      ranger = {
        t: "rangeRoundPoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
      range = steps(start + step * outerPadding, step);
      if (reverse) range.reverse();
      rangeBand = step * (1 - padding);
      ranger = {
        t: "rangeBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
      range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
      if (reverse) range.reverse();
      rangeBand = Math.round(step * (1 - padding));
      ranger = {
        t: "rangeRoundBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeBand = function() {
      return rangeBand;
    };
    scale.rangeExtent = function() {
      return d3_scaleExtent(ranger.a[0]);
    };
    scale.copy = function() {
      return d3_scale_ordinal(domain, ranger);
    };
    return scale.domain(domain);
  }
  d3.scale.category10 = function() {
    return d3.scale.ordinal().range(d3_category10);
  };
  d3.scale.category20 = function() {
    return d3.scale.ordinal().range(d3_category20);
  };
  d3.scale.category20b = function() {
    return d3.scale.ordinal().range(d3_category20b);
  };
  d3.scale.category20c = function() {
    return d3.scale.ordinal().range(d3_category20c);
  };
  var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);
  var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);
  var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);
  var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);
  d3.scale.quantile = function() {
    return d3_scale_quantile([], []);
  };
  function d3_scale_quantile(domain, range) {
    var thresholds;
    function rescale() {
      var k = 0, q = range.length;
      thresholds = [];
      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
      return scale;
    }
    function scale(x) {
      if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.quantiles = function() {
      return thresholds;
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];
    };
    scale.copy = function() {
      return d3_scale_quantile(domain, range);
    };
    return rescale();
  }
  d3.scale.quantize = function() {
    return d3_scale_quantize(0, 1, [ 0, 1 ]);
  };
  function d3_scale_quantize(x0, x1, range) {
    var kx, i;
    function scale(x) {
      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
    }
    function rescale() {
      kx = range.length / (x1 - x0);
      i = range.length - 1;
      return scale;
    }
    scale.domain = function(x) {
      if (!arguments.length) return [ x0, x1 ];
      x0 = +x[0];
      x1 = +x[x.length - 1];
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      y = y < 0 ? NaN : y / kx + x0;
      return [ y, y + 1 / kx ];
    };
    scale.copy = function() {
      return d3_scale_quantize(x0, x1, range);
    };
    return rescale();
  }
  d3.scale.threshold = function() {
    return d3_scale_threshold([ .5 ], [ 0, 1 ]);
  };
  function d3_scale_threshold(domain, range) {
    function scale(x) {
      if (x <= x) return range[d3.bisect(domain, x)];
    }
    scale.domain = function(_) {
      if (!arguments.length) return domain;
      domain = _;
      return scale;
    };
    scale.range = function(_) {
      if (!arguments.length) return range;
      range = _;
      return scale;
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      return [ domain[y - 1], domain[y] ];
    };
    scale.copy = function() {
      return d3_scale_threshold(domain, range);
    };
    return scale;
  }
  d3.scale.identity = function() {
    return d3_scale_identity([ 0, 1 ]);
  };
  function d3_scale_identity(domain) {
    function identity(x) {
      return +x;
    }
    identity.invert = identity;
    identity.domain = identity.range = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(identity);
      return identity;
    };
    identity.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    identity.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    identity.copy = function() {
      return d3_scale_identity(domain);
    };
    return identity;
  }
  d3.svg = {};
  function d3_zero() {
    return 0;
  }
  d3.svg.arc = function() {
    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
    function arc() {
      var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - halfπ, a1 = endAngle.apply(this, arguments) - halfπ, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
      if (r1 < r0) rc = r1, r1 = r0, r0 = rc;
      if (da >= τε) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
      var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
      if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
        rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
        if (!cw) p1 *= -1;
        if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));
        if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));
      }
      if (r1) {
        x0 = r1 * Math.cos(a0 + p1);
        y0 = r1 * Math.sin(a0 + p1);
        x1 = r1 * Math.cos(a1 - p1);
        y1 = r1 * Math.sin(a1 - p1);
        var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;
        if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
          var h1 = (a0 + a1) / 2;
          x0 = r1 * Math.cos(h1);
          y0 = r1 * Math.sin(h1);
          x1 = y1 = null;
        }
      } else {
        x0 = y0 = 0;
      }
      if (r0) {
        x2 = r0 * Math.cos(a1 - p0);
        y2 = r0 * Math.sin(a1 - p0);
        x3 = r0 * Math.cos(a0 + p0);
        y3 = r0 * Math.sin(a0 + p0);
        var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;
        if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
          var h0 = (a0 + a1) / 2;
          x2 = r0 * Math.cos(h0);
          y2 = r0 * Math.sin(h0);
          x3 = y3 = null;
        }
      } else {
        x2 = y2 = 0;
      }
      if ((rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
        cr = r0 < r1 ^ cw ? 0 : 1;
        var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
        if (x1 != null) {
          var rc1 = Math.min(rc, (r1 - lc) / (kc + 1)), t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);
          if (rc === rc1) {
            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
          } else {
            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
          }
        } else {
          path.push("M", x0, ",", y0);
        }
        if (x3 != null) {
          var rc0 = Math.min(rc, (r0 - lc) / (kc - 1)), t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);
          if (rc === rc0) {
            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
          } else {
            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
          }
        } else {
          path.push("L", x2, ",", y2);
        }
      } else {
        path.push("M", x0, ",", y0);
        if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
        path.push("L", x2, ",", y2);
        if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
      }
      path.push("Z");
      return path.join("");
    }
    function circleSegment(r1, cw) {
      return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
    }
    arc.innerRadius = function(v) {
      if (!arguments.length) return innerRadius;
      innerRadius = d3_functor(v);
      return arc;
    };
    arc.outerRadius = function(v) {
      if (!arguments.length) return outerRadius;
      outerRadius = d3_functor(v);
      return arc;
    };
    arc.cornerRadius = function(v) {
      if (!arguments.length) return cornerRadius;
      cornerRadius = d3_functor(v);
      return arc;
    };
    arc.padRadius = function(v) {
      if (!arguments.length) return padRadius;
      padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
      return arc;
    };
    arc.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return arc;
    };
    arc.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return arc;
    };
    arc.padAngle = function(v) {
      if (!arguments.length) return padAngle;
      padAngle = d3_functor(v);
      return arc;
    };
    arc.centroid = function() {
      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;
      return [ Math.cos(a) * r, Math.sin(a) * r ];
    };
    return arc;
  };
  var d3_svg_arcAuto = "auto";
  function d3_svg_arcInnerRadius(d) {
    return d.innerRadius;
  }
  function d3_svg_arcOuterRadius(d) {
    return d.outerRadius;
  }
  function d3_svg_arcStartAngle(d) {
    return d.startAngle;
  }
  function d3_svg_arcEndAngle(d) {
    return d.endAngle;
  }
  function d3_svg_arcPadAngle(d) {
    return d && d.padAngle;
  }
  function d3_svg_arcSweep(x0, y0, x1, y1) {
    return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
  }
  function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
    var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(r * r * d2 - D * D), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
    return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];
  }
  function d3_svg_line(projection) {
    var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
    function line(data) {
      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
      function segment() {
        segments.push("M", interpolate(projection(points), tension));
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
        } else if (points.length) {
          segment();
          points = [];
        }
      }
      if (points.length) segment();
      return segments.length ? segments.join("") : null;
    }
    line.x = function(_) {
      if (!arguments.length) return x;
      x = _;
      return line;
    };
    line.y = function(_) {
      if (!arguments.length) return y;
      y = _;
      return line;
    };
    line.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return line;
    };
    line.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      return line;
    };
    line.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return line;
    };
    return line;
  }
  d3.svg.line = function() {
    return d3_svg_line(d3_identity);
  };
  var d3_svg_lineInterpolators = d3.map({
    linear: d3_svg_lineLinear,
    "linear-closed": d3_svg_lineLinearClosed,
    step: d3_svg_lineStep,
    "step-before": d3_svg_lineStepBefore,
    "step-after": d3_svg_lineStepAfter,
    basis: d3_svg_lineBasis,
    "basis-open": d3_svg_lineBasisOpen,
    "basis-closed": d3_svg_lineBasisClosed,
    bundle: d3_svg_lineBundle,
    cardinal: d3_svg_lineCardinal,
    "cardinal-open": d3_svg_lineCardinalOpen,
    "cardinal-closed": d3_svg_lineCardinalClosed,
    monotone: d3_svg_lineMonotone
  });
  d3_svg_lineInterpolators.forEach(function(key, value) {
    value.key = key;
    value.closed = /-closed$/.test(key);
  });
  function d3_svg_lineLinear(points) {
    return points.join("L");
  }
  function d3_svg_lineLinearClosed(points) {
    return d3_svg_lineLinear(points) + "Z";
  }
  function d3_svg_lineStep(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
    if (n > 1) path.push("H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepBefore(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepAfter(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
    return path.join("");
  }
  function d3_svg_lineCardinalOpen(points, tension) {
    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineCardinalClosed(points, tension) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), 
    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
  }
  function d3_svg_lineCardinal(points, tension) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineHermite(points, tangents) {
    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
      return d3_svg_lineLinear(points);
    }
    var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
    if (quad) {
      path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
      p0 = points[1];
      pi = 2;
    }
    if (tangents.length > 1) {
      t = tangents[1];
      p = points[pi];
      pi++;
      path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      for (var i = 2; i < tangents.length; i++, pi++) {
        p = points[pi];
        t = tangents[i];
        path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      }
    }
    if (quad) {
      var lp = points[pi];
      path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
    }
    return path;
  }
  function d3_svg_lineCardinalTangents(points, tension) {
    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
    while (++i < n) {
      p0 = p1;
      p1 = p2;
      p2 = points[i];
      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
    }
    return tangents;
  }
  function d3_svg_lineBasis(points) {
    if (points.length < 3) return d3_svg_lineLinear(points);
    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    points.push(points[n - 1]);
    while (++i <= n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    points.pop();
    path.push("L", pi);
    return path.join("");
  }
  function d3_svg_lineBasisOpen(points) {
    if (points.length < 4) return d3_svg_lineLinear(points);
    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
    while (++i < 3) {
      pi = points[i];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
    --i;
    while (++i < n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBasisClosed(points) {
    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
    while (++i < 4) {
      pi = points[i % n];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    --i;
    while (++i < m) {
      pi = points[i % n];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBundle(points, tension) {
    var n = points.length - 1;
    if (n) {
      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
      while (++i <= n) {
        p = points[i];
        t = i / n;
        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
      }
    }
    return d3_svg_lineBasis(points);
  }
  function d3_svg_lineDot4(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  }
  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
  function d3_svg_lineBasisBezier(path, x, y) {
    path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
  }
  function d3_svg_lineSlope(p0, p1) {
    return (p1[1] - p0[1]) / (p1[0] - p0[0]);
  }
  function d3_svg_lineFiniteDifferences(points) {
    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
    while (++i < j) {
      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
    }
    m[i] = d;
    return m;
  }
  function d3_svg_lineMonotoneTangents(points) {
    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
    while (++i < j) {
      d = d3_svg_lineSlope(points[i], points[i + 1]);
      if (abs(d) < ε) {
        m[i] = m[i + 1] = 0;
      } else {
        a = m[i] / d;
        b = m[i + 1] / d;
        s = a * a + b * b;
        if (s > 9) {
          s = d * 3 / Math.sqrt(s);
          m[i] = s * a;
          m[i + 1] = s * b;
        }
      }
    }
    i = -1;
    while (++i <= j) {
      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
      tangents.push([ s || 0, m[i] * s || 0 ]);
    }
    return tangents;
  }
  function d3_svg_lineMonotone(points) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
  }
  d3.svg.line.radial = function() {
    var line = d3_svg_line(d3_svg_lineRadial);
    line.radius = line.x, delete line.x;
    line.angle = line.y, delete line.y;
    return line;
  };
  function d3_svg_lineRadial(points) {
    var point, i = -1, n = points.length, r, a;
    while (++i < n) {
      point = points[i];
      r = point[0];
      a = point[1] - halfπ;
      point[0] = r * Math.cos(a);
      point[1] = r * Math.sin(a);
    }
    return points;
  }
  function d3_svg_area(projection) {
    var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
    function area(data) {
      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
        return x;
      } : d3_functor(x1), fy1 = y0 === y1 ? function() {
        return y;
      } : d3_functor(y1), x, y;
      function segment() {
        segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
        } else if (points0.length) {
          segment();
          points0 = [];
          points1 = [];
        }
      }
      if (points0.length) segment();
      return segments.length ? segments.join("") : null;
    }
    area.x = function(_) {
      if (!arguments.length) return x1;
      x0 = x1 = _;
      return area;
    };
    area.x0 = function(_) {
      if (!arguments.length) return x0;
      x0 = _;
      return area;
    };
    area.x1 = function(_) {
      if (!arguments.length) return x1;
      x1 = _;
      return area;
    };
    area.y = function(_) {
      if (!arguments.length) return y1;
      y0 = y1 = _;
      return area;
    };
    area.y0 = function(_) {
      if (!arguments.length) return y0;
      y0 = _;
      return area;
    };
    area.y1 = function(_) {
      if (!arguments.length) return y1;
      y1 = _;
      return area;
    };
    area.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return area;
    };
    area.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      interpolateReverse = interpolate.reverse || interpolate;
      L = interpolate.closed ? "M" : "L";
      return area;
    };
    area.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return area;
    };
    return area;
  }
  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
  d3.svg.area = function() {
    return d3_svg_area(d3_identity);
  };
  d3.svg.area.radial = function() {
    var area = d3_svg_area(d3_svg_lineRadial);
    area.radius = area.x, delete area.x;
    area.innerRadius = area.x0, delete area.x0;
    area.outerRadius = area.x1, delete area.x1;
    area.angle = area.y, delete area.y;
    area.startAngle = area.y0, delete area.y0;
    area.endAngle = area.y1, delete area.y1;
    return area;
  };
  d3.svg.chord = function() {
    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
    function chord(d, i) {
      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
      return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
    }
    function subgroup(self, f, d, i) {
      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - halfπ, a1 = endAngle.call(self, subgroup, i) - halfπ;
      return {
        r: r,
        a0: a0,
        a1: a1,
        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
      };
    }
    function equals(a, b) {
      return a.a0 == b.a0 && a.a1 == b.a1;
    }
    function arc(r, p, a) {
      return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
    }
    function curve(r0, p0, r1, p1) {
      return "Q 0,0 " + p1;
    }
    chord.radius = function(v) {
      if (!arguments.length) return radius;
      radius = d3_functor(v);
      return chord;
    };
    chord.source = function(v) {
      if (!arguments.length) return source;
      source = d3_functor(v);
      return chord;
    };
    chord.target = function(v) {
      if (!arguments.length) return target;
      target = d3_functor(v);
      return chord;
    };
    chord.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return chord;
    };
    chord.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return chord;
    };
    return chord;
  };
  function d3_svg_chordRadius(d) {
    return d.radius;
  }
  d3.svg.diagonal = function() {
    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
    function diagonal(d, i) {
      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
        x: p0.x,
        y: m
      }, {
        x: p3.x,
        y: m
      }, p3 ];
      p = p.map(projection);
      return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
    }
    diagonal.source = function(x) {
      if (!arguments.length) return source;
      source = d3_functor(x);
      return diagonal;
    };
    diagonal.target = function(x) {
      if (!arguments.length) return target;
      target = d3_functor(x);
      return diagonal;
    };
    diagonal.projection = function(x) {
      if (!arguments.length) return projection;
      projection = x;
      return diagonal;
    };
    return diagonal;
  };
  function d3_svg_diagonalProjection(d) {
    return [ d.x, d.y ];
  }
  d3.svg.diagonal.radial = function() {
    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
    diagonal.projection = function(x) {
      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
    };
    return diagonal;
  };
  function d3_svg_diagonalRadialProjection(projection) {
    return function() {
      var d = projection.apply(this, arguments), r = d[0], a = d[1] - halfπ;
      return [ r * Math.cos(a), r * Math.sin(a) ];
    };
  }
  d3.svg.symbol = function() {
    var type = d3_svg_symbolType, size = d3_svg_symbolSize;
    function symbol(d, i) {
      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
    }
    symbol.type = function(x) {
      if (!arguments.length) return type;
      type = d3_functor(x);
      return symbol;
    };
    symbol.size = function(x) {
      if (!arguments.length) return size;
      size = d3_functor(x);
      return symbol;
    };
    return symbol;
  };
  function d3_svg_symbolSize() {
    return 64;
  }
  function d3_svg_symbolType() {
    return "circle";
  }
  function d3_svg_symbolCircle(size) {
    var r = Math.sqrt(size / π);
    return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
  }
  var d3_svg_symbols = d3.map({
    circle: d3_svg_symbolCircle,
    cross: function(size) {
      var r = Math.sqrt(size / 5) / 2;
      return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
    },
    diamond: function(size) {
      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
      return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
    },
    square: function(size) {
      var r = Math.sqrt(size) / 2;
      return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
    },
    "triangle-down": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
    },
    "triangle-up": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
    }
  });
  d3.svg.symbolTypes = d3_svg_symbols.keys();
  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
  d3_selectionPrototype.transition = function(name) {
    var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
      time: Date.now(),
      ease: d3_ease_cubicInOut,
      delay: 0,
      duration: 250
    };
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_selectionPrototype.interrupt = function(name) {
    return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
  };
  var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
  function d3_selection_interruptNS(ns) {
    return function() {
      var lock, active;
      if ((lock = this[ns]) && (active = lock[lock.active])) {
        if (--lock.count) delete lock[lock.active]; else delete this[ns];
        lock.active += .5;
        active.event && active.event.interrupt.call(this, this.__data__, active.index);
      }
    };
  }
  function d3_transition(groups, ns, id) {
    d3_subclass(groups, d3_transitionPrototype);
    groups.namespace = ns;
    groups.id = id;
    return groups;
  }
  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
  d3_transitionPrototype.call = d3_selectionPrototype.call;
  d3_transitionPrototype.empty = d3_selectionPrototype.empty;
  d3_transitionPrototype.node = d3_selectionPrototype.node;
  d3_transitionPrototype.size = d3_selectionPrototype.size;
  d3.transition = function(selection, name) {
    return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
  };
  d3.transition.prototype = d3_transitionPrototype;
  d3_transitionPrototype.select = function(selector) {
    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
    selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          d3_transitionNode(subnode, i, ns, id, node[ns][id]);
          subgroup.push(subnode);
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_transitionPrototype.selectAll = function(selector) {
    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
    selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          transition = node[ns][id];
          subnodes = selector.call(node, node.__data__, i, j);
          subgroups.push(subgroup = []);
          for (var k = -1, o = subnodes.length; ++k < o; ) {
            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);
            subgroup.push(subnode);
          }
        }
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_transitionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
          subgroup.push(node);
        }
      }
    }
    return d3_transition(subgroups, this.namespace, this.id);
  };
  d3_transitionPrototype.tween = function(name, tween) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 2) return this.node()[ns][id].tween.get(name);
    return d3_selection_each(this, tween == null ? function(node) {
      node[ns][id].tween.remove(name);
    } : function(node) {
      node[ns][id].tween.set(name, tween);
    });
  };
  function d3_transition_tween(groups, name, value, tween) {
    var id = groups.id, ns = groups.namespace;
    return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
      node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
    } : (value = tween(value), function(node) {
      node[ns][id].tween.set(name, value);
    }));
  }
  d3_transitionPrototype.attr = function(nameNS, value) {
    if (arguments.length < 2) {
      for (value in nameNS) this.attr(value, nameNS[value]);
      return this;
    }
    var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrTween(b) {
      return b == null ? attrNull : (b += "", function() {
        var a = this.getAttribute(name), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttribute(name, i(t));
        });
      });
    }
    function attrTweenNS(b) {
      return b == null ? attrNullNS : (b += "", function() {
        var a = this.getAttributeNS(name.space, name.local), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttributeNS(name.space, name.local, i(t));
        });
      });
    }
    return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.attrTween = function(nameNS, tween) {
    var name = d3.ns.qualify(nameNS);
    function attrTween(d, i) {
      var f = tween.call(this, d, i, this.getAttribute(name));
      return f && function(t) {
        this.setAttribute(name, f(t));
      };
    }
    function attrTweenNS(d, i) {
      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
      return f && function(t) {
        this.setAttributeNS(name.space, name.local, f(t));
      };
    }
    return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.style(priority, name[priority], value);
        return this;
      }
      priority = "";
    }
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleString(b) {
      return b == null ? styleNull : (b += "", function() {
        var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
        return a !== b && (i = d3_interpolate(a, b), function(t) {
          this.style.setProperty(name, i(t), priority);
        });
      });
    }
    return d3_transition_tween(this, "style." + name, value, styleString);
  };
  d3_transitionPrototype.styleTween = function(name, tween, priority) {
    if (arguments.length < 3) priority = "";
    function styleTween(d, i) {
      var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
      return f && function(t) {
        this.style.setProperty(name, f(t), priority);
      };
    }
    return this.tween("style." + name, styleTween);
  };
  d3_transitionPrototype.text = function(value) {
    return d3_transition_tween(this, "text", value, d3_transition_text);
  };
  function d3_transition_text(b) {
    if (b == null) b = "";
    return function() {
      this.textContent = b;
    };
  }
  d3_transitionPrototype.remove = function() {
    var ns = this.namespace;
    return this.each("end.transition", function() {
      var p;
      if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);
    });
  };
  d3_transitionPrototype.ease = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].ease;
    if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
    return d3_selection_each(this, function(node) {
      node[ns][id].ease = value;
    });
  };
  d3_transitionPrototype.delay = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].delay;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node[ns][id].delay = +value.call(node, node.__data__, i, j);
    } : (value = +value, function(node) {
      node[ns][id].delay = value;
    }));
  };
  d3_transitionPrototype.duration = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].duration;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
    } : (value = Math.max(1, value), function(node) {
      node[ns][id].duration = value;
    }));
  };
  d3_transitionPrototype.each = function(type, listener) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 2) {
      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
      try {
        d3_transitionInheritId = id;
        d3_selection_each(this, function(node, i, j) {
          d3_transitionInherit = node[ns][id];
          type.call(node, node.__data__, i, j);
        });
      } finally {
        d3_transitionInherit = inherit;
        d3_transitionInheritId = inheritId;
      }
    } else {
      d3_selection_each(this, function(node) {
        var transition = node[ns][id];
        (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
      });
    }
    return this;
  };
  d3_transitionPrototype.transition = function() {
    var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if (node = group[i]) {
          transition = node[ns][id0];
          d3_transitionNode(node, i, ns, id1, {
            time: transition.time,
            ease: transition.ease,
            delay: transition.delay + transition.duration,
            duration: transition.duration
          });
        }
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, ns, id1);
  };
  function d3_transitionNamespace(name) {
    return name == null ? "__transition__" : "__transition_" + name + "__";
  }
  function d3_transitionNode(node, i, ns, id, inherit) {
    var lock = node[ns] || (node[ns] = {
      active: 0,
      count: 0
    }), transition = lock[id];
    if (!transition) {
      var time = inherit.time;
      transition = lock[id] = {
        tween: new d3_Map(),
        time: time,
        delay: inherit.delay,
        duration: inherit.duration,
        ease: inherit.ease,
        index: i
      };
      inherit = null;
      ++lock.count;
      d3.timer(function(elapsed) {
        var delay = transition.delay, duration, ease, timer = d3_timer_active, tweened = [];
        timer.t = delay + time;
        if (delay <= elapsed) return start(elapsed - delay);
        timer.c = start;
        function start(elapsed) {
          if (lock.active > id) return stop();
          var active = lock[lock.active];
          if (active) {
            --lock.count;
            delete lock[lock.active];
            active.event && active.event.interrupt.call(node, node.__data__, active.index);
          }
          lock.active = id;
          transition.event && transition.event.start.call(node, node.__data__, i);
          transition.tween.forEach(function(key, value) {
            if (value = value.call(node, node.__data__, i)) {
              tweened.push(value);
            }
          });
          ease = transition.ease;
          duration = transition.duration;
          d3.timer(function() {
            timer.c = tick(elapsed || 1) ? d3_true : tick;
            return 1;
          }, 0, time);
        }
        function tick(elapsed) {
          if (lock.active !== id) return 1;
          var t = elapsed / duration, e = ease(t), n = tweened.length;
          while (n > 0) {
            tweened[--n].call(node, e);
          }
          if (t >= 1) {
            transition.event && transition.event.end.call(node, node.__data__, i);
            return stop();
          }
        }
        function stop() {
          if (--lock.count) delete lock[id]; else delete node[ns];
          return 1;
        }
      }, 0, time);
    }
  }
  d3.svg.axis = function() {
    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;
    function axis(g) {
      g.each(function() {
        var g = d3.select(this);
        var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
        var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ε), tickExit = d3.transition(tick.exit()).style("opacity", ε).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
        var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), 
        d3.transition(path));
        tickEnter.append("line");
        tickEnter.append("text");
        var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;
        if (orient === "bottom" || orient === "top") {
          tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
          text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
          pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
        } else {
          tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
          text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
          pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
        }
        lineEnter.attr(y2, sign * innerTickSize);
        textEnter.attr(y1, sign * tickSpacing);
        lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
        textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
        if (scale1.rangeBand) {
          var x = scale1, dx = x.rangeBand() / 2;
          scale0 = scale1 = function(d) {
            return x(d) + dx;
          };
        } else if (scale0.rangeBand) {
          scale0 = scale1;
        } else {
          tickExit.call(tickTransform, scale1, scale0);
        }
        tickEnter.call(tickTransform, scale0, scale1);
        tickUpdate.call(tickTransform, scale1, scale1);
      });
    }
    axis.scale = function(x) {
      if (!arguments.length) return scale;
      scale = x;
      return axis;
    };
    axis.orient = function(x) {
      if (!arguments.length) return orient;
      orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
      return axis;
    };
    axis.ticks = function() {
      if (!arguments.length) return tickArguments_;
      tickArguments_ = arguments;
      return axis;
    };
    axis.tickValues = function(x) {
      if (!arguments.length) return tickValues;
      tickValues = x;
      return axis;
    };
    axis.tickFormat = function(x) {
      if (!arguments.length) return tickFormat_;
      tickFormat_ = x;
      return axis;
    };
    axis.tickSize = function(x) {
      var n = arguments.length;
      if (!n) return innerTickSize;
      innerTickSize = +x;
      outerTickSize = +arguments[n - 1];
      return axis;
    };
    axis.innerTickSize = function(x) {
      if (!arguments.length) return innerTickSize;
      innerTickSize = +x;
      return axis;
    };
    axis.outerTickSize = function(x) {
      if (!arguments.length) return outerTickSize;
      outerTickSize = +x;
      return axis;
    };
    axis.tickPadding = function(x) {
      if (!arguments.length) return tickPadding;
      tickPadding = +x;
      return axis;
    };
    axis.tickSubdivide = function() {
      return arguments.length && axis;
    };
    return axis;
  };
  var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
    top: 1,
    right: 1,
    bottom: 1,
    left: 1
  };
  function d3_svg_axisX(selection, x0, x1) {
    selection.attr("transform", function(d) {
      var v0 = x0(d);
      return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
    });
  }
  function d3_svg_axisY(selection, y0, y1) {
    selection.attr("transform", function(d) {
      var v0 = y0(d);
      return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
    });
  }
  d3.svg.brush = function() {
    var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
    function brush(g) {
      g.each(function() {
        var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
        var background = g.selectAll(".background").data([ 0 ]);
        background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
        g.selectAll(".extent").data([ 0 ]).enter().append("rect").attr("class", "extent").style("cursor", "move");
        var resize = g.selectAll(".resize").data(resizes, d3_identity);
        resize.exit().remove();
        resize.enter().append("g").attr("class", function(d) {
          return "resize " + d;
        }).style("cursor", function(d) {
          return d3_svg_brushCursor[d];
        }).append("rect").attr("x", function(d) {
          return /[ew]$/.test(d) ? -3 : null;
        }).attr("y", function(d) {
          return /^[ns]/.test(d) ? -3 : null;
        }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
        resize.style("display", brush.empty() ? "none" : null);
        var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
        if (x) {
          range = d3_scaleRange(x);
          backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
          redrawX(gUpdate);
        }
        if (y) {
          range = d3_scaleRange(y);
          backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
          redrawY(gUpdate);
        }
        redraw(gUpdate);
      });
    }
    brush.event = function(g) {
      g.each(function() {
        var event_ = event.of(this, arguments), extent1 = {
          x: xExtent,
          y: yExtent,
          i: xExtentDomain,
          j: yExtentDomain
        }, extent0 = this.__chart__ || extent1;
        this.__chart__ = extent1;
        if (d3_transitionInheritId) {
          d3.select(this).transition().each("start.brush", function() {
            xExtentDomain = extent0.i;
            yExtentDomain = extent0.j;
            xExtent = extent0.x;
            yExtent = extent0.y;
            event_({
              type: "brushstart"
            });
          }).tween("brush:brush", function() {
            var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
            xExtentDomain = yExtentDomain = null;
            return function(t) {
              xExtent = extent1.x = xi(t);
              yExtent = extent1.y = yi(t);
              event_({
                type: "brush",
                mode: "resize"
              });
            };
          }).each("end.brush", function() {
            xExtentDomain = extent1.i;
            yExtentDomain = extent1.j;
            event_({
              type: "brush",
              mode: "resize"
            });
            event_({
              type: "brushend"
            });
          });
        } else {
          event_({
            type: "brushstart"
          });
          event_({
            type: "brush",
            mode: "resize"
          });
          event_({
            type: "brushend"
          });
        }
      });
    };
    function redraw(g) {
      g.selectAll(".resize").attr("transform", function(d) {
        return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
      });
    }
    function redrawX(g) {
      g.select(".extent").attr("x", xExtent[0]);
      g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
    }
    function redrawY(g) {
      g.select(".extent").attr("y", yExtent[0]);
      g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
    }
    function brushstart() {
      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;
      var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
      if (d3.event.changedTouches) {
        w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
      } else {
        w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
      }
      g.interrupt().selectAll("*").interrupt();
      if (dragging) {
        origin[0] = xExtent[0] - origin[0];
        origin[1] = yExtent[0] - origin[1];
      } else if (resizing) {
        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
        offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];
        origin[0] = xExtent[ex];
        origin[1] = yExtent[ey];
      } else if (d3.event.altKey) center = origin.slice();
      g.style("pointer-events", "none").selectAll(".resize").style("display", null);
      d3.select("body").style("cursor", eventTarget.style("cursor"));
      event_({
        type: "brushstart"
      });
      brushmove();
      function keydown() {
        if (d3.event.keyCode == 32) {
          if (!dragging) {
            center = null;
            origin[0] -= xExtent[1];
            origin[1] -= yExtent[1];
            dragging = 2;
          }
          d3_eventPreventDefault();
        }
      }
      function keyup() {
        if (d3.event.keyCode == 32 && dragging == 2) {
          origin[0] += xExtent[1];
          origin[1] += yExtent[1];
          dragging = 0;
          d3_eventPreventDefault();
        }
      }
      function brushmove() {
        var point = d3.mouse(target), moved = false;
        if (offset) {
          point[0] += offset[0];
          point[1] += offset[1];
        }
        if (!dragging) {
          if (d3.event.altKey) {
            if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];
            origin[0] = xExtent[+(point[0] < center[0])];
            origin[1] = yExtent[+(point[1] < center[1])];
          } else center = null;
        }
        if (resizingX && move1(point, x, 0)) {
          redrawX(g);
          moved = true;
        }
        if (resizingY && move1(point, y, 1)) {
          redrawY(g);
          moved = true;
        }
        if (moved) {
          redraw(g);
          event_({
            type: "brush",
            mode: dragging ? "move" : "resize"
          });
        }
      }
      function move1(point, scale, i) {
        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
        if (dragging) {
          r0 -= position;
          r1 -= size + position;
        }
        min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
        if (dragging) {
          max = (min += position) + size;
        } else {
          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
          if (position < min) {
            max = min;
            min = position;
          } else {
            max = position;
          }
        }
        if (extent[0] != min || extent[1] != max) {
          if (i) yExtentDomain = null; else xExtentDomain = null;
          extent[0] = min;
          extent[1] = max;
          return true;
        }
      }
      function brushend() {
        brushmove();
        g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
        d3.select("body").style("cursor", null);
        w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
        dragRestore();
        event_({
          type: "brushend"
        });
      }
    }
    brush.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.clamp = function(z) {
      if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;
      if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;
      return brush;
    };
    brush.extent = function(z) {
      var x0, x1, y0, y1, t;
      if (!arguments.length) {
        if (x) {
          if (xExtentDomain) {
            x0 = xExtentDomain[0], x1 = xExtentDomain[1];
          } else {
            x0 = xExtent[0], x1 = xExtent[1];
            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
            if (x1 < x0) t = x0, x0 = x1, x1 = t;
          }
        }
        if (y) {
          if (yExtentDomain) {
            y0 = yExtentDomain[0], y1 = yExtentDomain[1];
          } else {
            y0 = yExtent[0], y1 = yExtent[1];
            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
            if (y1 < y0) t = y0, y0 = y1, y1 = t;
          }
        }
        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
      }
      if (x) {
        x0 = z[0], x1 = z[1];
        if (y) x0 = x0[0], x1 = x1[0];
        xExtentDomain = [ x0, x1 ];
        if (x.invert) x0 = x(x0), x1 = x(x1);
        if (x1 < x0) t = x0, x0 = x1, x1 = t;
        if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];
      }
      if (y) {
        y0 = z[0], y1 = z[1];
        if (x) y0 = y0[1], y1 = y1[1];
        yExtentDomain = [ y0, y1 ];
        if (y.invert) y0 = y(y0), y1 = y(y1);
        if (y1 < y0) t = y0, y0 = y1, y1 = t;
        if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];
      }
      return brush;
    };
    brush.clear = function() {
      if (!brush.empty()) {
        xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];
        xExtentDomain = yExtentDomain = null;
      }
      return brush;
    };
    brush.empty = function() {
      return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
    };
    return d3.rebind(brush, event, "on");
  };
  var d3_svg_brushCursor = {
    n: "ns-resize",
    e: "ew-resize",
    s: "ns-resize",
    w: "ew-resize",
    nw: "nwse-resize",
    ne: "nesw-resize",
    se: "nwse-resize",
    sw: "nesw-resize"
  };
  var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
  var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
  var d3_time_formatUtc = d3_time_format.utc;
  var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
  d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
  function d3_time_formatIsoNative(date) {
    return date.toISOString();
  }
  d3_time_formatIsoNative.parse = function(string) {
    var date = new Date(string);
    return isNaN(date) ? null : date;
  };
  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
  d3_time.second = d3_time_interval(function(date) {
    return new d3_date(Math.floor(date / 1e3) * 1e3);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 1e3);
  }, function(date) {
    return date.getSeconds();
  });
  d3_time.seconds = d3_time.second.range;
  d3_time.seconds.utc = d3_time.second.utc.range;
  d3_time.minute = d3_time_interval(function(date) {
    return new d3_date(Math.floor(date / 6e4) * 6e4);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 6e4);
  }, function(date) {
    return date.getMinutes();
  });
  d3_time.minutes = d3_time.minute.range;
  d3_time.minutes.utc = d3_time.minute.utc.range;
  d3_time.hour = d3_time_interval(function(date) {
    var timezone = date.getTimezoneOffset() / 60;
    return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 36e5);
  }, function(date) {
    return date.getHours();
  });
  d3_time.hours = d3_time.hour.range;
  d3_time.hours.utc = d3_time.hour.utc.range;
  d3_time.month = d3_time_interval(function(date) {
    date = d3_time.day(date);
    date.setDate(1);
    return date;
  }, function(date, offset) {
    date.setMonth(date.getMonth() + offset);
  }, function(date) {
    return date.getMonth();
  });
  d3_time.months = d3_time.month.range;
  d3_time.months.utc = d3_time.month.utc.range;
  function d3_time_scale(linear, methods, format) {
    function scale(x) {
      return linear(x);
    }
    scale.invert = function(x) {
      return d3_time_scaleDate(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
      linear.domain(x);
      return scale;
    };
    function tickMethod(extent, count) {
      var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
      return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {
        return d / 31536e6;
      }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
    }
    scale.nice = function(interval, skip) {
      var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
      if (method) interval = method[0], skip = method[1];
      function skipped(date) {
        return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
      }
      return scale.domain(d3_scale_nice(domain, skip > 1 ? {
        floor: function(date) {
          while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);
          return date;
        },
        ceil: function(date) {
          while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);
          return date;
        }
      } : interval));
    };
    scale.ticks = function(interval, skip) {
      var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [ {
        range: interval
      }, skip ];
      if (method) interval = method[0], skip = method[1];
      return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
    };
    scale.tickFormat = function() {
      return format;
    };
    scale.copy = function() {
      return d3_time_scale(linear.copy(), methods, format);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_time_scaleDate(t) {
    return new Date(t);
  }
  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
  var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];
  var d3_time_scaleLocalFormat = d3_time_format.multi([ [ ".%L", function(d) {
    return d.getMilliseconds();
  } ], [ ":%S", function(d) {
    return d.getSeconds();
  } ], [ "%I:%M", function(d) {
    return d.getMinutes();
  } ], [ "%I %p", function(d) {
    return d.getHours();
  } ], [ "%a %d", function(d) {
    return d.getDay() && d.getDate() != 1;
  } ], [ "%b %d", function(d) {
    return d.getDate() != 1;
  } ], [ "%B", function(d) {
    return d.getMonth();
  } ], [ "%Y", d3_true ] ]);
  var d3_time_scaleMilliseconds = {
    range: function(start, stop, step) {
      return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
    },
    floor: d3_identity,
    ceil: d3_identity
  };
  d3_time_scaleLocalMethods.year = d3_time.year;
  d3_time.scale = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
  };
  var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
    return [ m[0].utc, m[1] ];
  });
  var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ ".%L", function(d) {
    return d.getUTCMilliseconds();
  } ], [ ":%S", function(d) {
    return d.getUTCSeconds();
  } ], [ "%I:%M", function(d) {
    return d.getUTCMinutes();
  } ], [ "%I %p", function(d) {
    return d.getUTCHours();
  } ], [ "%a %d", function(d) {
    return d.getUTCDay() && d.getUTCDate() != 1;
  } ], [ "%b %d", function(d) {
    return d.getUTCDate() != 1;
  } ], [ "%B", function(d) {
    return d.getUTCMonth();
  } ], [ "%Y", d3_true ] ]);
  d3_time_scaleUtcMethods.year = d3_time.year.utc;
  d3_time.scale.utc = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
  };
  d3.text = d3_xhrType(function(request) {
    return request.responseText;
  });
  d3.json = function(url, callback) {
    return d3_xhr(url, "application/json", d3_json, callback);
  };
  function d3_json(request) {
    return JSON.parse(request.responseText);
  }
  d3.html = function(url, callback) {
    return d3_xhr(url, "text/html", d3_html, callback);
  };
  function d3_html(request) {
    var range = d3_document.createRange();
    range.selectNode(d3_document.body);
    return range.createContextualFragment(request.responseText);
  }
  d3.xml = d3_xhrType(function(request) {
    return request.responseXML;
  });
  if (typeof define === "function" && define.amd) define(d3); else if (typeof module === "object" && module.exports) module.exports = d3;
  this.d3 = d3;
}();
},{}],14:[function(require,module,exports){
(function () {
  var gju = this.gju = {};

  // Export the geojson object for **CommonJS**
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = gju;
  }

  // adapted from http://www.kevlindev.com/gui/math/intersection/Intersection.js
  gju.lineStringsIntersect = function (l1, l2) {
    var intersects = [];
    for (var i = 0; i <= l1.coordinates.length - 2; ++i) {
      for (var j = 0; j <= l2.coordinates.length - 2; ++j) {
        var a1 = {
          x: l1.coordinates[i][1],
          y: l1.coordinates[i][0]
        },
          a2 = {
            x: l1.coordinates[i + 1][1],
            y: l1.coordinates[i + 1][0]
          },
          b1 = {
            x: l2.coordinates[j][1],
            y: l2.coordinates[j][0]
          },
          b2 = {
            x: l2.coordinates[j + 1][1],
            y: l2.coordinates[j + 1][0]
          },
          ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x),
          ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x),
          u_b = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
        if (u_b != 0) {
          var ua = ua_t / u_b,
            ub = ub_t / u_b;
          if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
            intersects.push({
              'type': 'Point',
              'coordinates': [a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)]
            });
          }
        }
      }
    }
    if (intersects.length == 0) intersects = false;
    return intersects;
  }

  // Bounding Box

  function boundingBoxAroundPolyCoords (coords) {
    var xAll = [], yAll = []

    for (var i = 0; i < coords[0].length; i++) {
      xAll.push(coords[0][i][1])
      yAll.push(coords[0][i][0])
    }

    xAll = xAll.sort(function (a,b) { return a - b })
    yAll = yAll.sort(function (a,b) { return a - b })

    return [ [xAll[0], yAll[0]], [xAll[xAll.length - 1], yAll[yAll.length - 1]] ]
  }

  gju.pointInBoundingBox = function (point, bounds) {
    return !(point.coordinates[1] < bounds[0][0] || point.coordinates[1] > bounds[1][0] || point.coordinates[0] < bounds[0][1] || point.coordinates[0] > bounds[1][1]) 
  }

  // Point in Polygon
  // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html#Listing the Vertices

  function pnpoly (x,y,coords) {
    var vert = [ [0,0] ]

    for (var i = 0; i < coords.length; i++) {
      for (var j = 0; j < coords[i].length; j++) {
        vert.push(coords[i][j])
      }
	  vert.push(coords[i][0])
      vert.push([0,0])
    }

    var inside = false
    for (var i = 0, j = vert.length - 1; i < vert.length; j = i++) {
      if (((vert[i][0] > y) != (vert[j][0] > y)) && (x < (vert[j][1] - vert[i][1]) * (y - vert[i][0]) / (vert[j][0] - vert[i][0]) + vert[i][1])) inside = !inside
    }

    return inside
  }

  gju.pointInPolygon = function (p, poly) {
    var coords = (poly.type == "Polygon") ? [ poly.coordinates ] : poly.coordinates

    var insideBox = false
    for (var i = 0; i < coords.length; i++) {
      if (gju.pointInBoundingBox(p, boundingBoxAroundPolyCoords(coords[i]))) insideBox = true
    }
    if (!insideBox) return false

    var insidePoly = false
    for (var i = 0; i < coords.length; i++) {
      if (pnpoly(p.coordinates[1], p.coordinates[0], coords[i])) insidePoly = true
    }

    return insidePoly
  }

  // support multi (but not donut) polygons
  gju.pointInMultiPolygon = function (p, poly) {
    var coords_array = (poly.type == "MultiPolygon") ? [ poly.coordinates ] : poly.coordinates

    var insideBox = false
    var insidePoly = false
    for (var i = 0; i < coords_array.length; i++){
      var coords = coords_array[i];
      for (var j = 0; j < coords.length; j++) {
        if (!insideBox){
          if (gju.pointInBoundingBox(p, boundingBoxAroundPolyCoords(coords[j]))) {
            insideBox = true
          }
        }
      }
      if (!insideBox) return false
      for (var j = 0; j < coords.length; j++) {
        if (!insidePoly){
          if (pnpoly(p.coordinates[1], p.coordinates[0], coords[j])) {
            insidePoly = true
          }
        }
      }
    }

    return insidePoly
  }

  gju.numberToRadius = function (number) {
    return number * Math.PI / 180;
  }

  gju.numberToDegree = function (number) {
    return number * 180 / Math.PI;
  }

  // written with help from @tautologe
  gju.drawCircle = function (radiusInMeters, centerPoint, steps) {
    var center = [centerPoint.coordinates[1], centerPoint.coordinates[0]],
      dist = (radiusInMeters / 1000) / 6371,
      // convert meters to radiant
      radCenter = [gju.numberToRadius(center[0]), gju.numberToRadius(center[1])],
      steps = steps || 15,
      // 15 sided circle
      poly = [[center[0], center[1]]];
    for (var i = 0; i < steps; i++) {
      var brng = 2 * Math.PI * i / steps;
      var lat = Math.asin(Math.sin(radCenter[0]) * Math.cos(dist)
              + Math.cos(radCenter[0]) * Math.sin(dist) * Math.cos(brng));
      var lng = radCenter[1] + Math.atan2(Math.sin(brng) * Math.sin(dist) * Math.cos(radCenter[0]),
                                          Math.cos(dist) - Math.sin(radCenter[0]) * Math.sin(lat));
      poly[i] = [];
      poly[i][1] = gju.numberToDegree(lat);
      poly[i][0] = gju.numberToDegree(lng);
    }
    return {
      "type": "Polygon",
      "coordinates": [poly]
    };
  }

  // assumes rectangle starts at lower left point
  gju.rectangleCentroid = function (rectangle) {
    var bbox = rectangle.coordinates[0];
    var xmin = bbox[0][0],
      ymin = bbox[0][1],
      xmax = bbox[2][0],
      ymax = bbox[2][1];
    var xwidth = xmax - xmin;
    var ywidth = ymax - ymin;
    return {
      'type': 'Point',
      'coordinates': [xmin + xwidth / 2, ymin + ywidth / 2]
    };
  }

  // from http://www.movable-type.co.uk/scripts/latlong.html
  gju.pointDistance = function (pt1, pt2) {
    var lon1 = pt1.coordinates[0],
      lat1 = pt1.coordinates[1],
      lon2 = pt2.coordinates[0],
      lat2 = pt2.coordinates[1],
      dLat = gju.numberToRadius(lat2 - lat1),
      dLon = gju.numberToRadius(lon2 - lon1),
      a = Math.pow(Math.sin(dLat / 2), 2) + Math.cos(gju.numberToRadius(lat1))
        * Math.cos(gju.numberToRadius(lat2)) * Math.pow(Math.sin(dLon / 2), 2),
      c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return (6371 * c) * 1000; // returns meters
  },

  // checks if geometry lies entirely within a circle
  // works with Point, LineString, Polygon
  gju.geometryWithinRadius = function (geometry, center, radius) {
    if (geometry.type == 'Point') {
      return gju.pointDistance(geometry, center) <= radius;
    } else if (geometry.type == 'LineString' || geometry.type == 'Polygon') {
      var point = {};
      var coordinates;
      if (geometry.type == 'Polygon') {
        // it's enough to check the exterior ring of the Polygon
        coordinates = geometry.coordinates[0];
      } else {
        coordinates = geometry.coordinates;
      }
      for (var i in coordinates) {
        point.coordinates = coordinates[i];
        if (gju.pointDistance(point, center) > radius) {
          return false;
        }
      }
    }
    return true;
  }

  // adapted from http://paulbourke.net/geometry/polyarea/javascript.txt
  gju.area = function (polygon) {
    var area = 0;
    // TODO: polygon holes at coordinates[1]
    var points = polygon.coordinates[0];
    var j = points.length - 1;
    var p1, p2;

    for (var i = 0; i < points.length; j = i++) {
      var p1 = {
        x: points[i][1],
        y: points[i][0]
      };
      var p2 = {
        x: points[j][1],
        y: points[j][0]
      };
      area += p1.x * p2.y;
      area -= p1.y * p2.x;
    }

    area /= 2;
    return area;
  },

  // adapted from http://paulbourke.net/geometry/polyarea/javascript.txt
  gju.centroid = function (polygon) {
    var f, x = 0,
      y = 0;
    // TODO: polygon holes at coordinates[1]
    var points = polygon.coordinates[0];
    var j = points.length - 1;
    var p1, p2;

    for (var i = 0; i < points.length; j = i++) {
      var p1 = {
        x: points[i][1],
        y: points[i][0]
      };
      var p2 = {
        x: points[j][1],
        y: points[j][0]
      };
      f = p1.x * p2.y - p2.x * p1.y;
      x += (p1.x + p2.x) * f;
      y += (p1.y + p2.y) * f;
    }

    f = gju.area(polygon) * 6;
    return {
      'type': 'Point',
      'coordinates': [y / f, x / f]
    };
  },

  gju.simplify = function (source, kink) { /* source[] array of geojson points */
    /* kink	in metres, kinks above this depth kept  */
    /* kink depth is the height of the triangle abc where a-b and b-c are two consecutive line segments */
    kink = kink || 20;
    source = source.map(function (o) {
      return {
        lng: o.coordinates[0],
        lat: o.coordinates[1]
      }
    });

    var n_source, n_stack, n_dest, start, end, i, sig;
    var dev_sqr, max_dev_sqr, band_sqr;
    var x12, y12, d12, x13, y13, d13, x23, y23, d23;
    var F = (Math.PI / 180.0) * 0.5;
    var index = new Array(); /* aray of indexes of source points to include in the reduced line */
    var sig_start = new Array(); /* indices of start & end of working section */
    var sig_end = new Array();

    /* check for simple cases */

    if (source.length < 3) return (source); /* one or two points */

    /* more complex case. initialize stack */

    n_source = source.length;
    band_sqr = kink * 360.0 / (2.0 * Math.PI * 6378137.0); /* Now in degrees */
    band_sqr *= band_sqr;
    n_dest = 0;
    sig_start[0] = 0;
    sig_end[0] = n_source - 1;
    n_stack = 1;

    /* while the stack is not empty  ... */
    while (n_stack > 0) {

      /* ... pop the top-most entries off the stacks */

      start = sig_start[n_stack - 1];
      end = sig_end[n_stack - 1];
      n_stack--;

      if ((end - start) > 1) { /* any intermediate points ? */

        /* ... yes, so find most deviant intermediate point to
        either side of line joining start & end points */

        x12 = (source[end].lng() - source[start].lng());
        y12 = (source[end].lat() - source[start].lat());
        if (Math.abs(x12) > 180.0) x12 = 360.0 - Math.abs(x12);
        x12 *= Math.cos(F * (source[end].lat() + source[start].lat())); /* use avg lat to reduce lng */
        d12 = (x12 * x12) + (y12 * y12);

        for (i = start + 1, sig = start, max_dev_sqr = -1.0; i < end; i++) {

          x13 = source[i].lng() - source[start].lng();
          y13 = source[i].lat() - source[start].lat();
          if (Math.abs(x13) > 180.0) x13 = 360.0 - Math.abs(x13);
          x13 *= Math.cos(F * (source[i].lat() + source[start].lat()));
          d13 = (x13 * x13) + (y13 * y13);

          x23 = source[i].lng() - source[end].lng();
          y23 = source[i].lat() - source[end].lat();
          if (Math.abs(x23) > 180.0) x23 = 360.0 - Math.abs(x23);
          x23 *= Math.cos(F * (source[i].lat() + source[end].lat()));
          d23 = (x23 * x23) + (y23 * y23);

          if (d13 >= (d12 + d23)) dev_sqr = d23;
          else if (d23 >= (d12 + d13)) dev_sqr = d13;
          else dev_sqr = (x13 * y12 - y13 * x12) * (x13 * y12 - y13 * x12) / d12; // solve triangle
          if (dev_sqr > max_dev_sqr) {
            sig = i;
            max_dev_sqr = dev_sqr;
          }
        }

        if (max_dev_sqr < band_sqr) { /* is there a sig. intermediate point ? */
          /* ... no, so transfer current start point */
          index[n_dest] = start;
          n_dest++;
        } else { /* ... yes, so push two sub-sections on stack for further processing */
          n_stack++;
          sig_start[n_stack - 1] = sig;
          sig_end[n_stack - 1] = end;
          n_stack++;
          sig_start[n_stack - 1] = start;
          sig_end[n_stack - 1] = sig;
        }
      } else { /* ... no intermediate points, so transfer current start point */
        index[n_dest] = start;
        n_dest++;
      }
    }

    /* transfer last point */
    index[n_dest] = n_source - 1;
    n_dest++;

    /* make return array */
    var r = new Array();
    for (var i = 0; i < n_dest; i++)
      r.push(source[index[i]]);

    return r.map(function (o) {
      return {
        type: "Point",
        coordinates: [o.lng, o.lat]
      }
    });
  }

  // http://www.movable-type.co.uk/scripts/latlong.html#destPoint
  gju.destinationPoint = function (pt, brng, dist) {
    dist = dist/6371;  // convert dist to angular distance in radians
    brng = gju.numberToRadius(brng);

    var lon1 = gju.numberToRadius(pt.coordinates[0]);
    var lat1 = gju.numberToRadius(pt.coordinates[1]);

    var lat2 = Math.asin( Math.sin(lat1)*Math.cos(dist) +
                          Math.cos(lat1)*Math.sin(dist)*Math.cos(brng) );
    var lon2 = lon1 + Math.atan2(Math.sin(brng)*Math.sin(dist)*Math.cos(lat1),
                                 Math.cos(dist)-Math.sin(lat1)*Math.sin(lat2));
    lon2 = (lon2+3*Math.PI) % (2*Math.PI) - Math.PI;  // normalise to -180..+180º

    return {
      'type': 'Point',
      'coordinates': [gju.numberToDegree(lon2), gju.numberToDegree(lat2)]
    };
  };

})();

},{}],15:[function(require,module,exports){
/**
 * Module dependencies
 */

var debug = require('debug')('jsonp');

/**
 * Module exports.
 */

module.exports = jsonp;

/**
 * Callback index.
 */

var count = 0;

/**
 * Noop function.
 */

function noop(){}

/**
 * JSONP handler
 *
 * Options:
 *  - param {String} qs parameter (`callback`)
 *  - prefix {String} qs parameter (`__jp`)
 *  - name {String} qs parameter (`prefix` + incr)
 *  - timeout {Number} how long after a timeout error is emitted (`60000`)
 *
 * @param {String} url
 * @param {Object|Function} optional options / callback
 * @param {Function} optional callback
 */

function jsonp(url, opts, fn){
  if ('function' == typeof opts) {
    fn = opts;
    opts = {};
  }
  if (!opts) opts = {};

  var prefix = opts.prefix || '__jp';

  // use the callback name that was passed if one was provided.
  // otherwise generate a unique name by incrementing our counter.
  var id = opts.name || (prefix + (count++));

  var param = opts.param || 'callback';
  var timeout = null != opts.timeout ? opts.timeout : 60000;
  var enc = encodeURIComponent;
  var target = document.getElementsByTagName('script')[0] || document.head;
  var script;
  var timer;


  if (timeout) {
    timer = setTimeout(function(){
      cleanup();
      if (fn) fn(new Error('Timeout'));
    }, timeout);
  }

  function cleanup(){
    if (script.parentNode) script.parentNode.removeChild(script);
    window[id] = noop;
    if (timer) clearTimeout(timer);
  }

  function cancel(){
    if (window[id]) {
      cleanup();
    }
  }

  window[id] = function(data){
    debug('jsonp got', data);
    cleanup();
    if (fn) fn(null, data);
  };

  // add qs component
  url += (~url.indexOf('?') ? '&' : '?') + param + '=' + enc(id);
  url = url.replace('?&', '?');

  debug('jsonp req "%s"', url);

  // create script
  script = document.createElement('script');
  script.src = url;
  target.parentNode.insertBefore(script, target);

  return cancel;
}

},{"debug":16}],16:[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Use chrome.storage.local if we are in an app
 */

var storage;

if (typeof chrome !== 'undefined' && typeof chrome.storage !== 'undefined')
  storage = chrome.storage.local;
else
  storage = localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      storage.removeItem('debug');
    } else {
      storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

},{"./debug":17}],17:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":18}],18:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],19:[function(require,module,exports){
require('javascript.util');
var jsts = require('./lib/jsts');
module.exports = jsts

},{"./lib/jsts":20,"javascript.util":22}],20:[function(require,module,exports){
/* The JSTS Topology Suite is a collection of JavaScript classes that
implement the fundamental operations required to validate a given
geo-spatial data set to a known topological specification.

Copyright (C) 2011 The Authors

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
/* ======================================================================
    jsts.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/** @namespace */
jsts = {
  version: '0.16.0',
  /** @namespace */
  algorithm: {
    /** @namespace */
    distance: {},
    /** @namespace */
    locate: {}
  },
  /** @namespace */
  error: {},
  /** @namespace */
  geom: {
    /** @namespace */
    util: {}
  },
  /** @namespace */
  geomgraph: {
    /** @namespace */
    index: {}
  },
  /** @namespace */
  index: {
    /** @namespace */
    bintree: {},
    /** @namespace */
    chain: {},
    /** @namespace */
    kdtree: {},
    /** @namespace */
    quadtree: {},
    /** @namespace */
    strtree: {}
  },
  /** @namespace */
  io: {},
  /** @namespace */
  noding: {
    /** @namespace */
    snapround: {}
  },
  /** @namespace */
  operation: {
    /** @namespace */
    buffer: {},
    /** @namespace */
    distance: {},
    /** @namespace */
    overlay: {
      /** @namespace */
      snap: {}
    },
    /** @namespace */
    polygonize: {},
    /** @namespace */
    predicate: {},
    /** @namespace */
    relate: {},
    /** @namespace */
    union: {},
    /** @namespace */
    valid: {}
  },
  /** @namespace */
  planargraph: {},
  /** @namespace */
  simplify: {},
  /** @namespace */
  triangulate: {
    /** @namespace */
    quadedge: {}
  },
  /** @namespace */
  util: {}
};

/**
 * Implement String.trim if native support is missing.
 */
if(typeof String.prototype.trim !== 'function') {
  String.prototype.trim = function() {
    return this.replace(/^\s+|\s+$/g, ''); 
  };
}

/**
 * Global function intended for use as a generic abstract method.
 * @private
 */
jsts.abstractFunc = function() {
  throw new jsts.error.AbstractMethodInvocationError();
};

jsts.error = {};



/**
 * @constructor
 */
jsts.error.IllegalArgumentError = function(message) {
  this.name = 'IllegalArgumentError';
  this.message = message;
};
jsts.error.IllegalArgumentError.prototype = new Error();



/**
 * @constructor
 */
jsts.error.TopologyError = function(message, pt) {
  this.name = 'TopologyError';
  this.message = pt ? message + ' [ ' + pt + ' ]' : message;
};
jsts.error.TopologyError.prototype = new Error();



/**
 * @constructor
 */
jsts.error.AbstractMethodInvocationError = function() {
  this.name = 'AbstractMethodInvocationError';
  this.message = 'Abstract method called, should be implemented in subclass.';
};
jsts.error.AbstractMethodInvocationError.prototype = new Error();



/**
 * @constructor
 */
jsts.error.NotImplementedError = function() {
  this.name = 'NotImplementedError';
  this.message = 'This method has not yet been implemented.';
};
jsts.error.NotImplementedError.prototype = new Error();



/**
 * @constructor
 */
jsts.error.NotRepresentableError = function(message) {
  this.name = 'NotRepresentableError';
  this.message = message;
};
jsts.error.NotRepresentableError.prototype = new Error();



/**
 * @constructor message
 */
jsts.error.LocateFailureError = function(message) {
  this.name = 'LocateFailureError';
  this.message = message;
};
jsts.error.LocateFailureError.prototype = new Error();

if (typeof module !== "undefined") module.exports = jsts;

/* ======================================================================
    jsts/geom/GeometryFilter.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */


/**
 * <code>GeometryCollection</code> classes support the concept of applying a
 * <code>GeometryFilter</code> to the <code>Geometry</code>. The filter is
 * applied to every element <code>Geometry</code>. A
 * <code>GeometryFilter</code> can either record information about the
 * <code>Geometry</code> or change the <code>Geometry</code> in some way.
 * <code>GeometryFilter</code> is an example of the Gang-of-Four Visitor
 * pattern.
 */
jsts.geom.GeometryFilter = function() {
};


/**
 * Performs an operation with or on <code>geom</code>.
 *
 * @param {Geometry}
 *          geom a <code>Geometry</code> to which the filter is applied.
 */
jsts.geom.GeometryFilter.prototype.filter = function(geom) {
  throw new jsts.error.AbstractMethodInvocationError();
};
/* ======================================================================
    jsts/geom/util/PolygonExtracter.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @requires jsts/geom/GeometryFilter.js
 */



/**
 * Extracts all the {@link Polygon} elements from a {@link Geometry}.
 *
 * Constructs a PolygonExtracterFilter with a list in which to store Polygons
 * found.
 *
 * @param {Array}
 *          comps
 * @extends {jsts.geom.GeometryFilter}
 * @see GeometryExtracter
 * @constructor
 */
jsts.geom.util.PolygonExtracter = function(comps) {
  this.comps = comps;
};

jsts.geom.util.PolygonExtracter.prototype = new jsts.geom.GeometryFilter();


/**
 * @private
 */
jsts.geom.util.PolygonExtracter.prototype.comps = null;


/**
 * Extracts the {@link Polygon} elements from a single {@link Geometry} and adds
 * them to the provided {@link List}.
 *
 * @param {jsts.geom.Geometry}
 *          geom the geometry from which to extract.
 * @param {Array}
 *          list the list to add the extracted elements to.
 * @return {Array}
 */
jsts.geom.util.PolygonExtracter.getPolygons = function(geom, list) {
  if (list === undefined) {
    list = [];
  }

  if (geom instanceof jsts.geom.Polygon) {
    list.push(geom);
  } else if (geom instanceof jsts.geom.GeometryCollection) {
    geom.apply(new jsts.geom.util.PolygonExtracter(list));
  }
  // skip non-Polygonal elemental geometries

  return list;
};


/**
 * @param {jsts.geom.Geometry}
 *          geom
 */
jsts.geom.util.PolygonExtracter.prototype.filter = function(geom) {
  if (geom instanceof jsts.geom.Polygon)
    this.comps.push(geom);
};
/* ======================================================================
    jsts/io/WKTParser.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 *
 * This file incorporates work covered by the following copyright and
 * permission notice:
 *
 * Copyright (c) 2006-2011 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the Clear BSD license.
 * See http://svn.openlayers.org/trunk/openlayers/license.txt for the
 * full text of the license.
 */

/**
 * Class for reading and writing Well-Known Text.
 *
 * NOTE: Adapted from OpenLayers 2.11 implementation.
 */

/**
 * Create a new parser for WKT
 * 
 * @param {}
 *          geometryFactory
 * @return An instance of WKTParser.
 */
jsts.io.WKTParser = function(geometryFactory) {
  this.geometryFactory = geometryFactory || new jsts.geom.GeometryFactory();

  this.regExes = {
    'typeStr': /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
    'emptyTypeStr': /^\s*(\w+)\s*EMPTY\s*$/,
    'spaces': /\s+/,
    'parenComma': /\)\s*,\s*\(/,
    'doubleParenComma': /\)\s*\)\s*,\s*\(\s*\(/, // can't use {2} here
    'trimParens': /^\s*\(?(.*?)\)?\s*$/
  };
};


/**
 * Deserialize a WKT string and return a geometry. Supports WKT for POINT,
 * MULTIPOINT, LINESTRING, LINEARRING, MULTILINESTRING, POLYGON, MULTIPOLYGON,
 * and GEOMETRYCOLLECTION.
 * 
 * @param {String}
 *          wkt A WKT string.
 * @return {jsts.geom.Geometry} A geometry instance.
 */
jsts.io.WKTParser.prototype.read = function(wkt) {
  var geometry, type, str;
  wkt = wkt.replace(/[\n\r]/g, ' ');
  var matches = this.regExes.typeStr.exec(wkt);
  if (wkt.search('EMPTY') !== -1) {
    matches = this.regExes.emptyTypeStr.exec(wkt);
    matches[2] = undefined;
  }
  if (matches) {
    type = matches[1].toLowerCase();
    str = matches[2];
    if (this.parse[type]) {
      geometry = this.parse[type].apply(this, [str]);
    }
  }

  if (geometry === undefined)
    throw new Error('Could not parse WKT ' + wkt);

  return geometry;
};

/**
 * Serialize a geometry into a WKT string.
 * 
 * @param {jsts.geom.Geometry}
 *          geometry A feature or array of features.
 * @return {String} The WKT string representation of the input geometries.
 */
jsts.io.WKTParser.prototype.write = function(geometry) {
  return this.extractGeometry(geometry);
};

/**
 * Entry point to construct the WKT for a single Geometry object.
 * 
 * @param {jsts.geom.Geometry}
 *          geometry
 * 
 * @return {String} A WKT string of representing the geometry.
 */
jsts.io.WKTParser.prototype.extractGeometry = function(geometry) {
  var type = geometry.CLASS_NAME.split('.')[2].toLowerCase();
  if (!this.extract[type]) {
    return null;
  }
  var wktType = type.toUpperCase();
  var data;
  if (geometry.isEmpty()) {
    data = wktType + ' EMPTY';
  } else {
    data = wktType + '(' + this.extract[type].apply(this, [geometry]) + ')';
  }
  return data;
};

/**
 * Object with properties corresponding to the geometry types. Property values
 * are functions that do the actual data extraction.
 */
jsts.io.WKTParser.prototype.extract = {
  'coordinate': function(coordinate) {
    return coordinate.x + ' ' + coordinate.y;
  },

  /**
   * Return a space delimited string of point coordinates.
   * 
   * @param {jsts.geom.Point}
   *          point
   * @return {String} A string of coordinates representing the point.
   */
  'point': function(point) {
    return point.coordinate.x + ' ' + point.coordinate.y;
  },

  /**
   * Return a comma delimited string of point coordinates from a multipoint.
   * 
   * @param {jsts.geom.MultiPoint>}
   *          multipoint
   * @return {String} A string of point coordinate strings representing the
   *         multipoint.
   */
  'multipoint': function(multipoint) {
    var array = [];
    for ( var i = 0, len = multipoint.geometries.length; i < len; ++i) {
      array.push('(' +
          this.extract.point.apply(this, [multipoint.geometries[i]]) + ')');
    }
    return array.join(',');
  },

  /**
   * Return a comma delimited string of point coordinates from a line.
   * 
   * @param {jsts.geom.LineString>}
   *          linestring
   * @return {String} A string of point coordinate strings representing the
   *         linestring.
   */
  'linestring': function(linestring) {
    var array = [];
    for ( var i = 0, len = linestring.points.length; i < len; ++i) {
      array.push(this.extract.coordinate.apply(this, [linestring.points[i]]));
    }
    return array.join(',');
  },

  /**
   * Return a comma delimited string of linestring strings from a
   * multilinestring.
   * 
   * @param {jsts.geom.MultiLineString>}
   *          multilinestring
   * @return {String} A string of of linestring strings representing the
   *         multilinestring.
   */
  'multilinestring': function(multilinestring) {
    var array = [];
    for ( var i = 0, len = multilinestring.geometries.length; i < len; ++i) {
      array.push('(' +
          this.extract.linestring.apply(this, [multilinestring.geometries[i]]) +
          ')');
    }
    return array.join(',');
  },

  /**
   * Return a comma delimited string of linear ring arrays from a polygon.
   * 
   * @param {jsts.geom.Polygon>}
   *          polygon
   * @return {String} An array of linear ring arrays representing the polygon.
   */
  'polygon': function(polygon) {
    var array = [];
    array.push('(' + this.extract.linestring.apply(this, [polygon.shell]) + ')');
    for ( var i = 0, len = polygon.holes.length; i < len; ++i) {
      array.push('(' + this.extract.linestring.apply(this, [polygon.holes[i]]) + ')');
    }
    return array.join(',');
  },

  /**
   * Return an array of polygon arrays from a multipolygon.
   * 
   * @param {jsts.geom.MultiPolygon>}
   *          multipolygon
   * @return {String} An array of polygon arrays representing the multipolygon.
   */
  'multipolygon': function(multipolygon) {
    var array = [];
    for ( var i = 0, len = multipolygon.geometries.length; i < len; ++i) {
      array.push('(' + this.extract.polygon.apply(this, [multipolygon.geometries[i]]) + ')');
    }
    return array.join(',');
  },

  /**
   * Return the WKT portion between 'GEOMETRYCOLLECTION(' and ')' for an
   * geometrycollection.
   * 
   * @param {jsts.geom.GeometryCollection>}
   *          collection
   * @return {String} internal WKT representation of the collection.
   */
  'geometrycollection': function(collection) {
    var array = [];
    for ( var i = 0, len = collection.geometries.length; i < len; ++i) {
      array.push(this.extractGeometry.apply(this, [collection.geometries[i]]));
    }
    return array.join(',');
  }

};

/**
 * Object with properties corresponding to the geometry types. Property values
 * are functions that do the actual parsing.
 */
jsts.io.WKTParser.prototype.parse = {
  /**
   * Return point geometry given a point WKT fragment.
   * 
   * @param {String}
   *          str A WKT fragment representing the point.
   * @return {jsts.geom.Point} A point geometry.
   * @private
   */
  'point': function(str) {
    if (str === undefined) {
      return this.geometryFactory.createPoint(null);
    }

    var coords = str.trim().split(this.regExes.spaces);
    return this.geometryFactory.createPoint(new jsts.geom.Coordinate(coords[0],
        coords[1]));
  },

  /**
   * Return a multipoint geometry given a multipoint WKT fragment.
   * 
   * @param {String}
   *          A WKT fragment representing the multipoint.
   * @return {jsts.geom.Point} A multipoint feature.
   * @private
   */
  'multipoint': function(str) {
    if (str === undefined) {
      return this.geometryFactory.createMultiPoint(null);
    }

    var point;
    var points = str.trim().split(',');
    var components = [];
    for ( var i = 0, len = points.length; i < len; ++i) {
      point = points[i].replace(this.regExes.trimParens, '$1');
      components.push(this.parse.point.apply(this, [point]));
    }
    return this.geometryFactory.createMultiPoint(components);
  },

  /**
   * Return a linestring geometry given a linestring WKT fragment.
   * 
   * @param {String}
   *          A WKT fragment representing the linestring.
   * @return {jsts.geom.LineString} A linestring geometry.
   * @private
   */
  'linestring': function(str) {
    if (str === undefined) {
      return this.geometryFactory.createLineString(null);
    }

    var points = str.trim().split(',');
    var components = [];
    var coords;
    for ( var i = 0, len = points.length; i < len; ++i) {
      coords = points[i].trim().split(this.regExes.spaces);
      components.push(new jsts.geom.Coordinate(coords[0], coords[1]));
    }
    return this.geometryFactory.createLineString(components);
  },

  /**
   * Return a linearring geometry given a linearring WKT fragment.
   * 
   * @param {String}
   *          A WKT fragment representing the linearring.
   * @return {jsts.geom.LinearRing} A linearring geometry.
   * @private
   */
  'linearring': function(str) {
    if (str === undefined) {
      return this.geometryFactory.createLinearRing(null);
    }

    var points = str.trim().split(',');
    var components = [];
    var coords;
    for ( var i = 0, len = points.length; i < len; ++i) {
      coords = points[i].trim().split(this.regExes.spaces);
      components.push(new jsts.geom.Coordinate(coords[0], coords[1]));
    }
    return this.geometryFactory.createLinearRing(components);
  },

  /**
   * Return a multilinestring geometry given a multilinestring WKT fragment.
   * 
   * @param {String}
   *          A WKT fragment representing the multilinestring.
   * @return {jsts.geom.MultiLineString} A multilinestring geometry.
   * @private
   */
  'multilinestring': function(str) {
    if (str === undefined) {
      return this.geometryFactory.createMultiLineString(null);
    }

    var line;
    var lines = str.trim().split(this.regExes.parenComma);
    var components = [];
    for ( var i = 0, len = lines.length; i < len; ++i) {
      line = lines[i].replace(this.regExes.trimParens, '$1');
      components.push(this.parse.linestring.apply(this, [line]));
    }
    return this.geometryFactory.createMultiLineString(components);
  },

  /**
   * Return a polygon geometry given a polygon WKT fragment.
   * 
   * @param {String}
   *          A WKT fragment representing the polygon.
   * @return {jsts.geom.Polygon} A polygon geometry.
   * @private
   */
  'polygon': function(str) {
    if (str === undefined) {
      return this.geometryFactory.createPolygon(null);
    }

    var ring, linestring, linearring;
    var rings = str.trim().split(this.regExes.parenComma);
    var shell;
    var holes = [];
    for ( var i = 0, len = rings.length; i < len; ++i) {
      ring = rings[i].replace(this.regExes.trimParens, '$1');
      linestring = this.parse.linestring.apply(this, [ring]);
      linearring = this.geometryFactory.createLinearRing(linestring.points);
      if (i === 0) {
        shell = linearring;
      } else {
        holes.push(linearring);
      }

    }
    return this.geometryFactory.createPolygon(shell, holes);
  },

  /**
   * Return a multipolygon geometry given a multipolygon WKT fragment.
   * 
   * @param {String}
   *          A WKT fragment representing the multipolygon.
   * @return {jsts.geom.MultiPolygon} A multipolygon geometry.
   * @private
   */
  'multipolygon': function(str) {
    if (str === undefined) {
      return this.geometryFactory.createMultiPolygon(null);
    }

    var polygon;
    var polygons = str.trim().split(this.regExes.doubleParenComma);
    var components = [];
    for ( var i = 0, len = polygons.length; i < len; ++i) {
      polygon = polygons[i].replace(this.regExes.trimParens, '$1');
      components.push(this.parse.polygon.apply(this, [polygon]));
    }
    return this.geometryFactory.createMultiPolygon(components);
  },

  /**
   * Return a geometrycollection given a geometrycollection WKT fragment.
   * 
   * @param {String}
   *          A WKT fragment representing the geometrycollection.
   * @return {jsts.geom.GeometryCollection}
   * @private
   */
  'geometrycollection': function(str) {
    if (str === undefined) {
      return this.geometryFactory.createGeometryCollection(null);
    }

    // separate components of the collection with |
    str = str.replace(/,\s*([A-Za-z])/g, '|$1');
    var wktArray = str.trim().split('|');
    var components = [];
    for ( var i = 0, len = wktArray.length; i < len; ++i) {
      components.push(jsts.io.WKTParser.prototype.read.apply(this,
          [wktArray[i]]));
    }
    return this.geometryFactory.createGeometryCollection(components);
  }

};
/* ======================================================================
    jsts/index/ItemVisitor.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * A visitor for items in an index.
 *
 * @interface
 */
jsts.index.ItemVisitor = function() {

};


/**
 * @param {Object} item
 * @public
 */
jsts.index.ItemVisitor.prototype.visitItem = function() {
  throw new jsts.error.AbstractMethodInvocationError();
};
/* ======================================================================
    jsts/algorithm/CGAlgorithms.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * Specifies and implements various fundamental Computational Geometric
 * algorithms. The algorithms supplied in this class are robust for
 * double-precision floating point.
 *
 * @constructor
 */
jsts.algorithm.CGAlgorithms = function() {

};


/**
 * A value that indicates an orientation of clockwise, or a right turn.
 */
jsts.algorithm.CGAlgorithms.CLOCKWISE = -1;


/**
 * A value that indicates an orientation of clockwise, or a right turn.
 */
jsts.algorithm.CGAlgorithms.RIGHT = jsts.algorithm.CGAlgorithms.CLOCKWISE;


/**
 * A value that indicates an orientation of counterclockwise, or a left turn.
 */
jsts.algorithm.CGAlgorithms.COUNTERCLOCKWISE = 1;


/**
 * A value that indicates an orientation of counterclockwise, or a left turn.
 */
jsts.algorithm.CGAlgorithms.LEFT = jsts.algorithm.CGAlgorithms.COUNTERCLOCKWISE;


/**
 * A value that indicates an orientation of collinear, or no turn (straight).
 */
jsts.algorithm.CGAlgorithms.COLLINEAR = 0;


/**
 * A value that indicates an orientation of collinear, or no turn (straight).
 */
jsts.algorithm.CGAlgorithms.STRAIGHT = jsts.algorithm.CGAlgorithms.COLLINEAR;


/**
 * Returns the index of the direction of the point <code>q</code> relative to
 * a vector specified by <code>p1-p2</code>.
 *
 * @param {jsts.geom.Coordinate}
 *          p1 the origin point of the vector.
 * @param {jsts.geom.Coordinate}
 *          p2 the final point of the vector.
 * @param {jsts.geom.Coordinate}
 *          q the point to compute the direction to.
 *
 * @return {Number} 1 if q is counter-clockwise (left) from p1-p2.
 * @return {Number} -1 if q is clockwise (right) from p1-p2.
 * @return {Number} 0 if q is collinear with p1-p2.
 */
jsts.algorithm.CGAlgorithms.orientationIndex = function(p1, p2, q) {
  /**
   * MD - 9 Aug 2010 It seems that the basic algorithm is slightly orientation
   * dependent, when computing the orientation of a point very close to a line.
   * This is possibly due to the arithmetic in the translation to the origin.
   *
   * For instance, the following situation produces identical results in spite
   * of the inverse orientation of the line segment:
   *
   * Coordinate p0 = new Coordinate(219.3649559090992, 140.84159161824724);
   * Coordinate p1 = new Coordinate(168.9018919682399, -5.713787599646864);
   *
   * Coordinate p = new Coordinate(186.80814046338352, 46.28973405831556); int
   * orient = orientationIndex(p0, p1, p); int orientInv = orientationIndex(p1,
   * p0, p);
   *
   * A way to force consistent results is to normalize the orientation of the
   * vector using the following code. However, this may make the results of
   * orientationIndex inconsistent through the triangle of points, so it's not
   * clear this is an appropriate patch.
   *
   */

  var dx1, dy1, dx2, dy2;
  dx1 = p2.x - p1.x;
  dy1 = p2.y - p1.y;
  dx2 = q.x - p2.x;
  dy2 = q.y - p2.y;

  return jsts.algorithm.RobustDeterminant.signOfDet2x2(dx1, dy1, dx2, dy2);
};


/**
 * Tests whether a point lies inside or on a ring. The ring may be oriented in
 * either direction. A point lying exactly on the ring boundary is considered to
 * be inside the ring.
 * <p>
 * This method does <i>not</i> first check the point against the envelope of
 * the ring.
 *
 * @param {jsts.geom.Coordinate}
 *          p point to check for ring inclusion.
 * @param {Array{jsts.geom.Coordinate}}
 *          ring an array of coordinates representing the ring (which must have
 *          first point identical to last point)
 * @return {Boolean} true if p is inside ring.
 *
 * @see locatePointInRing
 */
jsts.algorithm.CGAlgorithms.isPointInRing = function(p, ring) {
  return jsts.algorithm.CGAlgorithms.locatePointInRing(p, ring) !== jsts.geom.Location.EXTERIOR;
};


/**
 * Determines whether a point lies in the interior, on the boundary, or in the
 * exterior of a ring. The ring may be oriented in either direction.
 * <p>
 * This method does <i>not</i> first check the point against the envelope of
 * the ring.
 *
 * @param {jsts.geom.Coordinate}
 *          p point to check for ring inclusion.
 * @param {Array{jsts.geom.Coordinate}}
 *          ring an array of coordinates representing the ring (which must have
 *          first point identical to last point)
 * @return {jsts.geom.Location} the {@link Location} of p relative to the ring.
 */
jsts.algorithm.CGAlgorithms.locatePointInRing = function(p, ring) {
  return jsts.algorithm.RayCrossingCounter.locatePointInRing(p, ring);
};


/**
 * Tests whether a point lies on the line segments defined by a list of
 * coordinates.
 *
 * @param {jsts.geom.Coordinate}
 *          p the coordinate to test.
 * @param {Array{jsts.geom.Coordinate}}
 *          pt An array of coordinates defining line segments
 * @return {Boolean} true if the point is a vertex of the line or lies in the
 *         interior of a line segment in the linestring.
 */
jsts.algorithm.CGAlgorithms.isOnLine = function(p, pt) {
  var lineIntersector, i, il, p0, p1;
  lineIntersector = new jsts.algorithm.RobustLineIntersector();

  for (i = 1, il = pt.length; i < il; i++) {
    p0 = pt[i - 1];
    p1 = pt[i];
    lineIntersector.computeIntersection(p, p0, p1);

    if (lineIntersector.hasIntersection()) {
      return true;
    }
  }
  return false;
};


/**
 * Computes whether a ring defined by an array of {@link Coordinate}s is
 * oriented counter-clockwise.
 * <ul>
 * <li>The list of points is assumed to have the first and last points equal.
 * <li>This will handle coordinate lists which contain repeated points.
 * </ul>
 * This algorithm is <b>only</b> guaranteed to work with valid rings. If the
 * ring is invalid (e.g. self-crosses or touches), the computed result may not
 * be correct.
 *
 * @param {Array{jsts.geom.Coordinate}}
 *          ring an array of Coordinates forming a ring
 * @return {Boolean} true if the ring is oriented counter-clockwise.
 * @throws IllegalArgumentException
 *           if there are too few points to determine orientation (< 3)
 */
jsts.algorithm.CGAlgorithms.isCCW = function(ring) {
  var nPts, hiPt, hiIndex, p, iPrev, iNext, prev, next, i, disc, isCCW;

  // # of points without closing endpoint
  nPts = ring.length - 1;

  // sanity check
  if (nPts < 3) {
    throw new jsts.IllegalArgumentError(
        'Ring has fewer than 3 points, so orientation cannot be determined');
  }

  // find highets point
  hiPt = ring[0];
  hiIndex = 0;

  i = 1;
  for (i; i <= nPts; i++) {
    p = ring[i];
    if (p.y > hiPt.y) {
      hiPt = p;
      hiIndex = i;
    }
  }

  // find distinct point before highest point
  iPrev = hiIndex;
  do {
    iPrev = iPrev - 1;
    if (iPrev < 0) {
      iPrev = nPts;
    }
  } while (ring[iPrev].equals2D(hiPt) && iPrev !== hiIndex);

  // find distinct point after highest point
  iNext = hiIndex;
  do {
    iNext = (iNext + 1) % nPts;
  } while (ring[iNext].equals2D(hiPt) && iNext !== hiIndex);

  prev = ring[iPrev];
  next = ring[iNext];

  /**
   * This check catches cases where the ring contains an A-B-A configuration of
   * points. This can happen if the ring does not contain 3 distinct points
   * (including the case where the input array has fewer than 4 elements), or it
   * contains coincident line segments.
   */
  if (prev.equals2D(hiPt) || next.equals2D(hiPt) || prev.equals2D(next)) {
    return false;
  }

  disc = jsts.algorithm.CGAlgorithms.computeOrientation(prev, hiPt, next);

  /**
   * If disc is exactly 0, lines are collinear. There are two possible cases:
   * (1) the lines lie along the x axis in opposite directions (2) the lines lie
   * on top of one another
   *
   * (1) is handled by checking if next is left of prev ==> CCW (2) will never
   * happen if the ring is valid, so don't check for it (Might want to assert
   * this)
   */
  isCCW = false;
  if (disc === 0) {
    // poly is CCW if prev x is right of next x
    isCCW = (prev.x > next.x);
  } else {
    // if area is positive, points are ordered CCW
    isCCW = (disc > 0);
  }

  return isCCW;
};


/**
 * Computes the orientation of a point q to the directed line segment p1-p2. The
 * orientation of a point relative to a directed line segment indicates which
 * way you turn to get to q after travelling from p1 to p2.
 *
 * @param {jsts.geom.Coordinate}
 *          p1 First coordinate of the linesegment.
 * @param {jsts.geom.Coordinate}
 *          p2 Second coordinate of the linesegment.
 * @param {jsts.geom.Coordinate}
 *          q The point to calculate orientation of.
 *
 * @return {Number} 1 if q is counter-clockwise from p1-p2.
 * @return {Number} -1 if q is clockwise from p1-p2.
 * @return {Number} 0 if q is collinear with p1-p2.
 */
jsts.algorithm.CGAlgorithms.computeOrientation = function(p1, p2, q) {
  return jsts.algorithm.CGAlgorithms.orientationIndex(p1, p2, q);
};


/**
 * Computes the distance from a point p to a line segment AB
 *
 * Note: NON-ROBUST!
 *
 * @param {jsts.geom.Coordinate}
 *          p the point to compute the distance for.
 * @param {jsts.geom.Coordinate}
 *          A one point of the line.
 * @param {jsts.geom.Coordinate}
 *          B another point of the line (must be different to A).
 * @return {Number} the distance from p to line segment AB.
 */
jsts.algorithm.CGAlgorithms.distancePointLine = function(p, A, B) {
  if (!(A instanceof jsts.geom.Coordinate)) {
    jsts.algorithm.CGAlgorithms.distancePointLine2.apply(this, arguments);
  }

  // if start = end, then just compute distance to one of the endpoints
  if (A.x === B.x && A.y === B.y) {
    return p.distance(A);
  }
  // otherwise use comp.graphics.algorithms Frequently Asked Questions method
  /*(1)             AC dot AB
                   r = ---------
                         ||AB||^2
    r has the following meaning:
    r=0 P = A
    r=1 P = B
    r<0 P is on the backward extension of AB
    r>1 P is on the forward extension of AB
    0<r<1 P is interior to AB
  */
  var r, s;
  r = ((p.x - A.x) * (B.x - A.x) + (p.y - A.y) * (B.y - A.y)) /
      ((B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y));

  if (r <= 0.0) {
    return p.distance(A);
  }
  if (r >= 1.0) {
    return p.distance(B);
  }

  /*(2)
    (Ay-Cy)(Bx-Ax)-(Ax-Cx)(By-Ay)
  s = -----------------------------
             L^2

  Then the distance from C to P = |s|*L.
  */

  s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) /
      ((B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y));

  return Math.abs(s) *
      Math.sqrt(((B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y)));
};


/**
 * Computes the perpendicular distance from a point p to the (infinite) line
 * containing the points AB
 *
 * @param {jsts.geom.Coordinate}
 *          p the point to compute the distance for.
 * @param {jsts.geom.Coordinate}
 *          A one point of the line.
 * @param {jsts.geom.Coordinate}
 *          B another point of the line (must be different to A).
 * @return {Number} the distance from p to line AB.
 */
jsts.algorithm.CGAlgorithms.distancePointLinePerpendicular = function(p, A, B) {
  // use comp.graphics.algorithms Frequently Asked Questions method
  /*(2)
                   (Ay-Cy)(Bx-Ax)-(Ax-Cx)(By-Ay)
              s = -----------------------------
                                   L^2

              Then the distance from C to P = |s|*L.
  */
  var s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) /
      ((B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y));

  return Math.abs(s) *
      Math.sqrt(((B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y)));
};


/**
 * Computes the distance from a point to a sequence of line segments.
 *
 * @param {jsts.geom.Coordinate}
 *          p a point.
 * @param {Array{jsts.geom.Coordinate}}
 *          line a sequence of contiguous line segments defined by their
 *          vertices
 * @return {Number} the minimum distance between the point and the line
 *         segments.
 */
jsts.algorithm.CGAlgorithms.distancePointLine2 = function(p, line) {
  var minDistance, i, il, dist;
  if (line.length === 0) {
    throw new jsts.error.IllegalArgumentError(
        'Line array must contain at least one vertex');
  }
  minDistance = p.distance(line[0]);
  for (i = 0, il = line.length - 1; i < il; i++) {
    dist = jsts.algorithm.CGAlgorithms.distancePointLine(p, line[i],
        line[i + 1]);
    if (dist < minDistance) {
      minDistance = dist;
    }
  }
  return minDistance;
};

/**
 * Computes the distance from a line segment AB to a line segment CD
 *
 * Note: NON-ROBUST!
 *
 * @param {jsts.geom.Coordinate}
 *          A a point of one line.
 * @param {jsts.geom.Coordinate}
 *          B the second point of (must be different to A).
 * @param {jsts.geom.Coordinate}
 *          C one point of the line.
 * @param {jsts.geom.Coordinate}
 *          D another point of the line (must be different to A).
 * @return {Number} the distance.
 */

jsts.algorithm.CGAlgorithms.distanceLineLine = function(A, B, C, D) {
  // check for zero-length segments
  if (A.equals(B)) {
    return jsts.algorithm.CGAlgorithms.distancePointLine(A, C, D);
  }
  if (C.equals(D)) {
    return jsts.algorithm.CGAlgorithms.distancePointLine(D, A, B);
  }

  // AB and CD are line segments
  /* from comp.graphics.algo

  Solving the above for r and s yields
        (Ay-Cy)(Dx-Cx)-(Ax-Cx)(Dy-Cy)
             r = ----------------------------- (eqn 1)
        (Bx-Ax)(Dy-Cy)-(By-Ay)(Dx-Cx)

      (Ay-Cy)(Bx-Ax)-(Ax-Cx)(By-Ay)
    s = ----------------------------- (eqn 2)
      (Bx-Ax)(Dy-Cy)-(By-Ay)(Dx-Cx)
  Let P be the position vector of the intersection point, then
    P=A+r(B-A) or
    Px=Ax+r(Bx-Ax)
    Py=Ay+r(By-Ay)
  By examining the values of r & s, you can also determine some other
  limiting conditions:
    If 0<=r<=1 & 0<=s<=1, intersection exists
    r<0 or r>1 or s<0 or s>1 line segments do not intersect
    If the denominator in eqn 1 is zero, AB & CD are parallel
    If the numerator in eqn 1 is also zero, AB & CD are collinear.

  */
  var r_top, r_bot, s_top, s_bot, s, r;
  r_top = (A.y - C.y) * (D.x - C.x) - (A.x - C.x) * (D.y - C.y);
  r_bot = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x);

  s_top = (A.y - C.y) * (B.x - A.x) - (A.x - C.x) * (B.y - A.y);
  s_bot = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x);


  if ((r_bot === 0) || (s_bot === 0)) {
    return Math.min(jsts.algorithm.CGAlgorithms.distancePointLine(A, C, D),
        Math.min(jsts.algorithm.CGAlgorithms.distancePointLine(B, C, D), Math
            .min(jsts.algorithm.CGAlgorithms.distancePointLine(C, A, B),
                jsts.algorithm.CGAlgorithms.distancePointLine(D, A, B))));
  }

  s = s_top / s_bot;
  r = r_top / r_bot;
  if ((r < 0) || (r > 1) || (s < 0) || (s > 1)) {
    // no intersection
    return Math.min(jsts.algorithm.CGAlgorithms.distancePointLine(A, C, D),
        Math.min(jsts.algorithm.CGAlgorithms.distancePointLine(B, C, D), Math
            .min(jsts.algorithm.CGAlgorithms.distancePointLine(C, A, B),
                jsts.algorithm.CGAlgorithms.distancePointLine(D, A, B))));
  }

  return 0.0; // intersection exists
};


/**
 * Computes the signed area for a ring. The signed area is positive if the ring
 * is oriented CW, negative if the ring is oriented CCW, and zero if the ring is
 * degenerate or flat.
 *
 * @param {Array{jsts.geom.Coordinate}}
 *          ring the coordinates forming the ring
 * @return {Number} the signed area of the ring.
 */
jsts.algorithm.CGAlgorithms.signedArea = function(ring) {
  if (ring.length < 3) {
    return 0.0;
  }
  var sum, i, il, bx, by, cx, cy;

  sum = 0.0;

  for (i = 0, il = ring.length - 1; i < il; i++) {
    bx = ring[i].x;
    by = ring[i].y;
    cx = ring[i + 1].x;
    cy = ring[i + 1].y;
    sum += (bx + cx) * (cy - by);
  }

  return -sum / 2.0;
};


/**
 * Computes the signed area for a ring. The signed area is:
 * <ul>
 * <li>positive if the ring is oriented CW
 * <li>negative if the ring is oriented CCW
 * <li>zero if the ring is degenerate or flat
 * </ul>
 *
 * @param {Array{jsts.geom.Coordinate}}
 *          ring the coordinates forming the ring
 * @return {Number} the signed area of the ring.
 */
jsts.algorithm.CGAlgorithms.signedArea = function(ring) {
  var n, sum, p, bx, by, i, cx, cy;

  n = ring.length;
  if (n < 3) {
    return 0.0;
  }

  sum = 0.0;
  p = ring[0];

  bx = p.x;
  by = p.y;

  for (i = 1; i < n; i++) {
    p = ring[i];
    cx = p.x;
    cy = p.y;
    sum += (bx + cx) * (cy - by);
    bx = cx;
    by = cy;
  }

  return -sum / 2.0;
};

/**
 * Computes the length of a linestring specified by a sequence of points.
 *
 * NOTE: This is renamed from length() to computeLength() because 'length' is a
 * reserved keyword in javascript.
 *
 * @param {Array{jsts.geom.Coordinate}}
 *          pts the points specifying the linestring
 * @return {Number} the length of the linestring.
 */
jsts.algorithm.CGAlgorithms.computeLength = function(pts) {
  // optimized for processing CoordinateSequences
  var n = pts.length, len, x0, y0, x1, y1, dx, dy, p, i, il;
  if (n <= 1) {
    return 0.0;
  }

  len = 0.0;

  p = pts[0];

  x0 = p.x;
  y0 = p.y;

  i = 1, il = n;
  for (i; i < n; i++) {
    p = pts[i];

    x1 = p.x;
    y1 = p.y;
    dx = x1 - x0;
    dy = y1 - y0;

    len += Math.sqrt(dx * dx + dy * dy);

    x0 = x1;
    y0 = y1;
  }
  return len;
};

/**
 * @see {jsts.algorithm.CGAlgorithms.computeLength} Since 'length' is a reserved
 *      keyword in javascript this function does not act as a function. Please
 *      use 'computeLength' instead.
 */
jsts.algorithm.CGAlgorithms.length = function() {};
/* ======================================================================
    jsts/algorithm/Angle.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * Utility functions for working with angles.
 * Unless otherwise noted, methods in this class express angles in radians.
 *
 * @requires jsts/algorithm/CGAlgorithms.js
 *
 * @constructor
 */
jsts.algorithm.Angle = function() {

};


/**
 * Pi*2
 */
jsts.algorithm.Angle.PI_TIMES_2 = 2.0 * Math.PI;


/**
 * Pi/2
 */
jsts.algorithm.Angle.PI_OVER_2 = Math.PI / 2.0;


/**
 * Pi/4
 */
jsts.algorithm.Angle.PI_OVER_4 = Math.PI / 4.0;


/**
 * Constant representing counterclockwise orientation
 */
jsts.algorithm.Angle.COUNTERCLOCKWISE = jsts.algorithm.CGAlgorithms.COUNTERCLOCKWISE;


/**
 * Constant representing clockwise orientation
 */
jsts.algorithm.Angle.CLOCKWISE = jsts.algorithm.CGAlgorithms.CLOCKWISE;


/**
 * Constant representing no orientation
 */
jsts.algorithm.Angle.NONE = jsts.algorithm.CGAlgorithms.COLLINEAR;


/**
 * Converts from radians to degrees.
 *
 * @param {Number}
 *        radians an angle in radians.
 * @return {Number}
 *         the angle in degrees.
 */
jsts.algorithm.Angle.toDegrees = function(radians) {
  return (radians * 180) / Math.PI;
};


/**
 * Converts from degrees to radians.
 *
 * @param {Number}
 *        angleDegrees an angle in degrees.
 * @return {Number}
 *         the angle in radians.
 */
jsts.algorithm.Angle.toRadians = function(angleDegrees) {
  return (angleDegrees * Math.PI) / 180.0;
};


/**
 * Returns the angle
 * Calls correct angle* depending on argument
 *
 * @return {Number}
 *          The angle in radians.
 */
jsts.algorithm.Angle.angle = function() {
  if (arguments.length === 1) {
    return jsts.algorithm.Angle.angleFromOrigo(arguments[0]);
  }else {
    return jsts.algorithm.Angle.angleBetweenCoords(arguments[0], arguments[1]);
  }
};


/**
 * Returns the angle of the vector from p0 to p1,
 * relative to the positive X-axis.
 * The angle is normalized to be in the range [ -Pi, Pi ].
 *
 * @param {jsts.geom.Coordinate}
 *        p0 a coordinate.
 * @param {jsts.geom.Coordinate}
 *        p1 a coordinate.
 * @return {Number}
 *         the normalized angle (in radians) that p0-p1 makes with the positive
 *         x-axis.
 */
jsts.algorithm.Angle.angleBetweenCoords = function(p0, p1) {
  var dx, dy;
  dx = p1.x - p0.x;
  dy = p1.y - p0.y;
  return Math.atan2(dy, dx);
};


/**
 * Returns the angle that the vector from (0,0) to p,
 * relative to the positive X-axis.
 * The angle is normalized to be in the range ( -Pi, Pi ].
 *
 * @param {jsts.geom.Coordinate}
 *        p a coordinate.
 * @return {Number}
 *         the normalized angle (in radians) that p makes with the positive
 *         x-axis.
 */
jsts.algorithm.Angle.angleFromOrigo = function(p) {
  return Math.atan2(p.y, p.x);
};


/**
 * Tests whether the angle between p0-p1-p2 is acute.
 * An angle is acute if it is less than 90 degrees.
 * <p>
 * Note: this implementation is not precise (determistic) for angles very close to 90 degrees.
 *
 * @param {jsts.geom.Coordinate}
 *        p0 an endpoint of the angle.
 * @param {jsts.geom.Coordinate}
 *        p1 the base of the angle.
 * @param {jsts.geom.Coordinate}
 *        p2 the other endpoint of the angle.
 * @return {Boolean}
 *         true if the angle is acute.
 */
jsts.algorithm.Angle.isAcute = function(p0, p1, p2) {
  var dx0, dy0, dx1, dy1, dotprod;

  //relies on fact that A dot B is positive if A ang B is acute
  dx0 = p0.x - p1.x;
  dy0 = p0.y - p1.y;
  dx1 = p2.x - p1.x;
  dy1 = p2.y - p1.y;
  dotprod = dx0 * dx1 + dy0 * dy1;
  return dotprod > 0;
};


/**
 * Tests whether the angle between p0-p1-p2 is obtuse.
 * An angle is obtuse if it is greater than 90 degrees.
 * <p>
 * Note: this implementation is not precise (determistic) for angles very close to 90 degrees.
 *
 * @param {jsts.geom.Coordinate}
 *        p0 an endpoint of the angle.
 * @param {jsts.geom.Coordinate}
 *        p1 the base of the angle.
 * @param {jsts.geom.Coordinate}
 *        p2 the other endpoint of the angle.
 * @return {Boolean}
 *         true if the angle is obtuse.
 */
jsts.algorithm.Angle.isObtuse = function(p0, p1, p2) {
  var dx0, dy0, dx1, dy1, dotprod;

  //relies on fact that A dot B is negative iff A ang B is obtuse
  dx0 = p0.x - p1.x;
  dy0 = p0.y - p1.y;
  dx1 = p2.x - p1.x;
  dy1 = p2.y - p1.y;
  dotprod = dx0 * dx1 + dy0 * dy1;
  return dotprod < 0;
};


/**
 * Returns the unoriented smallest angle between two vectors.
 * The computed angle will be in the range [0, Pi).
 *
 * @param {jsts.geom.Coordinate}
 *        tip1 the tip of one vector.
 * @param {jsts.geom.Coordinate}
 *        tail the tail of each vector.
 * @param {jsts.geom.Coordinate}
 *        tip2 the tip of the other vector.
 * @return {Number}
 *         the angle between tail-tip1 and tail-tip2.
 */
jsts.algorithm.Angle.angleBetween = function(tip1, tail, tip2) {
  var a1, a2;
  a1 = jsts.algorithm.Angle.angle(tail, tip1);
  a2 = jsts.algorithm.Angle.angle(tail, tip2);

  return jsts.algorithm.Angle.diff(a1, a2);
};


/**
 * Returns the oriented smallest angle between two vectors.
 * The computed angle will be in the range (-Pi, Pi].
 * A positive result corresponds to a counterclockwise rotation
 * from v1 to v2;
 * a negative result corresponds to a clockwise rotation.
 *
 * @param {jsts.geom.Coordinate}
 *        tip1 the tip of v1.
 * @param {jsts.geom.Coordinate}
 *        tail the tail of each vector.
 * @param {jsts.geom.Coordinate}
 *        tip2 the tip of v2.
 * @return {Number}
 *         the angle between v1 and v2, relative to v1.
 */
jsts.algorithm.Angle.angleBetweenOriented = function(tip1, tail, tip2) {
  var a1, a2, angDel;

  a1 = jsts.algorithm.Angle.angle(tail, tip1);
  a2 = jsts.algorithm.Angle.angle(tail, tip2);
  angDel = a2 - a1;

  // normalize, maintaining orientation
  if (angDel <= -Math.PI) {
    return angDel + jsts.algorithm.Angle.PI_TIMES_2;
  }
  if (angDel > Math.PI) {
    return angDel - jsts.algorithm.Angle.PI_TIMES_2;
  }
  return angDel;
};


/**
 * Computes the interior angle between two segments of a ring. The ring is
 * assumed to be oriented in a clockwise direction. The computed angle will be
 * in the range [0, 2Pi]
 *
 * @param {jsts.geom.Coordinate}
 *        p0 a point of the ring.
 * @param {jsts.geom.Coordinate}
 *        p1 the next point of the ring.
 * @param {jsts.geom.Coordinate}
 *        p2 the next point of the ring.
 * @return {Number}
 *         the interior angle based at <code>p1.</code>
 */
jsts.algorithm.Angle.interiorAngle = function(p0, p1, p2) {
  var anglePrev, angleNext;

  anglePrev = jsts.algorithm.Angle.angle(p1, p0);
  angleNext = jsts.algorithm.Angle.angle(p1, p2);
  return Math.abs(angleNext - anglePrev);
};


/**
 * Returns whether an angle must turn clockwise or counterclockwise
 * to overlap another angle.
 *
 * @param {Number}
 *        ang1 an angle (in radians).
 * @param {Number}
 *        ang2 an angle (in radians).
 * @return {Number}
 *         whether a1 must turn CLOCKWISE, COUNTERCLOCKWISE or NONE to
 *         overlap a2.
 */
jsts.algorithm.Angle.getTurn = function(ang1, ang2) {
  var crossproduct = Math.sin(ang2 - ang1);

  if (crossproduct > 0) {
    return jsts.algorithm.Angle.COUNTERCLOCKWISE;
  }
  if (crossproduct < 0) {
    return jsts.algorithm.Angle.CLOCKWISE;
  }
  return jsts.algorithm.Angle.NONE;
};


/**
 * Computes the normalized value of an angle, which is the
 * equivalent angle in the range ( -Pi, Pi ].
 *
 * @param {Number}
 *        angle the angle to normalize.
 * @return {Number}
 *         an equivalent angle in the range (-Pi, Pi].
 */
jsts.algorithm.Angle.normalize = function(angle) {
  while (angle > Math.PI) {
    angle -= jsts.algorithm.Angle.PI_TIMES_2;
  }
  while (angle <= -Math.PI) {
    angle += jsts.algorithm.Angle.PI_TIMES_2;
  }
  return angle;
};


/**
 * Computes the normalized positive value of an angle, which is the
 * equivalent angle in the range [ 0, 2*Pi ).
 * E.g.:
 * <ul>
 * <li>normalizePositive(0.0) = 0.0
 * <li>normalizePositive(-PI) = PI
 * <li>normalizePositive(-2PI) = 0.0
 * <li>normalizePositive(-3PI) = PI
 * <li>normalizePositive(-4PI) = 0
 * <li>normalizePositive(PI) = PI
 * <li>normalizePositive(2PI) = 0.0
 * <li>normalizePositive(3PI) = PI
 * <li>normalizePositive(4PI) = 0.0
 * </ul>
 *
 * @param {Number}
 *        angle the angle to normalize, in radians.
 * @return {Number}
 *         an equivalent positive angle.
 */
jsts.algorithm.Angle.normalizePositive = function(angle) {
  if (angle < 0.0) {
    while (angle < 0.0) {
      angle += jsts.algorithm.Angle.PI_TIMES_2;
    }
    // in case round-off error bumps the value over
    if (angle >= jsts.algorithm.Angle.PI_TIMES_2) {
      angle = 0.0;
    }
  }
  else {
    while (angle >= jsts.algorithm.Angle.PI_TIMES_2) {
      angle -= jsts.algorithm.Angle.PI_TIMES_2;
    }
    // in case round-off error bumps the value under
    if (angle < 0.0) {
      angle = 0.0;
    }
  }
  return angle;
};


/**
 * Computes the unoriented smallest difference between two angles.
 * The angles are assumed to be normalized to the range [-Pi, Pi].
 * The result will be in the range [0, Pi].
 *
 * @param {Number}
 *        ang1 the angle of one vector (in [-Pi, Pi] ).
 * @param {Number}
 *        ang2 the angle of the other vector (in range [-Pi, Pi] ).
 * @return {Number}
 *         the angle (in radians) between the two vectors (in range [0, Pi] ).
 */
jsts.algorithm.Angle.diff = function(ang1, ang2) {
  var delAngle;

  if (ang1 < ang2) {
    delAngle = ang2 - ang1;
  } else {
    delAngle = ang1 - ang2;
  }

  if (delAngle > Math.PI) {
    delAngle = (2 * Math.PI) - delAngle;
  }

  return delAngle;
};
/* ======================================================================
    jsts/geom/GeometryComponentFilter.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */


/**
 * <code>Geometry</code> classes support the concept of applying a
 * <code>GeometryComponentFilter</code> filter to the <code>Geometry</code>.
 * The filter is applied to every component of the <code>Geometry</code> which
 * is itself a <code>Geometry</code> and which does not itself contain any
 * components. (For instance, all the {@link LinearRing}s in {@link Polygon}s
 * are visited, but in a {@link MultiPolygon} the {@link Polygon}s themselves
 * are not visited.) Thus the only classes of Geometry which must be handled as
 * arguments to {@link #filter} are {@link LineString}s, {@link LinearRing}s
 * and {@link Point}s.
 * <p>
 * A <code>GeometryComponentFilter</code> filter can either record information
 * about the <code>Geometry</code> or change the <code>Geometry</code> in
 * some way. <code>GeometryComponentFilter</code> is an example of the
 * Gang-of-Four Visitor pattern.
 */
jsts.geom.GeometryComponentFilter = function() {
};


/**
 * Performs an operation with or on <code>geom</code>.
 *
 * @param {Geometry}
 *          geom a <code>Geometry</code> to which the filter is applied.
 */
jsts.geom.GeometryComponentFilter.prototype.filter = function(geom) {
  throw new jsts.error.AbstractMethodInvocationError();
};
/* ======================================================================
    jsts/geom/util/LinearComponentExtracter.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @requires jsts/geom/GeometryComponentFilter.js
 */



/**
 * Extracts all the 1-dimensional ({@link LineString}) components from a
 * {@link Geometry}.
 *
 * @extends {jsts.geom.GeometryComponentFilter}
 * @constructor
 */
jsts.geom.util.LinearComponentExtracter = function(lines, isForcedToLineString) {
  this.lines = lines;
  this.isForcedToLineString = isForcedToLineString;
};

jsts.geom.util.LinearComponentExtracter.prototype = new jsts.geom.GeometryComponentFilter();


/**
 * @private
 */
jsts.geom.util.LinearComponentExtracter.prototype.lines = null;


/**
 * @private
 */
jsts.geom.util.LinearComponentExtracter.prototype.isForcedToLineString = false;


/**
 * Extracts the linear components from a single {@link Geometry} and adds them
 * to the provided {@link Collection}.
 *
 * NOTE: will call "overloaded" function depending on args.
 *
 * @param {[]}
 *          geoms the collection of geometries from which to extract linear
 *          components.
 * @param {[]}
 *          lines the collection to add the extracted linear components to.
 * @return {[]} the collection of linear components (LineStrings or
 *         LinearRings).
 */
jsts.geom.util.LinearComponentExtracter.getLines = function(geoms, lines) {
  if (arguments.length == 1) {
    return jsts.geom.util.LinearComponentExtracter.getLines5.apply(this, arguments);
  }
  else if (arguments.length == 2 && typeof lines === 'boolean') {
    return jsts.geom.util.LinearComponentExtracter.getLines6.apply(this, arguments);
  }
  else if (arguments.length == 2 && geoms instanceof jsts.geom.Geometry) {
    return jsts.geom.util.LinearComponentExtracter.getLines3.apply(this, arguments);
  }
  else if (arguments.length == 3 && geoms instanceof jsts.geom.Geometry) {
    return jsts.geom.util.LinearComponentExtracter.getLines4.apply(this, arguments);
  }
  else if (arguments.length == 3) {
    return jsts.geom.util.LinearComponentExtracter.getLines2.apply(this, arguments);
  }

  for (var i = 0; i < geoms.length; i++) {
    var g = geoms[i];
    jsts.geom.util.LinearComponentExtracter.getLines3(g, lines);
  }
  return lines;
};


/**
 * Extracts the linear components from a single {@link Geometry} and adds them
 * to the provided {@link Collection}.
 *
 * @param {[]}
 *          geoms the Collection of geometries from which to extract linear
 *          components.
 * @param {[]}
 *          lines the collection to add the extracted linear components to.
 * @param {boolean}
 *          forceToLineString true if LinearRings should be converted to
 *          LineStrings.
 * @return {[]} the collection of linear components (LineStrings or
 *         LinearRings).
 */
jsts.geom.util.LinearComponentExtracter.getLines2 = function(geoms, lines,
    forceToLineString) {
  for (var i = 0; i < geoms.length; i++) {
    var g = geoms[i];
    jsts.geom.util.LinearComponentExtracter.getLines4(g, lines,
        forceToLineString);
  }
  return lines;
};


/**
 * Extracts the linear components from a single {@link Geometry} and adds them
 * to the provided {@link Collection}.
 *
 * @param {Geometry}
 *          geom the geometry from which to extract linear components.
 * @param {[]}
 *          lines the Collection to add the extracted linear components to.
 * @return {[]} the Collection of linear components (LineStrings or
 *         LinearRings).
 */
jsts.geom.util.LinearComponentExtracter.getLines3 = function(geom, lines) {
  if (geom instanceof LineString) {
    lines.add(geom);
  } else {
    geom.apply(new jsts.geom.util.LinearComponentExtracter(lines));
  }
  return lines;
};


/**
 * Extracts the linear components from a single {@link Geometry} and adds them
 * to the provided {@link Collection}.
 *
 * @param {Geometry}
 *          geom the geometry from which to extract linear components.
 * @param {[]}
 *          lines the Collection to add the extracted linear components to.
 * @param {boolean}
 *          forceToLineString true if LinearRings should be converted to
 *          LineStrings.
 * @return {[]} the Collection of linear components (LineStrings or
 *         LinearRings).
 */
jsts.geom.util.LinearComponentExtracter.getLines4 = function(geom, lines,
    forceToLineString) {
  geom.apply(new jsts.geom.util.LinearComponentExtracter(lines,
      forceToLineString));
  return lines;
};


/**
 * Extracts the linear components from a single geometry. If more than one
 * geometry is to be processed, it is more efficient to create a single
 * {@link LinearComponentExtracter} instance and pass it to multiple geometries.
 *
 * @param {Geometry}
 *          geom the geometry from which to extract linear components.
 * @return {[]} the list of linear components.
 */
jsts.geom.util.LinearComponentExtracter.getLines5 = function(geom) {
  return jsts.geom.util.LinearComponentExtracter.getLines6(geom, false);
};


/**
 * Extracts the linear components from a single geometry. If more than one
 * geometry is to be processed, it is more efficient to create a single
 * {@link LinearComponentExtracter} instance and pass it to multiple geometries.
 *
 * @param {Geometry}
 *          geom the geometry from which to extract linear components.
 * @param {boolean}
 *          forceToLineString true if LinearRings should be converted to
 *          LineStrings.
 * @return {[] the list of linear components.}
 */
jsts.geom.util.LinearComponentExtracter.getLines6 = function(geom,
    forceToLineString) {
  var lines = [];
  geom.apply(new jsts.geom.util.LinearComponentExtracter(lines,
      forceToLineString));
  return lines;
};


/**
 * Indicates that LinearRing components should be converted to pure LineStrings.
 *
 * @param {boolean}
 *          isForcedToLineString true if LinearRings should be converted to
 *          LineStrings.
 */
jsts.geom.util.LinearComponentExtracter.prototype.setForceToLineString = function(
    isForcedToLineString) {
  this.isForcedToLineString = isForcedToLineString;
};

jsts.geom.util.LinearComponentExtracter.prototype.filter = function(geom) {
  if (this.isForcedToLineString && geom instanceof jsts.geom.LinearRing) {
    var line = geom.getFactory().createLineString(geom.getCoordinateSequence());
    this.lines.push(line);
    return;
  }
  // if not being forced, and this is a linear component
  // NOTE: inheritance will not show LinearRing to be of LineString heritance...
  if (geom instanceof jsts.geom.LineString || geom instanceof jsts.geom.LinearRing)
    this.lines.push(geom);

  // else this is not a linear component, so skip it
};
/* ======================================================================
    jsts/geom/Location.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * Constants representing the different topological locations which can occur in
 * a {@link Geometry}. The constants are also used as the row and column
 * indices of DE-9IM {@link IntersectionMatrix}es.
 *
 * @constructor
 */
jsts.geom.Location = function() {
};


/**
 * The location value for the interior of a geometry. Also, DE-9IM row index of
 * the interior of the first geometry and column index of the interior of the
 * second geometry.
 *
 * @const
 * @type {number}
 */
jsts.geom.Location.INTERIOR = 0;


/**
 * The location value for the boundary of a geometry. Also, DE-9IM row index of
 * the boundary of the first geometry and column index of the boundary of the
 * second geometry.
 *
 * @const
 * @type {number}
 */
jsts.geom.Location.BOUNDARY = 1;


/**
 * The location value for the exterior of a geometry. Also, DE-9IM row index of
 * the exterior of the first geometry and column index of the exterior of the
 * second geometry.
 *
 * @const
 * @type {number}
 */
jsts.geom.Location.EXTERIOR = 2;


/**
 * Used for uninitialized location values.
 *
 * @const
 * @type {number}
 */
jsts.geom.Location.NONE = -1;


/**
 * Converts the location value to a location symbol, for example,
 * <code>EXTERIOR => 'e'</code> .
 *
 * @param {number}
 *          locationValue either EXTERIOR, BOUNDARY, INTERIOR or NONE.
 * @return {string} either 'e', 'b', 'i' or '-'.
 */
jsts.geom.Location.toLocationSymbol = function(locationValue) {
  switch (locationValue) {
    case jsts.geom.Location.EXTERIOR:
      return 'e';
    case jsts.geom.Location.BOUNDARY:
      return 'b';
    case jsts.geom.Location.INTERIOR:
      return 'i';
    case jsts.geom.Location.NONE:
      return '-';
  }
  throw new jsts.IllegalArgumentError('Unknown location value: ' +
      locationValue);
};
/* ======================================================================
    jsts/io/GeoJSONReader.js
   ====================================================================== */

/* Copyright (c) 2011, 2012 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */
(function() {

    /**
     * Converts a geometry in GeoJSON to a {@link Geometry}.
     * <p>
     * A <code>GeoJSONReader</code> is parameterized by a <code>GeometryFactory</code>,
     * to allow it to create <code>Geometry</code> objects of the appropriate
     * implementation. In particular, the <code>GeometryFactory</code> determines
     * the <code>PrecisionModel</code> and <code>SRID</code> that is used.
     * <P>
     *
     * @constructor
     */
    jsts.io.GeoJSONReader = function(geometryFactory) {
      this.geometryFactory = geometryFactory || new jsts.geom.GeometryFactory();
      this.precisionModel = this.geometryFactory.getPrecisionModel();
      this.parser = new jsts.io.GeoJSONParser(this.geometryFactory);
    };

    /**
     * Reads a GeoJSON representation of a {@link Geometry}
     *
     * @param {object}
     *          geoJson a GeoJSON Object or String.
     * @return {jsts.geom.Geometry} a <code>Geometry.</code>
     */
    jsts.io.GeoJSONReader.prototype.read = function(geoJson) {
      var geometry = this.parser.read(geoJson);

      if (this.precisionModel.getType() === jsts.geom.PrecisionModel.FIXED) {
        this.reducePrecision(geometry);
      }

      return geometry;
    };

    // NOTE: this is a hack
    jsts.io.GeoJSONReader.prototype.reducePrecision = function(geometry) {
      var i, len;

      if (geometry.coordinate) {
        this.precisionModel.makePrecise(geometry.coordinate);
      } else if (geometry.points) {
        for (i = 0, len = geometry.points.length; i < len; i++) {
          this.precisionModel.makePrecise(geometry.points[i]);
        }
      } else if (geometry.geometries) {
        for (i = 0, len = geometry.geometries.length; i < len; i++) {
          this.reducePrecision(geometry.geometries[i]);
        }
      }
    };
})();
/* ======================================================================
    jsts/geom/Geometry.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * The base class for all geometric objects.
 *
 *  <H3>Binary Predicates</H3>
 * Because it is not clear at this time
 * what semantics for spatial
 *  analysis methods involving <code>GeometryCollection</code>s would be useful,
 *  <code>GeometryCollection</code>s are not supported as arguments to binary
 *  predicates (other than <code>convexHull</code>) or the <code>relate</code>
 *  method.
 *
 *  <H3>Set-Theoretic Methods</H3>
 *
 *  The spatial analysis methods will
 *  return the most specific class possible to represent the result. If the
 *  result is homogeneous, a <code>Point</code>, <code>LineString</code>, or
 *  <code>Polygon</code> will be returned if the result contains a single
 *  element; otherwise, a <code>MultiPoint</code>, <code>MultiLineString</code>,
 *  or <code>MultiPolygon</code> will be returned. If the result is
 *  heterogeneous a <code>GeometryCollection</code> will be returned. <P>
 *
 *  Because it is not clear at this time what semantics for set-theoretic
 *  methods involving <code>GeometryCollection</code>s would be useful,
 * <code>GeometryCollections</code>
 *  are not supported as arguments to the set-theoretic methods.
 *
 *  <H4>Representation of Computed Geometries </H4>
 *
 *  The SFS states that the result
 *  of a set-theoretic method is the "point-set" result of the usual
 *  set-theoretic definition of the operation (SFS 3.2.21.1). However, there are
 *  sometimes many ways of representing a point set as a <code>Geometry</code>.
 *  <P>
 *
 *  The SFS does not specify an unambiguous representation of a given point set
 *  returned from a spatial analysis method. One goal of JTS is to make this
 *  specification precise and unambiguous. JTS will use a canonical form for
 *  <code>Geometry</code>s returned from spatial analysis methods. The canonical
 *  form is a <code>Geometry</code> which is simple and noded:
 *  <UL>
 *    <LI> Simple means that the Geometry returned will be simple according to
 *    the JTS definition of <code>isSimple</code>.
 *    <LI> Noded applies only to overlays involving <code>LineString</code>s. It
 *    means that all intersection points on <code>LineString</code>s will be
 *    present as endpoints of <code>LineString</code>s in the result.
 *  </UL>
 *  This definition implies that non-simple geometries which are arguments to
 *  spatial analysis methods must be subjected to a line-dissolve process to
 *  ensure that the results are simple.
 *
 *  <H4> Constructed Points And The Precision Model </H4>
 *
 *  The results computed by the set-theoretic methods may contain constructed
 *  points which are not present in the input <code>Geometry</code>.
 *  These new points arise from intersections between line segments in the
 *  edges of the input <code>Geometry</code>s. In the general case it is not
 *  possible to represent constructed points exactly. This is due to the fact
 *  that the coordinates of an intersection point may contain twice as many bits
 *  of precision as the coordinates of the input line segments. In order to
 *  represent these constructed points explicitly, JTS must truncate them to fit
 *  the <code>PrecisionModel</code>.
 *
 *  Unfortunately, truncating coordinates moves them slightly. Line segments
 *  which would not be coincident in the exact result may become coincident in
 *  the truncated representation. This in turn leads to "topology collapses" --
 *  situations where a computed element has a lower dimension than it would in
 *  the exact result.
 *
 *  When JTS detects topology collapses during the computation of spatial
 *  analysis methods, it will throw an exception. If possible the exception will
 *  report the location of the collapse.
 *
 *  #equals(Object) and #hashCode are not overridden, so that when two
 *  topologically equal Geometries are added to HashMaps and HashSets, they
 *  remain distinct. This behaviour is desired in many cases.
 */



/**
 * Creates a new <tt>Geometry</tt> via the specified GeometryFactory.
 *
 * @constructor
 */
jsts.geom.Geometry = function(factory) {
  this.factory = factory;
};


/**
 * The bounding box of this <code>Geometry</code>.
 */
jsts.geom.Geometry.prototype.envelope = null;

/**
 * The {@link GeometryFactory} used to create this Geometry
 *
 * @protected
 */
jsts.geom.Geometry.prototype.factory = null;


/**
 * Returns the name of this object's <code>com.vivid.jts.geom</code>
 * interface.
 *
 * @return {string} the name of this <code>Geometry</code>s most specific
 *         <code>jsts.geom</code> interface.
 */
jsts.geom.Geometry.prototype.getGeometryType = function() {
  return 'Geometry';
};


/**
 * Returns true if the array contains any non-empty <code>Geometry</code>s.
 *
 * @param {Geometry[]}
 *          geometries an array of <code>Geometry</code>s; no elements may be
 *          <code>null.</code>
 * @return {boolean} <code>true</code> if any of the <code>Geometry</code>s
 *         <code>isEmpty</code> methods return <code>false.</code>
 */
jsts.geom.Geometry.hasNonEmptyElements = function(geometries) {
  var i;
  for (i = 0; i < geometries.length; i++) {
    if (!geometries[i].isEmpty()) {
      return true;
    }
  }
  return false;
};


/**
 * Returns true if the array contains any <code>null</code> elements.
 *
 * @param {Object[]}
 *          array an array to validate.
 * @return {boolean} <code>true</code> if any of <code>array</code>s
 *         elements are <code>null.</code>
 */
jsts.geom.Geometry.hasNullElements = function(array) {
  var i;
  for (i = 0; i < array.length; i++) {
    if (array[i] === null) {
      return true;
    }
  }
  return false;
};


/**
 * Gets the factory which contains the context in which this geometry was
 * created.
 *
 * @return {jsts.geom.GeometryFactory} the factory for this geometry.
 */
jsts.geom.Geometry.prototype.getFactory = function() {
  // NOTE: Geometry could be created without JSTS constructor so need to check
  // for member data
  // TODO: above should not happen
  if (this.factory === null || this.factory === undefined) {
    this.factory = new jsts.geom.GeometryFactory();
  }

  return this.factory;
};


/**
 * Returns the number of {@link Geometry}s in a {@link GeometryCollection} (or
 * 1, if the geometry is not a collection).
 *
 * @return {number} the number of geometries contained in this geometry.
 */
jsts.geom.Geometry.prototype.getNumGeometries = function() {
  return 1;
};


/**
 * Returns an element {@link Geometry} from a {@link GeometryCollection} (or
 * <code>this</code>, if the geometry is not a collection).
 *
 * @param {number}
 *          n the index of the geometry element.
 * @return {Geometry} the n'th geometry contained in this geometry.
 */
jsts.geom.Geometry.prototype.getGeometryN = function(n) {
  return this;
};


/**
 * Returns the <code>PrecisionModel</code> used by the <code>Geometry</code>.
 *
 * @return {PrecisionModel} the specification of the grid of allowable points,
 *         for this <code>Geometry</code> and all other <code>Geometry</code>s.
 */
jsts.geom.Geometry.prototype.getPrecisionModel = function() {
  return this.getFactory().getPrecisionModel();
};



/**
 * Returns a vertex of this <code>Geometry</code> (usually, but not
 * necessarily, the first one). The returned coordinate should not be assumed to
 * be an actual Coordinate object used in the internal representation.
 *
 * @return {Coordinate} a {@link Coordinate} which is a vertex of this
 *         <code>Geometry</code>. null if this Geometry is empty.
 */
jsts.geom.Geometry.prototype.getCoordinate = function() {
  throw new jsts.error.AbstractMethodInvocationError();
};


/**
 * Returns an array containing the values of all the vertices for this geometry.
 * If the geometry is a composite, the array will contain all the vertices for
 * the components, in the order in which the components occur in the geometry.
 * <p>
 * In general, the array cannot be assumed to be the actual internal storage for
 * the vertices. Thus modifying the array may not modify the geometry itself.
 * Use the {@link CoordinateSequence#setOrdinate} method (possibly on the
 * components) to modify the underlying data. If the coordinates are modified,
 * {@link #geometryChanged} must be called afterwards.
 *
 * @return {Coordinate[]} the vertices of this <code>Geometry.</code>
 * @see geometryChanged
 * @see CoordinateSequence#setOrdinate
 */
jsts.geom.Geometry.prototype.getCoordinates = function() {
  throw new jsts.error.AbstractMethodInvocationError();
};


/**
 * Returns the count of this <code>Geometry</code>s vertices. The
 * <code>Geometry</code> s contained by composite <code>Geometry</code>s
 * must be Geometry's; that is, they must implement <code>getNumPoints</code>
 *
 * @return {number} the number of vertices in this <code>Geometry.</code>
 */
jsts.geom.Geometry.prototype.getNumPoints = function() {
  throw new jsts.error.AbstractMethodInvocationError();
};


/**
 * Tests whether this {@link Geometry} is simple. In general, the SFS
 * specification of simplicity follows the rule:
 * <UL>
 * <LI> A Geometry is simple iff the only self-intersections are at boundary
 * points.
 * </UL>
 * Simplicity is defined for each {@link Geometry} subclass as follows:
 * <ul>
 * <li>Valid polygonal geometries are simple by definition, so
 * <code>isSimple</code> trivially returns true.
 * <li>Linear geometries are simple iff they do not self-intersect at points
 * other than boundary points.
 * <li>Zero-dimensional geometries (points) are simple iff they have no
 * repeated points.
 * <li>Empty <code>Geometry</code>s are always simple
 * <ul>
 *
 * @return {boolean} <code>true</code> if this <code>Geometry</code> has any
 *         points of self-tangency, self-intersection or other anomalous points.
 * @see #isValid
 */
jsts.geom.Geometry.prototype.isSimple = function() {
  this.checkNotGeometryCollection(this);
  var op = new jsts.operation.IsSimpleOp(this);
  return op.isSimple();
};


/**
 * Tests the validity of this <code>Geometry</code>. Subclasses provide their
 * own definition of "valid".
 *
 * @return {boolean} <code>true</code> if this <code>Geometry</code> is
 *         valid.
 *
 * @see IsValidOp
 */
jsts.geom.Geometry.prototype.isValid = function() {
  var isValidOp = new jsts.operation.valid.IsValidOp(this);
  return isValidOp.isValid();
};


/**
 * Returns whether or not the set of points in this <code>Geometry</code> is
 * empty.
 *
 * @return {boolean} <code>true</code> if this <code>Geometry</code> equals
 *         the empty geometry.
 */
jsts.geom.Geometry.prototype.isEmpty = function() {
  throw new jsts.error.AbstractMethodInvocationError();
};


/**
 * Returns the minimum distance between this <code>Geometry</code> and the
 * <code>Geometry</code> g
 *
 * @param {Geometry}
 *          g the <code>Geometry</code> from which to compute the distance.
 * @return {number} the distance between the geometries. 0 if either input
 *         geometry is empty.
 * @throws IllegalArgumentException
 *           if g is null
 */
jsts.geom.Geometry.prototype.distance = function(g) {
  return jsts.operation.distance.DistanceOp.distance(this, g);
};


/**
 * Tests whether the distance from this <code>Geometry</code> to another is
 * less than or equal to a specified value.
 *
 * @param {Geometry}
 *          geom the Geometry to check the distance to.
 * @param {number}
 *          distance the distance value to compare.
 * @return {boolean} <code>true</code> if the geometries are less than
 *         <code>distance</code> apart.
 */
jsts.geom.Geometry.prototype.isWithinDistance = function(geom, distance) {
  var envDist = this.getEnvelopeInternal().distance(geom.getEnvelopeInternal());
  if (envDist > distance) {
    return false;
  }
  return DistanceOp.isWithinDistance(this, geom, distance);
};

jsts.geom.Geometry.prototype.isRectangle = function() {
  // Polygon overrides to check for actual rectangle
  return false;
};

/**
 * Returns the area of this <code>Geometry</code>. Areal Geometries have a
 * non-zero area. They override this function to compute the area. Others return
 * 0.0
 *
 * @return the area of the Geometry.
 */
jsts.geom.Geometry.prototype.getArea = function() {
  return 0.0;
};

/**
 * Returns the length of this <code>Geometry</code>. Linear geometries return
 * their length. Areal geometries return their perimeter. They override this
 * function to compute the area. Others return 0.0
 *
 * @return the length of the Geometry.
 */
jsts.geom.Geometry.prototype.getLength = function() {
  return 0.0;
};

/**
 * Computes the centroid of this <code>Geometry</code>. The centroid is equal
 * to the centroid of the set of component Geometries of highest dimension
 * (since the lower-dimension geometries contribute zero "weight" to the
 * centroid)
 *
 * @return a {@link Point} which is the centroid of this Geometry.
 */
jsts.geom.Geometry.prototype.getCentroid = function() {
  if (this.isEmpty()) {
    return null;
  }
  var cent;
  var centPt = null;
  var dim = this.getDimension();
  if (dim === 0) {
    cent = new jsts.algorithm.CentroidPoint();
    cent.add(this);
    centPt = cent.getCentroid();
  } else if (dim === 1) {
    cent = new jsts.algorithm.CentroidLine();
    cent.add(this);
    centPt = cent.getCentroid();
  } else {
    cent = new jsts.algorithm.CentroidArea();
    cent.add(this);
    centPt = cent.getCentroid();
  }
  return this.createPointFromInternalCoord(centPt, this);

};


/**
 * Computes an interior point of this <code>Geometry</code>. An interior
 * point is guaranteed to lie in the interior of the Geometry, if it possible to
 * calculate such a point exactly. Otherwise, the point may lie on the boundary
 * of the geometry.
 *
 * @return {Point} a {@link Point} which is in the interior of this Geometry.
 */
jsts.geom.Geometry.prototype.getInteriorPoint = function() {
  var intPt;
  var interiorPt = null;
  var dim = this.getDimension();
  if (dim === 0) {
    intPt = new jsts.algorithm.InteriorPointPoint(this);
    interiorPt = intPt.getInteriorPoint();
  } else if (dim === 1) {
    intPt = new jsts.algorithm.InteriorPointLine(this);
    interiorPt = intPt.getInteriorPoint();
  } else {
    intPt = new jsts.algorithm.InteriorPointArea(this);
    interiorPt = intPt.getInteriorPoint();
  }
  return this.createPointFromInternalCoord(interiorPt, this);
};


/**
 * Returns the dimension of this geometry. The dimension of a geometry is is the
 * topological dimension of its embedding in the 2-D Euclidean plane. In the JTS
 * spatial model, dimension values are in the set {0,1,2}.
 * <p>
 * Note that this is a different concept to the dimension of the vertex
 * {@link Coordinate}s. The geometry dimension can never be greater than the
 * coordinate dimension. For example, a 0-dimensional geometry (e.g. a Point)
 * may have a coordinate dimension of 3 (X,Y,Z).
 *
 * @return {number} the topological dimension of this geometry.
 */
jsts.geom.Geometry.prototype.getDimension = function() {
  throw new jsts.error.AbstractMethodInvocationError();
};


/**
 * Returns the boundary, or an empty geometry of appropriate dimension if this
 * <code>Geometry</code> is empty. (In the case of zero-dimensional
 * geometries, ' an empty GeometryCollection is returned.) For a discussion of
 * this function, see the OpenGIS Simple Features Specification. As stated in
 * SFS Section 2.1.13.1, "the boundary of a Geometry is a set of Geometries of
 * the next lower dimension."
 *
 * @return {Geometry} the closure of the combinatorial boundary of this
 *         <code>Geometry.</code>
 */
jsts.geom.Geometry.prototype.getBoundary = function() {
  throw new jsts.error.AbstractMethodInvocationError();
};


/**
 * Returns the dimension of this <code>Geometry</code>s inherent boundary.
 *
 * @return {number} the dimension of the boundary of the class implementing this
 *         interface, whether or not this object is the empty geometry. Returns
 *         <code>Dimension.FALSE</code> if the boundary is the empty geometry.
 */
jsts.geom.Geometry.prototype.getBoundaryDimension = function() {
  throw new jsts.error.AbstractMethodInvocationError();
};


/**
 * Returns this <code>Geometry</code>s bounding box. If this
 * <code>Geometry</code> is the empty geometry, returns an empty
 * <code>Point</code>. If the <code>Geometry</code> is a point, returns a
 * non-empty <code>Point</code>. Otherwise, returns a <code>Polygon</code>
 * whose points are (minx, miny), (maxx, miny), (maxx, maxy), (minx, maxy),
 * (minx, miny).
 *
 * @return {Geometry} an empty <code>Point</code> (for empty
 *         <code>Geometry</code>s), a <code>Point</code> (for
 *         <code>Point</code>s) or a <code>Polygon</code> (in all other
 *         cases).
 */
jsts.geom.Geometry.prototype.getEnvelope = function() {
  return this.getFactory().toGeometry(this.getEnvelopeInternal());
};


/**
 * Returns the minimum and maximum x and y values in this <code>Geometry</code>,
 * or a null <code>Envelope</code> if this <code>Geometry</code> is empty.
 *
 * @return {Envelope} this <code>Geometry</code>s bounding box; if the
 *         <code>Geometry</code> is empty, <code>Envelope#isNull</code> will
 *         return <code>true.</code>
 */
jsts.geom.Geometry.prototype.getEnvelopeInternal = function() {
  if (this.envelope === null) {
    this.envelope = this.computeEnvelopeInternal();
  }
  return this.envelope;
};


/**
 * Tests whether this geometry is disjoint from the specified geometry.
 * <p>
 * The <code>disjoint</code> predicate has the following equivalent
 * definitions:
 * <ul>
 * <li>The two geometries have no point in common
 * <li>The DE-9IM Intersection Matrix for the two geometries matches
 * <code>[FF*FF****]</code>
 * <li><code>! g.intersects(this)</code> (<code>disjoint</code> is the
 * inverse of <code>intersects</code>)
 * </ul>
 *
 * @param {Geometry}
 *          g the <code>Geometry</code> with which to compare this
 *          <code>Geometry.</code>
 * @return {boolean} <code>true</code> if the two <code>Geometry</code>s
 *         are disjoint.
 *
 * @see Geometry#intersects
 */
jsts.geom.Geometry.prototype.disjoint = function(g) {
  return !this.intersects(g);
};


/**
 * Tests whether this geometry touches the specified geometry.
 * <p>
 * The <code>touches</code> predicate has the following equivalent
 * definitions:
 * <ul>
 * <li>The geometries have at least one point in common, but their interiors do
 * not intersect.
 * <li>The DE-9IM Intersection Matrix for the two geometries matches
 * <code>[FT*******]</code> or <code>[F**T*****]</code> or
 * <code>[F***T****]</code>
 * </ul>
 * If both geometries have dimension 0, this predicate returns
 * <code>false</code>
 *
 * @param {Geometry}
 *          g the <code>Geometry</code> with which to compare this
 *          <code>Geometry.</code>
 * @return {boolean} <code>true</code> if the two <code>Geometry</code>s
 *         touch; Returns <code>false</code> if both <code>Geometry</code>s
 *         are points.
 */
jsts.geom.Geometry.prototype.touches = function(g) {
  // short-circuit test
  if (!this.getEnvelopeInternal().intersects(g.getEnvelopeInternal())) {
    return false;
  }
  return this.relate(g).isTouches(this.getDimension(), g.getDimension());
};


/**
 * Tests whether this geometry intersects the specified geometry.
 * <p>
 * The <code>intersects</code> predicate has the following equivalent
 * definitions:
 * <ul>
 * <li>The two geometries have at least one point in common
 * <li>The DE-9IM Intersection Matrix for the two geometries matches
 * <code>[T********]</code> or <code>[*T*******]</code> or
 * <code>[***T*****]</code> or <code>[****T****]</code>
 * <li><code>! g.disjoint(this)</code> (<code>intersects</code> is the
 * inverse of <code>disjoint</code>)
 * </ul>
 *
 * @param {Geometry}
 *          g the <code>Geometry</code> with which to compare this
 *          <code>Geometry.</code>
 * @return {boolean} <code>true</code> if the two <code>Geometry</code>s
 *         intersect.
 *
 * @see Geometry#disjoint
 */
jsts.geom.Geometry.prototype.intersects = function(g) {

  // short-circuit envelope test
  if (!this.getEnvelopeInternal().intersects(g.getEnvelopeInternal())) {
    return false;
  }

  // optimization for rectangle arguments
  if (this.isRectangle()) {
    return jsts.operation.predicate.RectangleIntersects.intersects(this, g);
  }
  if (g.isRectangle()) {
    return jsts.operation.predicate.RectangleIntersects.intersects(g, this);
  }
  // general case
  return this.relate(g).isIntersects();
};


/**
 * Tests whether this geometry crosses the specified geometry.
 * <p>
 * The <code>crosses</code> predicate has the following equivalent
 * definitions:
 * <ul>
 * <li>The geometries have some but not all interior points in common.
 * <li>The DE-9IM Intersection Matrix for the two geometries matches
 * <ul>
 * <li><code>[T*T******]</code> (for P/L, P/A, and L/A situations)
 * <li><code>[T*****T**]</code> (for L/P, A/P, and A/L situations)
 * <li><code>[0********]</code> (for L/L situations)
 * </ul>
 * </ul>
 * For any other combination of dimensions this predicate returns
 * <code>false</code>.
 * <p>
 * The SFS defined this predicate only for P/L, P/A, L/L, and L/A situations.
 * JTS extends the definition to apply to L/P, A/P and A/L situations as well,
 * in order to make the relation symmetric.
 *
 * @param {Geometry}
 *          g the <code>Geometry</code> with which to compare this
 *          <code>Geometry.</code>
 * @return {boolean} <code>true</code> if the two <code>Geometry</code>s
 *         cross.
 */
jsts.geom.Geometry.prototype.crosses = function(g) {
  // short-circuit test
  if (!this.getEnvelopeInternal().intersects(g.getEnvelopeInternal())) {
    return false;
  }
  return this.relate(g).isCrosses(this.getDimension(), g.getDimension());
};


/**
 * Tests whether this geometry is within the specified geometry.
 * <p>
 * The <code>within</code> predicate has the following equivalent definitions:
 * <ul>
 * <li>Every point of this geometry is a point of the other geometry, and the
 * interiors of the two geometries have at least one point in common.
 * <li>The DE-9IM Intersection Matrix for the two geometries matches
 * <code>[T*F**F***]</code>
 * <li><code>g.contains(this)</code> (<code>within</code> is the converse
 * of <code>contains</code>)
 * </ul>
 * An implication of the definition is that "The boundary of a Geometry is not
 * within the Geometry". In other words, if a geometry A is a subset of the
 * points in the boundary of a geomtry B, <code>A.within(B) = false</code>
 *
 * @param {Geometry}
 *          g the <code>Geometry</code> with which to compare this
 *          <code>Geometry.</code>
 * @return {boolean} <code>true</code> if this <code>Geometry</code> is
 *         within <code>other.</code>
 *
 * @see Geometry#contains
 */
jsts.geom.Geometry.prototype.within = function(g) {
  return g.contains(this);
};


/**
 * Tests whether this geometry contains the specified geometry.
 * <p>
 * The <code>contains</code> predicate has the following equivalent
 * definitions:
 * <ul>
 * <li>Every point of the other geometry is a point of this geometry, and the
 * interiors of the two geometries have at least one point in common.
 * <li>The DE-9IM Intersection Matrix for the two geometries matches
 * <code>[T*****FF*]</code>
 * <li><code>g.within(this)</code> (<code>contains</code> is the converse
 * of <code>within</code>)
 * </ul>
 * An implication of the definition is that "Geometries do not contain their
 * boundary". In other words, if a geometry A is a subset of the points in the
 * boundary of a geometry B, <code>B.contains(A) = false</code>
 *
 * @param {Geometry}
 *          g the <code>Geometry</code> with which to compare this
 *          <code>Geometry.</code>
 * @return {boolean} <code>true</code> if this <code>Geometry</code>
 *         contains <code>g.</code>
 *
 * @see Geometry#within
 */
jsts.geom.Geometry.prototype.contains = function(g) {
  // short-circuit test
  if (!this.getEnvelopeInternal().contains(g.getEnvelopeInternal())) {
    return false;
  }
  // optimization for rectangle arguments
  if (this.isRectangle()) {
    return jsts.operation.predicate.RectangleContains.contains(this, g);
  }
  // general case
  return this.relate(g).isContains();
};


/**
 * Tests whether this geometry overlaps the specified geometry.
 * <p>
 * The <code>overlaps</code> predicate has the following equivalent
 * definitions:
 * <ul>
 * <li>The geometries have at least one point each not shared by the other (or
 * equivalently neither covers the other), they have the same dimension, and the
 * intersection of the interiors of the two geometries has the same dimension as
 * the geometries themselves.
 * <li>The DE-9IM Intersection Matrix for the two geometries matches
 * <code>[T*T***T**]</code> (for two points or two surfaces) or
 * <code>[1*T***T**]</code> (for two curves)
 * </ul>
 * If the geometries are of different dimension this predicate returns
 * <code>false</code>.
 *
 * @param {Geometry}
 *          g the <code>Geometry</code> with which to compare this
 *          <code>Geometry.</code>
 * @return {boolean} <code>true</code> if the two <code>Geometry</code>s
 *         overlap.
 */
jsts.geom.Geometry.prototype.overlaps = function(g) {
  // short-circuit test
  if (!this.getEnvelopeInternal().intersects(g.getEnvelopeInternal())) {
    return false;
  }
  return this.relate(g).isOverlaps(this.getDimension(), g.getDimension());
};


/**
 * Tests whether this geometry covers the specified geometry.
 * <p>
 * The <code>covers</code> predicate has the following equivalent definitions:
 * <ul>
 * <li>Every point of the other geometry is a point of this geometry.
 * <li>The DE-9IM Intersection Matrix for the two geometries matches
 * <code>[T*****FF*]</code> or <code>[*T****FF*]</code> or
 * <code>[***T**FF*]</code> or <code>[****T*FF*]</code>
 * <li><code>g.coveredBy(this)</code> (<code>covers</code> is the converse
 * of <code>coveredBy</code>)
 * </ul>
 * If either geometry is empty, the value of this predicate is <tt>false</tt>.
 * <p>
 * This predicate is similar to {@link #contains}, but is more inclusive (i.e.
 * returns <tt>true</tt> for more cases). In particular, unlike
 * <code>contains</code> it does not distinguish between points in the
 * boundary and in the interior of geometries. For most situations,
 * <code>covers</code> should be used in preference to <code>contains</code>.
 * As an added benefit, <code>covers</code> is more amenable to optimization,
 * and hence should be more performant.
 *
 * @param {Geometry}
 *          g the <code>Geometry</code> with which to compare this
 *          <code>Geometry.</code>
 * @return {boolean} <code>true</code> if this <code>Geometry</code> covers
 *         <code>g.</code>
 *
 * @see Geometry#contains
 * @see Geometry#coveredBy
 */
jsts.geom.Geometry.prototype.covers = function(g) {
  // short-circuit test
  if (!this.getEnvelopeInternal().covers(g.getEnvelopeInternal())) {
    return false;
  }
  // optimization for rectangle arguments
  if (this.isRectangle()) {
    // since we have already tested that the test envelope is covered
    return true;
  }
  return this.relate(g).isCovers();
};


/**
 * Tests whether this geometry is covered by the specified geometry.
 * <p>
 * The <code>coveredBy</code> predicate has the following equivalent
 * definitions:
 * <ul>
 * <li>Every point of this geometry is a point of the other geometry.
 * <li>The DE-9IM Intersection Matrix for the two geometries matches
 * <code>[T*F**F***]</code> or <code>[*TF**F***]</code> or
 * <code>[**FT*F***]</code> or <code>[**F*TF***]</code>
 * <li><code>g.covers(this)</code> (<code>coveredBy</code> is the converse
 * of <code>covers</code>)
 * </ul>
 * If either geometry is empty, the value of this predicate is <tt>false</tt>.
 * <p>
 * This predicate is similar to {@link #within}, but is more inclusive (i.e.
 * returns <tt>true</tt> for more cases).
 *
 * @param {Geometry}
 *          g the <code>Geometry</code> with which to compare this
 *          <code>Geometry.</code>
 * @return {boolean} <code>true</code> if this <code>Geometry</code> is
 *         covered by <code>g.</code>
 *
 * @see Geometry#within
 * @see Geometry#covers
 */
jsts.geom.Geometry.prototype.coveredBy = function(g) {
  return g.covers(this);
};


/**
 * Tests whether the elements in the DE-9IM {@link IntersectionMatrix} for the
 * two <code>Geometry</code>s match the elements in
 * <code>intersectionPattern</code>. The pattern is a 9-character string,
 * with symbols drawn from the following set:
 * <UL>
 * <LI> 0 (dimension 0)
 * <LI> 1 (dimension 1)
 * <LI> 2 (dimension 2)
 * <LI> T ( matches 0, 1 or 2)
 * <LI> F ( matches FALSE)
 * <LI> * ( matches any value)
 * </UL>
 * For more information on the DE-9IM, see the <i>OpenGIS Simple Features
 * Specification</i>.
 *
 * @param {Geometry}
 *          other the <code>Geometry</code> with which to compare this
 *          <code>Geometry.</code>
 * @param {string}
 *          intersectionPattern the pattern against which to check the
 *          intersection matrix for the two <code>Geometry</code>s.
 * @return {boolean} <code>true</code> if the DE-9IM intersection matrix for
 *         the two <code>Geometry</code>s match
 *         <code>intersectionPattern.</code>
 * @see IntersectionMatrix
 */
jsts.geom.Geometry.prototype.relate = function(g, intersectionPattern) {
  if (arguments.length === 1) {
    return this.relate2.apply(this, arguments);
  }

  return this.relate2(g).matches(intersectionPattern);
};


/**
 * Returns the DE-9IM {@link IntersectionMatrix} for the two
 * <code>Geometry</code>s.
 *
 * @param {Geometry}
 *          g the <code>Geometry</code> with which to compare this
 *          <code>Geometry.</code>
 * @return {IntersectionMatrix} an {@link IntersectionMatrix} describing the
 *         intersections of the interiors, boundaries and exteriors of the two
 *         <code>Geometry</code>s.
 */
jsts.geom.Geometry.prototype.relate2 = function(g) {
  this.checkNotGeometryCollection(this);
  this.checkNotGeometryCollection(g);
  return jsts.operation.relate.RelateOp.relate(this, g);
};


/**
 * Tests whether this geometry is topologically equal to the argument geometry
 * as defined by the SFS <tt>equals</tt> predicate.
 * <p>
 * The SFS <code>equals</code> predicate has the following equivalent
 * definitions:
 * <ul>
 * <li>The two geometries have at least one point in common, and no point of
 * either geometry lies in the exterior of the other geometry.
 * <li>The DE-9IM Intersection Matrix for the two geometries matches the
 * pattern <tt>T*F**FFF*</tt>
 * <pre>
 * T*F
 * **F
 * FF*
 * </pre>
 *
 * </ul>
 * <b>Note</b> that this method computes <b>topologically equality</b>. For
 * structural equality, see {@link #equalsExact(Geometry)}.
 *
 * @param {Geometry}
 *          g the <code>Geometry</code> with which to compare this
 *          <code>Geometry.</code>
 * @return {boolean} <code>true</code> if the two <code>Geometry</code>s
 *         are topologically equal.
 *
 * @see #equalsExact(Geometry)
 */
jsts.geom.Geometry.prototype.equalsTopo = function(g) {
  // short-circuit test
  if (!this.getEnvelopeInternal().equals(g.getEnvelopeInternal())) {
    return false;
  }
  return this.relate(g).isEquals(this.getDimension(), g.getDimension());
};


/**
 * Tests whether this geometry is structurally and numerically equal to a given
 * <tt>Object</tt>. If the argument <tt>Object</tt> is not a
 * <tt>Geometry</tt>, the result is <tt>false</tt>. Otherwise, the result
 * is computed using {@link #equalsExact(Geometry)}.
 * <p>
 * This method is provided to fulfill the Java contract for value-based object
 * equality. In conjunction with {@link #hashCode()} it provides semantics which
 * are most useful for using <tt>Geometry</tt>s as keys and values in Java
 * collections.
 * <p>
 * Note that to produce the expected result the input geometries should be in
 * normal form. It is the caller's responsibility to perform this where required
 * (using {@link Geometry#norm() or {@link #normalize()} as appropriate).
 *
 * @param {Object}
 *          o the Object to compare.
 * @return {boolean} true if this geometry is exactly equal to the argument.
 *
 * @see #equalsExact(Geometry)
 * @see #hashCode()
 * @see #norm()
 * @see #normalize()
 */
jsts.geom.Geometry.prototype.equals = function(o) {
  if (o instanceof jsts.geom.Geometry || o instanceof jsts.geom.LinearRing ||
      o instanceof jsts.geom.Polygon ||
      o instanceof jsts.geom.GeometryCollection ||
      o instanceof jsts.geom.MultiPoint ||
      o instanceof jsts.geom.MultiLineString ||
      o instanceof jsts.geom.MultiPolygon) {
    return this.equalsExact(o);
  }
  return false;
};

/**
 * Computes a buffer area around this geometry having the given width and with a
 * specified accuracy of approximation for circular arcs, and using a specified
 * end cap style.
 * <p>
 * Mathematically-exact buffer area boundaries can contain circular arcs. To
 * represent these arcs using linear geometry they must be approximated with
 * line segments. The <code>quadrantSegments</code> argument allows
 * controlling the accuracy of the approximation by specifying the number of
 * line segments used to represent a quadrant of a circle
 * <p>
 * The end cap style specifies the buffer geometry that will be created at the
 * ends of linestrings. The styles provided are:
 * <ul>
 * <li><tt>BufferOp.CAP_ROUND</tt> - (default) a semi-circle
 * <li><tt>BufferOp.CAP_BUTT</tt> - a straight line perpendicular to the end
 * segment
 * <li><tt>BufferOp.CAP_SQUARE</tt> - a half-square
 * </ul>
 * <p>
 * The buffer operation always returns a polygonal result. The negative or
 * zero-distance buffer of lines and points is always an empty {@link Polygon}.
 * This is also the result for the buffers of degenerate (zero-area) polygons.
 *
 * @param {number}
 *          distance the width of the buffer (may be positive, negative or 0).
 * @param {number}
 *          quadrantSegments the number of line segments used to represent a
 *          quadrant of a circle.
 * @param {number}
 *          endCapStyle the end cap style to use.
 * @return {Geometry} a polygonal geometry representing the buffer region (which
 *         may be empty).
 *
 * @throws TopologyException
 *           if a robustness error occurs
 *
 * @see #buffer(double)
 * @see #buffer(double, int)
 * @see BufferOp
 */
jsts.geom.Geometry.prototype.buffer = function(distance, quadrantSegments, endCapStyle) {
  var params = new jsts.operation.buffer.BufferParameters(quadrantSegments, endCapStyle)
  return jsts.operation.buffer.BufferOp.bufferOp2(this, distance, params);
};


/**
 * Computes the smallest convex <code>Polygon</code> that contains all the
 * points in the <code>Geometry</code>. This obviously applies only to
 * <code>Geometry</code> s which contain 3 or more points; the results for
 * degenerate cases are specified as follows: <TABLE>
 * <TR>
 * <TH> Number of <code>Point</code>s in argument <code>Geometry</code>
 * </TH>
 * <TH> <code>Geometry</code> class of result </TH>
 * </TR>
 * <TR>
 * <TD> 0 </TD>
 * <TD> empty <code>GeometryCollection</code> </TD>
 * </TR>
 * <TR>
 * <TD> 1 </TD>
 * <TD> <code>Point</code> </TD>
 * </TR>
 * <TR>
 * <TD> 2 </TD>
 * <TD> <code>LineString</code> </TD>
 * </TR>
 * <TR>
 * <TD> 3 or more </TD>
 * <TD> <code>Polygon</code> </TD>
 * </TR>
 * </TABLE>
 *
 * @return {Geometry} the minimum-area convex polygon containing this
 *         <code>Geometry</code>' s points.
 */
jsts.geom.Geometry.prototype.convexHull = function() {
  return new jsts.algorithm.ConvexHull(this).getConvexHull();
};


/**
 * Computes a <code>Geometry</code> representing the points shared by this
 * <code>Geometry</code> and <code>other</code>. {@link GeometryCollection}s
 * support intersection with homogeneous collection types, with the semantics
 * that the result is a {@link GeometryCollection} of the intersection of each
 * element of the target with the argument.
 *
 * @param {Geometry}
 *          other the <code>Geometry</code> with which to compute the
 *          intersection.
 * @return {Geometry} the points common to the two <code>Geometry</code>s.
 * @throws TopologyException
 *           if a robustness error occurs
 * @throws IllegalArgumentException
 *           if the argument is a non-empty GeometryCollection
 */
jsts.geom.Geometry.prototype.intersection = function(other) {
  /**
   * TODO: MD - add optimization for P-A case using Point-In-Polygon
   */
  // special case: if one input is empty ==> empty
  if (this.isEmpty()) {
    return this.getFactory().createGeometryCollection(null);
  }
  if (other.isEmpty()) {
    return this.getFactory().createGeometryCollection(null);
  }

  // compute for GCs
  if (this.isGeometryCollection(this)) {
    var g2 = other;
    // TODO: probably not straightforward to port...
    /*
     * return GeometryCollectionMapper.map(this, new
     * GeometryCollectionMapper.MapOp() { public Geometry map(Geometry g) {
     * return g.intersection(g2); } });
     */
  }

  this.checkNotGeometryCollection(this);
  this.checkNotGeometryCollection(other);
  return jsts.operation.overlay.snap.SnapIfNeededOverlayOp.overlayOp(this,
      other, jsts.operation.overlay.OverlayOp.INTERSECTION);
};


/**
 * Computes a <code>Geometry</code> representing all the points in this
 * <code>Geometry</code> and <code>other</code>.
 *
 * Or without arguments:
 *
 * Computes the union of all the elements of this geometry. Heterogeneous
 * {@link GeometryCollection}s are fully supported.
 *
 * The result obeys the following contract:
 * <ul>
 * <li>Unioning a set of {@link LineString}s has the effect of fully noding
 * and dissolving the linework.
 * <li>Unioning a set of {@link Polygon}s will always return a
 * {@link Polygonal} geometry (unlike {link #union(Geometry)}, which may return
 * geometrys of lower dimension if a topology collapse occurred.
 * </ul>
 *
 * @param {Geometry}
 *          other the <code>Geometry</code> with which to compute the union.
 * @return {Geometry} a set combining the points of this <code>Geometry</code>
 *         and the points of <code>other.</code>
 * @throws TopologyException
 *           if a robustness error occurs
 * @throws IllegalArgumentException
 *           if either input is a non-empty GeometryCollection
 */
jsts.geom.Geometry.prototype.union = function(other) {
  if (arguments.length === 0) {
    return jsts.operation.union.UnaryUnionOp.union(this);
  }

  // special case: if either input is empty ==> other input
  if (this.isEmpty()) {
    return other.clone();
  }
  if (other.isEmpty()) {
    return this.clone();
  }

  // TODO: optimize if envelopes of geometries do not intersect

  this.checkNotGeometryCollection(this);
  this.checkNotGeometryCollection(other);
  return jsts.operation.overlay.snap.SnapIfNeededOverlayOp.overlayOp(this,
      other, jsts.operation.overlay.OverlayOp.UNION);
};


/**
 * Computes a <code>Geometry</code> representing the points making up this
 * <code>Geometry</code> that do not make up <code>other</code>. This
 * method returns the closure of the resultant <code>Geometry</code>.
 *
 * @param {Geometry}
 *          other the <code>Geometry</code> with which to compute the
 *          difference.
 * @return {Geometry} the point set difference of this <code>Geometry</code>
 *         with <code>other.</code>
 * @throws TopologyException
 *           if a robustness error occurs
 * @throws IllegalArgumentException
 *           if either input is a non-empty GeometryCollection
 */
jsts.geom.Geometry.prototype.difference = function(other) {
  // mod to handle empty cases better - return type of input
  // if (this.isEmpty() || other.isEmpty()) return (Geometry) clone();

  // special case: if A.isEmpty ==> empty; if B.isEmpty ==> A
  if (this.isEmpty()) {
    return this.getFactory().createGeometryCollection(null);
  }
  if (other.isEmpty()) {
    return this.clone();
  }

  this.checkNotGeometryCollection(this);
  this.checkNotGeometryCollection(other);
  return jsts.operation.overlay.snap.SnapIfNeededOverlayOp.overlayOp(this,
      other, jsts.operation.overlay.OverlayOp.DIFFERENCE);
};


/**
 * Returns a set combining the points in this <code>Geometry</code> not in
 * <code>other</code>, and the points in <code>other</code> not in this
 * <code>Geometry</code>. This method returns the closure of the resultant
 * <code>Geometry</code>.
 *
 * @param {Geometry}
 *          other the <code>Geometry</code> with which to compute the
 *          symmetric difference.
 * @return {Geometry} the point set symmetric difference of this
 *         <code>Geometry</code> with <code>other.</code>
 * @throws TopologyException
 *           if a robustness error occurs
 * @throws IllegalArgumentException
 *           if either input is a non-empty GeometryCollection
 */
jsts.geom.Geometry.prototype.symDifference = function(other) {
  // special case: if either input is empty ==> other input
  if (this.isEmpty()) {
    return other.clone();
  }
  if (other.isEmpty()) {
    return this.clone();
  }

  this.checkNotGeometryCollection(this);
  this.checkNotGeometryCollection(other);
  return jsts.operation.overlay.snap.SnapIfNeededOverlayOp.overlayOp(this,
      other, jsts.operation.overlay.OverlayOp.SYMDIFFERENCE);
};

/**
 * Returns true if the two <code>Geometry</code>s are exactly equal, up to a
 * specified distance tolerance. Two Geometries are exactly equal within a
 * distance tolerance if and only if:
 * <ul>
 * <li>they have the same class
 * <li>they have the same values for their vertices, within the given tolerance
 * distance, in exactly the same order.
 * </ul>
 * If this and the other <code>Geometry</code>s are composites and any
 * children are not <code>Geometry</code>s, returns <code>false</code>.
 *
 * @param {Geometry}
 *          other the <code>Geometry</code> with which to compare this
 *          <code>Geometry.</code>
 * @param {number}
 *          tolerance distance at or below which two <code>Coordinate</code>s
 *          are considered equal.
 * @return {boolean}
 */
jsts.geom.Geometry.prototype.equalsExact = function(other, tolerance) {
  throw new jsts.error.AbstractMethodInvocationError();
};

/**
 * Tests whether two geometries are exactly equal in their normalized forms.
 * This is a convenience method which creates normalized versions of both
 * geometries before computing {@link #equalsExact(Geometry)}. This method is
 * relatively expensive to compute. For maximum performance, the client should
 * instead perform normalization itself at an appropriate point during
 * execution.
 *
 * @param {Geometry}
 *          g a Geometry.
 * @return {boolean} true if the input geometries are exactly equal in their
 *         normalized form.
 */
jsts.geom.Geometry.prototype.equalsNorm = function(g) {
  if (g === null || g === undefined)
    return false;
  return this.norm().equalsExact(g.norm());
};


/**
 * Performs an operation with or on this <code>Geometry</code> and its
 * subelement <code>Geometry</code>s (if any). Only GeometryCollections and
 * subclasses have subelement Geometry's.
 *
 * @param filter
 *          the filter to apply to this <code>Geometry</code> (and its
 *          children, if it is a <code>GeometryCollection</code>).
 */
jsts.geom.Geometry.prototype.apply = function(filter) {
  throw new jsts.error.AbstractMethodInvocationError();
};

/**
 * Creates and returns a full copy of this {@link Geometry} object (including
 * all coordinates contained by it). Subclasses are responsible for overriding
 * this method and copying their internal data. Overrides should call this
 * method first.
 *
 * @return a clone of this instance.
 */
jsts.geom.Geometry.prototype.clone = function() {
  throw new jsts.error.AbstractMethodInvocationError();
};


/**
 * Converts this <code>Geometry</code> to <b>normal form</b> (or <b>
 * canonical form</b> ). Normal form is a unique representation for
 * <code>Geometry</code> s. It can be used to test whether two
 * <code>Geometry</code>s are equal in a way that is independent of the
 * ordering of the coordinates within them. Normal form equality is a stronger
 * condition than topological equality, but weaker than pointwise equality. The
 * definitions for normal form use the standard lexicographical ordering for
 * coordinates. "Sorted in order of coordinates" means the obvious extension of
 * this ordering to sequences of coordinates.
 */
jsts.geom.Geometry.prototype.normalize = function() {
  throw new jsts.error.AbstractMethodInvocationError();
};

/**
 * Creates a new Geometry which is a normalized copy of this Geometry.
 *
 * @return a normalized copy of this geometry.
 * @see #normalize()
 */
jsts.geom.Geometry.prototype.norm = function() {
  var copy = this.clone();
  copy.normalize();
  return copy;
};


/**
 * Returns whether this <code>Geometry</code> is greater than, equal to, or
 * less than another <code>Geometry</code>.
 * <P>
 *
 * If their classes are different, they are compared using the following
 * ordering:
 * <UL>
 * <LI> Point (lowest)
 * <LI> MultiPoint
 * <LI> LineString
 * <LI> LinearRing
 * <LI> MultiLineString
 * <LI> Polygon
 * <LI> MultiPolygon
 * <LI> GeometryCollection (highest)
 * </UL>
 * If the two <code>Geometry</code>s have the same class, their first
 * elements are compared. If those are the same, the second elements are
 * compared, etc.
 *
 * @param {Geometry}
 *          other a <code>Geometry</code> with which to compare this
 *          <code>Geometry.</code>
 * @return {number} a positive number, 0, or a negative number, depending on
 *         whether this object is greater than, equal to, or less than
 *         <code>o</code>, as defined in "Normal Form For Geometry" in the
 *         JTS Technical Specifications.
 */
jsts.geom.Geometry.prototype.compareTo = function(o) {
  var other = o;
  if (this.getClassSortIndex() !== other.getClassSortIndex()) {
    return this.getClassSortIndex() - other.getClassSortIndex();
  }
  if (this.isEmpty() && other.isEmpty()) {
    return 0;
  }
  if (this.isEmpty()) {
    return -1;
  }
  if (other.isEmpty()) {
    return 1;
  }
  return this.compareToSameClass(o);
};

/**
 * Returns whether the two <code>Geometry</code>s are equal, from the point
 * of view of the <code>equalsExact</code> method. Called by
 * <code>equalsExact</code> . In general, two <code>Geometry</code> classes
 * are considered to be "equivalent" only if they are the same class. An
 * exception is <code>LineString</code> , which is considered to be equivalent
 * to its subclasses.
 *
 * @param {Geometry}
 *          other the <code>Geometry</code> with which to compare this
 *          <code>Geometry</code> for equality.
 * @return {boolean} <code>true</code> if the classes of the two
 *         <code>Geometry</code> s are considered to be equal by the
 *         <code>equalsExact</code> method.
 */
jsts.geom.Geometry.prototype.isEquivalentClass = function(other) {
  if (this instanceof jsts.geom.Point && other instanceof jsts.geom.Point) {
    return true;
  } else if (this instanceof jsts.geom.LineString &&
      (other instanceof jsts.geom.LineString | other instanceof jsts.geom.LinearRing)) {
    return true;
  } else if (this instanceof jsts.geom.LinearRing &&
      (other instanceof jsts.geom.LineString | other instanceof jsts.geom.LinearRing)) {
    return true;
  } else if (this instanceof jsts.geom.Polygon &&
      (other instanceof jsts.geom.Polygon)) {
    return true;
  } else if (this instanceof jsts.geom.MultiPoint &&
      (other instanceof jsts.geom.MultiPoint)) {
    return true;
  } else if (this instanceof jsts.geom.MultiLineString &&
      (other instanceof jsts.geom.MultiLineString)) {
    return true;
  } else if (this instanceof jsts.geom.MultiPolygon &&
      (other instanceof jsts.geom.MultiPolygon)) {
    return true;
  } else if (this instanceof jsts.geom.GeometryCollection &&
      (other instanceof jsts.geom.GeometryCollection)) {
    return true;
  }

  return false;
};



/**
 * Throws an exception if <code>g</code>'s class is
 * <code>GeometryCollection</code> . (Its subclasses do not trigger an
 * exception).
 *
 * @param {Geometry}
 *          g the <code>Geometry</code> to check.
 * @throws Error
 *           if <code>g</code> is a <code>GeometryCollection</code> but not
 *           one of its subclasses
 */
jsts.geom.Geometry.prototype.checkNotGeometryCollection = function(g) {
  if (g.isGeometryCollectionBase()) {
    throw new jsts.error.IllegalArgumentError(
        'This method does not support GeometryCollection');
  }
};


/**
 *
 * @return {boolean} true if this is a GeometryCollection.
 */
jsts.geom.Geometry.prototype.isGeometryCollection = function() {
  return (this instanceof jsts.geom.GeometryCollection);
};

/**
 *
 * @return {boolean} true if this is a GeometryCollection but not subclass.
 */
jsts.geom.Geometry.prototype.isGeometryCollectionBase = function() {
  return (this.CLASS_NAME === 'jsts.geom.GeometryCollection');
};


/**
 * Returns the minimum and maximum x and y values in this <code>Geometry</code>,
 * or a null <code>Envelope</code> if this <code>Geometry</code> is empty.
 * Unlike <code>getEnvelopeInternal</code>, this method calculates the
 * <code>Envelope</code> each time it is called;
 * <code>getEnvelopeInternal</code> caches the result of this method.
 *
 * @return {Envelope} this <code>Geometry</code>s bounding box; if the
 *         <code>Geometry</code> is empty, <code>Envelope#isNull</code> will
 *         return <code>true.</code>
 */
jsts.geom.Geometry.prototype.computeEnvelopeInternal = function() {
  throw new jsts.error.AbstractMethodInvocationError();
};


/**
 * Returns whether this <code>Geometry</code> is greater than, equal to, or
 * less than another <code>Geometry</code> having the same class.
 *
 * @param o
 *          a <code>Geometry</code> having the same class as this
 *          <code>Geometry.</code>
 * @return a positive number, 0, or a negative number, depending on whether this
 *         object is greater than, equal to, or less than <code>o</code>, as
 *         defined in "Normal Form For Geometry" in the JTS Technical
 *         Specifications.
 */
jsts.geom.Geometry.prototype.compareToSameClass = function(o) {
  throw new jsts.error.AbstractMethodInvocationError();
};

/**
 * Returns the first non-zero result of <code>compareTo</code> encountered as
 * the two <code>Collection</code>s are iterated over. If, by the time one of
 * the iterations is complete, no non-zero result has been encountered, returns
 * 0 if the other iteration is also complete. If <code>b</code> completes
 * before <code>a</code>, a positive number is returned; if a before b, a
 * negative number.
 *
 * @param {Array}
 *          a a <code>Collection</code> of <code>Comparable</code>s.
 * @param {Array}
 *          b a <code>Collection</code> of <code>Comparable</code>s.
 * @return {number} the first non-zero <code>compareTo</code> result, if any;
 *         otherwise, zero.
 */
jsts.geom.Geometry.prototype.compare = function(a, b) {
  var i = a.iterator();
  var j = b.iterator();
  while (i.hasNext() && j.hasNext()) {
    var aElement = i.next();
    var bElement = j.next();
    var comparison = aElement.compareTo(bElement);
    if (comparison !== 0) {
      return comparison;
    }
  }
  if (i.hasNext()) {
    return 1;
  }
  if (j.hasNext()) {
    return -1;
  }
  return 0;
};


/**
 * @param {jsts.geom.Coordinate}
 *          a first Coordinate to compare.
 * @param {jsts.geom.Coordinate}
 *          b second Coordinate to compare.
 * @param {number}
 *          tolerance tolerance when comparing.
 * @return {boolean} true if equal.
 */
jsts.geom.Geometry.prototype.equal = function(a, b, tolerance) {
  if (tolerance === undefined || tolerance === null || tolerance === 0) {
    return a.equals(b);
  }
  return a.distance(b) <= tolerance;
};

/**
 * @private
 */
jsts.geom.Geometry.prototype.getClassSortIndex = function() {
  var sortedClasses = [jsts.geom.Point, jsts.geom.MultiPoint,
      jsts.geom.LineString, jsts.geom.LinearRing, jsts.geom.MultiLineString,
      jsts.geom.Polygon, jsts.geom.MultiPolygon, jsts.geom.GeometryCollection];

  for (var i = 0; i < sortedClasses.length; i++) {
    if (this instanceof sortedClasses[i])
      return i;
  }
  jsts.util.Assert.shouldNeverReachHere('Class not supported: ' + this);
  return -1;
};

jsts.geom.Geometry.prototype.toString = function() {
  return new jsts.io.WKTWriter().write(this);
};

/**
 * @return {Point}
 * @private
 */
jsts.geom.Geometry.prototype.createPointFromInternalCoord = function(coord,
    exemplar) {
  exemplar.getPrecisionModel().makePrecise(coord);
  return exemplar.getFactory().createPoint(coord);
};
/* ======================================================================
    jsts/geom/Coordinate.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * A lightweight class used to store coordinates on the 2-dimensional
   * Cartesian plane. It is distinct from {@link Point}, which is a subclass of
   * {@link Geometry}. Unlike objects of type {@link Point} (which contain
   * additional information such as an envelope, a precision model, and spatial
   * reference system information), a <code>Coordinate</code> only contains
   * coordinate values and accessor methods.
   *
   * @requires jsts/geom/Geometry.js
   */



  /**
   * @constructor
   */
  jsts.geom.Coordinate = function(x, y) {
    if (typeof x === 'number') {
      this.x = x;
      this.y = y;
    } else if (x instanceof jsts.geom.Coordinate) {
      this.x = parseFloat(x.x);
      this.y = parseFloat(x.y);
    } else if (x === undefined || x === null) {
      this.x = 0;
      this.y = 0;
    } else if (typeof x === 'string') {
      this.x = parseFloat(x);
      this.y = parseFloat(y);
    }
  };

  /**
   * Sets this <code>Coordinate</code>s (x,y,z) values to that of
   * <code>other</code>.
   *
   * @param {Coordinate}
   *          other the <code>Coordinate</code> to copy.
   */
  jsts.geom.Coordinate.prototype.setCoordinate = function(other) {
    this.x = other.x;
    this.y = other.y;
  };


  /**
   * Clones this instance.
   *
   * @return {Coordinate} A point instance cloned from this.
   */
  jsts.geom.Coordinate.prototype.clone = function() {
    return new jsts.geom.Coordinate(this.x, this.y);
  };


  /**
   * Computes the 2-dimensional Euclidean distance to another location. The
   * Z-ordinate is ignored.
   *
   * @param {Coordinate}
   *          p a point.
   * @return {number} the 2-dimensional Euclidean distance between the
   *         locations.
   */
  jsts.geom.Coordinate.prototype.distance = function(p) {
    var dx = this.x - p.x;
    var dy = this.y - p.y;

    return Math.sqrt(dx * dx + dy * dy);
  };

  /**
   * Returns whether the planar projections of the two <code>Coordinate</code>s
   * are equal.
   *
   * @param {Coordinate}
   *          other a <code>Coordinate</code> with which to do the 2D
   *          comparison.
   * @return {boolean} <code>true</code> if the x- and y-coordinates are
   *         equal; the z-coordinates do not have to be equal.
   */
  jsts.geom.Coordinate.prototype.equals2D = function(other) {
    if (this.x !== other.x) {
      return false;
    }

    if (this.y !== other.y) {
      return false;
    }

    return true;
  };

  /**
   * Returns <code>true</code> if <code>other</code> has the same values for
   * the x and y ordinates. Since Coordinates are 2.5D, this routine ignores the
   * z value when making the comparison.
   *
   * @param {Coordinate}
   *          other a <code>Coordinate</code> with which to do the comparison.
   * @return {boolean} <code>true</code> if <code>other</code> is a
   *         <code>Coordinate</code> with the same values for the x and y
   *         ordinates.
   */
  jsts.geom.Coordinate.prototype.equals = function(other) {
    if (!other instanceof jsts.geom.Coordinate || other === undefined) {
      return false;
    }
    return this.equals2D(other);
  };

  /**
   * Compares this {@link Coordinate} with the specified {@link Coordinate} for
   * order. This method ignores the z value when making the comparison. Returns:
   * <UL>
   * <LI> -1 : this.x < other.x || ((this.x == other.x) && (this.y < other.y))
   * <LI> 0 : this.x == other.x && this.y = other.y
   * <LI> 1 : this.x > other.x || ((this.x == other.x) && (this.y > other.y))
   *
   * </UL>
   * Note: This method assumes that ordinate values are valid numbers. NaN
   * values are not handled correctly.
   *
   * @param {Coordinate}
   *          other the <code>Coordinate</code> with which this
   *          <code>Coordinate</code> is being compared.
   * @return {number} -1, zero, or 1 as explained above.
   */
  jsts.geom.Coordinate.prototype.compareTo = function(other) {
    if (this.x < other.x) {
      return -1;
    }
    if (this.x > other.x) {
      return 1;
    }
    if (this.y < other.y) {
      return -1;
    }
    if (this.y > other.y) {
      return 1;
    }

    return 0;
  };

  jsts.geom.Coordinate.prototype.toString = function() {
    return '(' + this.x + ', ' + this.y + ')';
  };

})();
/* ======================================================================
    jsts/geom/Envelope.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @requires jsts/geom/Coordinate.js
 */

/**
 * Defines a rectangular region of the 2D coordinate plane. It is often used to
 * represent the bounding box of a {@link Geometry}, e.g. the minimum and
 * maximum x and y values of the {@link Coordinate}s.
 * <p>
 * Note that Envelopes support infinite or half-infinite regions, by using the
 * values of <code>Double.POSITIVE_INFINITY</code> and
 * <code>Double.NEGATIVE_INFINITY</code>.
 * <p>
 * When Envelope objects are created or initialized, the supplies extent values
 * are automatically sorted into the correct order.
 */



/**
 * Creates an <code>Envelope</code> for a region defined by maximum and
 * minimum values.
 *
 * @constructor
 */
jsts.geom.Envelope = function() {
  jsts.geom.Envelope.prototype.init.apply(this, arguments);
};


/**
 * the minimum x-coordinate
 *
 * @type {?number}
 */
jsts.geom.Envelope.prototype.minx = null;


/**
 * the maximum x-coordinate
 *
 * @type {?number}
 */
jsts.geom.Envelope.prototype.maxx = null;


/**
 * the minimum y-coordinate
 *
 * @type {?number}
 */
jsts.geom.Envelope.prototype.miny = null;


/**
 * the maximum y-coordinate
 *
 * @type {?number}
 */
jsts.geom.Envelope.prototype.maxy = null;


/**
 * Creates an <code>Envelope</code> for a region defined by maximum and
 * minimum values.
 *
 * Will call appropriate init* method depending on arguments.
 */
jsts.geom.Envelope.prototype.init = function() {
  if (typeof arguments[0] === 'number' && arguments.length === 4) {
    this.initFromValues(arguments[0], arguments[1], arguments[2], arguments[3]);
  } else if (arguments[0] instanceof jsts.geom.Coordinate &&
      arguments.length === 1) {
    this.initFromCoordinate(arguments[0]);
  } else if (arguments[0] instanceof jsts.geom.Coordinate &&
      arguments.length === 2) {
    this.initFromCoordinates(arguments[0], arguments[1]);
  } else if (arguments[0] instanceof jsts.geom.Envelope &&
      arguments.length === 1) {
    this.initFromEnvelope(arguments[0]);
  } else {
    this.setToNull();
  }
};


/**
 * Initialize an <code>Envelope</code> for a region defined by maximum and
 * minimum values.
 *
 * @param {number}
 *          x1 the first x-value.
 * @param {number}
 *          x2 the second x-value.
 * @param {number}
 *          y1 the first y-value.
 * @param {number}
 *          y2 the second y-value.
 */
jsts.geom.Envelope.prototype.initFromValues = function(x1, x2, y1, y2) {
  if (x1 < x2) {
    this.minx = x1;
    this.maxx = x2;
  } else {
    this.minx = x2;
    this.maxx = x1;
  }
  if (y1 < y2) {
    this.miny = y1;
    this.maxy = y2;
  } else {
    this.miny = y2;
    this.maxy = y1;
  }
};


/**
 * Initialize an <code>Envelope</code> to a region defined by two Coordinates.
 *
 * @param {jsts.geom.Coordinate}
 *          p1 the first Coordinate.
 * @param {jsts.geom.Coordinate}
 *          p2 the second Coordinate.
 */
jsts.geom.Envelope.prototype.initFromCoordinates = function(p1, p2) {
  this.initFromValues(p1.x, p2.x, p1.y, p2.y);
};


/**
 * Initialize an <code>Envelope</code> to a region defined by a single
 * Coordinate.
 *
 * @param {jsts.geom.Coordinate}
 *          p the Coordinate.
 */
jsts.geom.Envelope.prototype.initFromCoordinate = function(p) {
  this.initFromValues(p.x, p.x, p.y, p.y);
};


/**
 * Initialize an <code>Envelope</code> from an existing Envelope.
 *
 * @param {jsts.geom.Envelope}
 *          env the Envelope to initialize from.
 */
jsts.geom.Envelope.prototype.initFromEnvelope = function(env) {
  this.minx = env.minx;
  this.maxx = env.maxx;
  this.miny = env.miny;
  this.maxy = env.maxy;
};


/**
 * Makes this <code>Envelope</code> a "null" envelope, that is, the envelope
 * of the empty geometry.
 */
jsts.geom.Envelope.prototype.setToNull = function() {
  this.minx = 0;
  this.maxx = -1;
  this.miny = 0;
  this.maxy = -1;
};


/**
 * Returns <code>true</code> if this <code>Envelope</code> is a "null"
 * envelope.
 *
 * @return {boolean} <code>true</code> if this <code>Envelope</code> is
 *         uninitialized or is the envelope of the empty geometry.
 */
jsts.geom.Envelope.prototype.isNull = function() {
  return this.maxx < this.minx;
};


/**
 * Returns the difference between the maximum and minimum y values.
 *
 * @return {number} max y - min y, or 0 if this is a null <code>Envelope.</code>
 */
jsts.geom.Envelope.prototype.getHeight = function() {
  if (this.isNull()) {
    return 0;
  }
  return this.maxy - this.miny;
};


/**
 * Returns the difference between the maximum and minimum x values.
 *
 * @return {number} max x - min x, or 0 if this is a null <code>Envelope.</code>
 */
jsts.geom.Envelope.prototype.getWidth = function() {
  if (this.isNull()) {
    return 0;
  }
  return this.maxx - this.minx;
};


/**
 * Returns the <code>Envelope</code>s minimum x-value. min x > max x
 * indicates that this is a null <code>Envelope</code>.
 *
 * @return {number} the minimum x-coordinate.
 */
jsts.geom.Envelope.prototype.getMinX = function() {
  return this.minx;
};


/**
 * Returns the <code>Envelope</code>s maximum x-value. min x > max x
 * indicates that this is a null <code>Envelope</code>.
 *
 * @return {number} the maximum x-coordinate.
 */
jsts.geom.Envelope.prototype.getMaxX = function() {
  return this.maxx;
};


/**
 * Returns the <code>Envelope</code>s minimum y-value. min y > max y
 * indicates that this is a null <code>Envelope</code>.
 *
 * @return {number} the minimum y-coordinate.
 */
jsts.geom.Envelope.prototype.getMinY = function() {
  return this.miny;
};


/**
 * Returns the <code>Envelope</code>s maximum y-value. min y > max y
 * indicates that this is a null <code>Envelope</code>.
 *
 * @return {number} the maximum y-coordinate.
 */
jsts.geom.Envelope.prototype.getMaxY = function() {
  return this.maxy;
};


/**
 * Gets the area of this envelope.
 *
 * @return {number} the area of the envelope, 0.0 if the envelope is null.
 */
jsts.geom.Envelope.prototype.getArea = function() {
  return this.getWidth() * this.getHeight();
};


/**
 * Enlarges this <code>Envelope</code>
 *
 * Will call appropriate expandToInclude* depending on arguments.
 */
jsts.geom.Envelope.prototype.expandToInclude = function() {
  if (arguments[0] instanceof jsts.geom.Coordinate) {
    this.expandToIncludeCoordinate(arguments[0]);
  } else if (arguments[0] instanceof jsts.geom.Envelope) {
    this.expandToIncludeEnvelope(arguments[0]);
  } else {
    this.expandToIncludeValues(arguments[0], arguments[1]);
  }
};


/**
 * Enlarges this <code>Envelope</code> so that it contains the given
 * {@link Coordinate}. Has no effect if the point is already on or within the
 * envelope.
 *
 * @param {jsts.geom.Coordinate}
 *          p the Coordinate to expand to include.
 */
jsts.geom.Envelope.prototype.expandToIncludeCoordinate = function(p) {
  this.expandToIncludeValues(p.x, p.y);
};


/**
 * Enlarges this <code>Envelope</code> so that it contains the given point.
 * Has no effect if the point is already on or within the envelope.
 *
 * @param {number}
 *          x the value to lower the minimum x to or to raise the maximum x to.
 * @param {number}
 *          y the value to lower the minimum y to or to raise the maximum y to.
 */
jsts.geom.Envelope.prototype.expandToIncludeValues = function(x, y) {
  if (this.isNull()) {
    this.minx = x;
    this.maxx = x;
    this.miny = y;
    this.maxy = y;
  } else {
    if (x < this.minx) {
      this.minx = x;
    }
    if (x > this.maxx) {
      this.maxx = x;
    }
    if (y < this.miny) {
      this.miny = y;
    }
    if (y > this.maxy) {
      this.maxy = y;
    }
  }
};


/**
 * Enlarges this <code>Envelope</code> so that it contains the
 * <code>other</code> Envelope. Has no effect if <code>other</code> is
 * wholly on or within the envelope.
 *
 * @param {jsts.geom.Envelope}
 *          other the <code>Envelope</code> to expand to include.
 */
jsts.geom.Envelope.prototype.expandToIncludeEnvelope = function(other) {
  if (other.isNull()) {
    return;
  }
  if (this.isNull()) {
    this.minx = other.getMinX();
    this.maxx = other.getMaxX();
    this.miny = other.getMinY();
    this.maxy = other.getMaxY();
  } else {
    if (other.minx < this.minx) {
      this.minx = other.minx;
    }
    if (other.maxx > this.maxx) {
      this.maxx = other.maxx;
    }
    if (other.miny < this.miny) {
      this.miny = other.miny;
    }
    if (other.maxy > this.maxy) {
      this.maxy = other.maxy;
    }
  }
};


/**
 * Enlarges this <code>Envelope</code>
 *
 * Will call appropriate expandBy* depending on arguments.
 */
jsts.geom.Envelope.prototype.expandBy = function() {
  if (arguments.length === 1) {
    this.expandByDistance(arguments[0]);
  } else {
    this.expandByDistances(arguments[0], arguments[1]);
  }
};


/**
 * Expands this envelope by a given distance in all directions. Both positive
 * and negative distances are supported.
 *
 * @param {number}
 *          distance the distance to expand the envelope.
 */
jsts.geom.Envelope.prototype.expandByDistance = function(distance) {
  this.expandByDistances(distance, distance);
};


/**
 * Expands this envelope by a given distance in all directions. Both positive
 * and negative distances are supported.
 *
 * @param {number}
 *          deltaX the distance to expand the envelope along the the X axis.
 * @param {number}
 *          deltaY the distance to expand the envelope along the the Y axis.
 */
jsts.geom.Envelope.prototype.expandByDistances = function(deltaX, deltaY) {
  if (this.isNull()) {
    return;
  }

  this.minx -= deltaX;
  this.maxx += deltaX;
  this.miny -= deltaY;
  this.maxy += deltaY;

  // check for envelope disappearing
  if (this.minx > this.maxx || this.miny > this.maxy) {
    this.setToNull();
  }
};


/**
 * Translates this envelope by given amounts in the X and Y direction.
 *
 * @param {number}
 *          transX the amount to translate along the X axis.
 * @param {number}
 *          transY the amount to translate along the Y axis.
 */
jsts.geom.Envelope.prototype.translate = function(transX, transY) {
  if (this.isNull()) {
    return;
  }
  this.init(this.minx + transX, this.maxx + transX, this.miny + transY,
      this.maxy + transY);
};


/**
 * Computes the coordinate of the centre of this envelope (as long as it is
 * non-null
 *
 * @return {jsts.geom.Coordinate} the centre coordinate of this envelope <code>null</code>
 *         if the envelope is null.
 */
jsts.geom.Envelope.prototype.centre = function() {
  if (this.isNull()) {
    return null;
  }
  return new jsts.geom.Coordinate((this.minx + this.maxx) / 2.0,
      (this.miny + this.maxy) / 2.0);
};


/**
 * Computes the intersection of two {@link Envelopes}
 *
 * @param {jsts.geom.Envelope}
 *          env the envelope to intersect with.
 * @return {jsts.geom.Envelope} a new Envelope representing the intersection of
 *         the envelopes (this will be the null envelope if either argument is
 *         null, or they do not intersect.
 */
jsts.geom.Envelope.prototype.intersection = function(env) {
  if (this.isNull() || env.isNull() || !this.intersects(env)) {
    return new jsts.geom.Envelope();
  }

  var intMinX = this.minx > env.minx ? this.minx : env.minx;
  var intMinY = this.miny > env.miny ? this.miny : env.miny;
  var intMaxX = this.maxx < env.maxx ? this.maxx : env.maxx;
  var intMaxY = this.maxy < env.maxy ? this.maxy : env.maxy;

  return new jsts.geom.Envelope(intMinX, intMaxX, intMinY, intMaxY);
};


/**
 * Check if the region defined by input overlaps (intersects) the region of this
 * <code>Envelope</code>.
 *
 * Will call appropriate intersects* depending on arguments.
 *
 * @return {boolean} <code>true</code> if an overlap is found.
 */
jsts.geom.Envelope.prototype.intersects = function() {
  if (arguments[0] instanceof jsts.geom.Envelope) {
    return this.intersectsEnvelope(arguments[0]);
  } else if (arguments[0] instanceof jsts.geom.Coordinate) {
    return this.intersectsCoordinate(arguments[0]);
  } else {
    return this.intersectsValues(arguments[0], arguments[1]);
  }
};


/**
 * Check if the region defined by <code>other</code> overlaps (intersects) the
 * region of this <code>Envelope</code>.
 *
 * @param {jsts.geom.Envelope}
 *          other the <code>Envelope</code> which this <code>Envelope</code>
 *          is being checked for overlapping.
 * @return {boolean} <code>true</code> if the <code>Envelope</code>s
 *         overlap.
 */
jsts.geom.Envelope.prototype.intersectsEnvelope = function(other) {
  if (this.isNull() || other.isNull()) {
    return false;
  }

  var result = !(other.minx > this.maxx || other.maxx < this.minx ||
      other.miny > this.maxy || other.maxy < this.miny);
  return result;
};


/**
 * Check if the point <code>p</code> overlaps (lies inside) the region of this
 * <code>Envelope</code>.
 *
 * @param {jsts.geom.Coordinate}
 *          p the <code>Coordinate</code> to be tested.
 * @return {boolean} <code>true</code> if the point overlaps this
 *         <code>Envelope.</code>
 */
jsts.geom.Envelope.prototype.intersectsCoordinate = function(p) {
  return this.intersectsValues(p.x, p.y);
};


/**
 * Check if the point <code>(x, y)</code> overlaps (lies inside) the region of
 * this <code>Envelope</code>.
 *
 * @param {number}
 *          x the x-ordinate of the point.
 * @param {number}
 *          y the y-ordinate of the point.
 * @return {boolean} <code>true</code> if the point overlaps this
 *         <code>Envelope.</code>
 */
jsts.geom.Envelope.prototype.intersectsValues = function(x, y) {
  if (this.isNull()) {
    return false;
  }

  return !(x > this.maxx || x < this.minx || y > this.maxy || y < this.miny);
};


/**
 * Tests if the input lies wholely inside this <code>Envelope</code>
 * (inclusive of the boundary).
 *
 * Will call appropriate contains* depending on arguments.
 *
 * @return {boolean} true if input is contained in this <code>Envelope.</code>
 */
jsts.geom.Envelope.prototype.contains = function() {
  if (arguments[0] instanceof jsts.geom.Envelope) {
    return this.containsEnvelope(arguments[0]);
  } else if (arguments[0] instanceof jsts.geom.Coordinate) {
    return this.containsCoordinate(arguments[0]);
  } else {
    return this.containsValues(arguments[0], arguments[1]);
  }
};


/**
 * Tests if the <code>Envelope other</code> lies wholely inside this
 * <code>Envelope</code> (inclusive of the boundary).
 * <p>
 * Note that this is <b>not</b> the same definition as the SFS
 * <tt>contains</tt>, which would exclude the envelope boundary.
 *
 * @param {jsts.geom.Envelope}
 *          other the <code>Envelope</code> to check.
 * @return {boolean} true if <code>other</code> is contained in this
 *         <code>Envelope.</code>
 *
 * @see covers(Envelope)
 */
jsts.geom.Envelope.prototype.containsEnvelope = function(other) {
  return this.coversEnvelope(other);
};


/**
 * Tests if the given point lies in or on the envelope.
 * <p>
 * Note that this is <b>not</b> the same definition as the SFS
 * <tt>contains</tt>, which would exclude the envelope boundary.
 *
 * @param {jsts.geom.Coordinate}
 *          p the point which this <code>Envelope</code> is being checked for
 *          containing.
 * @return {boolean} <code>true</code> if the point lies in the interior or on
 *         the boundary of this <code>Envelope</code>.
 *
 * @see covers(Coordinate)
 */
jsts.geom.Envelope.prototype.containsCoordinate = function(p) {
  return this.coversCoordinate(p);
};


/**
 * Tests if the given point lies in or on the envelope.
 * <p>
 * Note that this is <b>not</b> the same definition as the SFS
 * <tt>contains</tt>, which would exclude the envelope boundary.
 *
 * @param {number}
 *          x the x-coordinate of the point which this <code>Envelope</code>
 *          is being checked for containing.
 * @param {number}
 *          y the y-coordinate of the point which this <code>Envelope</code>
 *          is being checked for containing.
 * @return {boolean} <code>true</code> if <code>(x, y)</code> lies in the
 *         interior or on the boundary of this <code>Envelope</code>.
 *
 * @see covers(double, double)
 */
jsts.geom.Envelope.prototype.containsValues = function(x, y) {
  return this.coversValues(x, y);
};


/**
 * Tests if the given point lies in or on the envelope.
 *
 * Will call appropriate contains* depending on arguments.
 */
jsts.geom.Envelope.prototype.covers = function() {
  if (arguments[0] instanceof jsts.geom.Envelope) {
    return this.coversEnvelope(arguments[0]);
  } else if (arguments[0] instanceof jsts.geom.Coordinate) {
    return this.coversCoordinate(arguments[0]);
  } else {
    return this.coversValues(arguments[0], arguments[1]);
  }
};


/**
 * Tests if the given point lies in or on the envelope.
 *
 * @param {number}
 *          x the x-coordinate of the point which this <code>Envelope</code>
 *          is being checked for containing.
 * @param {number}
 *          y the y-coordinate of the point which this <code>Envelope</code>
 *          is being checked for containing.
 * @return {boolean} <code>true</code> if <code>(x, y)</code> lies in the
 *         interior or on the boundary of this <code>Envelope</code>.
 */
jsts.geom.Envelope.prototype.coversValues = function(x, y) {
  if (this.isNull()) {
    return false;
  }
  return x >= this.minx && x <= this.maxx && y >= this.miny && y <= this.maxy;
};


/**
 * Tests if the given point lies in or on the envelope.
 *
 * @param {jsts.geom.Coordinate}
 *          p the point which this <code>Envelope</code> is being checked for
 *          containing.
 * @return {boolean} <code>true</code> if the point lies in the interior or on
 *         the boundary of this <code>Envelope</code>.
 */
jsts.geom.Envelope.prototype.coversCoordinate = function(p) {
  return this.coversValues(p.x, p.y);
};


/**
 * Tests if the <code>Envelope other</code> lies wholely inside this
 * <code>Envelope</code> (inclusive of the boundary).
 *
 * @param {jsts.geom.Envelope}
 *          other the <code>Envelope</code> to check.
 * @return {boolean} true if this <code>Envelope</code> covers the
 *         <code>other.</code>
 */
jsts.geom.Envelope.prototype.coversEnvelope = function(other) {
  if (this.isNull() || other.isNull()) {
    return false;
  }
  return other.minx >= this.minx && other.maxx <= this.maxx &&
      other.miny >= this.miny && other.maxy <= this.maxy;
};


/**
 * Computes the distance between this and another <code>Envelope</code>.
 *
 * @param {jsts.geom.Envelope}
 *          env The <code>Envelope</code> to test this <code>Envelope</code>
 *          against.
 * @return {number} The distance between overlapping Envelopes is 0. Otherwise,
 *         the distance is the Euclidean distance between the closest points.
 */
jsts.geom.Envelope.prototype.distance = function(env) {
  if (this.intersects(env)) {
    return 0;
  }
  var dx = 0.0;
  if (this.maxx < env.minx) {
    dx = env.minx - this.maxx;
  }
  if (this.minx > env.maxx) {
    dx = this.minx - env.maxx;
  }

  var dy = 0.0;
  if (this.maxy < env.miny) {
    dy = env.miny - this.maxy;
  }
  if (this.miny > env.maxy) {
    dy = this.miny - env.maxy;
  }

  // if either is zero, the envelopes overlap either vertically or horizontally
  if (dx === 0.0) {
    return dy;
  }
  if (dy === 0.0) {
    return dx;
  }
  return Math.sqrt(dx * dx + dy * dy);
};


/**
 * @param {jsts.geom.Envelope}
 *          other the <code>Envelope</code> to check against.
 * @return {boolean} true if envelopes are equal.
 */
jsts.geom.Envelope.prototype.equals = function(other) {
  if (this.isNull()) {
    return other.isNull();
  }
  return this.maxx === other.maxx && this.maxy === other.maxy &&
      this.minx === other.minx && this.miny === other.miny;
};


/**
 * @return {string} String representation of this <code>Envelope.</code>
 */
jsts.geom.Envelope.prototype.toString = function() {
  return 'Env[' + this.minx + ' : ' + this.maxx + ', ' + this.miny + ' : ' +
      this.maxy + ']';
};


/**
 * Test the point q to see whether it intersects the Envelope defined by p1-p2
 *
 * NOTE: calls intersectsEnvelope if four arguments are given to simulate
 * overloaded function
 *
 * @param {jsts.geom.Coordinate}
 *          p1 one extremal point of the envelope.
 * @param {jsts.geom.Coordinate}
 *          p2 another extremal point of the envelope.
 * @param {jsts.geom.Coordinate}
 *          q the point to test for intersection.
 * @return {boolean} <code>true</code> if q intersects the envelope p1-p2.
 */
jsts.geom.Envelope.intersects = function(p1, p2, q) {
  if (arguments.length === 4) {
    return jsts.geom.Envelope.intersectsEnvelope(arguments[0], arguments[1],
        arguments[2], arguments[3]);
  }

  var xc1 = p1.x < p2.x ? p1.x : p2.x;
  var xc2 = p1.x > p2.x ? p1.x : p2.x;
  var yc1 = p1.y < p2.y ? p1.y : p2.y;
  var yc2 = p1.y > p2.y ? p1.y : p2.y;

  if (((q.x >= xc1) && (q.x <= xc2)) && ((q.y >= yc1) && (q.y <= yc2))) {
    return true;
  }
  return false;
};


/**
 * Test the envelope defined by p1-p2 for intersection with the envelope defined
 * by q1-q2
 *
 * @param {jsts.geom.Coordinate}
 *          p1 one extremal point of the envelope P.
 * @param {jsts.geom.Coordinate}
 *          p2 another extremal point of the envelope P.
 * @param {jsts.geom.Coordinate}
 *          q1 one extremal point of the envelope Q.
 * @param {jsts.geom.Coordinate}
 *          q2 another extremal point of the envelope Q.
 * @return {boolean} <code>true</code> if Q intersects P.
 */
jsts.geom.Envelope.intersectsEnvelope = function(p1, p2, q1, q2) {
  var minq = Math.min(q1.x, q2.x);
  var maxq = Math.max(q1.x, q2.x);
  var minp = Math.min(p1.x, p2.x);
  var maxp = Math.max(p1.x, p2.x);

  if (minp > maxq) {
    return false;
  }
  if (maxp < minq) {
    return false;
  }

  minq = Math.min(q1.y, q2.y);
  maxq = Math.max(q1.y, q2.y);
  minp = Math.min(p1.y, p2.y);
  maxp = Math.max(p1.y, p2.y);

  if (minp > maxq) {
    return false;
  }
  if (maxp < minq) {
    return false;
  }
  return true;
};


/**
 * @return {jsts.geom.Envelope} A new instance copied from this.
 */
jsts.geom.Envelope.prototype.clone = function() {
  return new jsts.geom.Envelope(this.minx, this.maxx, this.miny, this.maxy);
};
/* ======================================================================
    jsts/geom/util/GeometryCombiner.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Combines {@link Geometry}s
 * to produce a {@link GeometryCollection} of the most appropriate type.
 * Input geometries which are already collections
 * will have their elements extracted first.
 * No validation of the result geometry is performed.
 * (The only case where invalidity is possible is where {@link Polygonal} geometries
 * are combined and result in a self-intersection).
 *
 * @see GeometryFactory#buildGeometry
 */



/**
 * Creates a new combiner for a collection of geometries
 *
 * @param {Array} geoms the geometries to combine.
 * @constructor
 */
jsts.geom.util.GeometryCombiner = function(geoms) {
  this.geomFactory = jsts.geom.util.GeometryCombiner.extractFactory(geoms);
  this.inputGeoms = geoms;
};


/**
 * Combines a collection of geometries.
 *
 * @param {ArrayList} geoms the geometries to combine.
 * @return {Geometry} the combined geometry.
 * @public
 */
jsts.geom.util.GeometryCombiner.combine = function(geoms) {
  if (arguments.length>1) return this.combine2.apply(this, arguments);
  var combiner = new jsts.geom.util.GeometryCombiner(geoms);
  return combiner.combine();
};


/**
 * Combines two or three geometries.
 *
 * @param {Geometry} g0 a geometry to combine.
 * @param {Geometry} g1 a geometry to combine.
 * @param {Geometry=} [g2] a geometry to combine.
 * @return {Geometry} the combined geometry.
 * @public
 */
jsts.geom.util.GeometryCombiner.combine2 = function() {
  var arrayList = new javascript.util.ArrayList();
  Array.prototype.slice.call(arguments).forEach(function(a) {
    arrayList.add(a);
  });
  var combiner = new jsts.geom.util.GeometryCombiner(arrayList);
  return combiner.combine();
};


/**
 * @type {GeometryFactory}
 * @private
 */
jsts.geom.util.GeometryCombiner.prototype.geomFactory = null;


/**
 * @type {boolean}
 * @private
 */
jsts.geom.util.GeometryCombiner.prototype.skipEmpty = false;


/**
 * @type {Array}
 * @private
 */
jsts.geom.util.GeometryCombiner.prototype.inputGeoms;


/**
 * Extracts the GeometryFactory used by the geometries in a collection
 *
 * @param {Array} geoms
 * @return {jsts.geom.GeometryFactory} a GeometryFactory.
 * @public
 */
jsts.geom.util.GeometryCombiner.extractFactory = function(geoms) {
  if (geoms.isEmpty()) return null;
  return geoms.iterator().next().getFactory();
};


/**
 * Computes the combination of the input geometries
 * to produce the most appropriate {@link Geometry} or {@link GeometryCollection}
 *
 * @return {jsts.geom.Geometry} a Geometry which is the combination of the inputs.
 * @public
 */
jsts.geom.util.GeometryCombiner.prototype.combine = function() {
    var elems = new javascript.util.ArrayList(), i;
  	for (i = this.inputGeoms.iterator(); i.hasNext(); ) {
        var g = i.next();
        this.extractElements(g, elems);
  	}
    
    if (elems.size() === 0) {
    	if (this.geomFactory !== null) {
            // return an empty GC
            return this.geomFactory.createGeometryCollection(null);
    	}
    	return null;
    }
    // return the "simplest possible" geometry
    return this.geomFactory.buildGeometry(elems);
};


/**
 * @param {jsts.geom.Geometry} geom
 * @param {Array} elems
 * @private
 */
jsts.geom.util.GeometryCombiner.prototype.extractElements = function(geom, elems) {
  if (geom === null) {
    return;
  }

  for (var i = 0; i < geom.getNumGeometries(); i++) {
    var elemGeom = geom.getGeometryN(i);
    if (this.skipEmpty && elemGeom.isEmpty()) {
      continue;
    }
    elems.add(elemGeom);
  }
};
/* ======================================================================
    jsts/geom/PrecisionModel.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * Specifies the precision model of the {@link Coordinate}s in a
 * {@link Geometry}. In other words, specifies the grid of allowable points for
 * all <code>Geometry</code>s.
 * <p>
 * The {@link makePrecise} method allows rounding a coordinate to a "precise"
 * value; that is, one whose precision is known exactly.
 * <p>
 * Coordinates are assumed to be precise in geometries. That is, the coordinates
 * are assumed to be rounded to the precision model given for the geometry. JTS
 * input routines automatically round coordinates to the precision model before
 * creating Geometries. All internal operations assume that coordinates are
 * rounded to the precision model. Constructive methods (such as boolean
 * operations) always round computed coordinates to the appropriate precision
 * model.
 * <p>
 * Currently one type of precision model are supported:
 * <ul>
 * <li>FLOATING - represents full double precision floating point.
 * <p>
 * Coordinates are represented internally as Java double-precision values. Since
 * Java uses the IEEE-754 floating point standard, this provides 53 bits of
 * precision.
 * <p>
 * JSTS methods currently do not handle inputs with different precision models.
 *
 * @constructor
 */
jsts.geom.PrecisionModel = function(modelType) {
  if (typeof modelType === 'number') {
    this.modelType = jsts.geom.PrecisionModel.FIXED;
    this.scale = modelType;
    return;
  }

  this.modelType = modelType || jsts.geom.PrecisionModel.FLOATING;

  if (this.modelType === jsts.geom.PrecisionModel.FIXED) {
    this.scale = 1.0;
  }
};


/**
 * @type {string}
 */
jsts.geom.PrecisionModel.FLOATING = 'FLOATING';


/**
 * @type {string}
 */
jsts.geom.PrecisionModel.FIXED = 'FIXED';


/**
 * @type {string}
 */
jsts.geom.PrecisionModel.FLOATING_SINGLE = 'FLOATING_SINGLE';

jsts.geom.PrecisionModel.prototype.scale = null;
jsts.geom.PrecisionModel.prototype.modelType = null;


/**
 * Tests whether the precision model supports floating point
 *
 * @return {boolean} if the precision model supports floating point.
 */
jsts.geom.PrecisionModel.prototype.isFloating = function() {
  return this.modelType === jsts.geom.PrecisionModel.FLOATING ||
      this.modelType === jsts.geom.PrecisionModel.FLOATING_SINLGE;
};

/**
 * Returns the scale factor used to specify a fixed precision model. The number
 * of decimal places of precision is equal to the base-10 logarithm of the scale
 * factor. Non-integral and negative scale factors are supported. Negative scale
 * factors indicate that the places of precision is to the left of the decimal
 * point.
 *
 * @return the scale factor for the fixed precision model.
 */
jsts.geom.PrecisionModel.prototype.getScale = function() {
  return this.scale;
};

/**
 * @return {string} always jsts.geom.PrecisionModel.FLOATING.
 */
jsts.geom.PrecisionModel.prototype.getType = function() {
  return this.modelType;
};

jsts.geom.PrecisionModel.prototype.equals = function(other) {
  return true;

  if (!(other instanceof jsts.geom.PrecisionModel)) {
    return false;
  }
  var otherPrecisionModel = other;
  return this.modelType === otherPrecisionModel.modelType &&
      this.scale === otherPrecisionModel.scale;
};


/**
 * Rounds a numeric value to the PrecisionModel grid. Asymmetric Arithmetic
 * Rounding is used, to provide uniform rounding behaviour no matter where the
 * number is on the number line.
 * <p>
 * This method has no effect on NaN values.
 * <p>
 * <b>Note:</b> Java's <code>Math#rint</code> uses the "Banker's Rounding"
 * algorithm, which is not suitable for precision operations elsewhere in JTS.
 */
jsts.geom.PrecisionModel.prototype.makePrecise = function(val) {
  if (val instanceof jsts.geom.Coordinate) {
    this.makePrecise2(val);
    return;
  }

  // don't change NaN values
  if (isNaN(val))
    return val;

  // TODO: support single precision?
  /*if (this.modelType == FLOATING_SINGLE) {
    float floatSingleVal = (float) val;
    return (double) floatSingleVal;
  }*/
  if (this.modelType === jsts.geom.PrecisionModel.FIXED) {
    return Math.round(val * this.scale) / this.scale;
  }
  // modelType == FLOATING - no rounding necessary
  return val;
};


/**
 * Rounds a Coordinate to the PrecisionModel grid.
 */
jsts.geom.PrecisionModel.prototype.makePrecise2 = function(coord) {
  // optimization for full precision
  if (this.modelType === jsts.geom.PrecisionModel.FLOATING)
    return;

  coord.x = this.makePrecise(coord.x);
  coord.y = this.makePrecise(coord.y);
  // MD says it's OK that we're not makePrecise'ing the z [Jon Aquino]
};


/**
 * Compares this {@link PrecisionModel} object with the specified object for
 * order. A PrecisionModel is greater than another if it provides greater
 * precision. The comparison is based on the value returned by the
 * {@link #getMaximumSignificantDigits} method. This comparison is not strictly
 * accurate when comparing floating precision models to fixed models; however,
 * it is correct when both models are either floating or fixed.
 *
 * @param o
 *          the <code>PrecisionModel</code> with which this
 *          <code>PrecisionModel</code> is being compared.
 * @return a negative integer, zero, or a positive integer as this
 *         <code>PrecisionModel</code> is less than, equal to, or greater than
 *         the specified <code>PrecisionModel.</code>
 */
jsts.geom.PrecisionModel.prototype.compareTo = function(o) {
  var other = o;

  // TODO: needs to be ported for fixed precision

  // var sigDigits = this.getMaximumSignificantDigits();
  // var otherSigDigits = other.getMaximumSignificantDigits();
  // return (new Integer(sigDigits)).compareTo(new Integer(otherSigDigits));

  return 0;
};
/* ======================================================================
    jsts/geom/CoordinateFilter.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */


/**
 * <code>Geometry</code> classes support the concept of applying a coordinate
 * filter to every coordinate in the <code>Geometry</code>. A coordinate
 * filter can either record information about each coordinate or change the
 * coordinate in some way. Coordinate filters implement the interface
 * <code>CoordinateFilter</code>. (<code>CoordinateFilter</code> is an
 * example of the Gang-of-Four Visitor pattern). Coordinate filters can be used
 * to implement such things as coordinate transformations, centroid and envelope
 * computation, and many other functions.
 *
 * @interface
 */
jsts.geom.CoordinateFilter = function() {};
/**
 * Performs an operation with or on <code>coord</code>.
 *
 * @param coord
 *          a <code>Coordinate</code> to which the filter is applied.
 */
jsts.geom.CoordinateFilter.prototype.filter = function(coord) {
  throw new jsts.error.AbstractMethodInvocationError();
};
/* ======================================================================
    jsts/simplify/DouglasPeuckerLineSimplifier.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Simplifies a linestring (sequence of points) using
 * the standard Douglas-Peucker algorithm.
 * @constructor
 * 
 * @param {jsts.geom.Coordinate}
 *          pts 
 */
jsts.simplify.DouglasPeuckerLineSimplifier = function(
    pts) {
  this.pts = pts;
  this.seg = new jsts.geom.LineSegment();
};

/**
 * @type {jsts.geom.Coordinate[]} 
 */
jsts.simplify.DouglasPeuckerLineSimplifier.prototype.pts = null;

/**
 * @type {boolean[]}
 */
jsts.simplify.DouglasPeuckerLineSimplifier.prototype.usePt = null;

/**
 * @type {double} 
 */
jsts.simplify.DouglasPeuckerLineSimplifier.prototype.distanceTolerance = null;

/**
 * @param {jsts.geom.Coordinate[]}
 *          pts
 * @param {double}
 *          distanceTolerance
 * @return {jsts.geom.Coordinate[]} 
 */
jsts.simplify.DouglasPeuckerLineSimplifier.simplify = function(
    pts, distanceTolerance) {
  var simp = new jsts.simplify.DouglasPeuckerLineSimplifier(pts);
  simp.setDistanceTolerance(distanceTolerance);
  return simp.simplify();
};

/**
 * Set the distance tolerance for the simplification.
 * All vertices in the simplified linestring will be within this
 * distance of the original linestring.
 * @param {double}
 *          distanceTolerance 
 */
jsts.simplify.DouglasPeuckerLineSimplifier.prototype.setDistanceTolerance = function(
    distanceTolerance) {
  this.distanceTolerance = distanceTolerance;
};

/**
 * @return {jsts.geom.Coordinate[]} 
 */
jsts.simplify.DouglasPeuckerLineSimplifier.prototype.simplify = function() {
  this.usePt = [];
  for (var i = 0; i < this.pts.length; i++) {
    this.usePt[i] = true;
  }
  this.simplifySection(0, this.pts.length - 1);
  var coordList = new jsts.geom.CoordinateList();
  for (var j = 0; j < this.pts.length; j++) {
    if (this.usePt[j]) {
      coordList.add(new jsts.geom.Coordinate(this.pts[j]));
    }
  }
  return coordList.toCoordinateArray();
};

/**
 * @type {jsts.geom.LineSegment}
 */
jsts.simplify.DouglasPeuckerLineSimplifier.prototype.seg = null;

/**
 * @param {int}
 *          i
 * @param {int}
 *          j 
 */
jsts.simplify.DouglasPeuckerLineSimplifier.prototype.simplifySection = function(
    i, j) {
  if (i+1 == j) {
    return;
  }
  this.seg.p0 = this.pts[i];
  this.seg.p1 = this.pts[j];
  var maxDistance = -1.0;
  var maxIndex = i;
  for (var k = i + 1; k < j; k++) {
    var distance = this.seg.distance(this.pts[k]);
    if (distance > maxDistance) {
      maxDistance = distance;
      maxIndex = k;
    }
  }
  if (maxDistance <= this.distanceTolerance) {
    for (var l = i + 1; l < j; l++) {
      this.usePt[l] = false;
    }
  } else {
    this.simplifySection(i, maxIndex);
    this.simplifySection(maxIndex, j);
  }
};
/* ======================================================================
    jsts/geomgraph/EdgeIntersection.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * @param {Coordinate}
 *          coord
 * @param {int}
 *          segmentIndex
 * @param {double}
 *          dist
 * @constructor
 */
jsts.geomgraph.EdgeIntersection = function(coord, segmentIndex, dist) {
  this.coord = new jsts.geom.Coordinate(coord);
  this.segmentIndex = segmentIndex;
  this.dist = dist;
};


/**
 * the point of intersection
 *
 * @type {Coordinate}
 */
jsts.geomgraph.EdgeIntersection.prototype.coord = null;


/**
 * the index of the containing line segment in the parent edge
 *
 * @type {int}
 */
jsts.geomgraph.EdgeIntersection.prototype.segmentIndex = null;


/**
 * the edge distance of this point along the containing line segment
 *
 * @type {double}
 */
jsts.geomgraph.EdgeIntersection.prototype.dist = null;


/**
 * @return {Coordinate}
 */
jsts.geomgraph.EdgeIntersection.prototype.getCoordinate = function() {
  return this.coord;
};


/**
 * @return {int}
 */
jsts.geomgraph.EdgeIntersection.prototype.getSegmentIndex = function() {
  return this.segmentIndex;
};


/**
 * @return {double}
 */
jsts.geomgraph.EdgeIntersection.prototype.getDistance = function() {
  return this.dist;
};


/**
 * @param {EdgeIntersection}
 *          other
 * @return {int}
 */
jsts.geomgraph.EdgeIntersection.prototype.compareTo = function(other) {
  return this.compare(other.segmentIndex, other.dist);
};


/**
 * @param {int}
 *          segmentIndex
 * @param {double}
 *          dist
 * @return {int} -1 this EdgeIntersection is located before the argument
 *         location.
 * @return {int} 0 this EdgeIntersection is at the argument location.
 * @return {int} 1 this EdgeIntersection is located after the argument location.
 */
jsts.geomgraph.EdgeIntersection.prototype.compare = function(segmentIndex, dist) {
  if (this.segmentIndex < segmentIndex)
    return -1;
  if (this.segmentIndex > segmentIndex)
    return 1;
  if (this.dist < dist)
    return -1;
  if (this.dist > dist)
    return 1;
  return 0;
};


/**
 * @param {int}
 *          maxSegmentIndex
 * @return {boolean}
 */
jsts.geomgraph.EdgeIntersection.prototype.isEndPoint = function(maxSegmentIndex) {
  if (this.segmentIndex === 0 && this.dist === 0.0)
    return true;
  if (this.segmentIndex === maxSegmentIndex)
    return true;
  return false;
};

jsts.geomgraph.EdgeIntersection.prototype.toString = function() {
  return '' + this.segmentIndex + this.dist;
};

/* ======================================================================
    jsts/geomgraph/EdgeIntersectionList.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * @requires jsts/geomgraph/EdgeIntersection.js
   */

  var EdgeIntersection = jsts.geomgraph.EdgeIntersection;
  var TreeMap = javascript.util.TreeMap;

  /**
   * @constructor
   * @name jsts.geomgraph.EdgeIntersectionList
   */
  jsts.geomgraph.EdgeIntersectionList = function(edge) {
    this.nodeMap = new TreeMap();
    this.edge = edge;
  };



  /**
   * @type {javascript.util.Map}
   * @private
   */
  jsts.geomgraph.EdgeIntersectionList.prototype.nodeMap = null;


  /**
   * the parent edge
   *
   * @type {Edge}
   */
  jsts.geomgraph.EdgeIntersectionList.prototype.edge = null;

  jsts.geomgraph.EdgeIntersectionList.prototype.isIntersection = function(pt) {
    for (var it = this.iterator(); it.hasNext(); ) {
      var ei = it.next();
      if (ei.coord.equals(pt)) {
       return true;
      }
    }
    return false;
  };


  /**
   * Adds an intersection into the list, if it isn't already there. The input
   * segmentIndex and dist are expected to be normalized.
   *
   * @param {Coordinate}
   *          intPt
   * @param {int}
   *          segmentIndex
   * @param {double}
   *          dist
   * @return {EdgeIntersection} the EdgeIntersection found or added.
   */
  jsts.geomgraph.EdgeIntersectionList.prototype.add = function(intPt, segmentIndex, dist) {
    var eiNew = new EdgeIntersection(intPt, segmentIndex, dist);
    var ei = this.nodeMap.get(eiNew);
    if (ei !== null) {
      return ei;
    }
    this.nodeMap.put(eiNew, eiNew);
    return eiNew;
  };

  /**
   * Returns an iterator of {@link EdgeIntersection}s
   *
   * @return an Iterator of EdgeIntersections.
   */
  jsts.geomgraph.EdgeIntersectionList.prototype.iterator = function() {
    return this.nodeMap.values().iterator();
  };


  /**
   * Adds entries for the first and last points of the edge to the list
   */
  jsts.geomgraph.EdgeIntersectionList.prototype.addEndpoints = function() {
    var maxSegIndex = this.edge.pts.length - 1;
    this.add(this.edge.pts[0], 0, 0.0);
    this.add(this.edge.pts[maxSegIndex], maxSegIndex, 0.0);
  };

  /**
   * Creates new edges for all the edges that the intersections in this
   * list split the parent edge into.
   * Adds the edges to the input list (this is so a single list
   * can be used to accumulate all split edges for a Geometry).
   *
   * @param edgeList a list of EdgeIntersections.
   */
  jsts.geomgraph.EdgeIntersectionList.prototype.addSplitEdges = function(edgeList)
  {
    // ensure that the list has entries for the first and last point of the edge
    this.addEndpoints();

    var it = this.iterator();
    // there should always be at least two entries in the list
    var eiPrev = it.next();
    while (it.hasNext()) {
      var ei = it.next();
      var newEdge = this.createSplitEdge(eiPrev, ei);
      edgeList.add(newEdge);

      eiPrev = ei;
    }
  };
  /**
   * Create a new "split edge" with the section of points between
   * (and including) the two intersections.
   * The label for the new edge is the same as the label for the parent edge.
   */
  jsts.geomgraph.EdgeIntersectionList.prototype.createSplitEdge = function(ei0,  ei1)  {
    var npts = ei1.segmentIndex - ei0.segmentIndex + 2;

    var lastSegStartPt = this.edge.pts[ei1.segmentIndex];
    // if the last intersection point is not equal to the its segment start pt,
    // add it to the points list as well.
    // (This check is needed because the distance metric is not totally reliable!)
    // The check for point equality is 2D only - Z values are ignored
    var useIntPt1 = ei1.dist > 0.0 || ! ei1.coord.equals2D(lastSegStartPt);
    if (! useIntPt1) {
      npts--;
    }

    var pts = [];
    var ipt = 0;
    pts[ipt++] = new jsts.geom.Coordinate(ei0.coord);
    for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {
      pts[ipt++] = this.edge.pts[i];
    }
    if (useIntPt1) pts[ipt] = ei1.coord;
    return new jsts.geomgraph.Edge(pts, new jsts.geomgraph.Label(this.edge.label));
  };

})();

/* ======================================================================
    jsts/util/AssertionFailedException.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * Thrown when the application is in an inconsistent state. Indicates a
   * problem with the code.
   *
   * @constructor
   */
  var AssertionFailedException = function(message) {
    this.message = message;
  };
  AssertionFailedException.prototype = new Error();
  AssertionFailedException.prototype.name = 'AssertionFailedException';

  jsts.util.AssertionFailedException = AssertionFailedException;

})();
/* ======================================================================
    jsts/util/Assert.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * @requires jsts/util/AssertionFailedException.js
   */

  var AssertionFailedException = jsts.util.AssertionFailedException;

  /**
   * A utility for making programming assertions.
   *
   * @constructor
   * @name jsts.util.Assert
   */
  jsts.util.Assert = function() {};

  /**
   * Throws an <code>AssertionFailedException</code> with the given message if
   * the given assertion is not true.
   *
   * @param {boolean}
   *          assertion a condition that is supposed to be true.
   * @param {String=}
   *          message a description of the assertion.
   * @throws AssertionFailedException
   *           if the condition is false
   */
  jsts.util.Assert.isTrue = function(assertion, message) {
    if (!assertion) {
      if (message === null) {
        throw new AssertionFailedException();
      } else {
        throw new AssertionFailedException(message);
      }
    }
  };

  /**
   * Throws an <code>AssertionFailedException</code> with the given message if
   * the given objects are not equal, according to the <code>equals</code>
   * method.
   *
   * @param expectedValue
   *          the correct value.
   * @param actualValue
   *          the value being checked.
   * @param {string=}
   *          message a description of the assertion.
   * @throws AssertionFailedException
   *           if the two objects are not equal
   */
  jsts.util.Assert.equals = function(expectedValue, actualValue, message) {
    if (!actualValue.equals(expectedValue)) {
      throw new AssertionFailedException('Expected ' + expectedValue +
          ' but encountered ' + actualValue +
          (message != null ? ': ' + message : ''));
    }
  };

  /**
   * Always throws an <code>AssertionFailedException</code> with the given
   * message.
   *
   * @param {string=}
   *          message a description of the assertion.
   * @throws AssertionFailedException
   *           thrown always
   */
  jsts.util.Assert.shouldNeverReachHere = function(message) {
    throw new AssertionFailedException('Should never reach here' +
        (message != null ? ': ' + message : ''));
  };

})();
/* ======================================================================
    jsts/operation/relate/RelateComputer.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * @requires jsts/geom/Location.js
   * @requires jsts/util/Assert.js
   */

  var Location = jsts.geom.Location;
  var Assert = jsts.util.Assert;
  var ArrayList = javascript.util.ArrayList;


  /**
   * Computes the topological relationship between two Geometries.
   * <p>
   * RelateComputer does not need to build a complete graph structure to compute
   * the IntersectionMatrix. The relationship between the geometries can be
   * computed by simply examining the labelling of edges incident on each node.
   * <p>
   * RelateComputer does not currently support arbitrary GeometryCollections.
   * This is because GeometryCollections can contain overlapping Polygons. In
   * order to correct compute relate on overlapping Polygons, they would first
   * need to be noded and merged (if not explicitly, at least implicitly).
   *
   * @constructor
   */
  jsts.operation.relate.RelateComputer = function(arg) {
    this.li = new jsts.algorithm.RobustLineIntersector();
    this.ptLocator = new jsts.algorithm.PointLocator();
    this.nodes = new jsts.geomgraph.NodeMap(
        new jsts.operation.relate.RelateNodeFactory());
    this.isolatedEdges = new ArrayList();

    this.arg = arg;
  };


  /**
   * @type {LineIntersector}
   * @private
   */
  jsts.operation.relate.RelateComputer.prototype.li = null;


  /**
   * @type {PointLocator}
   * @private
   */
  jsts.operation.relate.RelateComputer.prototype.ptLocator = null;


  /**
   * the arg(s) of the operation
   *
   * @type {GeometryGraph[]}
   * @private
   */
  jsts.operation.relate.RelateComputer.prototype.arg = null;


  /**
   * @type {NodeMap}
   * @private
   */
  jsts.operation.relate.RelateComputer.prototype.nodes = null;


  /**
   * this intersection matrix will hold the results compute for the relate
   *
   * @type {IntersectionMatrix}
   * @private
   */
  jsts.operation.relate.RelateComputer.prototype.im = null;


  /**
   * @type {javascript.util.ArrayList}
   * @private
   */
  jsts.operation.relate.RelateComputer.prototype.isolatedEdges = null;


  /**
   * the intersection point found (if any)
   *
   * @type {Coordinate}
   * @private
   */
  jsts.operation.relate.RelateComputer.prototype.invalidPoint = null;


  jsts.operation.relate.RelateComputer.prototype.computeIM = function() {
    var im = new jsts.geom.IntersectionMatrix();
    // since Geometries are finite and embedded in a 2-D space, the EE element
    // must always be 2
    im.set(Location.EXTERIOR, Location.EXTERIOR, 2);

    // if the Geometries don't overlap there is nothing to do
    if (!this.arg[0].getGeometry().getEnvelopeInternal().intersects(
        this.arg[1].getGeometry().getEnvelopeInternal())) {
      this.computeDisjointIM(im);
      return im;
    }
    this.arg[0].computeSelfNodes(this.li, false);
    this.arg[1].computeSelfNodes(this.li, false);

    // compute intersections between edges of the two input geometries
    var intersector = this.arg[0].computeEdgeIntersections(this.arg[1],
        this.li, false);
    // System.out.println("computeIM: # segment intersection tests: " +
    // intersector.numTests);
    this.computeIntersectionNodes(0);
    this.computeIntersectionNodes(1);
    /**
     * Copy the labelling for the nodes in the parent Geometries. These override
     * any labels determined by intersections between the geometries.
     */
    this.copyNodesAndLabels(0);
    this.copyNodesAndLabels(1);

    // complete the labelling for any nodes which only have a label for a single
    // geometry
    this.labelIsolatedNodes();

    // If a proper intersection was found, we can set a lower bound on the IM.
    this.computeProperIntersectionIM(intersector, im);

    /**
     * Now process improper intersections (eg where one or other of the
     * geometries has a vertex at the intersection point) We need to compute the
     * edge graph at all nodes to determine the IM.
     */

    // build EdgeEnds for all intersections
    var eeBuilder = new jsts.operation.relate.EdgeEndBuilder();
    var ee0 = eeBuilder.computeEdgeEnds(this.arg[0].getEdgeIterator());
    this.insertEdgeEnds(ee0);
    var ee1 = eeBuilder.computeEdgeEnds(this.arg[1].getEdgeIterator());
    this.insertEdgeEnds(ee1);

    this.labelNodeEdges();

    /**
     * Compute the labeling for isolated components <br>
     * Isolated components are components that do not touch any other components
     * in the graph. They can be identified by the fact that they will contain
     * labels containing ONLY a single element, the one for their parent
     * geometry. We only need to check components contained in the input graphs,
     * since isolated components will not have been replaced by new components
     * formed by intersections.
     */
    this.labelIsolatedEdges(0, 1);
    this.labelIsolatedEdges(1, 0);

    // update the IM from all components
    this.updateIM(im);
    return im;
  };


  /**
   * @private
   */
  jsts.operation.relate.RelateComputer.prototype.insertEdgeEnds = function(ee) {
    for (var i = ee.iterator(); i.hasNext();) {
      var e = i.next();
      this.nodes.add(e);
    }
  };


  /**
   * @param {jsts.geom.IntersectionMatrix}
   *          im
   * @private
   */
  jsts.operation.relate.RelateComputer.prototype.computeProperIntersectionIM = function(
      intersector, im) {
    // If a proper intersection is found, we can set a lower bound on the IM.
    var dimA = this.arg[0].getGeometry().getDimension();
    var dimB = this.arg[1].getGeometry().getDimension();
    var hasProper = intersector.hasProperIntersection();
    var hasProperInterior = intersector.hasProperInteriorIntersection();

    // For Geometry's of dim 0 there can never be proper intersections.

    /**
     * If edge segments of Areas properly intersect, the areas must properly
     * overlap.
     */
    if (dimA === 2 && dimB === 2) {
      if (hasProper)
        im.setAtLeast('212101212');
    }
    /**
     * If an Line segment properly intersects an edge segment of an Area, it
     * follows that the Interior of the Line intersects the Boundary of the
     * Area. If the intersection is a proper <i>interior</i> intersection, then
     * there is an Interior-Interior intersection too. Note that it does not
     * follow that the Interior of the Line intersects the Exterior of the Area,
     * since there may be another Area component which contains the rest of the
     * Line.
     */
    else if (dimA === 2 && dimB === 1) {
      if (hasProper)
        im.setAtLeast('FFF0FFFF2');
      if (hasProperInterior)
        im.setAtLeast('1FFFFF1FF');
    } else if (dimA === 1 && dimB === 2) {
      if (hasProper)
        im.setAtLeast('F0FFFFFF2');
      if (hasProperInterior)
        im.setAtLeast('1F1FFFFFF');
    }
    /* If edges of LineStrings properly intersect *in an interior point*, all
            we can deduce is that
            the interiors intersect.  (We can NOT deduce that the exteriors intersect,
            since some other segments in the geometries might cover the points in the
            neighbourhood of the intersection.)
            It is important that the point be known to be an interior point of
            both Geometries, since it is possible in a self-intersecting geometry to
            have a proper intersection on one segment that is also a boundary point of another segment.
        */
    else if (dimA === 1 && dimB === 1) {
      if (hasProperInterior)
        im.setAtLeast('0FFFFFFFF');
    }
  };


  /**
   * Copy all nodes from an arg geometry into this graph. The node label in the
   * arg geometry overrides any previously computed label for that argIndex.
   * (E.g. a node may be an intersection node with a computed label of BOUNDARY,
   * but in the original arg Geometry it is actually in the interior due to the
   * Boundary Determination Rule)
   *
   * @private
   */
  jsts.operation.relate.RelateComputer.prototype.copyNodesAndLabels = function(
      argIndex) {
    for (var i = this.arg[argIndex].getNodeIterator(); i.hasNext();) {
      var graphNode = i.next();
      var newNode = this.nodes.addNode(graphNode.getCoordinate());
      newNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));
    }
  };


  /**
   * Insert nodes for all intersections on the edges of a Geometry. Label the
   * created nodes the same as the edge label if they do not already have a
   * label. This allows nodes created by either self-intersections or mutual
   * intersections to be labelled. Endpoint nodes will already be labelled from
   * when they were inserted.
   *
   * @private
   */
  jsts.operation.relate.RelateComputer.prototype.computeIntersectionNodes = function(
      argIndex) {
    for (var i = this.arg[argIndex].getEdgeIterator(); i.hasNext();) {
      var e = i.next();
      var eLoc = e.getLabel().getLocation(argIndex);
      for (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext();) {
        var ei = eiIt.next();
        var n = this.nodes.addNode(ei.coord);
        if (eLoc === Location.BOUNDARY)
          n.setLabelBoundary(argIndex);
        else {
          if (n.getLabel().isNull(argIndex))
            n.setLabel(argIndex, Location.INTERIOR);
        }
      }
    }
  };


  /**
   * For all intersections on the edges of a Geometry, label the corresponding
   * node IF it doesn't already have a label. This allows nodes created by
   * either self-intersections or mutual intersections to be labelled. Endpoint
   * nodes will already be labelled from when they were inserted.
   *
   * @private
   */
  jsts.operation.relate.RelateComputer.prototype.labelIntersectionNodes = function(
      argIndex) {
    for (var i = this.arg[argIndex].getEdgeIterator(); i.hasNext();) {
      var e = i.next();
      var eLoc = e.getLabel().getLocation(argIndex);
      for (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext();) {
        var ei = eiIt.next();
        var n = this.nodes.find(ei.coord);
        if (n.getLabel().isNull(argIndex)) {
          if (eLoc === Location.BOUNDARY)
            n.setLabelBoundary(argIndex);
          else
            n.setLabel(argIndex, Location.INTERIOR);
        }
      }
    }
  };


  /**
   * If the Geometries are disjoint, we need to enter their dimension and
   * boundary dimension in the Ext rows in the IM
   *
   * @private
   */
  jsts.operation.relate.RelateComputer.prototype.computeDisjointIM = function(
      im) {
    var ga = this.arg[0].getGeometry();
    if (!ga.isEmpty()) {
      im.set(Location.INTERIOR, Location.EXTERIOR, ga.getDimension());
      im.set(Location.BOUNDARY, Location.EXTERIOR, ga.getBoundaryDimension());
    }
    var gb = this.arg[1].getGeometry();
    if (!gb.isEmpty()) {
      im.set(Location.EXTERIOR, Location.INTERIOR, gb.getDimension());
      im.set(Location.EXTERIOR, Location.BOUNDARY, gb.getBoundaryDimension());
    }
  };


  /**
   * @private
   */
  jsts.operation.relate.RelateComputer.prototype.labelNodeEdges = function() {
    for (var ni = this.nodes.iterator(); ni.hasNext();) {
      var node = ni.next();
      node.getEdges().computeLabelling(this.arg);
    }
  };


  /**
   * update the IM with the sum of the IMs for each component
   *
   * @private
   */
  jsts.operation.relate.RelateComputer.prototype.updateIM = function(im) {
    for (var ei = this.isolatedEdges.iterator(); ei.hasNext();) {
      var e = ei.next();
      e.updateIM(im);
    }
    for (var ni = this.nodes.iterator(); ni.hasNext();) {
      var node = ni.next();
      node.updateIM(im);
      node.updateIMFromEdges(im);
    }
  };


  /**
   * Processes isolated edges by computing their labelling and adding them to
   * the isolated edges list. Isolated edges are guaranteed not to touch the
   * boundary of the target (since if they did, they would have caused an
   * intersection to be computed and hence would not be isolated)
   *
   * @private
   */
  jsts.operation.relate.RelateComputer.prototype.labelIsolatedEdges = function(
      thisIndex, targetIndex) {
    for (var ei = this.arg[thisIndex].getEdgeIterator(); ei.hasNext();) {
      var e = ei.next();
      if (e.isIsolated()) {
        this.labelIsolatedEdge(e, targetIndex, this.arg[targetIndex]
            .getGeometry());
        this.isolatedEdges.add(e);
      }
    }
  };


  /**
   * Label an isolated edge of a graph with its relationship to the target
   * geometry. If the target has dim 2 or 1, the edge can either be in the
   * interior or the exterior. If the target has dim 0, the edge must be in the
   * exterior
   *
   * @private
   */
  jsts.operation.relate.RelateComputer.prototype.labelIsolatedEdge = function(
      e, targetIndex, target) {
    // this won't work for GeometryCollections with both dim 2 and 1 geoms
    if (target.getDimension() > 0) {
      // since edge is not in boundary, may not need the full generality of
      // PointLocator?
      // Possibly should use ptInArea locator instead? We probably know here
      // that the edge does not touch the bdy of the target Geometry
      var loc = this.ptLocator.locate(e.getCoordinate(), target);
      e.getLabel().setAllLocations(targetIndex, loc);
    } else {
      e.getLabel().setAllLocations(targetIndex, Location.EXTERIOR);
    }
  };


  /**
   * Isolated nodes are nodes whose labels are incomplete (e.g. the location for
   * one Geometry is null). This is the case because nodes in one graph which
   * don't intersect nodes in the other are not completely labelled by the
   * initial process of adding nodes to the nodeList. To complete the labelling
   * we need to check for nodes that lie in the interior of edges, and in the
   * interior of areas.
   *
   * @private
   */
  jsts.operation.relate.RelateComputer.prototype.labelIsolatedNodes = function() {
    for (var ni = this.nodes.iterator(); ni.hasNext();) {
      var n = ni.next();
      var label = n.getLabel();
      // isolated nodes should always have at least one geometry in their label
      Assert
          .isTrue(label.getGeometryCount() > 0, 'node with empty label found');
      if (n.isIsolated()) {
        if (label.isNull(0))
          this.labelIsolatedNode(n, 0);
        else
          this.labelIsolatedNode(n, 1);
      }
    }
  };


  /**
   * Label an isolated node with its relationship to the target geometry.
   */
  jsts.operation.relate.RelateComputer.prototype.labelIsolatedNode = function(
      n, targetIndex) {
    var loc = this.ptLocator.locate(n.getCoordinate(), this.arg[targetIndex]
        .getGeometry());
    n.getLabel().setAllLocations(targetIndex, loc);
  };

})();
/* ======================================================================
    jsts/geomgraph/GraphComponent.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * @requires jsts/util/Assert.js
   */

  var Assert = jsts.util.Assert;

  /**
   * A GraphComponent is the parent class for the objects' that form a graph.
   * Each GraphComponent can carry a Label.
   *
   * @constructor
   */
  jsts.geomgraph.GraphComponent = function(label) {
    this.label = label;
  };


  /**
   * @type {Label}
   * @protected
   */
  jsts.geomgraph.GraphComponent.prototype.label = null;


  /**
   * isInResult indicates if this component has already been included in the
   * result
   *
   * @type {boolean}
   * @private
   */
  jsts.geomgraph.GraphComponent.prototype._isInResult = false;


  /**
   * @type {boolean}
   * @private
   */
  jsts.geomgraph.GraphComponent.prototype._isCovered = false;


  /**
   * @type {boolean}
   * @private
   */
  jsts.geomgraph.GraphComponent.prototype._isCoveredSet = false;


  /**
   * @type {boolean}
   * @private
   */
  jsts.geomgraph.GraphComponent.prototype._isVisited = false;

  jsts.geomgraph.GraphComponent.prototype.getLabel = function() {
    return this.label;
  };
  jsts.geomgraph.GraphComponent.prototype.setLabel = function(label) {
    if (arguments.length === 2) {
      this.setLabel2.apply(this, arguments);
      return;
    }

    this.label = label;
  };


  /**
   * @param {boolean}
   *          isInResult
   */
  jsts.geomgraph.GraphComponent.prototype.setInResult = function(isInResult) {
    this._isInResult = isInResult;
  };


  /**
   * @return {boolean}
   */
  jsts.geomgraph.GraphComponent.prototype.isInResult = function() {
    return this._isInResult;
  };


  /**
   * @param {boolean}
   *          isCovered
   */
  jsts.geomgraph.GraphComponent.prototype.setCovered = function(isCovered) {
    this._isCovered = isCovered;
    this._isCoveredSet = true;
  };


  /**
   * @return {boolean}
   */
  jsts.geomgraph.GraphComponent.prototype.isCovered = function() {
    return this._isCovered;
  };


  /**
   * @return {boolean}
   */
  jsts.geomgraph.GraphComponent.prototype.isCoveredSet = function() {
    return this._isCoveredSet;
  };


  /**
   * @return {boolean}
   */
  jsts.geomgraph.GraphComponent.prototype.isVisited = function() {
    return this._isVisited;
  };


  /**
   * @param {boolean}
   *          isVisited
   */
  jsts.geomgraph.GraphComponent.prototype.setVisited = function(isVisited) {
    this._isVisited = isVisited;
  };


  /**
   * @return {Coordinate} a coordinate in this component (or null, if there are
   *         none).
   */
  jsts.geomgraph.GraphComponent.prototype.getCoordinate = function() {
    throw new jsts.error.AbstractMethodInvocationError();
  };


  /**
   * compute the contribution to an IM for this component
   *
   * @param {IntersectionMatrix}
   *          im
   * @protected
   */
  jsts.geomgraph.GraphComponent.prototype.computeIM = function(im) {
    throw new jsts.error.AbstractMethodInvocationError();
  };


  /**
   * An isolated component is one that does not intersect or touch any other
   * component. This is the case if the label has valid locations for only a
   * single Geometry.
   *
   * @return true if this component is isolated.
   */
  jsts.geomgraph.GraphComponent.prototype.isIsolated = function() {
    throw new jsts.error.AbstractMethodInvocationError();
  };


  /**
   * Update the IM with the contribution for this component. A component only
   * contributes if it has a labelling for both parent geometries
   *
   * @param {IntersectionMatrix}
   *          im
   */
  jsts.geomgraph.GraphComponent.prototype.updateIM = function(im) {
    Assert.isTrue(this.label.getGeometryCount() >= 2, 'found partial label');
    this.computeIM(im);
  };

})();
/* ======================================================================
    jsts/geomgraph/Node.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @requires jsts/geomgraph/GraphComponent.js
 */



/**
 * @constructor
 * @param {jsts.geom.Coordinate}
 *          coord
 * @param {jsts.geom.EdgeEndStar}
 *          edges
 * @augments jsts.geomgraph.GraphComponent
 */
jsts.geomgraph.Node = function(coord, edges) {
  this.coord = coord;
  this.edges = edges;
  this.label = new jsts.geomgraph.Label(0, jsts.geom.Location.NONE);
};

jsts.geomgraph.Node.prototype = new jsts.geomgraph.GraphComponent();


/**
 * only non-null if this node is precise
 */
jsts.geomgraph.Node.prototype.coord = null;
jsts.geomgraph.Node.prototype.edges = null;

jsts.geomgraph.Node.prototype.isIsolated = function() {
  return (this.label.getGeometryCount() == 1);
};

jsts.geomgraph.Node.prototype.setLabel2 = function(argIndex, onLocation) {
  if (this.label === null) {
    this.label = new jsts.geomgraph.Label(argIndex, onLocation);
  } else
    this.label.setLocation(argIndex, onLocation);
};


/**
 * Updates the label of a node to BOUNDARY, obeying the mod-2
 * boundaryDetermination rule.
 */
jsts.geomgraph.Node.prototype.setLabelBoundary = function(argIndex) {
  // determine the current location for the point (if any)
  var loc = jsts.geom.Location.NONE;
  if (this.label !== null)
    loc = this.label.getLocation(argIndex);
  // flip the loc
  var newLoc;
  switch (loc) {
  case jsts.geom.Location.BOUNDARY:
    newLoc = jsts.geom.Location.INTERIOR;
    break;
  case jsts.geom.Location.INTERIOR:
    newLoc = jsts.geom.Location.BOUNDARY;
    break;
  default:
    newLoc = jsts.geom.Location.BOUNDARY;
    break;
  }
  this.label.setLocation(argIndex, newLoc);
};


/**
 * Add the edge to the list of edges at this node
 */
jsts.geomgraph.Node.prototype.add = function(e) {
  this.edges.insert(e);
  e.setNode(this);
};

jsts.geomgraph.Node.prototype.getCoordinate = function() {
  return this.coord;
};
jsts.geomgraph.Node.prototype.getEdges = function() {
  return this.edges;
};

/**
 * Tests whether any incident edge is flagged as being in the result. This test
 * can be used to determine if the node is in the result, since if any incident
 * edge is in the result, the node must be in the result as well.
 *
 * @return <code>true</code> if any indicident edge in the in the result.
 */
jsts.geomgraph.Node.prototype.isIncidentEdgeInResult = function() {
  for (var it = this.getEdges().getEdges().iterator(); it.hasNext();) {
    var de = it.next();
    if (de.getEdge().isInResult())
      return true;
  }
  return false;
};

// TODO: port rest
/* ======================================================================
    jsts/geom/Point.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */


/**
 * @requires jsts/geom/Coordinate.js
 * @requires jsts/geom/Geometry.js
 */



/**
 * @constructor
 * @extends jsts.geom.Geometry
 */
jsts.geom.Point = function(coordinate, factory) {
  this.factory = factory;

  if (coordinate === undefined)
    return;

  this.coordinate = coordinate;
};

jsts.geom.Point.prototype = new jsts.geom.Geometry();
jsts.geom.Point.constructor = jsts.geom.Point;


jsts.geom.Point.CLASS_NAME = 'jsts.geom.Point';


jsts.geom.Point.prototype.coordinate = null;


/**
 * @return {number} x-axis value of this Point.
 */
jsts.geom.Point.prototype.getX = function() {
  return this.coordinate.x;
};


/**
 * @return {number} y-axis value of this Point.
 */
jsts.geom.Point.prototype.getY = function() {
  return this.coordinate.y;
};

jsts.geom.Point.prototype.getCoordinate = function() {
  return this.coordinate;
};


/**
 * @return {Coordinate[]} this Point as coordinate array.
 */
jsts.geom.Point.prototype.getCoordinates = function() {
  return this.isEmpty() ? [] : [this.coordinate];
};

jsts.geom.Point.prototype.getCoordinateSequence = function() {
  return this.isEmpty() ? [] : [this.coordinate];
};

jsts.geom.Point.prototype.isEmpty = function() {
  return this.coordinate === null;
};

jsts.geom.Point.prototype.equalsExact = function(other, tolerance) {
  if (!this.isEquivalentClass(other)) {
    return false;
  }
  if (this.isEmpty() && other.isEmpty()) {
    return true;
  }
  return this.equal(other.getCoordinate(), this.getCoordinate(), tolerance);
};


/**
 * @return {number} number of coordinates (0 or 1).
 */
jsts.geom.Point.prototype.getNumPoints = function() {
  return this.isEmpty() ? 0 : 1;
};


/**
 * @return {boolean} Point is always simple.
 */
jsts.geom.Point.prototype.isSimple = function() {
  return true;
};


/**
 * Gets the boundary of this geometry. Zero-dimensional geometries have no
 * boundary by definition, so an empty GeometryCollection is returned.
 *
 * @return {GeometryCollection} an empty GeometryCollection.
 * @see Geometry#getBoundary
 */
jsts.geom.Point.prototype.getBoundary = function() {
  return new jsts.geom.GeometryCollection(null);
};


/**
 * @return {Envelope} Envelope of this point.
 */
jsts.geom.Point.prototype.computeEnvelopeInternal = function() {
  if (this.isEmpty()) {
    return new jsts.geom.Envelope();
  }
  return new jsts.geom.Envelope(this.coordinate);
};

jsts.geom.Point.prototype.apply = function(filter) {
  if (filter instanceof jsts.geom.GeometryFilter || filter instanceof jsts.geom.GeometryComponentFilter) {
    filter.filter(this);
  } else if (filter instanceof jsts.geom.CoordinateFilter) {
    if (this.isEmpty()) { return; }
    filter.filter(this.getCoordinate());
  }

};

jsts.geom.Point.prototype.clone = function() {
  return new jsts.geom.Point(this.coordinate.clone(), this.factory);
};


/**
 * @return {number} Always 0.
 */
jsts.geom.Point.prototype.getDimension = function() {
  return 0;
};


/**
 * @return {number} Always Dimension.FALSE.
 */
jsts.geom.Point.prototype.getBoundaryDimension = function() {
  return jsts.geom.Dimension.FALSE;
};


/**
 * @return {Point} Reversed point is a cloned point.
 */
jsts.geom.Point.prototype.reverse = function() {
  return this.clone();
};


/**
 * A Point is valid iff:
 * <ul>
 * <li>the coordinate which defines it is a valid coordinate (i.e does not have
 * an NaN X or Y ordinate)
 * </ul>
 *
 * @return {boolean} true iff the Point is valid.
 */
jsts.geom.Point.prototype.isValid = function() {
  if (!jsts.operation.valid.IsValidOp.isValid(this.getCoordinate())) {
    return false;
  }
  return true;
};


/**
 *
 */
jsts.geom.Point.prototype.normalize = function() {
  // a Point is always in normalized form
};

jsts.geom.Point.prototype.compareToSameClass = function(other) {
  var point = other;
  return this.getCoordinate().compareTo(point.getCoordinate());
};

/**
 * @return {string} String representation of Point type.
 */
jsts.geom.Point.prototype.getGeometryType = function() {
  return 'Point';
};

jsts.geom.Point.prototype.hashCode = function() {
  return 'Point_' + this.coordinate.hashCode();
};

jsts.geom.Point.prototype.CLASS_NAME = 'jsts.geom.Point';
/* ======================================================================
    jsts/geom/Dimension.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * Provides constants representing the dimensions of a point, a curve and a
 * surface. Also provides constants representing the dimensions of the empty
 * geometry and non-empty geometries, and the wildcard constant
 * {@link #DONTCARE} meaning "any dimension". These constants are used as the
 * entries in {@link IntersectionMatrix}s.
 *
 * @constructor
 */
jsts.geom.Dimension = function() {
};


/**
 * Dimension value of a point (0).
 *
 * @const
 * @type {number}
 */
jsts.geom.Dimension.P = 0;


/**
 * Dimension value of a curve (1).
 *
 * @const
 * @type {number}
 */
jsts.geom.Dimension.L = 1;


/**
 * Dimension value of a surface (2).
 *
 * @const
 * @type {number}
 */
jsts.geom.Dimension.A = 2;


/**
 * Dimension value of the empty geometry (-1).
 *
 * @const
 * @type {number}
 */
jsts.geom.Dimension.FALSE = -1;


/**
 * Dimension value of non-empty geometries (= {P, L, A}).
 *
 * @const
 * @type {number}
 */
jsts.geom.Dimension.TRUE = -2;


/**
 * Dimension value for any dimension (= {FALSE, TRUE}).
 *
 * @const
 * @type {number}
 */
jsts.geom.Dimension.DONTCARE = -3;


/**
 * Converts the dimension value to a dimension symbol, for example,
 * <code>TRUE => 'T'</code> .
 *
 * @param {number}
 *          dimensionValue a number that can be stored in the
 *          <code>IntersectionMatrix</code> . Possible values are
 *          <code>{TRUE, FALSE, DONTCARE, 0, 1, 2}</code>.
 * @return {String} a character for use in the string representation of an
 *         <code>IntersectionMatrix</code>. Possible values are
 *         <code>{T, F, * , 0, 1, 2}</code> .
 */
jsts.geom.Dimension.toDimensionSymbol = function(dimensionValue) {
  switch (dimensionValue) {
    case jsts.geom.Dimension.FALSE:
      return 'F';
    case jsts.geom.Dimension.TRUE:
      return 'T';
    case jsts.geom.Dimension.DONTCARE:
      return '*';
    case jsts.geom.Dimension.P:
      return '0';
    case jsts.geom.Dimension.L:
      return '1';
    case jsts.geom.Dimension.A:
      return '2';
  }
  throw new jsts.IllegalArgumentError('Unknown dimension value: ' +
      dimensionValue);
};


/**
 * Converts the dimension symbol to a dimension value, for example,
 * <code>'*' => DONTCARE</code> .
 *
 * @param {string}
 *          dimensionSymbol a character for use in the string representation of
 *          an <code>IntersectionMatrix</code>. Possible values are
 *          <code>{T, F, * , 0, 1, 2}</code> .
 * @return {number} a number that can be stored in the
 *         <code>IntersectionMatrix</code> . Possible values are
 *         <code>{TRUE, FALSE, DONTCARE, 0, 1, 2}</code>.
 */
jsts.geom.Dimension.toDimensionValue = function(dimensionSymbol) {
  switch (dimensionSymbol.toUpperCase()) {
    case 'F':
      return jsts.geom.Dimension.FALSE;
    case 'T':
      return jsts.geom.Dimension.TRUE;
    case '*':
      return jsts.geom.Dimension.DONTCARE;
    case '0':
      return jsts.geom.Dimension.P;
    case '1':
      return jsts.geom.Dimension.L;
    case '2':
      return jsts.geom.Dimension.A;
  }
  throw new jsts.error.IllegalArgumentError('Unknown dimension symbol: ' +
      dimensionSymbol);
};
/* ======================================================================
    jsts/geom/LineString.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * @requires jsts/geom/Geometry.js
   * @requires jsts/geom/Dimension.js
   */

  var Dimension = jsts.geom.Dimension;

  /**
   * @extends jsts.geom.Geometry
   * @constructor
   */
  jsts.geom.LineString = function(points, factory) {
    this.factory = factory;
    this.points = points || [];
  };

  jsts.geom.LineString.prototype = new jsts.geom.Geometry();
  jsts.geom.LineString.constructor = jsts.geom.LineString;

  /**
   * @type {jsts.geom.Coordinate[]}
   * @private
   */
  jsts.geom.LineString.prototype.points = null;

  /**
   * @return {jsts.geom.Coordinate[]} this LineString's internal coordinate
   *         array.
   */
  jsts.geom.LineString.prototype.getCoordinates = function() {
    return this.points;
  };

  jsts.geom.LineString.prototype.getCoordinateSequence = function() {
    return this.points;
  };


  /**
   * @return {jsts.geom.Coordinate} The n'th coordinate of this
   *         jsts.geom.LineString.
   * @param {int}
   *          n index.
   */
  jsts.geom.LineString.prototype.getCoordinateN = function(n) {
    return this.points[n];
  };


  /**
   * @return {jsts.geom.Coordinate} The first coordinate of this LineString or
   *         null if empty.
   */
  jsts.geom.LineString.prototype.getCoordinate = function() {
    if (this.isEmpty()) {
      return null;
    }
    return this.getCoordinateN(0);
  };


  /**
   * @return {number} LineStrings are always 1-dimensional.
   */
  jsts.geom.LineString.prototype.getDimension = function() {
    return 1;
  };


  /**
   * @return {number} dimension of the boundary of this jsts.geom.LineString.
   */
  jsts.geom.LineString.prototype.getBoundaryDimension = function() {
    if (this.isClosed()) {
      return Dimension.FALSE;
    }
    return 0;
  };


  /**
   * @return {Boolean} true if empty.
   */
  jsts.geom.LineString.prototype.isEmpty = function() {
    return this.points.length === 0;
  };

  jsts.geom.LineString.prototype.getNumPoints = function() {
    return this.points.length;
  };

  jsts.geom.LineString.prototype.getPointN = function(n) {
    return this.getFactory().createPoint(this.points[n]);
  };


  jsts.geom.LineString.prototype.getStartPoint = function() {
    if (this.isEmpty()) {
      return null;
    }
    return this.getPointN(0);
  };

  jsts.geom.LineString.prototype.getEndPoint = function() {
    if (this.isEmpty()) {
      return null;
    }
    return this.getPointN(this.getNumPoints() - 1);
  };


  /**
   * @return {Boolean} true if LineString is Closed.
   */
  jsts.geom.LineString.prototype.isClosed = function() {
    if (this.isEmpty()) {
      return false;
    }
    return this.getCoordinateN(0).equals2D(
        this.getCoordinateN(this.points.length - 1));
  };


  /**
   * @return {Boolean} true if LineString is a Ring.
   */
  jsts.geom.LineString.prototype.isRing = function() {
    return this.isClosed() && this.isSimple();
  };


  /**
   * @return {String} String representation of LineString type.
   */
  jsts.geom.LineString.prototype.getGeometryType = function() {
    return 'LineString';
  };


  /**
   * Returns the length of this <code>LineString</code>
   *
   * @return the length of the linestring.
   */
  jsts.geom.LineString.prototype.getLength = function() {
    return jsts.algorithm.CGAlgorithms.computeLength(this.points);
  };

  /**
   * Gets the boundary of this geometry. The boundary of a lineal geometry is
   * always a zero-dimensional geometry (which may be empty).
   *
   * @return {Geometry} the boundary geometry.
   * @see Geometry#getBoundary
   */
  jsts.geom.LineString.prototype.getBoundary = function() {
    return (new jsts.operation.BoundaryOp(this)).getBoundary();
  };


  jsts.geom.LineString.prototype.computeEnvelopeInternal = function() {
    if (this.isEmpty()) {
      return new jsts.geom.Envelope();
    }

    var env = new jsts.geom.Envelope();
    this.points.forEach(function(component) {
      env.expandToInclude(component);
    });

    return env;
  };


  /**
   * @param {Geometry}
   *          other Geometry to compare this LineString to.
   * @param {double}
   *          tolerance Tolerance.
   * @return {Boolean} true if equal.
   */
  jsts.geom.LineString.prototype.equalsExact = function(other, tolerance) {
    if (!this.isEquivalentClass(other)) {
      return false;
    }

    if (this.points.length !== other.points.length) {
      return false;
    }

    if (this.isEmpty() && other.isEmpty()) {
      return true;
    }

    return this.points
        .reduce(function(equal, point, i) {
          return equal &&
              jsts.geom.Geometry.prototype.equal(point, other.points[i],
                  tolerance);
        });
  };

  jsts.geom.LineString.prototype.isEquivalentClass = function(other) {
    return other instanceof jsts.geom.LineString;
  };

  jsts.geom.LineString.prototype.compareToSameClass = function(o) {
    var line = o;
    // MD - optimized implementation
    var i = 0, il = this.points.length;
    var j = 0, jl = line.points.length;
    while (i < il && j < jl) {
      var comparison = this.points[i].compareTo(line.points[j]);
      if (comparison !== 0) {
        return comparison;
      }
      i++;
      j++;
    }
    if (i < il) {
      return 1;
    }
    if (j < jl) {
      return -1;
    }
    return 0;
  };

  jsts.geom.LineString.prototype.apply = function(filter) {
    if (filter instanceof jsts.geom.GeometryFilter ||
        filter instanceof jsts.geom.GeometryComponentFilter) {
      filter.filter(this);
    } else if (filter instanceof jsts.geom.CoordinateFilter) {
      for (var i = 0, len = this.points.length; i < len; i++) {
        filter.filter(this.points[i]);
      }
    } else if (filter instanceof jsts.geom.CoordinateSequenceFilter) {
      this.apply2.apply(this, arguments);
    }
  };

  jsts.geom.LineString.prototype.apply2 = function(filter) {
    if (this.points.length === 0)
      return;
    for (var i = 0; i < this.points.length; i++) {
      filter.filter(this.points, i);
      if (filter.isDone())
        break;
    }
    if (filter.isGeometryChanged()) {
      // TODO: call geometryChanged(); when ported
    }
  };

  jsts.geom.LineString.prototype.clone = function() {
    var points = [];

    for (var i = 0, len = this.points.length; i < len; i++) {
      points.push(this.points[i].clone());
    }

    return this.factory.createLineString(points);
  };

  /**
   * Normalizes a LineString. A normalized linestring has the first point which
   * is not equal to it's reflected point less than the reflected point.
   */
  jsts.geom.LineString.prototype.normalize = function() {
    var i, il, j, ci, cj, len;

    len = this.points.length;
    il = parseInt(len / 2);

    for (i = 0; i < il; i++) {
      j = len - 1 - i;
      // skip equal points on both ends
      ci = this.points[i];
      cj = this.points[j];
      if (!ci.equals(cj)) {
        if (ci.compareTo(cj) > 0) {
          this.points.reverse();
        }
        return;
      }
    }
  };

  jsts.geom.LineString.prototype.CLASS_NAME = 'jsts.geom.LineString';

})();
/* ======================================================================
    jsts/geom/Polygon.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * Represents a linear polygon, which may include holes. The shell and holes
   * of the polygon are represented by {@link LinearRing}s. In a valid polygon,
   * holes may touch the shell or other holes at a single point. However, no
   * sequence of touching holes may split the polygon into two pieces. The
   * orientation of the rings in the polygon does not matter.
   *
   * The shell and holes must conform to the assertions specified in the <A
   * HREF="http://www.opengis.org/techno/specs.htm">OpenGIS Simple Features
   * Specification for SQL</A>.
   */


  /**
   * @requires jsts/geom/Geometry.js
   */

  /**
   * @extends {jsts.geom.Geometry}
   * @constructor
   */
  jsts.geom.Polygon = function(shell, holes, factory) {
    this.shell = shell || factory.createLinearRing(null);
    this.holes = holes || [];
    this.factory = factory;
  };

  jsts.geom.Polygon.prototype = new jsts.geom.Geometry();
  jsts.geom.Polygon.constructor = jsts.geom.Polygon;

  jsts.geom.Polygon.prototype.getCoordinate = function() {
    return this.shell.getCoordinate();
  };

  jsts.geom.Polygon.prototype.getCoordinates = function() {
    if (this.isEmpty()) {
      return [];
    }
    var coordinates = [];
    var k = -1;
    var shellCoordinates = this.shell.getCoordinates();
    for (var x = 0; x < shellCoordinates.length; x++) {
      k++;
      coordinates[k] = shellCoordinates[x];
    }
    for (var i = 0; i < this.holes.length; i++) {
      var childCoordinates = this.holes[i].getCoordinates();
      for (var j = 0; j < childCoordinates.length; j++) {
        k++;
        coordinates[k] = childCoordinates[j];
      }
    }
    return coordinates;
  };

  /**
   * @return {number}
   */
  jsts.geom.Polygon.prototype.getNumPoints = function() {
    var numPoints = this.shell.getNumPoints();
    for (var i = 0; i < this.holes.length; i++) {
      numPoints += this.holes[i].getNumPoints();
    }
    return numPoints;
  };

  /**
   * @return {boolean}
   */
  jsts.geom.Polygon.prototype.isEmpty = function() {
    return this.shell.isEmpty();
  };
  
  jsts.geom.Polygon.prototype.isRectangle = function() {
    if (this.getNumInteriorRing() != 0) return false;
    if (this.shell == null) return false;
    if (this.shell.getNumPoints() != 5) return false;

    var seq = this.shell.getCoordinateSequence();

    // check vertices have correct values
    var env = this.getEnvelopeInternal();
    for (var i = 0; i < 5; i++) {
      // TODO: reworked cause CoordinateSequence is currently a simple array
      var x = seq[i].x;
      if (! (x == env.getMinX() || x == env.getMaxX())) return false;
      // TODO: reworked cause CoordinateSequence is currently a simple array
      var y = seq[i].y;
      if (! (y == env.getMinY() || y == env.getMaxY())) return false;
    }

    // check vertices are in right order
    // TODO: reworked cause CoordinateSequence is currently a simple array
    var prevX = seq[0].x;
    var prevY = seq[0].y;
    for (var i = 1; i <= 4; i++) {
      // TODO: reworked cause CoordinateSequence is currently a simple array
      var x = seq[i].x;
      var y = seq[i].y;
      var xChanged = x != prevX;
      var yChanged = y != prevY;
      if (xChanged == yChanged)
        return false;
      prevX = x;
      prevY = y;
    }
    return true;
  };

  jsts.geom.Polygon.prototype.getExteriorRing = function() {
    return this.shell;
  };

  jsts.geom.Polygon.prototype.getInteriorRingN = function(n) {
    return this.holes[n];
  };

  jsts.geom.Polygon.prototype.getNumInteriorRing = function() {
    return this.holes.length;
  };

  /**
   * Returns the area of this <code>Polygon</code>
   *
   * @return the area of the polygon.
   */
  jsts.geom.Polygon.prototype.getArea = function() {
    var area = 0.0;
    area += Math.abs(jsts.algorithm.CGAlgorithms.signedArea(this.shell
        .getCoordinateSequence()));
    for (var i = 0; i < this.holes.length; i++) {
      area -= Math.abs(jsts.algorithm.CGAlgorithms.signedArea(this.holes[i]
          .getCoordinateSequence()));
    }
    return area;
  };

  /**
   * Returns the perimeter of this <code>Polygon</code>
   *
   * @return the perimeter of the polygon.
   */
  jsts.geom.Polygon.prototype.getLength = function() {
    var len = 0.0;
    len += this.shell.getLength();
    for (var i = 0; i < this.holes.length; i++) {
      len += this.holes[i].getLength();
    }
    return len;
  };

  /**
   * Computes the boundary of this geometry
   *
   * @return {Geometry} a lineal geometry (which may be empty).
   * @see Geometry#getBoundary
   */
  jsts.geom.Polygon.prototype.getBoundary = function() {
    if (this.isEmpty()) {
      return this.getFactory().createMultiLineString(null);
    }
    var rings = [];
    rings[0] = this.shell.clone();
    for (var i = 0, len = this.holes.length; i < len; i++) {
      rings[i + 1] = this.holes[i].clone();
    }
    // create LineString or MultiLineString as appropriate
    if (rings.length <= 1)
      return rings[0];
    return this.getFactory().createMultiLineString(rings);
  };

  jsts.geom.Polygon.prototype.computeEnvelopeInternal = function() {
    return this.shell.getEnvelopeInternal();
  };

  jsts.geom.Polygon.prototype.getDimension = function() {
    return 2;
  };

  jsts.geom.Polygon.prototype.getBoundaryDimension = function() {
    return 1;
  };


  /**
   * @param {Geometry}
   *          other
   * @param {number}
   *          tolerance
   * @return {boolean}
   */
  jsts.geom.Polygon.prototype.equalsExact = function(other, tolerance) {
    if (!this.isEquivalentClass(other)) {
      return false;
    }
    if (this.isEmpty() && other.isEmpty()) {
      return true;
    }
    if (this.isEmpty() !== other.isEmpty()) {
      return false;
    }

    if (!this.shell.equalsExact(other.shell, tolerance)) {
      return false;
    }
    if (this.holes.length !== other.holes.length) {
      return false;
    }
    if (this.holes.length !== other.holes.length) {
      return false;
    }
    for (var i = 0; i < this.holes.length; i++) {
      if (!(this.holes[i]).equalsExact(other.holes[i], tolerance)) {
        return false;
      }
    }
    return true;
  };

  jsts.geom.Polygon.prototype.compareToSameClass = function(o) {
    return this.shell.compareToSameClass(o.shell);
  };

  jsts.geom.Polygon.prototype.apply = function(filter) {
    if (filter instanceof jsts.geom.GeometryComponentFilter) {
      filter.filter(this);
      this.shell.apply(filter);
      for (var i = 0, len = this.holes.length; i < len; i++) {
        this.holes[i].apply(filter);
      }
    } else if (filter instanceof jsts.geom.GeometryFilter) {
      filter.filter(this);
    } else if (filter instanceof jsts.geom.CoordinateFilter) {
      this.shell.apply(filter);
      for (var i = 0, len = this.holes.length; i < len; i++) {
        this.holes[i].apply(filter);
      }
    } else if (filter instanceof jsts.geom.CoordinateSequenceFilter) {
      this.apply2.apply(this, arguments);
    }
  };

  jsts.geom.Polygon.prototype.apply2 = function(filter) {
    this.shell.apply(filter);
    if (!filter.isDone()) {
      for (var i = 0; i < this.holes.length; i++) {
        this.holes[i].apply(filter);
        if (filter.isDone())
          break;
      }
    }
    if (filter.isGeometryChanged()) {
      // TODO: call this.geometryChanged(); when ported
    }
  };

  /**
   * Creates and returns a full copy of this {@link Polygon} object. (including
   * all coordinates contained by it).
   *
   * @return a clone of this instance.
   */
  jsts.geom.Polygon.prototype.clone = function() {
    var holes = [];

    for (var i = 0, len = this.holes.length; i < len; i++) {
      holes.push(this.holes[i].clone());
    }

    return this.factory.createPolygon(this.shell.clone(), holes);
  };

  jsts.geom.Polygon.prototype.normalize = function() {
    this.normalize2(this.shell, true);
    for (var i = 0, len = this.holes.length; i < len; i++) {
      this.normalize2(this.holes[i], false);
    }
    // TODO: might need to supply comparison function
    this.holes.sort();
  };

  /**
   * @private
   */
  jsts.geom.Polygon.prototype.normalize2 = function(ring, clockwise) {
    if (ring.isEmpty()) {
      return;
    }
    var uniqueCoordinates = ring.points.slice(0, ring.points.length - 1);
    var minCoordinate = jsts.geom.CoordinateArrays.minCoordinate(ring.points);
    jsts.geom.CoordinateArrays.scroll(uniqueCoordinates, minCoordinate);
    ring.points = uniqueCoordinates.concat();
    ring.points[uniqueCoordinates.length] = uniqueCoordinates[0];
    if (jsts.algorithm.CGAlgorithms.isCCW(ring.points) === clockwise) {
      ring.points.reverse();
    }
  };

  /**
   * @return {String} String representation of Polygon type.
   */
  jsts.geom.Polygon.prototype.getGeometryType = function() {
    return 'Polygon';
  };
  
  jsts.geom.Polygon.prototype.CLASS_NAME = 'jsts.geom.Polygon';

})();
/* ======================================================================
    jsts/geom/GeometryCollection.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * @requires jsts/geom/Geometry.js
   */

  var Geometry = jsts.geom.Geometry;
  var TreeSet = javascript.util.TreeSet;
  var Arrays = javascript.util.Arrays;

  /**
   * @constructor
   * @extends jsts.geom.Geometry
   */
  jsts.geom.GeometryCollection = function(geometries, factory) {
    this.geometries = geometries || [];
    this.factory = factory;
  };

  jsts.geom.GeometryCollection.prototype = new Geometry();
  jsts.geom.GeometryCollection.constructor = jsts.geom.GeometryCollection;

  /**
   * @return {boolean}
   */
  jsts.geom.GeometryCollection.prototype.isEmpty = function() {
    for (var i = 0, len = this.geometries.length; i < len; i++) {
      var geometry = this.getGeometryN(i);

      if (!geometry.isEmpty()) {
        return false;
      }
    }
    return true;
  };

  jsts.geom.GeometryCollection.prototype.getArea = function() {
    var area = 0.0;

    for (var i = 0, len = this.geometries.length; i < len; i++) {
      area += this.getGeometryN(i).getArea();
    }

    return area;
  };

  jsts.geom.GeometryCollection.prototype.getLength = function() {
    var length = 0.0;

    for (var i = 0, len = this.geometries.length; i < len; i++) {
      length += this.getGeometryN(i).getLength();
    }

    return length;
  };


  /**
   * @return {Coordinate}
   */
  jsts.geom.GeometryCollection.prototype.getCoordinate = function() {
    if (this.isEmpty())
      return null;

    return this.getGeometryN(0).getCoordinate();
  };


  /**
   * Collects all coordinates of all subgeometries into an Array.
   *
   * Note that while changes to the coordinate objects themselves may modify the
   * Geometries in place, the returned Array as such is only a temporary
   * container which is not synchronized back.
   *
   * @return {Coordinate[]} the collected coordinates.
   */
  jsts.geom.GeometryCollection.prototype.getCoordinates = function() {
    var coordinates = [];
    var k = -1;
    for (var i = 0, len = this.geometries.length; i < len; i++) {
      var geometry = this.getGeometryN(i);

      var childCoordinates = geometry.getCoordinates();
      for (var j = 0; j < childCoordinates.length; j++) {
        k++;
        coordinates[k] = childCoordinates[j];
      }
    }
    return coordinates;
  };


  /**
   * @return {int}
   */
  jsts.geom.GeometryCollection.prototype.getNumGeometries = function() {
    return this.geometries.length;
  };


  /**
   * @param {int}
   *          n
   * @return {Geometry}
   */
  jsts.geom.GeometryCollection.prototype.getGeometryN = function(n) {
    var geometry = this.geometries[n];
    if (geometry instanceof jsts.geom.Coordinate) {
      geometry = new jsts.geom.Point(geometry);
    }
    return geometry;
  };

  /**
   * @return {number}
   */
  jsts.geom.GeometryCollection.prototype.getNumPoints = function(n) {
    var numPoints = 0;
    for (var i = 0; i < this.geometries.length; i++) {
      numPoints += this.geometries[i].getNumPoints();
    }
    return numPoints;
  }

  /**
   * @param {Geometry}
   *          other
   * @param {double}
   *          tolerance
   * @return {boolean}
   */
  jsts.geom.GeometryCollection.prototype.equalsExact = function(other,
      tolerance) {
    if (!this.isEquivalentClass(other)) {
      return false;
    }
    if (this.geometries.length !== other.geometries.length) {
      return false;
    }
    for (var i = 0, len = this.geometries.length; i < len; i++) {
      var geometry = this.getGeometryN(i);

      if (!geometry.equalsExact(other.getGeometryN(i), tolerance)) {
        return false;
      }
    }
    return true;
  };

  /**
   * Creates and returns a full copy of this {@link GeometryCollection} object.
   * (including all coordinates contained by it).
   *
   * @return a clone of this instance.
   */
  jsts.geom.GeometryCollection.prototype.clone = function() {
    var geometries = [];
    for (var i = 0, len = this.geometries.length; i < len; i++) {
      geometries.push(this.geometries[i].clone());
    }
    return this.factory.createGeometryCollection(geometries);
  };

  jsts.geom.GeometryCollection.prototype.normalize = function() {
    for (var i = 0, len = this.geometries.length; i < len; i++) {
      this.getGeometryN(i).normalize();
    }
    // TODO: might need to supply comparison function
    this.geometries.sort();
  };

  jsts.geom.GeometryCollection.prototype.compareToSameClass = function(o) {
    var theseElements = new TreeSet(Arrays.asList(this.geometries));
    var otherElements = new TreeSet(Arrays.asList(o.geometries));
    return this.compare(theseElements, otherElements);
  };

  jsts.geom.GeometryCollection.prototype.apply = function(filter) {
    if (filter instanceof jsts.geom.GeometryFilter ||
        filter instanceof jsts.geom.GeometryComponentFilter) {
      filter.filter(this);
      for (var i = 0, len = this.geometries.length; i < len; i++) {
        this.getGeometryN(i).apply(filter);
      }
    } else if (filter instanceof jsts.geom.CoordinateFilter) {
      for (var i = 0, len = this.geometries.length; i < len; i++) {
        this.getGeometryN(i).apply(filter);
      }
    } else if (filter instanceof jsts.geom.CoordinateSequenceFilter) {
      this.apply2.apply(this, arguments);
    }
  };

  jsts.geom.GeometryCollection.prototype.apply2 = function(filter) {
    if (this.geometries.length == 0)
      return;
    for (var i = 0; i < this.geometries.length; i++) {
      this.geometries[i].apply(filter);
      if (filter.isDone()) {
        break;
      }
    }
    if (filter.isGeometryChanged()) {
      // TODO: call this.geometryChanged(); when ported
    }
  };

  jsts.geom.GeometryCollection.prototype.getDimension = function() {
    var dimension = jsts.geom.Dimension.FALSE;
    for (var i = 0, len = this.geometries.length; i < len; i++) {
      var geometry = this.getGeometryN(i);
      dimension = Math.max(dimension, geometry.getDimension());
    }
    return dimension;
  };

  /**
   * @protected
   */
  jsts.geom.GeometryCollection.prototype.computeEnvelopeInternal = function() {
    var envelope = new jsts.geom.Envelope();
    for (var i = 0, len = this.geometries.length; i < len; i++) {
      var geometry = this.getGeometryN(i);
      envelope.expandToInclude(geometry.getEnvelopeInternal());
    }
    return envelope;
  };

  jsts.geom.GeometryCollection.prototype.CLASS_NAME = 'jsts.geom.GeometryCollection';

})();

// TODO: port rest
/* ======================================================================
    jsts/algorithm/Centroid.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @requires jsts/geom/Coordinate.js
 * @requires jsts/geom/Point.js
 * @requires jsts/geom/LineString.js
 * @requires jsts/geom/Polygon.js
 * @requires jsts/geom/GeometryCollection.js
 * @requires jsts/algorithm/CGAlgorithms.js
 */

/**
 * Computes the centroid of a {@link Geometry} of any dimension.
 * If the geometry is nominally of higher dimension, 
 * but has lower <i>effective</i> dimension 
 * (i.e. contains only components
 * having zero length or area), 
 * the centroid will be computed as for the equivalent lower-dimension geometry.
 * If the input geometry is empty, a
 * <code>null</code> Coordinate is returned.
 * 
 * <h2>Algorithm</h2>
 * <ul>
 * <li><b>Dimension 2</b> - the centroid is computed 
 * as the weighted sum of the centroids
 * of a decomposition of the area into (possibly overlapping) triangles.
 * Holes and multipolygons are handled correctly.
 * See <code>http://www.faqs.org/faqs/graphics/algorithms-faq/</code>
 * for further details of the basic approach.
 * 
 * <li><b>Dimension 1</b> - Computes the average of the midpoints
 * of all line segments weighted by the segment length.
 * Zero-length lines are treated as points.
 * 
 * <li><b>Dimension 0</b> - Compute the average coordinate for all points.
 * Repeated points are all included in the average.
 * </ul>
 * 
 * @version 1.7
 *
 * @constructor
 */
jsts.algorithm.Centroid = function (geometry) {

    /**
     * The point all triangles are based at
     * @type {jsts.geom.Coordinate}
     * @private
     */
    this.areaBasePt = null;

    /**
     * Temporary variable to hold centroid of triangle
     * @type {jsts.geom.Coordinate}
     * @private
     */
    this.triangleCent3 = new jsts.geom.Coordinate();

    /**
     * Partial area sum
     * @type {number}
     * @private
     */
    this.areasum2 = 0;

    /**
     * Partial centroid sum
     * @type {jsts.geom.Coordinate}
     * @private
     */
    this.cg3 = new jsts.geom.Coordinate();

    // data for linear centroid computation, if needed
    this.lineCentSum = new jsts.geom.Coordinate();
    this.totalLength = 0;

    this.ptCount = 0;
    this.ptCentSum = new jsts.geom.Coordinate();


    this.add(geometry);
};

/**
 * Computes the centroid point of a geometry.
 * @param {jsts.geom.Geometry} geometry the geometry to use
 * @return {jsts.geom.Coordinate} the centroid point, or null if the geometry is empty
 */
jsts.algorithm.Centroid.getCentroid = function (geometry) {
    var cent = new jsts.algorithm.Centroid(geometry);
    return cent.getCentroid();
};

/**
 * Computes three times the centroid of the triangle p1-p2-p3.
 * The factor of 3 is left in to permit division to be avoided until later.
 * @param {jsts.geom.Coordinate} p0
 * @param {jsts.geom.Coordinate} p1
 * @param {jsts.geom.Coordinate} p2
 * @param {jsts.geom.Coordinate} c
 * @private
 */
jsts.algorithm.Centroid.centroid3 = function (p1, p2, p3, c) {
    c.x = p1.x + p2.x + p3.x;
    c.y = p1.y + p2.y + p3.y;
};

/**
 * Returns twice the signed area of the triangle p1-p2-p3.
 * The area is positive if the triangle is oriented CCW, and negative if CW.
 * @param {jsts.geom.Coordinate} p1
 * @param {jsts.geom.Coordinate} p2
 * @param {jsts.geom.Coordinate} p3
 * @private
 */
jsts.algorithm.Centroid.area2 = function (p1, p2, p3) {
    return (p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y);
};

/**
 * Adds a Geometry to the centroid total.
 * @param {jsts.geom.Geometry} geom the geometry to add
 * @private
 */
jsts.algorithm.Centroid.prototype.add = function (geom) {
    if (geom.isEmpty()) {
        return;
    }
    if (geom instanceof jsts.geom.Point) {
        this.addPoint(geom.getCoordinate());
    } else if (geom instanceof jsts.geom.LineString) {
        this.addLineSegments(geom.getCoordinates());
    } else if (geom instanceof jsts.geom.Polygon) {
        this.addPolygon(geom);
    } else if (geom instanceof jsts.geom.GeometryCollection) {
        for (var i = 0; i < geom.getNumGeometries(); i++) {
            this.add(geom.getGeometryN(i));
        }
    }
};

/**
 * Gets the computed centroid.
 * @return {jsts.geom.Coordinate} the computed centroid, or null if the input is empty
 */
jsts.algorithm.Centroid.prototype.getCentroid = function () {
    var cent = new jsts.geom.Coordinate();
    if (Math.abs(this.areasum2) > 0) {
        cent.x = this.cg3.x / 3 / this.areasum2;
        cent.y = this.cg3.y / 3 / this.areasum2;
    } else if (this.totalLength > 0) {
        // if polygon was degenerate, compute linear centroid instead
        cent.x = this.lineCentSum.x / this.totalLength;
        cent.y = this.lineCentSum.y / this.totalLength;
    } else if (this.ptCount > 0) {
        cent.x = this.ptCentSum.x / this.ptCount;
        cent.y = this.ptCentSum.y / this.ptCount;
    } else {
        return null;
    }
    return cent;
};

/**
 * @param {jsts.geom.Coordinate} basePt
 * @private
 */
jsts.algorithm.Centroid.prototype.setBasePoint = function (basePt) {
    if (this.areaBasePt === null) {
        this.areaBasePt = basePt;
    }
};

/**
 * @param {jsts.geom.Polygon} poly
 * @private
 */
jsts.algorithm.Centroid.prototype.addPolygon = function (poly) {
    this.addShell(poly.getExteriorRing().getCoordinates());
    for (var i = 0; i < poly.getNumInteriorRing(); i++) {
        this.addHole(poly.getInteriorRingN(i).getCoordinates());
    }
};

/**
 * @param {jsts.geom.Coordinate[]} pts
 * @private
 */
jsts.algorithm.Centroid.prototype.addShell = function (pts) {
    if (pts.length > 0) {
        this.setBasePoint(pts[0]);
    }
    var isPositiveArea = !jsts.algorithm.CGAlgorithms.isCCW(pts);
    for (var i = 0; i < pts.length - 1; i++) {
        this.addTriangle(this.areaBasePt, pts[i], pts[i + 1], isPositiveArea);
    }
    this.addLineSegments(pts);
};

/**
 * @param {jsts.geom.Coordinate[]} pts
 * @private
 */
jsts.algorithm.Centroid.prototype.addHole = function (pts) {
    var isPositiveArea = jsts.algorithm.CGAlgorithms.isCCW(pts);
    for (var i = 0; i < pts.length - 1; i++) {
        this.addTriangle(this.areaBasePt, pts[i], pts[i + 1], isPositiveArea);
    }
    this.addLineSegments(pts);
};

/**
 * @param {jsts.geom.Coordinate} p0
 * @param {jsts.geom.Coordinate} p1
 * @param {jsts.geom.Coordinate} p2
 * @param {boolean} isPositiveArea
 * @private
 */
jsts.algorithm.Centroid.prototype.addTriangle = function (p0, p1, p2, isPositiveArea) {
    var sign = (isPositiveArea) ? 1 : -1;
    jsts.algorithm.Centroid.centroid3(p0, p1, p2, this.triangleCent3);
    var area2 = jsts.algorithm.Centroid.area2(p0, p1, p2);
    this.cg3.x += sign * area2 * this.triangleCent3.x;
    this.cg3.y += sign * area2 * this.triangleCent3.y;
    this.areasum2 += sign * area2;
};

/**
 * Adds the line segments defined by an array of coordinates
 * to the linear centroid accumulators.
 * @param {jsts.geom.Coordinate[]} pts
 * @private
 */
jsts.algorithm.Centroid.prototype.addLineSegments = function (pts) {
    var lineLen = 0;
    for (var i = 0; i < pts.length - 1; i++) {
        var segmentLen = pts[i].distance(pts[i + 1]);
        if (segmentLen === 0) {
            continue;
        }

        lineLen += segmentLen;

        var midx = (pts[i].x + pts[i + 1].x) / 2;
        this.lineCentSum.x += segmentLen * midx;
        var midy = (pts[i].y + pts[i + 1].y) / 2;
        this.lineCentSum.y += segmentLen * midy;
    }
    this.totalLength += lineLen;
    if (lineLen === 0 && pts.length > 0) {
        this.addPoint(pts[0]);
    }
};

/**
 * Adds a point to the point centroid accumulator.
 * @param {jsts.geom.Coordinate} pt
 * @private
 */
jsts.algorithm.Centroid.prototype.addPoint = function (pt) {
    this.ptCount += 1;
    this.ptCentSum.x += pt.x;
    this.ptCentSum.y += pt.y;
};
/* ======================================================================
    jsts/operation/polygonize/EdgeRing.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Port source:
 * /jts/jts/java/src/com/vividsolutions/jts/operation/polygonize/EdgeRing.java
 * Revision: 109
 */

(function() {

  /**
   * Represents a ring of {@link PolygonizeDirectedEdge}s which form a ring of
   * a polygon. The ring may be either an outer shell or a hole.
   */
  var EdgeRing = function(factory) {
    this.deList = new javascript.util.ArrayList();

    this.factory = factory;
  };



  /**
   * Find the innermost enclosing shell EdgeRing containing the argument
   * EdgeRing, if any. The innermost enclosing ring is the <i>smallest</i>
   * enclosing ring. The algorithm used depends on the fact that: <br>
   * ring A contains ring B iff envelope(ring A) contains envelope(ring B) <br>
   * This routine is only safe to use if the chosen point of the hole is known
   * to be properly contained in a shell (which is guaranteed to be the case if
   * the hole does not touch its shell)
   *
   * @param {EdgeRing}
   *          testEr
   * @param {List}
   *          shellList
   *
   * @return containing EdgeRing, if there is one.
   * @return null if no containing EdgeRing is found.
   */
  EdgeRing.findEdgeRingContaining = function(testEr, shellList) {
    var testRing = testEr.getRing();
    var testEnv = testRing.getEnvelopeInternal();
    var testPt = testRing.getCoordinateN(0);

    var minShell = null;
    var minEnv = null;
    for (var it = shellList.iterator(); it.hasNext();) {
      var tryShell = it.next();
      var tryRing = tryShell.getRing();
      var tryEnv = tryRing.getEnvelopeInternal();
      if (minShell != null)
        minEnv = minShell.getRing().getEnvelopeInternal();
      var isContained = false;
      // the hole envelope cannot equal the shell envelope
      if (tryEnv.equals(testEnv))
        continue;

      testPt = jsts.geom.CoordinateArrays.ptNotInList(
          testRing.getCoordinates(), tryRing.getCoordinates());
      if (tryEnv.contains(testEnv) &&
          jsts.algorithm.CGAlgorithms.isPointInRing(testPt, tryRing
              .getCoordinates()))
        isContained = true;
      // check if this new containing ring is smaller than the current minimum
      // ring
      if (isContained) {
        if (minShell == null || minEnv.contains(tryEnv)) {
          minShell = tryShell;
        }
      }
    }
    return minShell;
  };

  /**
   * Finds a point in a list of points which is not contained in another list of
   * points
   *
   * @param {Coordinate[]}
   *          testPts the {@link Coordinate}s to test.
   * @param {Coordinate[]}
   *          pts an array of {@link Coordinate}s to test the input points
   *          against.
   * @return a {@link Coordinate} from <code>testPts</code> which is not in
   *         <code>pts</code>,.
   * @return null if there is no coordinate not in the list.
   */
  EdgeRing.ptNotInList = function(testPts, pts) {
    for (var i = 0; i < testPts.length; i++) {
      var testPt = testPts[i];
      if (!isInList(testPt, pts))
        return testPt;
    }
    return null;
  };

  /**
   * Tests whether a given point is in an array of points. Uses a value-based
   * test.
   *
   * @param {Coordinate}
   *          pt a {@link Coordinate} for the test point.
   * @param {Coordinate[]}
   *          pts an array of {@link Coordinate}s to test.
   * @return <code>true</code> if the point is in the array.
   */
  EdgeRing.isInList = function(pt, pts) {
    for (var i = 0; i < pts.length; i++) {
      if (pt.equals(pts[i]))
        return true;
    }
    return false;
  }

  EdgeRing.prototype.factory = null;

  EdgeRing.prototype.deList = null;

  // cache the following data for efficiency
  EdgeRing.prototype.ring = null;

  EdgeRing.prototype.ringPts = null;
  EdgeRing.prototype.holes = null;

  /**
   * Adds a {@link DirectedEdge} which is known to form part of this ring.
   *
   * @param de
   *          the {@link DirectedEdge} to add.
   */
  EdgeRing.prototype.add = function(de) {
    this.deList.add(de);
  };

  /**
   * Tests whether this ring is a hole. Due to the way the edges in the
   * polyongization graph are linked, a ring is a hole if it is oriented
   * counter-clockwise.
   *
   * @return <code>true</code> if this ring is a hole.
   */
  EdgeRing.prototype.isHole = function() {
    var ring = this.getRing();
    return jsts.algorithm.CGAlgorithms.isCCW(ring.getCoordinates());
  };

  /**
   * Adds a hole to the polygon formed by this ring.
   *
   * @param hole
   *          the {@link LinearRing} forming the hole.
   */
  EdgeRing.prototype.addHole = function(hole) {
    if (this.holes == null)
      this.holes = new javascript.util.ArrayList();
    this.holes.add(hole);
  };

  /**
   * Computes the {@link Polygon} formed by this ring and any contained holes.
   *
   * @return the {@link Polygon} formed by this ring and its holes.
   */
  EdgeRing.prototype.getPolygon = function() {
    var holeLR = null;
    if (this.holes != null) {
      holeLR = [];
      for (var i = 0; i < this.holes.size(); i++) {
        holeLR[i] = this.holes.get(i);
      }
    }
    var poly = this.factory.createPolygon(this.ring, holeLR);
    return poly;
  };

  /**
   * Tests if the {@link LinearRing} ring formed by this edge ring is
   * topologically valid.
   *
   * @return true if the ring is valid.
   */
  EdgeRing.prototype.isValid = function() {
    this.getCoordinates();
    if (this.ringPts.length <= 3)
      return false;
    this.getRing();
    return this.ring.isValid();
  };

  /**
   * Computes the list of coordinates which are contained in this ring. The
   * coordinatea are computed once only and cached.
   *
   * @return an array of the {@link Coordinate} s in this ring.
   */
  EdgeRing.prototype.getCoordinates = function() {
    if (this.ringPts == null) {
      var coordList = new jsts.geom.CoordinateList();
      for (var i = this.deList.iterator(); i.hasNext();) {
        var de = i.next();
        var edge = de.getEdge();
        EdgeRing.addEdge(edge.getLine().getCoordinates(), de.getEdgeDirection(),
            coordList);
      }
      this.ringPts = coordList.toCoordinateArray();
    }
    return this.ringPts;
  };

  /**
   * Gets the coordinates for this ring as a {@link LineString}. Used to return
   * the coordinates in this ring as a valid geometry, when it has been detected
   * that the ring is topologically invalid.
   *
   * @return a {@link LineString} containing the coordinates in this ring.
   */
  EdgeRing.prototype.getLineString = function() {
    this.getCoordinates();
    return this.factory.createLineString(this.ringPts);
  };

  /**
   * Returns this ring as a {@link LinearRing}, or null if an Exception occurs
   * while creating it (such as a topology problem). Details of problems are
   * written to standard output.
   */
  EdgeRing.prototype.getRing = function() {
    if (this.ring != null)
      return this.ring;
    this.getCoordinates();
    if (this.ringPts.length < 3)
      console.log(this.ringPts);
    try {
      this.ring = this.factory.createLinearRing(this.ringPts);
    } catch (ex) {
      console.log(this.ringPts);
    }
    return this.ring;
  };

  EdgeRing.addEdge = function(coords, isForward, coordList) {
    if (isForward) {
      for (var i = 0; i < coords.length; i++) {
        coordList.add(coords[i], false);
      }
    } else {
      for (var i = coords.length - 1; i >= 0; i--) {
        coordList.add(coords[i], false);
      }
    }
  };

  jsts.operation.polygonize.EdgeRing = EdgeRing;

})();
/* ======================================================================
    jsts/planargraph/GraphComponent.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Port source:
 * /jts/jts/java/src/com/vividsolutions/jts/planargraph/GraphComponent.java
 * Revision: 6
 */

(function() {

  /**
   * The base class for all graph component classes. Maintains flags of use in
   * generic graph algorithms. Provides two flags:
   * <ul>
   * <li><b>marked</b> - typically this is used to indicate a state that
   * persists for the course of the graph's lifetime. For instance, it can be
   * used to indicate that a component has been logically deleted from the
   * graph.
   * <li><b>visited</b> - this is used to indicate that a component has been
   * processed or visited by an single graph algorithm. For instance, a
   * breadth-first traversal of the graph might use this to indicate that a node
   * has already been traversed. The visited flag may be set and cleared many
   * times during the lifetime of a graph.
   *
   * <p>
   * Graph components support storing user context data. This will typically be
   * used by client algorithms which use planar graphs.
   */
  var GraphComponent = function() {

  };

  /**
   * Sets the Visited state for all {@link GraphComponent}s in an
   * {@link Iterator}
   *
   * @param i
   *          the Iterator to scan.
   * @param visited
   *          the state to set the visited flag to.
   */
  GraphComponent.setVisited = function(i, visited) {
    while (i.hasNext()) {
      var comp = i.next();
      comp.setVisited(visited);
    }
  };

  /**
   * Sets the Marked state for all {@link GraphComponent}s in an
   * {@link Iterator}
   *
   * @param i
   *          the Iterator to scan.
   * @param marked
   *          the state to set the Marked flag to.
   */
  GraphComponent.setMarked = function(i, marked) {
    while (i.hasNext()) {
      var comp = i.next();
      comp.setMarked(marked);
    }
  };

  /**
   * Finds the first {@link GraphComponent} in a {@link Iterator} set which has
   * the specified visited state.
   *
   * @param i
   *          an Iterator of GraphComponents.
   * @param visitedState
   *          the visited state to test.
   * @return the first component found, or <code>null</code> if none found.
   */
  GraphComponent.getComponentWithVisitedState = function(i, visitedState) {
    while (i.hasNext()) {
      var comp = i.next();
      if (comp.isVisited() == visitedState)
        return comp;
    }
    return null;
  };

  GraphComponent.prototype._isMarked = false;
  GraphComponent.prototype._isVisited = false;
  GraphComponent.prototype.data;


  /**
   * Tests if a component has been visited during the course of a graph
   * algorithm
   *
   * @return <code>true</code> if the component has been visited.
   */
  GraphComponent.prototype.isVisited = function() {
    return this._isVisited;
  };

  /**
   * Sets the visited flag for this component.
   *
   * @param isVisited
   *          the desired value of the visited flag.
   */
  GraphComponent.prototype.setVisited = function(isVisited) {
    this._isVisited = isVisited;
  };

  /**
   * Tests if a component has been marked at some point during the processing
   * involving this graph.
   *
   * @return <code>true</code> if the component has been marked.
   */
  GraphComponent.prototype.isMarked = function() {
    return this._isMarked;
  };

  /**
   * Sets the marked flag for this component.
   *
   * @param isMarked
   *          the desired value of the marked flag.
   */
  GraphComponent.prototype.setMarked = function(isMarked) {
    this._isMarked = isMarked;
  };

  /**
   * Sets the user-defined data for this component.
   *
   * @param data
   *          an Object containing user-defined data.
   */
  GraphComponent.prototype.setContext = function(data) {
    this.data = data;
  };

  /**
   * Gets the user-defined data for this component.
   *
   * @return the user-defined data.
   */
  GraphComponent.prototype.getContext = function() {
    return data;
  };

  /**
   * Sets the user-defined data for this component.
   *
   * @param data
   *          an Object containing user-defined data.
   */
  GraphComponent.prototype.setData = function(data) {
    this.data = data;
  };

  /**
   * Gets the user-defined data for this component.
   *
   * @return the user-defined data.
   */
  GraphComponent.prototype.getData = function() {
    return data;
  };

  /**
   * Tests whether this component has been removed from its containing graph
   *
   * @return <code>true</code> if this component is removed.
   */
  GraphComponent.prototype.isRemoved = function() {
    throw new jsts.error.AbstractMethodInvocationError();
  };

  jsts.planargraph.GraphComponent = GraphComponent;

})();
/* ======================================================================
    jsts/planargraph/Edge.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Port source:
 * /jts/jts/java/src/com/vividsolutions/jts/planargraph/Edge.java
 * Revision: 6
 */

/**
 * @requires jsts/planargraph/GraphComponent.js
 */

(function() {

  var GraphComponent = jsts.planargraph.GraphComponent;

  /**
   * Represents an undirected edge of a {@link PlanarGraph}. An undirected edge
   * in fact simply acts as a central point of reference for two opposite
   * {@link DirectedEdge}s.
   * <p>
   * Usually a client using a <code>PlanarGraph</code> will subclass
   * <code>Edge</code> to add its own application-specific data and methods.
   *
   * Constructs an Edge initialized with the given DirectedEdges, and for each
   * DirectedEdge: sets the Edge, sets the symmetric DirectedEdge, and adds this
   * Edge to its from-Node.
   */
  var Edge = function(de0, de1) {
    if (de0 === undefined) {
      return;
    }
    this.setDirectedEdges(de0, de1);
  };

  Edge.prototype = new GraphComponent();


  /**
   * The two DirectedEdges associated with this Edge. Index 0 is forward, 1 is
   * reverse.
   */
  Edge.prototype.dirEdge = null;

  /**
   * Initializes this Edge's two DirectedEdges, and for each DirectedEdge: sets
   * the Edge, sets the symmetric DirectedEdge, and adds this Edge to its
   * from-Node.
   */
  Edge.prototype.setDirectedEdges = function(de0, de1) {
    this.dirEdge = [de0, de1];
    de0.setEdge(this);
    de1.setEdge(this);
    de0.setSym(de1);
    de1.setSym(de0);
    de0.getFromNode().addOutEdge(de0);
    de1.getFromNode().addOutEdge(de1);
  };

  /**
   * Returns one of the DirectedEdges associated with this Edge.
   *
   * @param i
   *          0 or 1. 0 returns the forward directed edge, 1 returns the reverse.
   */
  Edge.prototype.getDirEdge = function(i) {
    if (i instanceof jsts.planargraph.Node) {
      this.getDirEdge2(i);
    }

    return this.dirEdge[i];
  };

  /**
   * Returns the {@link DirectedEdge} that starts from the given node, or null
   * if the node is not one of the two nodes associated with this Edge.
   */
  Edge.prototype.getDirEdge2 = function(fromNode) {
    if (this.dirEdge[0].getFromNode() == fromNode)
      return this.dirEdge[0];
    if (this.dirEdge[1].getFromNode() == fromNode)
      return this.dirEdge[1];
    // node not found
    // possibly should throw an exception here?
    return null;
  };

  /**
   * If <code>node</code> is one of the two nodes associated with this Edge,
   * returns the other node; otherwise returns null.
   */
  Edge.prototype.getOppositeNode = function(node) {
    if (this.dirEdge[0].getFromNode() == node)
      return this.dirEdge[0].getToNode();
    if (this.dirEdge[1].getFromNode() == node)
      return this.dirEdge[1].getToNode();
    // node not found
    // possibly should throw an exception here?
    return null;
  };

  /**
   * Removes this edge from its containing graph.
   */
  Edge.prototype.remove = function() {
    this.dirEdge = null;
  };

  /**
   * Tests whether this edge has been removed from its containing graph
   *
   * @return <code>true</code> if this edge is removed.
   */
  Edge.prototype.isRemoved = function() {
    return dirEdge == null;
  };

  jsts.planargraph.Edge = Edge;

})();
/* ======================================================================
    jsts/operation/polygonize/PolygonizeEdge.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Port source:
 * /jts/jts/java/src/com/vividsolutions/jts/operation/polygonize/PolygonizeEdge.java
 * Revision: 6
 */

/**
 * @requires jsts/planargraph/Edge.js
 */


/**
 * An edge of a polygonization graph.
 */
jsts.operation.polygonize.PolygonizeEdge = function(line) {
  this.line = line;
};

jsts.operation.polygonize.PolygonizeEdge.prototype = new jsts.planargraph.Edge();

jsts.operation.polygonize.PolygonizeEdge.prototype.line = null;

jsts.operation.polygonize.PolygonizeEdge.prototype.getLine = function() {
  return this.line;
};
/* ======================================================================
    jsts/planargraph/DirectedEdge.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Port source:
 * /jts/jts/java/src/com/vividsolutions/jts/planargraph/DirectedEdge.java
 * Revision: 6
 */

/**
 * @requires jsts/planargraph/GraphComponent.js
 */

(function() {

  var ArrayList = javascript.util.ArrayList;
  var GraphComponent = jsts.planargraph.GraphComponent;

  /**
   * Represents a directed edge in a {@link PlanarGraph}. A DirectedEdge may or
   * may not have a reference to a parent {@link Edge} (some applications of
   * planar graphs may not require explicit Edge objects to be created). Usually
   * a client using a <code>PlanarGraph</code> will subclass
   * <code>DirectedEdge</code> to add its own application-specific data and
   * methods.
   *
   * Constructs a DirectedEdge connecting the <code>from</code> node to the
   * <code>to</code> node.
   *
   * @param directionPt
   *          specifies this DirectedEdge's direction vector (determined by the
   *          vector from the <code>from</code> node to
   *          <code>directionPt</code>).
   * @param edgeDirection
   *          whether this DirectedEdge's direction is the same as or opposite
   *          to that of the parent Edge (if any).
   */
  var DirectedEdge = function(from, to, directionPt, edgeDirection) {
    if (from === undefined) {
      return;
    }

    this.from = from;
    this.to = to;
    this.edgeDirection = edgeDirection;
    this.p0 = from.getCoordinate();
    this.p1 = directionPt;
    var dx = this.p1.x - this.p0.x;
    var dy = this.p1.y - this.p0.y;
    this.quadrant = jsts.geomgraph.Quadrant.quadrant(dx, dy);
    this.angle = Math.atan2(dy, dx);
  };

  DirectedEdge.prototype = new GraphComponent();

  /**
   * Returns a List containing the parent Edge (possibly null) for each of the
   * given DirectedEdges.
   */
  DirectedEdge.toEdges = function(dirEdges) {
    var edges = new ArrayList();
    for (var i = dirEdges.iterator(); i.hasNext();) {
      edges.add((i.next()).parentEdge);
    }
    return edges;
  };

  DirectedEdge.prototype.parentEdge = null;
  DirectedEdge.prototype.from = null;
  DirectedEdge.prototype.to = null;
  DirectedEdge.prototype.p0 = null;
  DirectedEdge.prototype.p1 = null;
  DirectedEdge.prototype.sym = null; // optional
  DirectedEdge.prototype.edgeDirection = null;
  DirectedEdge.prototype.quadrant = null;
  DirectedEdge.prototype.angle = null;

  /**
   * Returns this DirectedEdge's parent Edge, or null if it has none.
   */
  DirectedEdge.prototype.getEdge = function() {
    return this.parentEdge;
  };

  /**
   * Associates this DirectedEdge with an Edge (possibly null, indicating no
   * associated Edge).
   */
  DirectedEdge.prototype.setEdge = function(parentEdge) {
    this.parentEdge = parentEdge;
  };

  /**
   * Returns 0, 1, 2, or 3, indicating the quadrant in which this DirectedEdge's
   * orientation lies.
   */
  DirectedEdge.prototype.getQuadrant = function() {
    return this.quadrant;
  };

  /**
   * Returns a point to which an imaginary line is drawn from the from-node to
   * specify this DirectedEdge's orientation.
   */
  DirectedEdge.prototype.getDirectionPt = function() {
    return this.p1;
  };

  /**
   * Returns whether the direction of the parent Edge (if any) is the same as
   * that of this Directed Edge.
   */
  DirectedEdge.prototype.getEdgeDirection = function() {
    return this.edgeDirection;
  };

  /**
   * Returns the node from which this DirectedEdge leaves.
   */
  DirectedEdge.prototype.getFromNode = function() {
    return this.from;
  };

  /**
   * Returns the node to which this DirectedEdge goes.
   */
  DirectedEdge.prototype.getToNode = function() {
    return this.to;
  };

  /**
   * Returns the coordinate of the from-node.
   */
  DirectedEdge.prototype.getCoordinate = function() {
    return this.from.getCoordinate();
  };

  /**
   * Returns the angle that the start of this DirectedEdge makes with the
   * positive x-axis, in radians.
   */
  DirectedEdge.prototype.getAngle = function() {
    return this.angle;
  };

  /**
   * Returns the symmetric DirectedEdge -- the other DirectedEdge associated
   * with this DirectedEdge's parent Edge.
   */
  DirectedEdge.prototype.getSym = function() {
    return this.sym;
  };

  /**
   * Sets this DirectedEdge's symmetric DirectedEdge, which runs in the opposite
   * direction.
   */
  DirectedEdge.prototype.setSym = function(sym) {
    this.sym = sym;
  };

  /**
   * Removes this directed edge from its containing graph.
   */
  DirectedEdge.prototype.remove = function() {
    this.sym = null;
    this.parentEdge = null;
  };

  /**
   * Tests whether this directed edge has been removed from its containing graph
   *
   * @return <code>true</code> if this directed edge is removed.
   */
  DirectedEdge.prototype.isRemoved = function() {
    return this.parentEdge == null;
  };

  /**
   * Returns 1 if this DirectedEdge has a greater angle with the positive x-axis
   * than b", 0 if the DirectedEdges are collinear, and -1 otherwise.
   * <p>
   * Using the obvious algorithm of simply computing the angle is not robust,
   * since the angle calculation is susceptible to roundoff. A robust algorithm
   * is:
   * <ul>
   * <li>first compare the quadrants. If the quadrants are different, it it
   * trivial to determine which vector is "greater".
   * <li>if the vectors lie in the same quadrant, the robust
   * {@link CGAlgorithms#computeOrientation(Coordinate, Coordinate, Coordinate)}
   * function can be used to decide the relative orientation of the vectors.
   * </ul>
   */
  DirectedEdge.prototype.compareTo = function(obj) {
    var de = obj;
    return this.compareDirection(de);
  };

  /**
   * Returns 1 if this DirectedEdge has a greater angle with the positive x-axis
   * than b", 0 if the DirectedEdges are collinear, and -1 otherwise.
   * <p>
   * Using the obvious algorithm of simply computing the angle is not robust,
   * since the angle calculation is susceptible to roundoff. A robust algorithm
   * is:
   * <ul>
   * <li>first compare the quadrants. If the quadrants are different, it it
   * trivial to determine which vector is "greater".
   * <li>if the vectors lie in the same quadrant, the robust
   * {@link CGAlgorithms#computeOrientation(Coordinate, Coordinate, Coordinate)}
   * function can be used to decide the relative orientation of the vectors.
   * </ul>
   */
  DirectedEdge.prototype.compareDirection = function(e) {
    // if the rays are in different quadrants, determining the ordering is
    // trivial
    if (this.quadrant > e.quadrant)
      return 1;
    if (this.quadrant < e.quadrant)
      return -1;
    // vectors are in the same quadrant - check relative orientation of
    // direction vectors
    // this is > e if it is CCW of e
    return jsts.algorithm.CGAlgorithms.computeOrientation(e.p0, e.p1, this.p1);
  };

  jsts.planargraph.DirectedEdge = DirectedEdge;

})();
/* ======================================================================
    jsts/operation/polygonize/PolygonizeDirectedEdge.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Port source:
 * /jts/jts/java/src/com/vividsolutions/jts/operation/polygonize/PolygonizeDirectedEdge.java
 * Revision: 6
 */

/**
 * @requires jsts/planargraph/DirectedEdge.js
 */

(function() {

  var DirectedEdge = jsts.planargraph.DirectedEdge;

  /**
   * A {@link DirectedEdge} of a {@link PolygonizeGraph}, which represents an
   * edge of a polygon formed by the graph. May be logically deleted from the
   * graph by setting the <code>marked</code> flag.
   *
   * Constructs a directed edge connecting the <code>from</code> node to the
   * <code>to</code> node.
   *
   * @param directionPt
   *          specifies this DirectedEdge's direction (given by an imaginary
   *          line from the <code>from</code> node to <code>directionPt</code>).
   * @param edgeDirection
   *          whether this DirectedEdge's direction is the same as or opposite
   *          to that of the parent Edge (if any).
   */
  var PolygonizeDirectedEdge = function(from, to, directionPt, edgeDirection) {
    DirectedEdge.apply(this, arguments);
  };

  PolygonizeDirectedEdge.prototype = new DirectedEdge();

  PolygonizeDirectedEdge.prototype.edgeRing = null;
  PolygonizeDirectedEdge.prototype.next = null;
  PolygonizeDirectedEdge.prototype.label = -1;

  /**
   * Returns the identifier attached to this directed edge.
   */
  PolygonizeDirectedEdge.prototype.getLabel = function() {
    return this.label;
  };
  /**
   * Attaches an identifier to this directed edge.
   */
  PolygonizeDirectedEdge.prototype.setLabel = function(label) {
    this.label = label;
  };

  /**
   * Returns the next directed edge in the EdgeRing that this directed edge is a
   * member of.
   */
  PolygonizeDirectedEdge.prototype.getNext = function() {
    return this.next;
  };

  /**
   * Sets the next directed edge in the EdgeRing that this directed edge is a
   * member of.
   */
  PolygonizeDirectedEdge.prototype.setNext = function(next) {
    this.next = next;
  };

  /**
   * Returns the ring of directed edges that this directed edge is a member of,
   * or null if the ring has not been set.
   *
   * @see #setRing(EdgeRing)
   */
  PolygonizeDirectedEdge.prototype.isInRing = function() {
    return this.edgeRing != null;
  };

  /**
   * Sets the ring of directed edges that this directed edge is a member of.
   */
  PolygonizeDirectedEdge.prototype.setRing = function(edgeRing) {
    this.edgeRing = edgeRing;
  };

  jsts.operation.polygonize.PolygonizeDirectedEdge = PolygonizeDirectedEdge;

})();
/* ======================================================================
    jsts/planargraph/DirectedEdgeStar.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Port source:
 * /jts/jts/java/src/com/vividsolutions/jts/planargraph/DirectedEdge.java
 * Revision: 6
 */


(function() {

  var ArrayList = javascript.util.ArrayList;

  /**
   * A sorted collection of {@link DirectedEdge}s which leave a {@link Node} in
   * a {@link PlanarGraph}.
   *
   * Constructs a DirectedEdgeStar with no edges.
   */
  var DirectedEdgeStar = function() {
    this.outEdges = new ArrayList();
  };


  /**
   * The underlying list of outgoing DirectedEdges
   */
  DirectedEdgeStar.prototype.outEdges = null;

  DirectedEdgeStar.prototype.sorted = false;

  /**
   * Adds a new member to this DirectedEdgeStar.
   */
  DirectedEdgeStar.prototype.add = function(de) {
    this.outEdges.add(de);
    this.sorted = false;
  };
  /**
   * Drops a member of this DirectedEdgeStar.
   */
  DirectedEdgeStar.prototype.remove = function(de) {
    this.outEdges.remove(de);
  };
  /**
   * Returns an Iterator over the DirectedEdges, in ascending order by angle
   * with the positive x-axis.
   */
  DirectedEdgeStar.prototype.iterator = function() {
    this.sortEdges();
    return this.outEdges.iterator();
  };

  /**
   * Returns the number of edges around the Node associated with this
   * DirectedEdgeStar.
   */
  DirectedEdgeStar.prototype.getDegree = function() {
    return this.outEdges.size();
  };

  /**
   * Returns the coordinate for the node at wich this star is based
   */
  DirectedEdgeStar.prototype.getCoordinate = function() {
    var it = iterator();
    if (!it.hasNext())
      return null;
    var e = it.next();
    return e.getCoordinate();
  };

  /**
   * Returns the DirectedEdges, in ascending order by angle with the positive
   * x-axis.
   */
  DirectedEdgeStar.prototype.getEdges = function() {
    this.sortEdges();
    return this.outEdges;
  };

  /**
   * @private
   */
  DirectedEdgeStar.prototype.sortEdges = function() {
    if (!this.sorted) {
      var array = this.outEdges.toArray();
      array.sort(function(a,b) { return a.compareTo(b);});
      this.outEdges = javascript.util.Arrays.asList(array);
      this.sorted = true;
    }
  };

  /**
   * Returns the zero-based index of the given Edge, after sorting in ascending
   * order by angle with the positive x-axis.
   */
  DirectedEdgeStar.prototype.getIndex = function(edge) {
    if (edge instanceof jsts.planargraph.DirectedEdge) {
      return this.getIndex2(edge);
    } else if (typeof (edge) === 'number') {
      return this.getIndex3(edge);
    }

    this.sortEdges();
    for (var i = 0; i < this.outEdges.size(); i++) {
      var de = this.outEdges.get(i);
      if (de.getEdge() == edge)
        return i;
    }
    return -1;
  };

  /**
   * Returns the zero-based index of the given DirectedEdge, after sorting in
   * ascending order by angle with the positive x-axis.
   */
  DirectedEdgeStar.prototype.getIndex2 = function(dirEdge) {
    this.sortEdges();
    for (var i = 0; i < this.outEdges.size(); i++) {
      var de = this.outEdges.get(i);
      if (de == dirEdge)
        return i;
    }
    return -1;
  };

  /**
   * Returns value of i modulo the number of edges in this DirectedEdgeStar
   * (i.e. the remainder when i is divided by the number of edges)
   *
   * @param i
   *          an integer (positive, negative or zero).
   */
  DirectedEdgeStar.prototype.getIndex3 = function(i) {
    var modi = toInt(i % this.outEdges.size());
    // I don't think modi can be 0 (assuming i is positive) [Jon Aquino
    // 10/28/2003]
    if (modi < 0)
      modi += this.outEdges.size();
    return modi;
  };

  /**
   * Returns the {@link DirectedEdge} on the left-hand (CCW) side of the given
   * {@link DirectedEdge} (which must be a member of this DirectedEdgeStar).
   */
  DirectedEdgeStar.prototype.getNextEdge = function(dirEdge) {
    var i = this.getIndex(dirEdge);
    return this.outEdges.get(getIndex(i + 1));
  };

  /**
   * Returns the {@link DirectedEdge} on the right-hand (CW) side of the given
   * {@link DirectedEdge} (which must be a member of this DirectedEdgeStar).
   */
  DirectedEdgeStar.prototype.getNextCWEdge = function(dirEdge) {
    var i = this.getIndex(dirEdge);
    return this.outEdges.get(getIndex(i - 1));
  };

  jsts.planargraph.DirectedEdgeStar = DirectedEdgeStar;

})();
/* ======================================================================
    jsts/planargraph/Node.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Port source:
 * /jts/jts/java/src/com/vividsolutions/jts/planargraph/Node.java
 * Revision: 6
 */

/**
 * @requires jsts/planargraph/GraphComponent.js
 * @requires jsts/planargraph/DirectedEdgeStar.js
 */

(function() {

  var GraphComponent = jsts.planargraph.GraphComponent;
  var DirectedEdgeStar = jsts.planargraph.DirectedEdgeStar;

  /**
   * A node in a {@link PlanarGraph}is a location where 0 or more {@link Edge}s
   * meet. A node is connected to each of its incident Edges via an outgoing
   * DirectedEdge. Some clients using a <code>PlanarGraph</code> may want to
   * subclass <code>Node</code> to add their own application-specific data and
   * methods.
   *
   * Constructs a Node with the given location and collection of outgoing
   * DirectedEdges.
   */
  var Node = function(pt, deStar) {
    this.pt = pt;
    this.deStar = deStar || new DirectedEdgeStar();
  };


  Node.prototype = new GraphComponent();


  /**
   * Returns all Edges that connect the two nodes (which are assumed to be
   * different).
   */
  Node.getEdgesBetween = function(node0, node1) {
    var edges0 = DirectedEdge.toEdges(node0.getOutEdges().getEdges());
    var commonEdges = new javascript.util.HashSet(edges0);
    var edges1 = DirectedEdge.toEdges(node1.getOutEdges().getEdges());
    commonEdges.retainAll(edges1);
    return commonEdges;
  };

  /** The location of this Node */
  Node.prototype.pt = null;

  /** The collection of DirectedEdges that leave this Node */
  Node.prototype.deStar = null;

  /**
   * Returns the location of this Node.
   */
  Node.prototype.getCoordinate = function() {
    return this.pt;
  };

  /**
   * Adds an outgoing DirectedEdge to this Node.
   */
  Node.prototype.addOutEdge = function(de) {
    this.deStar.add(de);
  };

  /**
   * Returns the collection of DirectedEdges that leave this Node.
   */
  Node.prototype.getOutEdges = function() {
    return this.deStar;
  };

  /**
   * Returns the number of edges around this Node.
   */
  Node.prototype.getDegree = function() {
    return this.deStar.getDegree();
  };

  /**
   * Returns the zero-based index of the given Edge, after sorting in ascending
   * order by angle with the positive x-axis.
   */
  Node.prototype.getIndex = function(edge) {
    return this.deStar.getIndex(edge);
  };

  /**
   * Removes a {@link DirectedEdge} incident on this node. Does not change the
   * state of the directed edge.
   */
  Node.prototype.remove = function(de) {
    if (de === undefined) {
      return this.remove2();
    }

    this.deStar.remove(de);
  };

  /**
   * Removes this node from its containing graph.
   */
  Node.prototype.remove2 = function() {
    this.pt = null;
  };


  /**
   * Tests whether this node has been removed from its containing graph
   *
   * @return <code>true</code> if this node is removed.
   */
  Node.prototype.isRemoved = function() {
    return this.pt == null;
  };

  jsts.planargraph.Node = Node;

})();
/* ======================================================================
    jsts/planargraph/NodeMap.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Port source:
 * /jts/jts/java/src/com/vividsolutions/jts/planargraph/NodeMap.java
 * Revision: 6
 */

/**
 * @requires jsts/geom/Coordinate.js
 * @requires jsts/planargraph/Node.js
 */

(function() {

  /**
   * A map of {@link Node}s, indexed by the coordinate of the node.
   *
   * Constructs a NodeMap without any Nodes.
   */
  var NodeMap = function() {
    this.nodeMap = new javascript.util.TreeMap();
  };


  NodeMap.prototype.nodeMap = null;


  /**
   * Adds a node to the map, replacing any that is already at that location.
   *
   * @return the added node.
   */
  NodeMap.prototype.add = function(n) {
    this.nodeMap.put(n.getCoordinate(), n);
    return n;
  };

  /**
   * Removes the Node at the given location, and returns it (or null if no Node
   * was there).
   */
  NodeMap.prototype.remove = function(pt) {
    return this.nodeMap.remove(pt);
  };

  /**
   * Returns the Node at the given location, or null if no Node was there.
   */
  NodeMap.prototype.find = function(coord) {
    return this.nodeMap.get(coord);
  };

  /**
   * Returns an Iterator over the Nodes in this NodeMap, sorted in ascending
   * order by angle with the positive x-axis.
   */
  NodeMap.prototype.iterator = function() {
    return this.nodeMap.values().iterator();
  };

  /**
   * Returns the Nodes in this NodeMap, sorted in ascending order by angle with
   * the positive x-axis.
   */
  NodeMap.prototype.values = function() {
    return this.nodeMap.values();
  };

  jsts.planargraph.NodeMap = NodeMap;

})();
/* ======================================================================
    jsts/planargraph/PlanarGraph.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Port source:
 * /jts/jts/java/src/com/vividsolutions/jts/planargraph/PlanarGraph.java
 * Revision: 107
 */

/**
 * @requires jsts/planargraph/NodeMap.js
 */

(function() {

  var ArrayList = javascript.util.ArrayList;


  /**
   * Represents a directed graph which is embeddable in a planar surface.
   * <p>
   * This class and the other classes in this package serve as a framework for
   * building planar graphs for specific algorithms. This class must be
   * subclassed to expose appropriate methods to construct the graph. This
   * allows controlling the types of graph components ({@link DirectedEdge}s,
   * {@link Edge}s and {@link Node}s) which can be added to the graph. An
   * application which uses the graph framework will almost always provide
   * subclasses for one or more graph components, which hold
   * application-specific data and graph algorithms.
   *
   * Constructs a empty graph.
   */
  var PlanarGraph = function() {
    this.edges = new javascript.util.HashSet();
    this.dirEdges = new javascript.util.HashSet();
    this.nodeMap = new jsts.planargraph.NodeMap();
  };


  PlanarGraph.prototype.edges = null;
  PlanarGraph.prototype.dirEdges = null;
  PlanarGraph.prototype.nodeMap = null;


  /**
   * Returns the {@link Node} at the given location, or null if no {@link Node}
   * was there.
   *
   * @param pt
   *          the location to query.
   * @return the node found.
   * @return <code>null</code> if this graph contains no node at the location.
   */
  PlanarGraph.prototype.findNode = function(pt) {
    return this.nodeMap.find(pt);
  };

  /**
   * Adds a node to the map, replacing any that is already at that location.
   * Only subclasses can add Nodes, to ensure Nodes are of the right type.
   *
   * @param node
   *          the node to add.
   */
  PlanarGraph.prototype.add = function(node) {
    if (node instanceof jsts.planargraph.Edge) {
      return this.add2(node);
    } else if (node instanceof jsts.planargraph.DirectedEdge) {
      return this.add3(node);
    }

    this.nodeMap.add(node);
  };

  /**
   * Adds the Edge and its DirectedEdges with this PlanarGraph. Assumes that the
   * Edge has already been created with its associated DirectEdges. Only
   * subclasses can add Edges, to ensure the edges added are of the right class.
   */
  PlanarGraph.prototype.add2 = function(edge) {
    this.edges.add(edge);
    this.add(edge.getDirEdge(0));
    this.add(edge.getDirEdge(1));
  };

  /**
   * Adds the Edge to this PlanarGraph; only subclasses can add DirectedEdges,
   * to ensure the edges added are of the right class.
   */
  PlanarGraph.prototype.add3 = function(dirEdge) {
    this.dirEdges.add(dirEdge);
  };

  /**
   * Returns an Iterator over the Nodes in this PlanarGraph.
   */
  PlanarGraph.prototype.nodeIterator = function() {
    return this.nodeMap.iterator();
  };

  /**
   * Returns the Nodes in this PlanarGraph.
   */

  /**
   * Tests whether this graph contains the given {@link Edge}
   *
   * @param e
   *          the edge to query.
   * @return <code>true</code> if the graph contains the edge.
   */
  PlanarGraph.prototype.contains = function(e) {
    if (e instanceof jsts.planargraph.DirectedEdge) {
      return this.contains2(e);
    }

    return this.edges.contains(e);
  };

  /**
   * Tests whether this graph contains the given {@link DirectedEdge}
   *
   * @param de
   *          the directed edge to query.
   * @return <code>true</code> if the graph contains the directed edge.
   */
  PlanarGraph.prototype.contains2 = function(de) {
    return this.dirEdges.contains(de);
  };

  PlanarGraph.prototype.getNodes = function() {
    return this.nodeMap.values();
  };

  /**
   * Returns an Iterator over the DirectedEdges in this PlanarGraph, in the
   * order in which they were added.
   *
   * @see #add(Edge)
   * @see #add(DirectedEdge)
   */
  PlanarGraph.prototype.dirEdgeIterator = function() {
    return this.dirEdges.iterator();
  };
  /**
   * Returns an Iterator over the Edges in this PlanarGraph, in the order in
   * which they were added.
   *
   * @see #add(Edge)
   */
  PlanarGraph.prototype.edgeIterator = function() {
    return this.edges.iterator();
  };

  /**
   * Returns the Edges that have been added to this PlanarGraph
   *
   * @see #add(Edge)
   */
  PlanarGraph.prototype.getEdges = function() {
    return this.edges;
  };

  /**
   * Removes an {@link Edge} and its associated {@link DirectedEdge}s from
   * their from-Nodes and from the graph. Note: This method does not remove the
   * {@link Node}s associated with the {@link Edge}, even if the removal of
   * the {@link Edge} reduces the degree of a {@link Node} to zero.
   */
  PlanarGraph.prototype.remove = function(edge) {
    if (edge instanceof jsts.planargraph.DirectedEdge) {
      return this.remove2(edge);
    }

    this.remove(edge.getDirEdge(0));
    this.remove(edge.getDirEdge(1));
    this.edges.remove(edge);
    this.edge.remove();
  };

  /**
   * Removes a {@link DirectedEdge} from its from-{@link Node} and from this
   * graph. This method does not remove the {@link Node}s associated with the
   * DirectedEdge, even if the removal of the DirectedEdge reduces the degree of
   * a Node to zero.
   */
  PlanarGraph.prototype.remove2 = function(de) {
    if (de instanceof jsts.planargraph.Node) {
      return this.remove3(de);
    }

    var sym = de.getSym();
    if (sym != null)
      sym.setSym(null);

    de.getFromNode().remove(de);
    de.remove();
    this.dirEdges.remove(de);
  };

  /**
   * Removes a node from the graph, along with any associated DirectedEdges and
   * Edges.
   */
  PlanarGraph.prototype.remove3 = function(node) {
    // unhook all directed edges
    var outEdges = node.getOutEdges().getEdges();
    for (var i = outEdges.iterator(); i.hasNext();) {
      var de = i.next();
      var sym = de.getSym();
      // remove the diredge that points to this node
      if (sym != null)
        this.remove(sym);
      // remove this diredge from the graph collection
      this.dirEdges.remove(de);

      var edge = de.getEdge();
      if (edge != null) {
        this.edges.remove(edge);
      }

    }
    // remove the node from the graph
    this.nodeMap.remove(node.getCoordinate());
    node.remove();
  };

  /**
   * Returns all Nodes with the given number of Edges around it.
   */
  PlanarGraph.prototype.findNodesOfDegree = function(degree) {
    var nodesFound = new ArrayList();
    for (var i = this.nodeIterator(); i.hasNext();) {
      var node = i.next();
      if (node.getDegree() == degree)
        nodesFound.add(node);
    }
    return nodesFound;
  };

  jsts.planargraph.PlanarGraph = PlanarGraph;

})();
/* ======================================================================
    jsts/operation/polygonize/PolygonizeGraph.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Port source:
 * /jts/jts/java/src/com/vividsolutions/jts/operation/polygonize/PolygonizeDirectedEdge.java
 * Revision: 6
 */

/**
 * @requires jsts/operation/polygonize/EdgeRing.js
 * @requires jsts/operation/polygonize/PolygonizeEdge.js
 * @requires jsts/operation/polygonize/PolygonizeDirectedEdge.js
 * @requires jsts/geom/Coordinate.js
 * @requires jsts/planargraph/PlanarGraph.js
 * @requires jsts/planargraph/Node.js
 */

(function() {

  var ArrayList = javascript.util.ArrayList;
  var Stack = javascript.util.Stack;
  var HashSet = javascript.util.HashSet;
  var Assert = jsts.util.Assert;
  var EdgeRing = jsts.operation.polygonize.EdgeRing;
  var PolygonizeEdge = jsts.operation.polygonize.PolygonizeEdge;
  var PolygonizeDirectedEdge = jsts.operation.polygonize.PolygonizeDirectedEdge;
  var PlanarGraph = jsts.planargraph.PlanarGraph;
  var Node = jsts.planargraph.Node;

  /**
   * Represents a planar graph of edges that can be used to compute a
   * polygonization, and implements the algorithms to compute the
   * {@link EdgeRings} formed by the graph.
   * <p>
   * The marked flag on {@link DirectedEdge}s is used to indicate that a
   * directed edge has be logically deleted from the graph.
   *
   * Create a new polygonization graph.
   */
  var PolygonizeGraph = function(factory) {
    PlanarGraph.apply(this);

    this.factory = factory;
  };

  PolygonizeGraph.prototype = new PlanarGraph();

  /**
   * @private
   */
  PolygonizeGraph.getDegreeNonDeleted = function(node) {
    var edges = node.getOutEdges().getEdges();
    var degree = 0;
    for (var i = edges.iterator(); i.hasNext();) {
      var de = i.next();
      if (!de.isMarked())
        degree++;
    }
    return degree;
  };

  /**
   * @private
   */
  PolygonizeGraph.getDegree = function(node, label) {
    var edges = node.getOutEdges().getEdges();
    var degree = 0;
    for (var i = edges.iterator(); i.hasNext();) {
      var de = i.next();
      if (de.getLabel() == label)
        degree++;
    }
    return degree;
  };

  /**
   * Deletes all edges at a node
   *
   * @private
   */
  PolygonizeGraph.deleteAllEdges = function(node) {
    var edges = node.getOutEdges().getEdges();
    for (var i = edges.iterator(); i.hasNext();) {
      var de = i.next();
      de.setMarked(true);
      var sym = de.getSym();
      if (sym != null)
        sym.setMarked(true);
    }
  };


  PolygonizeGraph.prototype.factory = null;


  /**
   * Add a {@link LineString} forming an edge of the polygon graph.
   *
   * @param line
   *          the line to add.
   */
  PolygonizeGraph.prototype.addEdge = function(line) {
    if (line.isEmpty()) {
      return;
    }
    var linePts = jsts.geom.CoordinateArrays.removeRepeatedPoints(line.getCoordinates());

    if (linePts.length < 2) {
      return;
    }

    var startPt = linePts[0];
    var endPt = linePts[linePts.length - 1];

    var nStart = this.getNode(startPt);
    var nEnd = this.getNode(endPt);

    var de0 = new PolygonizeDirectedEdge(nStart, nEnd, linePts[1], true);
    var de1 = new PolygonizeDirectedEdge(nEnd, nStart,
        linePts[linePts.length - 2], false);
    var edge = new PolygonizeEdge(line);
    edge.setDirectedEdges(de0, de1);
    this.add(edge);
  };

  /**
   * @private
   */
  PolygonizeGraph.prototype.getNode = function(pt) {
    var node = this.findNode(pt);
    if (node == null) {
      node = new Node(pt);
      // ensure node is only added once to graph
      this.add(node);
    }
    return node;
  };

  /**
   * @private
   */
  PolygonizeGraph.prototype.computeNextCWEdges = function() {
    // set the next pointers for the edges around each node
    for (var iNode = this.nodeIterator(); iNode.hasNext();) {
      var node = iNode.next();
      PolygonizeGraph.computeNextCWEdges(node);
    }
  };

  /**
   * Convert the maximal edge rings found by the initial graph traversal into
   * the minimal edge rings required by JTS polygon topology rules.
   *
   * @param ringEdges
   *          the list of start edges for the edgeRings to convert.
   * @private
   */
  PolygonizeGraph.prototype.convertMaximalToMinimalEdgeRings = function(
      ringEdges) {
    for (var i = ringEdges.iterator(); i.hasNext();) {
      var de = i.next();
      var label = de.getLabel();
      var intNodes = PolygonizeGraph.findIntersectionNodes(de, label);

      if (intNodes == null)
        continue;
      // flip the next pointers on the intersection nodes to create minimal edge
      // rings
      for (var iNode = intNodes.iterator(); iNode.hasNext();) {
        var node = iNode.next();
        PolygonizeGraph.computeNextCCWEdges(node, label);
      }
    }
  };

  /**
   * Finds all nodes in a maximal edgering which are self-intersection nodes
   *
   * @param startDE
   * @param label
   * @return the list of intersection nodes found, or <code>null</code> if no
   *         intersection nodes were found.
   * @private
   */
  PolygonizeGraph.findIntersectionNodes = function(startDE, label) {
    var de = startDE;
    var intNodes = null;
    do {
      var node = de.getFromNode();
      if (PolygonizeGraph.getDegree(node, label) > 1) {
        if (intNodes == null)
          intNodes = new ArrayList();
        intNodes.add(node);
      }

      de = de.getNext();
      Assert.isTrue(de != null, 'found null DE in ring');
      Assert
          .isTrue(de == startDE || !de.isInRing(), 'found DE already in ring');
    } while (de != startDE);

    return intNodes;
  };

  /**
   * Computes the minimal EdgeRings formed by the edges in this graph.
   *
   * @return a list of the {@link EdgeRing} s found by the polygonization
   *         process.
   *
   */
  PolygonizeGraph.prototype.getEdgeRings = function() {
    // maybe could optimize this, since most of these pointers should be set
    // correctly already
    // by deleteCutEdges()
    this.computeNextCWEdges();
    // clear labels of all edges in graph
    PolygonizeGraph.label(this.dirEdges, -1);
    var maximalRings = PolygonizeGraph.findLabeledEdgeRings(this.dirEdges);
    this.convertMaximalToMinimalEdgeRings(maximalRings);

    // find all edgerings (which will now be minimal ones, as required)
    var edgeRingList = new ArrayList();
    for (var i = this.dirEdges.iterator(); i.hasNext();) {
      var de = i.next();
      if (de.isMarked())
        continue;
      if (de.isInRing())
        continue;

      var er = this.findEdgeRing(de);
      edgeRingList.add(er);
    }
    return edgeRingList;
  };

  /**
   * Finds and labels all edgerings in the graph. The edge rings are labelling
   * with unique integers. The labelling allows detecting cut edges.
   *
   * @param dirEdges
   *          a List of the DirectedEdges in the graph.
   * @return a List of DirectedEdges, one for each edge ring found.
   * @private
   */
  PolygonizeGraph.findLabeledEdgeRings = function(dirEdges) {
    var edgeRingStarts = new ArrayList();
    // label the edge rings formed
    var currLabel = 1;
    for (var i = dirEdges.iterator(); i.hasNext();) {
      var de = i.next();
      if (de.isMarked())
        continue;
      if (de.getLabel() >= 0)
        continue;

      edgeRingStarts.add(de);
      var edges = PolygonizeGraph.findDirEdgesInRing(de);

      PolygonizeGraph.label(edges, currLabel);
      currLabel++;
    }
    return edgeRingStarts;
  };

  /**
   * Finds and removes all cut edges from the graph.
   *
   * @return a list of the {@link LineString} s forming the removed cut edges.
   */
  PolygonizeGraph.prototype.deleteCutEdges = function() {
    this.computeNextCWEdges();
    // label the current set of edgerings
    PolygonizeGraph.findLabeledEdgeRings(this.dirEdges);

    /**
     * Cut Edges are edges where both dirEdges have the same label. Delete them,
     * and record them
     */
    var cutLines = new ArrayList();
    for (var i = this.dirEdges.iterator(); i.hasNext();) {
      var de = i.next();
      if (de.isMarked())
        continue;

      var sym = de.getSym();

      if (de.getLabel() == sym.getLabel()) {
        de.setMarked(true);
        sym.setMarked(true);

        // save the line as a cut edge
        var e = de.getEdge();
        cutLines.add(e.getLine());
      }
    }
    return cutLines;
  };

  /**
   * @private
   */
  PolygonizeGraph.label = function(dirEdges, label) {
    for (var i = dirEdges.iterator(); i.hasNext();) {
      var de = i.next();
      de.setLabel(label);
    }
  };

  /**
   * @private
   */
  PolygonizeGraph.computeNextCWEdges = function(node) {
    var deStar = node.getOutEdges();
    var startDE = null;
    var prevDE = null;

    // the edges are stored in CCW order around the star
    for (var i = deStar.getEdges().iterator(); i.hasNext();) {
      var outDE = i.next();
      if (outDE.isMarked())
        continue;

      if (startDE == null)
        startDE = outDE;
      if (prevDE != null) {
        var sym = prevDE.getSym();
        sym.setNext(outDE);
      }
      prevDE = outDE;
    }
    if (prevDE != null) {
      var sym = prevDE.getSym();
      sym.setNext(startDE);
    }
  };

  /**
   * Computes the next edge pointers going CCW around the given node, for the
   * given edgering label. This algorithm has the effect of converting maximal
   * edgerings into minimal edgerings
   *
   * @private
   *
   */
  PolygonizeGraph.computeNextCCWEdges = function(node, label) {
    var deStar = node.getOutEdges();
    // PolyDirectedEdge lastInDE = null;
    var firstOutDE = null;
    var prevInDE = null;

    // the edges are stored in CCW order around the star
    var edges = deStar.getEdges();
    // for (Iterator i = deStar.getEdges().iterator(); i.hasNext(); ) {
    for (var i = edges.size() - 1; i >= 0; i--) {
      var de = edges.get(i);
      var sym = de.getSym();

      var outDE = null;
      if (de.getLabel() == label)
        outDE = de;
      var inDE = null;
      if (sym.getLabel() == label)
        inDE = sym;

      if (outDE == null && inDE == null)
        continue; // this edge is not in edgering

      if (inDE != null) {
        prevInDE = inDE;
      }

      if (outDE != null) {
        if (prevInDE != null) {
          prevInDE.setNext(outDE);
          prevInDE = null;
        }
        if (firstOutDE == null)
          firstOutDE = outDE;
      }
    }
    if (prevInDE != null) {
      Assert.isTrue(firstOutDE != null);
      prevInDE.setNext(firstOutDE);
    }
  };

  /**
   * Traverses a ring of DirectedEdges, accumulating them into a list. This
   * assumes that all dangling directed edges have been removed from the graph,
   * so that there is always a next dirEdge.
   *
   * @param startDE
   *          the DirectedEdge to start traversing at.
   * @return a List of DirectedEdges that form a ring.
   * @private
   */
  PolygonizeGraph.findDirEdgesInRing = function(startDE) {
    var de = startDE;
    var edges = new ArrayList();
    do {
      edges.add(de);
      de = de.getNext();
      Assert.isTrue(de != null, 'found null DE in ring');
      Assert
          .isTrue(de == startDE || !de.isInRing(), 'found DE already in ring');
    } while (de != startDE);

    return edges;
  };

  /**
   * @private
   */
  PolygonizeGraph.prototype.findEdgeRing = function(startDE) {
    var de = startDE;
    var er = new EdgeRing(this.factory);
    do {
      er.add(de);
      de.setRing(er);
      de = de.getNext();
      Assert.isTrue(de != null, 'found null DE in ring');
      Assert
          .isTrue(de == startDE || !de.isInRing(), 'found DE already in ring');
    } while (de != startDE);

    return er;
  };

  /**
   * Marks all edges from the graph which are "dangles". Dangles are which are
   * incident on a node with degree 1. This process is recursive, since removing
   * a dangling edge may result in another edge becoming a dangle. In order to
   * handle large recursion depths efficiently, an explicit recursion stack is
   * used
   *
   * @return a List containing the {@link LineStrings} that formed dangles.
   */
  PolygonizeGraph.prototype.deleteDangles = function() {
    var nodesToRemove = this.findNodesOfDegree(1);
    var dangleLines = new HashSet();

    var nodeStack = new Stack();
    for (var i = nodesToRemove.iterator(); i.hasNext();) {
      nodeStack.push(i.next());
    }

    while (!nodeStack.isEmpty()) {
      var node = nodeStack.pop();

      PolygonizeGraph.deleteAllEdges(node);
      var nodeOutEdges = node.getOutEdges().getEdges();
      for (var i = nodeOutEdges.iterator(); i.hasNext();) {
        var de = i.next();
        // delete this edge and its sym
        de.setMarked(true);
        var sym = de.getSym();
        if (sym != null)
          sym.setMarked(true);

        // save the line as a dangle
        var e = de.getEdge();
        dangleLines.add(e.getLine());

        var toNode = de.getToNode();
        // add the toNode to the list to be processed, if it is now a dangle
        if (PolygonizeGraph.getDegreeNonDeleted(toNode) == 1)
          nodeStack.push(toNode);
      }
    }
    return dangleLines;
  };

  /**
   * Traverses the polygonized edge rings in the graph and computes the depth
   * parity (odd or even) relative to the exterior of the graph. If the client
   * has requested that the output be polygonally valid, only odd polygons will
   * be constructed.
   *
   */
  PolygonizeGraph.prototype.computeDepthParity = function() {
    while (true) {
      var de = null;
      if (de == null)
        return;
      this.computeDepthParity(de);
    }
  };

  /**
   * Traverses all connected edges, computing the depth parity of the associated
   * polygons.
   *
   * @param de
   * @private
   */
  PolygonizeGraph.prototype.computeDepthParity = function(de) {

  };

  jsts.operation.polygonize.PolygonizeGraph = PolygonizeGraph;

})();
/* ======================================================================
    jsts/index/strtree/Interval.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * A contiguous portion of 1D-space. Used internally by SIRtree.
 *
 * @param {jsts.index.strtree.Interval}
 *          [other].
 * @param {number}
 *          [min].
 * @param {number}
 *          [max].
 * @see SIRtree
 * @constructor
 */
jsts.index.strtree.Interval = function() {
  var other;
  if (arguments.length === 1) {
    other = arguments[0];
    return jsts.index.strtree.Interval(other.min, other.max);
  } else if (arguments.length === 2) {
    jsts.util.Assert.isTrue(this.min <= this.max);
    this.min = arguments[0];
    this.max = arguments[1];
  }
};


/**
 * @type {number}
 * @private
 */
jsts.index.strtree.Interval.prototype.min = null;


/**
 * @type {number}
 * @private
 */
jsts.index.strtree.Interval.prototype.max = null;


/**
 * @return {number}
 * @public
 */
jsts.index.strtree.Interval.prototype.getCentre = function() {
  return (this.min + this.max) / 2;
};


/**
 *
 * @param {jsts.index.strtree.Interval}
 *          other
 * @return {jsts.index.strtree.Interval} this.
 * @public
 */
jsts.index.strtree.Interval.prototype.expandToInclude = function(other) {
  this.max = Math.max(this.max, other.max);
  this.min = Math.min(this.min, other.min);
  return this;
};


/**
 *
 * @param {jsts.index.strtree.Interval}
 *          other
 * @return {boolean}
 * @public
 */
jsts.index.strtree.Interval.prototype.intersects = function(other) {
  return !(other.min > this.max || other.max < this.min);
};


/**
 *
 * @param {Object}
 *          o
 * @return {boolean}
 * @public
 */
jsts.index.strtree.Interval.prototype.equals = function(o) {
  if (!(o instanceof jsts.index.strtree.Interval)) {
    return false;
  }
  other = o;
  return this.min === other.min && this.max === other.max;
};
/* ======================================================================
    jsts/geom/GeometryFactory.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Supplies a set of utility methods for building Geometry objects from lists
 * of Coordinates.
 *
 * Note that the factory constructor methods do <b>not</b> change the input
 * coordinates in any way.
 *
 * In particular, they are not rounded to the supplied <tt>PrecisionModel</tt>.
 * It is assumed that input Coordinates meet the given precision.
 */

/**
 * @requires jsts/geom/PrecisionModel.js
 */

/**
 * Constructs a GeometryFactory that generates Geometries having a floating
 * PrecisionModel and a spatial-reference ID of 0.
 *
 * @constructor
 */
jsts.geom.GeometryFactory = function(precisionModel) {
  this.precisionModel = precisionModel || new jsts.geom.PrecisionModel();
};

jsts.geom.GeometryFactory.prototype.precisionModel = null;

jsts.geom.GeometryFactory.prototype.getPrecisionModel = function() {
  return this.precisionModel;
};


/**
 * Creates a Point using the given Coordinate; a null Coordinate will create an
 * empty Geometry.
 *
 * @param {Coordinate}
 *          coordinate Coordinate to base this Point on.
 * @return {Point} A new Point.
 */
jsts.geom.GeometryFactory.prototype.createPoint = function(coordinate) {
  var point = new jsts.geom.Point(coordinate, this);

  return point;
};


/**
 * Creates a LineString using the given Coordinates; a null or empty array will
 * create an empty LineString. Consecutive points must not be equal.
 *
 * @param {Coordinate[]}
 *          coordinates an array without null elements, or an empty array, or
 *          null.
 * @return {LineString} A new LineString.
 */
jsts.geom.GeometryFactory.prototype.createLineString = function(coordinates) {
  var lineString = new jsts.geom.LineString(coordinates, this);

  return lineString;
};


/**
 * Creates a LinearRing using the given Coordinates; a null or empty array will
 * create an empty LinearRing. The points must form a closed and simple
 * linestring. Consecutive points must not be equal.
 *
 * @param {Coordinate[]}
 *          coordinates an array without null elements, or an empty array, or
 *          null.
 * @return {LinearRing} A new LinearRing.
 */
jsts.geom.GeometryFactory.prototype.createLinearRing = function(coordinates) {
  var linearRing = new jsts.geom.LinearRing(coordinates, this);

  return linearRing;
};


/**
 * Constructs a <code>Polygon</code> with the given exterior boundary and
 * interior boundaries.
 *
 * @param {LinearRing}
 *          shell the outer boundary of the new <code>Polygon</code>, or
 *          <code>null</code> or an empty <code>LinearRing</code> if the
 *          empty geometry is to be created.
 * @param {LinearRing[]}
 *          holes the inner boundaries of the new <code>Polygon</code>, or
 *          <code>null</code> or empty <code>LinearRing</code> s if the
 *          empty geometry is to be created.
 * @return {Polygon} A new Polygon.
 */
jsts.geom.GeometryFactory.prototype.createPolygon = function(shell, holes) {
  var polygon = new jsts.geom.Polygon(shell, holes, this);

  return polygon;
};


jsts.geom.GeometryFactory.prototype.createMultiPoint = function(points) {
  if (points && points[0] instanceof jsts.geom.Coordinate) {
    var converted = [];
    var i;
    for (i = 0; i < points.length; i++) {
      converted.push(this.createPoint(points[i]));
    }
    points = converted;
  }

  return new jsts.geom.MultiPoint(points, this);
};

jsts.geom.GeometryFactory.prototype.createMultiLineString = function(
    lineStrings) {
  return new jsts.geom.MultiLineString(lineStrings, this);
};

jsts.geom.GeometryFactory.prototype.createMultiPolygon = function(polygons) {
  return new jsts.geom.MultiPolygon(polygons, this);
};


/**
 * Build an appropriate <code>Geometry</code>, <code>MultiGeometry</code>,
 * or <code>GeometryCollection</code> to contain the <code>Geometry</code>s
 * in it. For example:<br>
 *
 * <ul>
 * <li> If <code>geomList</code> contains a single <code>Polygon</code>,
 * the <code>Polygon</code> is returned.
 * <li> If <code>geomList</code> contains several <code>Polygon</code>s, a
 * <code>MultiPolygon</code> is returned.
 * <li> If <code>geomList</code> contains some <code>Polygon</code>s and
 * some <code>LineString</code>s, a <code>GeometryCollection</code> is
 * returned.
 * <li> If <code>geomList</code> is empty, an empty
 * <code>GeometryCollection</code> is returned
 * </ul>
 *
 * Note that this method does not "flatten" Geometries in the input, and hence
 * if any MultiGeometries are contained in the input a GeometryCollection
 * containing them will be returned.
 *
 * @param geomList
 *          the <code>Geometry</code>s to combine.
 * @return {Geometry} a <code>Geometry</code> of the "smallest", "most
 *         type-specific" class that can contain the elements of
 *         <code>geomList</code> .
 */
jsts.geom.GeometryFactory.prototype.buildGeometry = function(geomList) {

  /**
   * Determine some facts about the geometries in the list
   */
  var geomClass = null;
  var isHeterogeneous = false;
  var hasGeometryCollection = false;
  for (var i = geomList.iterator(); i.hasNext();) {
    var geom = i.next();

    var partClass = geom.CLASS_NAME;

    if (geomClass === null) {
      geomClass = partClass;
    }
    if (!(partClass === geomClass)) {
      isHeterogeneous = true;
    }
    if (geom.isGeometryCollectionBase())
      hasGeometryCollection = true;
  }

  /**
   * Now construct an appropriate geometry to return
   */
  // for the empty geometry, return an empty GeometryCollection
  if (geomClass === null) {
    return this.createGeometryCollection(null);
  }
  if (isHeterogeneous || hasGeometryCollection) {
    return this.createGeometryCollection(geomList.toArray());
  }
  // at this point we know the collection is hetereogenous.
  // Determine the type of the result from the first Geometry in the list
  // this should always return a geometry, since otherwise an empty collection
  // would have already been returned
  var geom0 = geomList.get(0);
  var isCollection = geomList.size() > 1;
  if (isCollection) {
    if (geom0 instanceof jsts.geom.Polygon) {
      return this.createMultiPolygon(geomList.toArray());
    } else if (geom0 instanceof jsts.geom.LineString) {
      return this.createMultiLineString(geomList.toArray());
    } else if (geom0 instanceof jsts.geom.Point) {
      return this.createMultiPoint(geomList.toArray());
    }
    jsts.util.Assert.shouldNeverReachHere('Unhandled class: ' + geom0);
  }
  return geom0;
};

jsts.geom.GeometryFactory.prototype.createGeometryCollection = function(
    geometries) {
  return new jsts.geom.GeometryCollection(geometries, this);
};

/**
 * Creates a {@link Geometry} with the same extent as the given envelope. The
 * Geometry returned is guaranteed to be valid. To provide this behaviour, the
 * following cases occur:
 * <p>
 * If the <code>Envelope</code> is:
 * <ul>
 * <li>null : returns an empty {@link Point}
 * <li>a point : returns a non-empty {@link Point}
 * <li>a line : returns a two-point {@link LineString}
 * <li>a rectangle : returns a {@link Polygon}> whose points are (minx, miny),
 * (minx, maxy), (maxx, maxy), (maxx, miny), (minx, miny).
 * </ul>
 *
 * @param {jsts.geom.Envelope}
 *          envelope the <code>Envelope</code> to convert.
 * @return {jsts.geom.Geometry} an empty <code>Point</code> (for null
 *         <code>Envelope</code>s), a <code>Point</code> (when min x = max
 *         x and min y = max y) or a <code>Polygon</code> (in all other cases).
 */
jsts.geom.GeometryFactory.prototype.toGeometry = function(envelope) {
  // null envelope - return empty point geometry
  if (envelope.isNull()) {
    return this.createPoint(null);
  }

  // point?
  if (envelope.getMinX() === envelope.getMaxX() &&
      envelope.getMinY() === envelope.getMaxY()) {
    return this.createPoint(new jsts.geom.Coordinate(envelope.getMinX(),
        envelope.getMinY()));
  }

  // vertical or horizontal line?
  if (envelope.getMinX() === envelope.getMaxX() ||
      envelope.getMinY() === envelope.getMaxY()) {
    return this.createLineString([
        new jsts.geom.Coordinate(envelope.getMinX(), envelope.getMinY()),
        new jsts.geom.Coordinate(envelope.getMaxX(), envelope.getMaxY())]);
  }

  // create a CW ring for the polygon
  return this.createPolygon(this.createLinearRing([
      new jsts.geom.Coordinate(envelope.getMinX(), envelope.getMinY()),
      new jsts.geom.Coordinate(envelope.getMinX(), envelope.getMaxY()),
      new jsts.geom.Coordinate(envelope.getMaxX(), envelope.getMaxY()),
      new jsts.geom.Coordinate(envelope.getMaxX(), envelope.getMinY()),
      new jsts.geom.Coordinate(envelope.getMinX(), envelope.getMinY())]), null);
};
/* ======================================================================
    jsts/geomgraph/NodeFactory.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * @constructor
 */
jsts.geomgraph.NodeFactory = function() {

};


/**
 * The basic node constructor does not allow for incident edges
 */
jsts.geomgraph.NodeFactory.prototype.createNode = function(coord) {
  return new jsts.geomgraph.Node(coord, null);
};
/* ======================================================================
    jsts/geomgraph/Position.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */


(function() {

  /**
   * A Position indicates the position of a Location relative to a graph
   * component (Node, Edge, or Area).
   *
   * @constructor
   */
  jsts.geomgraph.Position = function() {

  };


  /**
   * An indicator that a Location is <i>on</i> a GraphComponent
   *
   * @type {int}
   */
  jsts.geomgraph.Position.ON = 0;


  /**
   * An indicator that a Location is to the <i>left</i> of a GraphComponent
   *
   * @type {int}
   */
  jsts.geomgraph.Position.LEFT = 1;


  /**
   * An indicator that a Location is to the <i>right</i> of a GraphComponent
   *
   * @type {int}
   */
  jsts.geomgraph.Position.RIGHT = 2;


  /**
   * Returns LEFT if the position is RIGHT, RIGHT if the position is LEFT, or
   * the position otherwise.
   *
   * @param {int}
   *          position
   * @return {int}
   */
  jsts.geomgraph.Position.opposite = function(position) {
    if (position === jsts.geomgraph.Position.LEFT) {
      return jsts.geomgraph.Position.RIGHT;
    }
    if (position === jsts.geomgraph.Position.RIGHT) {
      return jsts.geomgraph.Position.LEFT;
    }
    return position;
  };

})();
/* ======================================================================
    jsts/geomgraph/TopologyLocation.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @requires jsts/geomgraph/Position.js
 */

/**
 * A TopologyLocation is the labelling of a GraphComponent's topological
 * relationship to a single Geometry.
 * <p>
 * If the parent component is an area edge, each side and the edge itself have a
 * topological location. These locations are named
 * <ul>
 * <li> ON: on the edge
 * <li> LEFT: left-hand side of the edge
 * <li> RIGHT: right-hand side
 * </ul>
 * If the parent component is a line edge or node, there is a single topological
 * relationship attribute, ON.
 * <p>
 * The possible values of a topological location are {Location.NONE,
 * Location.EXTERIOR, Location.BOUNDARY, Location.INTERIOR}
 * <p>
 * The labelling is stored in an array location[j] where where j has the values
 * ON, LEFT, RIGHT
 *
 * @constructor
 */
jsts.geomgraph.TopologyLocation = function() {
  this.location = [];

  if (arguments.length === 3) {
    var on = arguments[0];
    var left = arguments[1];
    var right = arguments[2];
    this.init(3);
    this.location[jsts.geomgraph.Position.ON] = on;
    this.location[jsts.geomgraph.Position.LEFT] = left;
    this.location[jsts.geomgraph.Position.RIGHT] = right;
  } else if (arguments[0] instanceof jsts.geomgraph.TopologyLocation) {
    var gl = arguments[0];
    this.init(gl.location.length);
    if (gl != null) {
      for (var i = 0; i < this.location.length; i++) {
        this.location[i] = gl.location[i];
      }
    }
  } else if (typeof arguments[0] === 'number') {
    var on = arguments[0];
    this.init(1);
    this.location[jsts.geomgraph.Position.ON] = on;
  } else if (arguments[0] instanceof Array) {
    var location = arguments[0];
    this.init(location.length);
  }
};


/**
 * @private
 */
jsts.geomgraph.TopologyLocation.prototype.location = null;


/**
 * @param {int}
 *          size
 * @private
 */
jsts.geomgraph.TopologyLocation.prototype.init = function(size) {
  this.location[size - 1] = null;
  this.setAllLocations(jsts.geom.Location.NONE);
};


/**
 * @param {int}
 *          posIndex
 * @return {int}
 */
jsts.geomgraph.TopologyLocation.prototype.get = function(posIndex) {
  if (posIndex < this.location.length)
    return this.location[posIndex];
  return jsts.geom.Location.NONE;
};


/**
 * @return {boolean} true if all locations are NULL.
 */
jsts.geomgraph.TopologyLocation.prototype.isNull = function() {
  for (var i = 0; i < this.location.length; i++) {
    if (this.location[i] !== jsts.geom.Location.NONE)
      return false;
  }
  return true;
};


/**
 * @return {boolean} true if any locations are NULL.
 */
jsts.geomgraph.TopologyLocation.prototype.isAnyNull = function() {
  for (var i = 0; i < this.location.length; i++) {
    if (this.location[i] === jsts.geom.Location.NONE)
      return true;
  }
  return false;
};


/**
 * @param {TopologyLocation}
 *          le
 * @param {int}
 *          locIndex
 * @return {boolean}
 */
jsts.geomgraph.TopologyLocation.prototype.isEqualOnSide = function(le, locIndex) {
  return this.location[locIndex] == le.location[locIndex];
};


/**
 * @return {boolean}
 */
jsts.geomgraph.TopologyLocation.prototype.isArea = function() {
  return this.location.length > 1;
};


/**
 * @return {boolean}
 */
jsts.geomgraph.TopologyLocation.prototype.isLine = function() {
  return this.location.length === 1;
};

jsts.geomgraph.TopologyLocation.prototype.flip = function() {
  if (this.location.length <= 1)
    return;
  var temp = this.location[jsts.geomgraph.Position.LEFT];
  this.location[jsts.geomgraph.Position.LEFT] = this.location[jsts.geomgraph.Position.RIGHT];
  this.location[jsts.geomgraph.Position.RIGHT] = temp;
};


/**
 * @param {int}
 *          locValue
 */
jsts.geomgraph.TopologyLocation.prototype.setAllLocations = function(locValue) {
  for (var i = 0; i < this.location.length; i++) {
    this.location[i] = locValue;
  }
};


/**
 * @param {int}
 *          locValue
 */
jsts.geomgraph.TopologyLocation.prototype.setAllLocationsIfNull = function(
    locValue) {
  for (var i = 0; i < this.location.length; i++) {
    if (this.location[i] === jsts.geom.Location.NONE)
      this.location[i] = locValue;
  }
};


/**
 * @param {int}
 *          locIndex
 * @param {int}
 *          locValue
 */
jsts.geomgraph.TopologyLocation.prototype.setLocation = function(locIndex,
    locValue) {
  if (locValue !== undefined) {
    this.location[locIndex] = locValue;
  } else {
    this.setLocation(jsts.geomgraph.Position.ON, locIndex);
  }
};


/**
 * @return {int[]}
 */
jsts.geomgraph.TopologyLocation.prototype.getLocations = function() {
  return location;
};


/**
 * @param {int}
 *          on
 * @param {int}
 *          left
 * @param {int}
 *          right
 */
jsts.geomgraph.TopologyLocation.prototype.setLocations = function(on, left,
    right) {
  this.location[jsts.geomgraph.Position.ON] = on;
  this.location[jsts.geomgraph.Position.LEFT] = left;
  this.location[jsts.geomgraph.Position.RIGHT] = right;
};


/**
 * @param {int}
 *          loc
 * @return {boolean}
 */
jsts.geomgraph.TopologyLocation.prototype.allPositionsEqual = function(loc) {
  for (var i = 0; i < this.location.length; i++) {
    if (this.location[i] !== loc)
      return false;
  }
  return true;
};


/**
 * merge updates only the NULL attributes of this object with the attributes of
 * another.
 *
 * @param {TopologyLocation}
 *          gl
 */
jsts.geomgraph.TopologyLocation.prototype.merge = function(gl) {
  // if the src is an Area label & and the dest is not, increase the dest to be
  // an Area
  if (gl.location.length > this.location.length) {
    var newLoc = [];
    newLoc[jsts.geomgraph.Position.ON] = this.location[jsts.geomgraph.Position.ON];
    newLoc[jsts.geomgraph.Position.LEFT] = jsts.geom.Location.NONE;
    newLoc[jsts.geomgraph.Position.RIGHT] = jsts.geom.Location.NONE;
    this.location = newLoc;
  }
  for (var i = 0; i < this.location.length; i++) {
    if (this.location[i] === jsts.geom.Location.NONE && i < gl.location.length)
      this.location[i] = gl.location[i];
  }
};
/* ======================================================================
    jsts/geomgraph/Label.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @requires jsts/geomgraph/TopologyLocation.js
 */

/**
 * A <code>Label</code> indicates the topological relationship of a component
 * of a topology graph to a given <code>Geometry</code>. This class supports
 * labels for relationships to two <code>Geometry</code>s, which is
 * sufficient for algorithms for binary operations.
 * <P>
 * Topology graphs support the concept of labeling nodes and edges in the graph.
 * The label of a node or edge specifies its topological relationship to one or
 * more geometries. (In fact, since JTS operations have only two arguments
 * labels are required for only two geometries). A label for a node or edge has
 * one or two elements, depending on whether the node or edge occurs in one or
 * both of the input <code>Geometry</code>s. Elements contain attributes
 * which categorize the topological location of the node or edge relative to the
 * parent <code>Geometry</code>; that is, whether the node or edge is in the
 * interior, boundary or exterior of the <code>Geometry</code>. Attributes
 * have a value from the set <code>{Interior, Boundary, Exterior}</code>. In
 * a node each element has a single attribute <code>&lt;On&gt;</code>. For an
 * edge each element has a triplet of attributes
 * <code>&lt;Left, On, Right&gt;</code>.
 * <P>
 * It is up to the client code to associate the 0 and 1
 * <code>TopologyLocation</code>s with specific geometries.
 *
 * @constructor
 */
jsts.geomgraph.Label = function() {
  this.elt = [];

  var geomIndex, onLoc, leftLoc, lbl, rightLoc;
  if (arguments.length === 4) {
    geomIndex = arguments[0];
    onLoc = arguments[1];
    leftLoc = arguments[2];
    rightLoc = arguments[3];
    this.elt[0] = new jsts.geomgraph.TopologyLocation(jsts.geom.Location.NONE,
        jsts.geom.Location.NONE, jsts.geom.Location.NONE);
    this.elt[1] = new jsts.geomgraph.TopologyLocation(jsts.geom.Location.NONE,
        jsts.geom.Location.NONE, jsts.geom.Location.NONE);
    this.elt[geomIndex].setLocations(onLoc, leftLoc, rightLoc);
  } else if (arguments.length === 3) {
    onLoc = arguments[0];
    leftLoc = arguments[1];
    rightLoc = arguments[2];
    this.elt[0] = new jsts.geomgraph.TopologyLocation(onLoc, leftLoc, rightLoc);
    this.elt[1] = new jsts.geomgraph.TopologyLocation(onLoc, leftLoc, rightLoc);
  } else if (arguments.length === 2) {
    geomIndex = arguments[0];
    onLoc = arguments[1];
    this.elt[0] = new jsts.geomgraph.TopologyLocation(jsts.geom.Location.NONE);
    this.elt[1] = new jsts.geomgraph.TopologyLocation(jsts.geom.Location.NONE);
    this.elt[geomIndex].setLocation(onLoc);
  } else if (arguments[0] instanceof jsts.geomgraph.Label) {
    lbl = arguments[0];
    this.elt[0] = new jsts.geomgraph.TopologyLocation(lbl.elt[0]);
    this.elt[1] = new jsts.geomgraph.TopologyLocation(lbl.elt[1]);
  } else if (typeof arguments[0] === 'number') {
    onLoc = arguments[0];
    this.elt[0] = new jsts.geomgraph.TopologyLocation(onLoc);
    this.elt[1] = new jsts.geomgraph.TopologyLocation(onLoc);
  }
};


/**
 * converts a Label to a Line label (that is, one with no side Locations)
 *
 * @param {label}
 *          label
 * @return {Label}
 */
jsts.geomgraph.Label.toLineLabel = function(label) {
  var i, lineLabel = new jsts.geomgraph.Label(jsts.geom.Location.NONE);
  for (i = 0; i < 2; i++) {
    lineLabel.setLocation(i, label.getLocation(i));
  }
  return lineLabel;
};


/**
 * @type {TopologyLocation[]}
 * @private
 */
jsts.geomgraph.Label.prototype.elt = null;

jsts.geomgraph.Label.prototype.flip = function() {
  this.elt[0].flip();
  this.elt[1].flip();
};


/**
 * @param {int}
 *          geomIndex
 * @param {int}
 *          posIndex
 * @return {int}
 */
jsts.geomgraph.Label.prototype.getLocation = function(geomIndex, posIndex) {
  if (arguments.length == 1) {
    return this.getLocation2.apply(this, arguments);
  }
  return this.elt[geomIndex].get(posIndex);
};


/**
 * @param {int}
 *          geomIndex
 * @return {int}
 */
jsts.geomgraph.Label.prototype.getLocation2 = function(geomIndex) {
  return this.elt[geomIndex].get(jsts.geomgraph.Position.ON);
};


/**
 * @param {int}
 *          geomIndex
 * @param {int}
 *          posIndex
 * @param {int}
 *          location
 */
jsts.geomgraph.Label.prototype.setLocation = function(geomIndex, posIndex,
    location) {
  if (arguments.length == 2) {
    this.setLocation2.apply(this, arguments);
    return;
  }

  this.elt[geomIndex].setLocation(posIndex, location);
};


/**
 * @param {int}
 *          geomIndex
 * @param {int}
 *          location
 */
jsts.geomgraph.Label.prototype.setLocation2 = function(geomIndex, location) {
  this.elt[geomIndex].setLocation(jsts.geomgraph.Position.ON, location);
};


/**
 * @param {int}
 *          geomIndex
 * @param {int}
 *          location
 */
jsts.geomgraph.Label.prototype.setAllLocations = function(geomIndex, location) {
  this.elt[geomIndex].setAllLocations(location);
};


/**
 * @param {int}
 *          geomIndex
 * @param {int}
 *          location
 */
jsts.geomgraph.Label.prototype.setAllLocationsIfNull = function(geomIndex,
    location) {
  if (arguments.length == 1) {
    this.setAllLocationsIfNull2.apply(this, arguments);
    return;
  }

  this.elt[geomIndex].setAllLocationsIfNull(location);
};


/**
 * @param {int}
 *          location
 */
jsts.geomgraph.Label.prototype.setAllLocationsIfNull2 = function(location) {
  this.setAllLocationsIfNull(0, location);
  this.setAllLocationsIfNull(1, location);
};


/**
 * Merge this label with another one. Merging updates any null attributes of
 * this label with the attributes from lbl
 *
 * @param {Label}
 *          lbl
 */
jsts.geomgraph.Label.prototype.merge = function(lbl) {
  var i;
  for (i = 0; i < 2; i++) {
    if (this.elt[i] === null && lbl.elt[i] !== null) {
      this.elt[i] = new jsts.geomgraph.TopologyLocation(lbl.elt[i]);
    } else {
      this.elt[i].merge(lbl.elt[i]);
    }
  }
};


/**
 * @return {int}
 */
jsts.geomgraph.Label.prototype.getGeometryCount = function() {
  var count = 0;
  if (!this.elt[0].isNull()) {
    count++;
  }
  if (!this.elt[1].isNull()) {
    count++;
  }
  return count;
};


/**
 * @param {int}
 *          geomIndex
 * @return {boolean}
 */
jsts.geomgraph.Label.prototype.isNull = function(geomIndex) {
  return this.elt[geomIndex].isNull();
};


/**
 * @param {int}
 *          geomIndex
 * @return {boolean}
 */
jsts.geomgraph.Label.prototype.isAnyNull = function(geomIndex) {
  return this.elt[geomIndex].isAnyNull();
};


/**
 * @return {boolean}
 */
jsts.geomgraph.Label.prototype.isArea = function() {
  if (arguments.length == 1) {
    return this.isArea2(arguments[0]);
  }

  return this.elt[0].isArea() || this.elt[1].isArea();
};


/**
 * @param {int}
 *          geomIndex
 * @return {boolean}
 */
jsts.geomgraph.Label.prototype.isArea2 = function(geomIndex) {
  return this.elt[geomIndex].isArea();
};


/**
 * @param {int}
 *          geomIndex
 * @return {boolean}
 */
jsts.geomgraph.Label.prototype.isLine = function(geomIndex) {
  return this.elt[geomIndex].isLine();
};


/**
 * @param {Label}
 *          lbl
 * @param {int}
 *          side
 * @return {boolean}
 */
jsts.geomgraph.Label.prototype.isEqualOnSide = function(lbl, side) {
  return this.elt[0].isEqualOnSide(lbl.elt[0], side) &&
      this.elt[1].isEqualOnSide(lbl.elt[1], side);
};


/**
 * @param {int}
 *          geomIndex
 * @param {int}
 *          loc
 * @return {boolean}
 */
jsts.geomgraph.Label.prototype.allPositionsEqual = function(geomIndex, loc) {
  return this.elt[geomIndex].allPositionsEqual(loc);
};


/**
 * Converts one GeometryLocation to a Line location
 *
 * @param {int}
 *          geomIndex
 */
jsts.geomgraph.Label.prototype.toLine = function(geomIndex) {
  if (this.elt[geomIndex].isArea()) {
    this.elt[geomIndex] = new jsts.geomgraph.TopologyLocation(this.elt[geomIndex].location[0]);
  }
};
/* ======================================================================
    jsts/geomgraph/EdgeRing.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @requires jsts/geomgraph/Label.js
 */

/**
 * Port source: com.vividsolutions.jts.geomgraph.EdgeRing r6
 *
 * @constructor
 */
jsts.geomgraph.EdgeRing = function(start, geometryFactory) {
  this.edges = [];
  this.pts = [];
  this.holes = [];
  this.label = new jsts.geomgraph.Label(jsts.geom.Location.NONE);

  this.geometryFactory = geometryFactory;

  if (start) {
    this.computePoints(start);
    this.computeRing();
  }
};

jsts.geomgraph.EdgeRing.prototype.startDe = null; // the directed edge which
                                                  // starts the list of edges
                                                  // for this EdgeRing
jsts.geomgraph.EdgeRing.prototype.maxNodeDegree = -1;
jsts.geomgraph.EdgeRing.prototype.edges = null; // the DirectedEdges making up
                                                // this EdgeRing
jsts.geomgraph.EdgeRing.prototype.pts = null;
jsts.geomgraph.EdgeRing.prototype.label = null; // label stores the locations of
                                                // each geometry on the face
                                                // surrounded by this ring
jsts.geomgraph.EdgeRing.prototype.ring = null; // the ring created for this
                                                // EdgeRing
jsts.geomgraph.EdgeRing.prototype._isHole = null;
jsts.geomgraph.EdgeRing.prototype.shell = null; // if non-null, the ring is a
                                                // hole and this EdgeRing is its
                                                // containing shell
jsts.geomgraph.EdgeRing.prototype.holes = null; // a list of EdgeRings which are
                                                // holes in this EdgeRing

jsts.geomgraph.EdgeRing.prototype.geometryFactory = null;

jsts.geomgraph.EdgeRing.prototype.isIsolated = function() {
  return (this.label.getGeometryCount() == 1);
};
jsts.geomgraph.EdgeRing.prototype.isHole = function() {
  return this._isHole;
};

jsts.geomgraph.EdgeRing.prototype.getCoordinate = function(i) {
  return this.pts[i];
};
jsts.geomgraph.EdgeRing.prototype.getLinearRing = function() { return this.ring; };
jsts.geomgraph.EdgeRing.prototype.getLabel = function() {
  return this.label;
};
jsts.geomgraph.EdgeRing.prototype.isShell = function() {
  return this.shell === null;
};
jsts.geomgraph.EdgeRing.prototype.getShell = function() {
  return this.shell;
};
jsts.geomgraph.EdgeRing.prototype.setShell = function(shell) {
  this.shell = shell;
  if (shell !== null)
    shell.addHole(this);
};
jsts.geomgraph.EdgeRing.prototype.addHole = function(ring) {
  this.holes.push(ring);
};

jsts.geomgraph.EdgeRing.prototype.toPolygon = function(geometryFactory) {
  var holeLR = [];
  for (var i = 0; i < this.holes.length; i++) {
    holeLR[i] = this.holes[i].getLinearRing();
  }
  var poly = this.geometryFactory.createPolygon(this.getLinearRing(), holeLR);
  return poly;
};
/**
 * Compute a LinearRing from the point list previously collected. Test if the
 * ring is a hole (i.e. if it is CCW) and set the hole flag accordingly.
 */
jsts.geomgraph.EdgeRing.prototype.computeRing = function() {
  if (this.ring !== null)
    return; // don't compute more than once
  var coord = [];
  for (var i = 0; i < this.pts.length; i++) {
    coord[i] = this.pts[i];
  }
  this.ring = this.geometryFactory.createLinearRing(coord);
  this._isHole = jsts.algorithm.CGAlgorithms.isCCW(this.ring.getCoordinates());
};
jsts.geomgraph.EdgeRing.prototype.getNext = function(de) {
  throw new jsts.error.AbstractInvocationError();
};
jsts.geomgraph.EdgeRing.prototype.setEdgeRing = function(de, er) {
  throw new jsts.error.AbstractInvocationError();
};
/**
 * Returns the list of DirectedEdges that make up this EdgeRing
 */
jsts.geomgraph.EdgeRing.prototype.getEdges = function() {
  return this.edges;
};

/**
 * Collect all the points from the DirectedEdges of this ring into a contiguous
 * list
 */
jsts.geomgraph.EdgeRing.prototype.computePoints = function(start) {
  this.startDe = start;
  var de = start;
  var isFirstEdge = true;
  do {
    if (de === null)
      throw new jsts.error.TopologyError('Found null DirectedEdge');
    if (de.getEdgeRing() === this)
      throw new jsts.error.TopologyError(
          'Directed Edge visited twice during ring-building at ' +
              de.getCoordinate());

    this.edges.push(de);
    var label = de.getLabel();
    jsts.util.Assert.isTrue(label.isArea());
    this.mergeLabel(label);
    this.addPoints(de.getEdge(), de.isForward(), isFirstEdge);
    isFirstEdge = false;
    this.setEdgeRing(de, this);
    de = this.getNext(de);
  } while (de !== this.startDe);
};

jsts.geomgraph.EdgeRing.prototype.getMaxNodeDegree = function() {
  if (this.maxNodeDegree < 0)
    this.computeMaxNodeDegree();
  return this.maxNodeDegree;
};

jsts.geomgraph.EdgeRing.prototype.computeMaxNodeDegree = function() {
  this.maxNodeDegree = 0;
  var de = this.startDe;
  do {
    var node = de.getNode();
    var degree = node.getEdges().getOutgoingDegree(this);
    if (degree > this.maxNodeDegree)
      this.maxNodeDegree = degree;
    de = this.getNext(de);
  } while (de !== this.startDe);
  this.maxNodeDegree *= 2;
};


jsts.geomgraph.EdgeRing.prototype.setInResult = function() {
  var de = this.startDe;
  do {
    de.getEdge().setInResult(true);
    de = de.getNext();
  } while (de != this.startDe);
};

jsts.geomgraph.EdgeRing.prototype.mergeLabel = function(deLabel) {
  this.mergeLabel2(deLabel, 0);
  this.mergeLabel2(deLabel, 1);
};
/**
 * Merge the RHS label from a DirectedEdge into the label for this EdgeRing. The
 * DirectedEdge label may be null. This is acceptable - it results from a node
 * which is NOT an intersection node between the Geometries (e.g. the end node
 * of a LinearRing). In this case the DirectedEdge label does not contribute any
 * information to the overall labelling, and is simply skipped.
 */
jsts.geomgraph.EdgeRing.prototype.mergeLabel2 = function(deLabel, geomIndex) {
  var loc = deLabel.getLocation(geomIndex, jsts.geomgraph.Position.RIGHT);
  // no information to be had from this label
  if (loc == jsts.geom.Location.NONE)
    return;
  // if there is no current RHS value, set it
  if (this.label.getLocation(geomIndex) === jsts.geom.Location.NONE) {
    this.label.setLocation(geomIndex, loc);
    return;
  }
};
jsts.geomgraph.EdgeRing.prototype.addPoints = function(edge, isForward,
    isFirstEdge) {
  var edgePts = edge.getCoordinates();
  if (isForward) {
    var startIndex = 1;
    if (isFirstEdge)
      startIndex = 0;
    for (var i = startIndex; i < edgePts.length; i++) {
      this.pts.push(edgePts[i]);
    }
  } else { // is backward
    var startIndex = edgePts.length - 2;
    if (isFirstEdge)
      startIndex = edgePts.length - 1;
    for (var i = startIndex; i >= 0; i--) {
      this.pts.push(edgePts[i]);
    }
  }
};

/**
 * This method will cause the ring to be computed. It will also check any holes,
 * if they have been assigned.
 */
jsts.geomgraph.EdgeRing.prototype.containsPoint = function(p) {
  var shell = this.getLinearRing();
  var env = shell.getEnvelopeInternal();
  if (!env.contains(p))
    return false;
  if (!jsts.algorithm.CGAlgorithms.isPointInRing(p, shell.getCoordinates()))
    return false;

  for (var i = 0; i < this.holes.length; i++) {
    var hole = this.holes[i];
    if (hole.containsPoint(p))
      return false;
  }
  return true;
};
/* ======================================================================
    jsts/geom/LinearRing.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * Models an OGC SFS <code>LinearRing</code>. A LinearRing is a LineString
   * which is both closed and simple. In other words, the first and last
   * coordinate in the ring must be equal, and the interior of the ring must not
   * self-intersect. Either orientation of the ring is allowed.
   * <p>
   * A ring must have either 0 or 4 or more points. The first and last points
   * must be equal (in 2D). If these conditions are not met, the constructors
   * throw an {@link IllegalArgumentException}
   *
   * @requires jsts/geom/LineString.js
   */


  /**
   * @extends jsts.geom.LineString
   * @constructor
   */
  jsts.geom.LinearRing = function(points, factory) {
    jsts.geom.LineString.apply(this, arguments);
  };
  jsts.geom.LinearRing.prototype = new jsts.geom.LineString();
  jsts.geom.LinearRing.constructor = jsts.geom.LinearRing;


  /**
   * Returns <code>Dimension.FALSE</code>, since by definition LinearRings do
   * not have a boundary.
   *
   * @return {int} Dimension.FALSE.
   */
  jsts.geom.LinearRing.prototype.getBoundaryDimension = function() {
    return jsts.geom.Dimension.FALSE;
  };


  /**
   * Returns <code>true</code>, since by definition LinearRings are always
   * simple.
   *
   * @return {Boolean} <code>true.</code>
   *
   * @see Geometry#isSimple
   */
  jsts.geom.LinearRing.prototype.isSimple = function() {
    return true;
  };


  /**
   * @return {String} String representation of LinearRing type.
   */
  jsts.geom.LinearRing.prototype.getGeometryType = function() {
    return 'LinearRing';
  };

  jsts.geom.LinearRing.MINIMUM_VALID_SIZE = 4;

  jsts.geom.LinearRing.prototype.CLASS_NAME = 'jsts.geom.LinearRing';

})();
/* ======================================================================
    jsts/index/strtree/Boundable.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * A spatial object in an AbstractSTRtree.
 *
 * @version 1.7
 */



/**
 * @constructor
 * @interface
 */
jsts.index.strtree.Boundable = function() {

};


/**
 * Returns a representation of space that encloses this Boundable, preferably
 * not much bigger than this Boundable's boundary yet fast to test for intersection
 * with the bounds of other Boundables. The class of object returned depends
 * on the subclass of AbstractSTRtree.
 *
 * @return {Object} an Envelope (for STRtrees), an Interval (for SIRtrees), or other object
 * (for other subclasses of AbstractSTRtree).
 * @see jsts.index.strtree.AbstractSTRtree.IntersectsOp
 * @public
 */
jsts.index.strtree.Boundable.prototype.getBounds = function() {
  throw new jsts.error.AbstractMethodInvocationError();
};
/* ======================================================================
    jsts/index/strtree/AbstractNode.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * A node of the STR tree. The children of this node are either more nodes
 * (AbstractNodes) or real data (ItemBoundables). If this node contains real data
 * (rather than nodes), then we say that this node is a "leaf node".
 *
 * @requires jsts/index/strtree/Boundable.js
 */



/**
 * Constructs an AbstractNode at the given level in the tree
 * @param {Integer} level 0 if this node is a leaf, 1 if a parent of a leaf, and so on; the
 * root node will have the highest level.
 *
 * @extends {Boundable}
 * @constructor
 * @interface
 */
jsts.index.strtree.AbstractNode = function(level) {
  this.level = level;
  this.childBoundables = [];
};

jsts.index.strtree.AbstractNode.prototype = new jsts.index.strtree.Boundable();
jsts.index.strtree.AbstractNode.constructor = jsts.index.strtree.AbstractNode;

/**
 * @type {Array}
 * @private
 */
jsts.index.strtree.AbstractNode.prototype.childBoundables = null;


/**
 * @type {Object}
 * @private
 */
jsts.index.strtree.AbstractNode.prototype.bounds = null;


/**
 * @type {number}
 * @private
 */
jsts.index.strtree.AbstractNode.prototype.level = null;


/**
 * Returns either child {@link AbstractNodes}, or if this is a leaf node, real data (wrapped
 * in {@link ItemBoundables}).
 *
 * @return {Array}
 */
jsts.index.strtree.AbstractNode.prototype.getChildBoundables = function() {
  return this.childBoundables;
};


/**
 * Returns a representation of space that encloses this Boundable,
 * preferably not much bigger than this Boundable's boundary yet fast to
 * test for intersection with the bounds of other Boundables. The class of
 * object returned depends on the subclass of AbstractSTRtree.
 *
 * @return an Envelope (for STRtrees), an Interval (for SIRtrees), or other
 *         object (for other subclasses of AbstractSTRtree).
 * @see AbstractSTRtree.IntersectsOp
 */
jsts.index.strtree.AbstractNode.prototype.computeBounds = function() {
  throw new jsts.error.AbstractMethodInvocationError();
};

jsts.index.strtree.AbstractNode.prototype.getBounds = function() {
  if (this.bounds === null) {
    this.bounds = this.computeBounds();
  }
  return this.bounds;
};


/**
 * Returns 0 if this node is a leaf, 1 if a parent of a leaf, and so on; the
 * root node will have the highest level
 *
 * @return {number}
 */
jsts.index.strtree.AbstractNode.prototype.getLevel = function() {
  return this.level;
};


/**
 * Adds either an AbstractNode, or if this is a leaf node, a data object
 * (wrapped in an ItemBoundable)
 *
 * @param {jsts.index.strtree.Boundable} childBoundable
 */
jsts.index.strtree.AbstractNode.prototype.addChildBoundable = function(childBoundable) {
  this.childBoundables.push(childBoundable);
};
/* ======================================================================
    jsts/noding/Noder.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * Computes all intersections between segments in a set of
   * {@link SegmentString}s. Intersections found are represented as
   * {@link SegmentNode}s and added to the {@link SegmentString}s in which
   * they occur. As a final step in the noding a new set of segment strings
   * split at the nodes may be returned.
   *
   * @interface
   */
  jsts.noding.Noder = function() {

  };


  /**
   * Computes the noding for a collection of {@link SegmentString}s. Some
   * Noders may add all these nodes to the input SegmentStrings; others may only
   * add some or none at all.
   *
   * @param {Array}
   *          segStrings a collection of {@link SegmentString}s to node.
   */
  jsts.noding.Noder.prototype.computeNodes = jsts.abstractFunc;

  /**
   * Returns a {@link Collection} of fully noded {@link SegmentString}s. The
   * SegmentStrings have the same context as their parent.
   *
   * @return {Array} a Collection of SegmentStrings.
   */
  jsts.noding.Noder.prototype.getNodedSubstrings = jsts.abstractFunc;

})();
/* ======================================================================
    jsts/noding/SinglePassNoder.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * @requires jsts/noding/Noder.js
   */

  var Noder = jsts.noding.Noder;


  /**
   * Base class for {@link Noder}s which make a single pass to find
   * intersections. This allows using a custom {@link SegmentIntersector} (which
   * for instance may simply identify intersections, rather than insert them).
   *
   * @interface
   */
  jsts.noding.SinglePassNoder = function() {

  };


  jsts.noding.SinglePassNoder.prototype = new Noder();
  jsts.noding.SinglePassNoder.constructor = jsts.noding.SinglePassNoder;


  /**
   * @type {SegmentIntersector}
   * @protected
   */
  jsts.noding.SinglePassNoder.prototype.segInt = null;

  /**
   * Sets the SegmentIntersector to use with this noder. A SegmentIntersector
   * will normally add intersection nodes to the input segment strings, but it
   * may not - it may simply record the presence of intersections. However, some
   * Noders may require that intersections be added.
   *
   * @param {SegmentIntersector}
   *          segInt
   */
  jsts.noding.SinglePassNoder.prototype.setSegmentIntersector = function(segInt) {
    this.segInt = segInt;
  };

})();
/* ======================================================================
    jsts/index/SpatialIndex.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * The basic operations supported by classes
 * implementing spatial index algorithms.
 * <p>
 * A spatial index typically provides a primary filter for range rectangle queries.
 * A secondary filter is required to test for exact intersection.
 * The secondary filter may consist of other kinds of tests,
 * such as testing other spatial relationships.
 *
 * @version 1.7
 */



/**
 * @interface
 */
jsts.index.SpatialIndex = function() {

};


/**
 * Adds a spatial item with an extent specified by the given {@link Envelope} to the index
 *
 * @param {jsts.geom.Envelope} itemEnv
 * @param {Object} item
 * @public
 */
jsts.index.SpatialIndex.prototype.insert = function(itemEnv, item) {
  throw new jsts.error.AbstractMethodInvocationError();
};


/**
 * Queries the index for all items whose extents intersect the given search {@link Envelope}
 * and applies an {@link ItemVisitor} to them (if provided).
 * Note that some kinds of indexes may also return objects which do not in fact
 * intersect the query envelope.
 *
 * @param {jsts.geom.Envelope} searchEnv the envelope to query for.
 * @param {jsts.index.ItemVisitor=} [visitor] a visitor object to apply to the items found.
 * @return {?Array} a list of the items found by the query.
 * @public
 */
jsts.index.SpatialIndex.prototype.query = function(searchEnv, visitor) {
  throw new jsts.error.AbstractMethodInvocationError();
};


/**
 * Removes a single item from the tree.
 *
 * @param {jsts.geom.Envelope} itemEnv the Envelope of the item to remove.
 * @param {Object} item the item to remove.
 * @return {boolean} <code>true</code> if the item was found.
 * @public
 */
jsts.index.SpatialIndex.prototype.remove = function(itemEnv, item) {
  throw new jsts.error.AbstractMethodInvocationError();
};
/* ======================================================================
    jsts/index/strtree/AbstractSTRtree.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Base class for STRtree and SIRtree. STR-packed R-trees are described in:
 * P. Rigaux, Michel Scholl and Agnes Voisard. Spatial Databases With
 * Application To GIS. Morgan Kaufmann, San Francisco, 2002.
 * <p>
 * This implementation is based on Boundables rather than just AbstractNodes,
 * because the STR algorithm operates on both nodes and
 * data, both of which are treated here as Boundables.
 *
 * @see STRtree
 * @see SIRtree
 */



/**
 * Constructs an AbstractSTRtree with the specified maximum number of child
 * nodes that a node may have
 *
 * @param {Integer}
 *          nodeCapacity
 *
 * @constuctor
 */
jsts.index.strtree.AbstractSTRtree = function(nodeCapacity) {
  if (nodeCapacity === undefined)
    return;

  this.itemBoundables = [];

  jsts.util.Assert.isTrue(nodeCapacity > 1, 'Node capacity must be greater than 1');
  this.nodeCapacity = nodeCapacity;
};



/**
 * A test for intersection between two bounds, necessary because subclasses of
 * AbstractSTRtree have different implementations of bounds.
 *
 * @interface
 * @constructor
 * @public
 */
jsts.index.strtree.AbstractSTRtree.IntersectsOp = function() {

};


/**
 * For STRtrees, the bounds will be Envelopes; for SIRtrees, Intervals; for
 * other subclasses of AbstractSTRtree, some other class.
 *
 * @param {Object}
 *          aBounds the bounds of one spatial object.
 * @param {Object}
 *          bBounds the bounds of another spatial object.
 * @return {boolean} whether the two bounds intersect.
 */
jsts.index.strtree.AbstractSTRtree.IntersectsOp.prototype.intersects = function(
    aBounds, bBounds) {
  throw new jsts.error.AbstractMethodInvocationError();
};


/**
 * @type {jsts.index.strtree.AbstractNode}
 * @protected
 */
jsts.index.strtree.AbstractSTRtree.prototype.root = null;


/**
 * @type {boolean}
 * @private
 */
jsts.index.strtree.AbstractSTRtree.prototype.built = false;


/**
 * @type {Array}
 * @private
 */
jsts.index.strtree.AbstractSTRtree.prototype.itemBoundables = null;


/**
 * @type {number}
 * @private
 */
jsts.index.strtree.AbstractSTRtree.prototype.nodeCapacity = null;


/**
 * Creates parent nodes, grandparent nodes, and so forth up to the root node,
 * for the data that has been inserted into the tree. Can only be called once,
 * and thus can be called only after all of the data has been inserted into the
 * tree.
 */
jsts.index.strtree.AbstractSTRtree.prototype.build = function() {
  jsts.util.Assert.isTrue(!this.built);
  this.root = this.itemBoundables.length === 0 ? this.createNode(0) : this
      .createHigherLevels(this.itemBoundables, -1);
  this.built = true;
};


/**
 * @param {number}
 *          level
 * @return {jsts.index.strtree.AbstractNode}
 */
jsts.index.strtree.AbstractSTRtree.prototype.createNode = function(level) {
  throw new jsts.error.AbstractMethodInvocationError();
};


/**
 * Sorts the childBoundables then divides them into groups of size M, where M is
 * the node capacity.
 */
jsts.index.strtree.AbstractSTRtree.prototype.createParentBoundables = function(
    childBoundables, newLevel) {
  jsts.util.Assert.isTrue(!(childBoundables.length === 0));
  var parentBoundables = [];
  parentBoundables.push(this.createNode(newLevel));
  var sortedChildBoundables = [];
  for (var i = 0; i < childBoundables.length; i++) {
    sortedChildBoundables.push(childBoundables[i]);
  }
  sortedChildBoundables.sort(this.getComparator());
  for (var i = 0; i < sortedChildBoundables.length; i++) {
    var childBoundable = sortedChildBoundables[i];
    if (this.lastNode(parentBoundables).getChildBoundables().length === this
        .getNodeCapacity()) {
      parentBoundables.push(this.createNode(newLevel));
    }
    this.lastNode(parentBoundables).addChildBoundable(childBoundable);
  }
  return parentBoundables;
};


/**
 * @param {Array}
 *          nodes
 * @return {jsts.index.strtree.AbstractNode}
 */
jsts.index.strtree.AbstractSTRtree.prototype.lastNode = function(nodes) {
  return nodes[nodes.length - 1];
};


/**
 * @param {number}
 *          a
 * @param {number}
 *          b
 * @return {number}
 */
jsts.index.strtree.AbstractSTRtree.prototype.compareDoubles = function(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
};


/**
 * Creates the levels higher than the given level
 *
 * @param {Array}
 *          boundablesOfALevel the level to build on.
 * @param {number}
 *          level the level of the Boundables, or -1 if the boundables are item
 *          boundables (that is, below level 0).
 * @return {jsts.index.strtree.AbstractNode} the root, which may be a ParentNode
 *         or a LeafNode.
 * @private
 */
jsts.index.strtree.AbstractSTRtree.prototype.createHigherLevels = function(
    boundablesOfALevel, level) {
  jsts.util.Assert.isTrue(!(boundablesOfALevel.length === 0));
  var parentBoundables = this.createParentBoundables(boundablesOfALevel,
      level + 1);
  if (parentBoundables.length === 1) {
    return parentBoundables[0];
  }
  return this.createHigherLevels(parentBoundables, level + 1);
};


/**
 * @return {jsts.index.strtree.AbstractNode}
 */
jsts.index.strtree.AbstractSTRtree.prototype.getRoot = function() {
  if (!this.built)
    this.build();
  return this.root;
};


/**
 * Returns the maximum number of child nodes that a node may have
 *
 * return {number}
 */
jsts.index.strtree.AbstractSTRtree.prototype.getNodeCapacity = function() {
  return this.nodeCapacity;
};


/**
 * @return {number}
 */
jsts.index.strtree.AbstractSTRtree.prototype.size = function() {
  if (arguments.length === 1) {
    return this.size2(arguments[0]);
  }

  if (!this.built) {
    this.build();
  }
  if (this.itemBoundables.length === 0) {
    return 0;
  }
  return this.size2(root);
};

/**
 * @param {jsts.index.strtree.AbstractNode=}
 *          [node].
 * @return {number}
 */
jsts.index.strtree.AbstractSTRtree.prototype.size2 = function(node) {
  var size = 0;
  var childBoundables = node.getChildBoundables();
  for (var i = 0; i < childBoundables.length; i++) {
    var childBoundable = childBoundables[i];
    if (childBoundable instanceof jsts.index.strtree.AbstractNode) {
      size += this.size(childBoundable);
    } else if (childBoundable instanceof jsts.index.strtree.ItemBoundable) {
      size += 1;
    }
  }
  return size;
};


/**
 * @return {number}
 */
jsts.index.strtree.AbstractSTRtree.prototype.depth = function() {
  if (arguments.length === 1) {
    return this.depth2(arguments[0]);
  }

  if (!this.built) {
    this.build();
  }
  if (this.itemBoundables.length === 0) {
    return 0;
  }
  return this.depth2(root);
};

/**
 * @param {jsts.index.strtree.AbstractNode}
 *          [node].
 * @return {number}
 */
jsts.index.strtree.AbstractSTRtree.prototype.depth2 = function() {
  var maxChildDepth = 0;
  var childBoundables = node.getChildBoundables();
  for (var i = 0; i < childBoundables.length; i++) {
    var childBoundable = childBoundables[i];
    if (childBoundable instanceof jsts.index.strtree.AbstractNode) {
      var childDepth = this.depth(childBoundable);
      if (childDepth > maxChildDepth)
        maxChildDepth = childDepth;
    }
  }
  return maxChildDepth + 1;
};


/**
 *
 * @param {Object}
 *          bounds
 * @param {Object}
 *          item
 */
jsts.index.strtree.AbstractSTRtree.prototype.insert = function(bounds, item) {
  jsts.util.Assert.isTrue(!this.built, 'Cannot insert items into an STR packed R-tree after it has been built.');
  this.itemBoundables.push(new jsts.index.strtree.ItemBoundable(bounds, item));
};

/**
 * Also builds the tree, if necessary.
 *
 * @param {Object}
 *          searchBounds
 * @param {jsts.index.ItemVisitor}
 *          [visitor].
 * @param {jsts.index.strtree.AbstractNode}
 *          [node].
 * @param {Array}
 *          [matches].
 * @return {Array}
 */
jsts.index.strtree.AbstractSTRtree.prototype.query = function(searchBounds) {
  if (arguments.length > 1) {
    this.query2.apply(this, arguments);
  }

  if (!this.built) {
    this.build();
  }
  var matches = [];
  if (this.itemBoundables.length === 0) {
    jsts.util.Assert.isTrue(this.root.getBounds() === null);
    return matches;
  }
  if (this.getIntersectsOp().intersects(this.root.getBounds(), searchBounds)) {
    this.query3(searchBounds, this.root, matches);
  }
  return matches;
};

jsts.index.strtree.AbstractSTRtree.prototype.query2 = function(searchBounds,
    visitor) {
  if (arguments.length > 2) {
    this.query3.apply(this, arguments);
  }

  if (!this.built) {
    this.build();
  }
  if (this.itemBoundables.length === 0) {
    jsts.util.Assert.isTrue(this.root.getBounds() === null);
  }
  if (this.getIntersectsOp().intersects(this.root.getBounds(), searchBounds)) {
    this.query4(searchBounds, this.root, visitor);
  }
};

/**
 * @private
 */
jsts.index.strtree.AbstractSTRtree.prototype.query3 = function(searchBounds,
    node, matches) {
  if (!(arguments[2] instanceof Array)) {
    this.query4.apply(this, arguments);
  }

  var childBoundables = node.getChildBoundables();
  for (var i = 0; i < childBoundables.length; i++) {
    var childBoundable = childBoundables[i];
    if (!this.getIntersectsOp().intersects(childBoundable.getBounds(),
        searchBounds)) {
      continue;
    }
    if (childBoundable instanceof jsts.index.strtree.AbstractNode) {
      this.query3(searchBounds, childBoundable, matches);
    } else if (childBoundable instanceof jsts.index.strtree.ItemBoundable) {
      matches.push(childBoundable.getItem());
    } else {
      jsts.util.Assert.shouldNeverReachHere();
    }
  }
};

/**
 * @private
 */
jsts.index.strtree.AbstractSTRtree.prototype.query4 = function(searchBounds,
    node, visitor) {
  var childBoundables = node.getChildBoundables();
  for (var i = 0; i < childBoundables.length; i++) {
    var childBoundable = childBoundables[i];
    if (!this.getIntersectsOp().intersects(childBoundable.getBounds(),
        searchBounds)) {
      continue;
    }
    if (childBoundable instanceof jsts.index.strtree.AbstractNode) {
      this.query4(searchBounds, childBoundable, visitor);
    } else if (childBoundable instanceof jsts.index.strtree.ItemBoundable) {
      visitor.visitItem(childBoundable.getItem());
    } else {
      jsts.util.Assert.shouldNeverReachHere();
    }
  }
};

/**
 * @return {jsts.index.strtree.AbstractSTRtree.IntersectOp}
 */
jsts.index.strtree.AbstractSTRtree.prototype.getIntersectsOp = function() {
  throw new jsts.error.AbstractMethodInvocationError();
};

// TODO: port rest

/**
 * Gets a tree structure (as a nested list) corresponding to the structure of
 * the items and nodes in this tree.
 * <p>
 * The returned {@link List}s contain either {@link Object} items, or Lists
 * which correspond to subtrees of the tree Subtrees which do not contain any
 * items are not included.
 * <p>
 * Builds the tree if necessary.
 *
 * @return {Array} a List of items and/or Lists.
 */
jsts.index.strtree.AbstractSTRtree.prototype.itemsTree = function() {
  if (arguments.length === 1) {
    return this.itemsTree2.apply(this, arguments);
  }

  if (!this.built) {
    this.build();
  }

  var valuesTree = this.itemsTree2(this.root);
  if (valuesTree === null)
    return [];
  return valuesTree;
};

jsts.index.strtree.AbstractSTRtree.prototype.itemsTree2 = function(node) {
  var valuesTreeForNode = [];
  var childBoundables = node.getChildBoundables();
  for (var i = 0; i < childBoundables.length; i++) {
    var childBoundable = childBoundables[i];
    if (childBoundable instanceof jsts.index.strtree.AbstractNode) {
      var valuesTreeForChild = this.itemsTree(childBoundable);
      // only add if not null (which indicates an item somewhere in this tree
      if (valuesTreeForChild != null)
        valuesTreeForNode.push(valuesTreeForChild);
    } else if (childBoundable instanceof jsts.index.strtree.ItemBoundable) {
      valuesTreeForNode.push(childBoundable.getItem());
    } else {
      jsts.util.Assert.shouldNeverReachHere();
    }
  }
  if (valuesTreeForNode.length <= 0)
    return null;
  return valuesTreeForNode;
};

/**
 * Removes an item from the tree. (Builds the tree, if necessary.)
 *
 * @param {Object}
 *          searchBounds
 * @param {jsts.index.strtree.AbstractNode}
 *          [node].
 * @param {Object]
 *          item}
 * @return {boolean}
 */
jsts.index.strtree.AbstractSTRtree.prototype.remove = function(searchBounds,
    item) {
  // TODO: argument switch


  if (!this.built) {
    this.build();
  }
  if (this.itemBoundables.length === 0) {
    jsts.util.Assert.isTrue(this.root.getBounds() == null);
  }
  if (this.getIntersectsOp().intersects(this.root.getBounds(), searchBounds)) {
    return this.remove2(searchBounds, this.root, item);
  }
  return false;
};

jsts.index.strtree.AbstractSTRtree.prototype.remove2 = function(searchBounds,
    node, item) {
  // first try removing item from this node
  var found = this.removeItem(node, item);
  if (found)
    return true;

  var childToPrune = null;
  // next try removing item from lower nodes
  var childBoundables = node.getChildBoundables();
  for (var i = 0; i < childBoundables.length; i++) {
    var childBoundable = childBoundables[i];
    if (!this.getIntersectsOp().intersects(childBoundable.getBounds(),
        searchBounds)) {
      continue;
    }
    if (childBoundable instanceof jsts.index.strtree.AbstractNode) {
      found = this.remove(searchBounds, childBoundable, item);
      // if found, record child for pruning and exit
      if (found) {
        childToPrune = childBoundable;
        break;
      }
    }
  }
  // prune child if possible
  if (childToPrune != null) {
    if (childToPrune.getChildBoundables().length === 0) {
      childBoundables.splice(childBoundables.indexOf(childToPrune), 1);
    }
  }
  return found;
};



/**
 *
 * @param {jsts.index.strtree.AbstractNode}
 *          node
 * @param {Object}
 *          item
 * @return {boolean}
 */
jsts.index.strtree.AbstractSTRtree.prototype.removeItem = function(node, item) {
  var childToRemove = null;
  var childBoundables = node.getChildBoundables();
  for (var i = 0; i < childBoundables.length; i++) {
    var childBoundable = childBoundables[i];
    if (childBoundable instanceof jsts.index.strtree.ItemBoundable) {
      if (childBoundable.getItem() === item)
        childToRemove = childBoundable;
    }
  }
  if (childToRemove !== null) {
    childBoundables.splice(childBoundables.indexOf(childToRemove), 1);
    return true;
  }
  return false;
};


jsts.index.strtree.AbstractSTRtree.prototype.boundablesAtLevel = function(level) {
  if (arguments.length > 1) {
    this.boundablesAtLevel2.apply(this, arguments);
    return;
  }

  var boundables = [];
  this.boundablesAtLevel2(level, this.root, boundables);
  return boundables;
};

/**
 * @param {number}
 *          level
 * @param {jsts.index.strtree.AbstractNode}
 *          [top].
 * @param {Array}
 *          [boundables].
 * @return {?Array}
 */
jsts.index.strtree.AbstractSTRtree.prototype.boundablesAtLevel2 = function(
    level, top, boundables) {
  jsts.util.Assert.isTrue(level > -2);
  if (top.getLevel() === level) {
    boundables.add(top);
    return;
  }
  var childBoundables = node.getChildBoundables();
  for (var i = 0; i < childBoundables.length; i++) {
    var boundable = childBoundables[i];
    if (boundable instanceof jsts.index.strtree.AbstractNode) {
      this.boundablesAtLevel(level, boundable, boundables);
    } else {
      jsts.util.Assert.isTrue(boundable instanceof jsts.index.strtree.ItemBoundable);
      if (level === -1) {
        boundables.add(boundable);
      }
    }
  }
  return;
};


/**
 * @return {Comparator}
 */
jsts.index.strtree.AbstractSTRtree.prototype.getComparator = function() {
  throw new jsts.error.AbstractMethodInvocationError();
};
/* ======================================================================
    jsts/index/strtree/STRtree.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 *  A query-only R-tree created using the Sort-Tile-Recursive (STR) algorithm.
 *  For two-dimensional spatial data.
 * <P>
 *  The STR packed R-tree is simple to implement and maximizes space
 *  utilization; that is, as many leaves as possible are filled to capacity.
 *  Overlap between nodes is far less than in a basic R-tree. However, once the
 *  tree has been built (explicitly or on the first call to #query), items may
 *  not be added or removed.
 * <P>
 * Described in: P. Rigaux, Michel Scholl and Agnes Voisard.
 * <i>Spatial Databases With Application To GIS</i>.
 * Morgan Kaufmann, San Francisco, 2002.
 *
 * @requires jsts/index/SpatialIndex.js
 * @requires jsts/index/strtree/STRtree.js
 * @requires jsts/index/strtree/AbstractSTRtree.js
 */



/**
 * Constructs an STRtree with the default node capacity or with the given
 * maximum number of child nodes that a node may have.
 * <p>
 * The minimum recommended capacity setting is 4.
 *
 *
 * @param {number}
 *          [nodeCapacity].
 * @extends {jsts.index.strtree.AbstractSTRtree}
 * @extends {jsts.index.SpatialIndex}
 * @constructor
 */
jsts.index.strtree.STRtree = function(nodeCapacity) {
  nodeCapacity = nodeCapacity ||
      jsts.index.strtree.STRtree.DEFAULT_NODE_CAPACITY;
  jsts.index.strtree.AbstractSTRtree.call(this, nodeCapacity);
};

jsts.index.strtree.STRtree.prototype = new jsts.index.strtree.AbstractSTRtree();
jsts.index.strtree.STRtree.constructor = jsts.index.strtree.STRtree;

/**
 * @type {Object} implements function for comparison
 * @private
 */
jsts.index.strtree.STRtree.prototype.xComparator = function(o1, o2) {
  return jsts.index.strtree.AbstractSTRtree.prototype.compareDoubles(
      jsts.index.strtree.STRtree.prototype.centreX(o1.getBounds()),
      jsts.index.strtree.STRtree.prototype.centreX(o2.getBounds()));
};


/**
 * @type {Object} implements function for comparison
 * @private
 */
jsts.index.strtree.STRtree.prototype.yComparator = function(o1, o2) {
  return jsts.index.strtree.AbstractSTRtree.prototype.compareDoubles(
      jsts.index.strtree.STRtree.prototype.centreY(o1.getBounds()),
      jsts.index.strtree.STRtree.prototype.centreY(o2.getBounds()));
};


/**
 * @param {jsts.geom.Envelope}
 *          e
 * @return {number}
 */
jsts.index.strtree.STRtree.prototype.centreX = function(e) {
  return jsts.index.strtree.STRtree.prototype.avg(e.getMinX(), e.getMaxX());
};


/**
 * @param {jsts.geom.Envelope}
 *          e
 * @return {number}
 */
jsts.index.strtree.STRtree.prototype.centreY = function(e) {
  return jsts.index.strtree.STRtree.prototype.avg(e.getMinY(), e.getMaxY());
};


/**
 * @param {number}
 *          a
 * @param {number}
 *          b
 * @return {number}
 */
jsts.index.strtree.STRtree.prototype.avg = function(a, b) {
  return (a + b) / 2.0;
};


/**
 * @type {Object}
 * @extends {jsts.index.strtree.AbstractSTRtree.IntersectsOp}
 * @private
 */
jsts.index.strtree.STRtree.prototype.intersectsOp = {
  intersects: function(aBounds, bBounds) {
    return aBounds.intersects(bBounds);
  }
};


/**
 * Creates the parent level for the given child level. First, orders the items
 * by the x-values of the midpoints, and groups them into vertical slices. For
 * each slice, orders the items by the y-values of the midpoints, and group them
 * into runs of size M (the node capacity). For each run, creates a new (parent)
 * node.
 *
 * @param {Array}
 *          childBoundables
 * @param {number}
 *          newLevel
 * @return {Array}
 * @protected
 */
jsts.index.strtree.STRtree.prototype.createParentBoundables = function(
    childBoundables, newLevel) {
  jsts.util.Assert.isTrue(!(childBoundables.length === 0));
  var minLeafCount = Math.ceil(childBoundables.length / this.getNodeCapacity());
  var sortedChildBoundables = [];
  for (var i = 0; i < childBoundables.length; i++) {
    sortedChildBoundables.push(childBoundables[i]);
  }
  sortedChildBoundables.sort(this.xComparator);
  var verticalSlices = this.verticalSlices(sortedChildBoundables, Math
      .ceil(Math.sqrt(minLeafCount)));
  return this
      .createParentBoundablesFromVerticalSlices(verticalSlices, newLevel);
};


/**
 *
 * @param {Array.
 *          <Array>} verticalSlices
 * @param {number}
 *          newLevel
 * @return {Array.<Array>}
 * @private
 */
jsts.index.strtree.STRtree.prototype.createParentBoundablesFromVerticalSlices = function(
    verticalSlices, newLevel) {
  jsts.util.Assert.isTrue(verticalSlices.length > 0);
  var parentBoundables = [];
  for (var i = 0; i < verticalSlices.length; i++) {
    parentBoundables = parentBoundables.concat(this.createParentBoundablesFromVerticalSlice(
        verticalSlices[i], newLevel));
  }
  return parentBoundables;
};


/**
 *
 * @param {Array}
 *          childBoundables
 * @param {number}
 *          newLevel
 * @return {Array}
 * @protected
 */
jsts.index.strtree.STRtree.prototype.createParentBoundablesFromVerticalSlice = function(
    childBoundables, newLevel) {
  return jsts.index.strtree.AbstractSTRtree.prototype.createParentBoundables
      .call(this, childBoundables, newLevel);
};


/**
 *
 * @param {Array}
 *          childBoundables
 * @param {number}
 *          sliceCount
 * @return {Array.<Array>}
 * @protected
 */
jsts.index.strtree.STRtree.prototype.verticalSlices = function(childBoundables,
    sliceCount) {
  var sliceCapacity = Math.ceil(childBoundables.length / sliceCount);
  var slices = [];

  var i = 0, boundablesAddedToSlice, childBoundable;

  for (var j = 0; j < sliceCount; j++) {
    slices[j] = [];
    boundablesAddedToSlice = 0;
    while (i < childBoundables.length && boundablesAddedToSlice < sliceCapacity) {
      childBoundable = childBoundables[i++];
      slices[j].push(childBoundable);
      boundablesAddedToSlice++;
    }
  }

  return slices;
};


/**
 * @type {number}
 * @const
 * @private
 */
jsts.index.strtree.STRtree.DEFAULT_NODE_CAPACITY = 10;


/**
 * @param {number}
 *          level
 * @return {jsts.index.strtree.AbstractNode}
 * @protected
 */
jsts.index.strtree.STRtree.prototype.createNode = function(level) {
  var abstractNode = new jsts.index.strtree.AbstractNode(level);

  abstractNode.computeBounds = function() {
    var bounds = null;
    var childBoundables = this.getChildBoundables();
    for (var i = 0; i < childBoundables.length; i++) {
      var childBoundable = childBoundables[i];
      if (bounds === null) {
        bounds = new jsts.geom.Envelope(childBoundable.getBounds());
      } else {
        bounds.expandToInclude(childBoundable.getBounds());
      }
    }
    return bounds;
  };

  return abstractNode;
};


/**
 * @return {jsts.index.strtree.AbstractSTRtree.IntersectsOp}
 * @protected
 */
jsts.index.strtree.STRtree.prototype.getIntersectsOp = function() {
  return this.intersectsOp;
};


/**
 * Inserts an item having the given bounds into the tree.
 *
 * @param {jsts.geom.Envelope}
 *          itemEnv
 * @param {Object}
 *          item
 * @public
 */
jsts.index.strtree.STRtree.prototype.insert = function(itemEnv, item) {
  if (itemEnv.isNull()) {
    return;
  }
  jsts.index.strtree.AbstractSTRtree.prototype.insert.call(this, itemEnv, item);
};


/**
 * Returns items whose bounds intersect the given envelope.
 *
 * @param {jsts.geom.Envelope}
 *          searchEnv
 * @param {jsts.index.ItemVisitor}
 *          visitor
 * @return {Array}
 * @public
 */
jsts.index.strtree.STRtree.prototype.query = function(searchEnv, visitor) {
  // Yes this method does something. It specifies that the bounds is an
  // Envelope. super.query takes an Object, not an Envelope. [Jon Aquino
  // 10/24/2003]
  return jsts.index.strtree.AbstractSTRtree.prototype.query.apply(this,
      arguments);
};


/**
 * Removes a single item from the tree.
 *
 * @param {jsts.geom.Envelope}
 *          itemEnv the Envelope of the item to remove.
 * @param {Object}
 *          item the item to remove.
 * @return {boolean} <code>true</code> if the item was found.
 * @public
 */
jsts.index.strtree.STRtree.prototype.remove = function(itemEnv, item) {
  return jsts.index.strtree.AbstractSTRtree.prototype.remove.call(this,
      itemEnv, item);
};


/**
 * Returns the number of items in the tree.
 *
 * @return {number} the number of items in the tree.
 * @public
 */
jsts.index.strtree.STRtree.prototype.size = function() {
  return jsts.index.strtree.AbstractSTRtree.prototype.size.call(this);
};


/**
 * Returns the number of items in the tree.
 *
 * @return {number} the number of items in the tree.
 * @public
 */
jsts.index.strtree.STRtree.prototype.depth = function() {
  return jsts.index.strtree.AbstractSTRtree.prototype.depth.call(this);
};


/**
 * @return {Object}
 * @protected
 */
jsts.index.strtree.STRtree.prototype.getComparator = function() {
  return this.yComparator;
};

/**
 * Finds the two nearest items in the tree, using {@link ItemDistance} as the
 * distance metric. A Branch-and-Bound tree traversal algorithm is used to
 * provide an efficient search.
 *
 * @param {ItemDistance}
 *          itemDist a distance metric applicable to the items in this tree.
 * @return {Object[]} the pair of the nearest items.
 */
jsts.index.strtree.STRtree.prototype.nearestNeighbour = function(itemDist) {
  var bp = new jsts.index.strtree.BoundablePair(this.getRoot(), this.getRoot(),
      itemDist);
  return this.nearestNeighbour4(bp);
};

/**
 * Finds the nearest item to the given object in this tree, using
 * {@link ItemDistance} as the distance metric. A Branch-and-Bound tree
 * traversal algorithm is used to provide an efficient search.
 *
 * @param {Envelope}
 *          env the envelope of the query item.
 * @param {Object}
 *          item the item to find the nearest neighbour of.
 * @param {ItemDistance}
 *          itemDist a distance metric applicable to the items in this tree and
 *          the query item.
 * @return {Object[]} the nearest item in this tree.
 */
jsts.index.strtree.STRtree.prototype.nearestNeighbour2 = function(env, item,
    itemDist) {
  var bnd = new jsts.index.strtree.ItemBoundable(env, item);
  var bp = new jsts.index.strtree.BoundablePair(this.getRoot(), bnd, itemDist);
  return this.nearestNeighbour4(bp)[0];
};

/**
 * Finds the two nearest items from this tree and another tree, using
 * {@link ItemDistance} as the distance metric. A Branch-and-Bound tree
 * traversal algorithm is used to provide an efficient search. The result value
 * is a pair of items, the first from this tree and the second from the argument
 * tree.
 *
 * @param {STRtree}
 *          tree another tree.
 * @param {ItemDistance}
 *          itemDist a distance metric applicable to the items in the trees.
 * @return {Object[]} the pair of the nearest items, one from each tree.
 */
jsts.index.strtree.STRtree.prototype.nearestNeighbour3 = function(tree,
    itemDist) {
  var bp = new jsts.index.strtree.BoundablePair(this.getRoot(), tree.getRoot(),
      itemDist);
  return this.nearestNeighbour4(bp);
};

jsts.index.strtree.STRtree.prototype.nearestNeighbour4 = function(initBndPair) {
  return this.nearestNeighbour5(initBndPair, Double.POSITIVE_INFINITY);
};

/**
 * NOTE: PriorityQueue replaces by js array
 *
 * @param initBndPair
 * @param maxDistance
 * @return {Array}
 */
jsts.index.strtree.STRtree.prototype.nearestNeighbour5 = function(initBndPair,
    maxDistance) {
  var distanceLowerBound = maxDistance;
  var minPair = null;

  // initialize internal structures
  var priQ = [];

  // initialize queue
  priQ.push(initBndPair);

  while (!priQ.isEmpty() && distanceLowerBound > 0.0) {
    // pop head of queue and expand one side of pair
    var bndPair = priQ.pop();
    var currentDistance = bndPair.getDistance();

    /**
     * If the distance for the first node in the queue is >= the current minimum
     * distance, all other nodes in the queue must also have a greater distance.
     * So the current minDistance must be the true minimum, and we are done.
     */
    if (currentDistance >= distanceLowerBound)
      break;

    /**
     * If the pair members are leaves then their distance is the exact lower
     * bound. Update the distanceLowerBound to reflect this (which must be
     * smaller, due to the test immediately prior to this).
     */
    if (bndPair.isLeaves()) {
      // assert: currentDistance < minimumDistanceFound
      distanceLowerBound = currentDistance;
      minPair = bndPair;
    } else {
      /**
       * Otherwise, expand one side of the pair, (the choice of which side to
       * expand is heuristically determined) and insert the new expanded pairs
       * into the queue
       */
      bndPair.expandToQueue(priQ, distanceLowerBound);
    }
  }
  // done - return items with min distance
  return [minPair.getBoundable(0).getItem(), minPair.getBoundable(1).getItem()];
};
/* ======================================================================
    jsts/noding/SegmentString.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * An interface for classes which represent a sequence of contiguous line
 * segments. SegmentStrings can carry a context object, which is useful for
 * preserving topological or parentage information.
 *
 * @interface
 */
jsts.noding.SegmentString = function() {

};


/**
 * Gets the user-defined data for this segment string.
 *
 * @return {Object} the user-defined data.
 */
jsts.noding.SegmentString.prototype.getData = jsts.abstractFunc;


/**
 * Sets the user-defined data for this segment string.
 *
 * @param {Object}
 *          data an Object containing user-defined data.
 */
jsts.noding.SegmentString.prototype.setData = jsts.abstractFunc;


/**
 * @return {number}
 */
jsts.noding.SegmentString.prototype.size = jsts.abstractFunc;


/**
 * @param {number}
 *          i
 * @return {jsts.geom.Coordinate}
 */
jsts.noding.SegmentString.prototype.getCoordinate = jsts.abstractFunc;


/**
 * @return {Array.<jsts.geom.Coordinate>}
 */
jsts.noding.SegmentString.prototype.getCoordinates = jsts.abstractFunc;


/**
 * @return {boolean}
 */
jsts.noding.SegmentString.prototype.isClosed = jsts.abstractFunc;
/* ======================================================================
    jsts/noding/NodableSegmentString.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @requires jsts/noding/SegmentString.js
 */



/**
 * An interface for classes which support adding nodes to a segment string.
 *
 * @interface
 */
jsts.noding.NodableSegmentString = function() {

};


jsts.noding.NodableSegmentString.prototype = new jsts.noding.SegmentString();


/**
 * Adds an intersection node for a given point and segment to this segment
 * string.
 *
 * @param {Coordinate}
 *          intPt the location of the intersection.
 * @param {number}
 *          segmentIndex the index of the segment containing the intersection.
 */
jsts.noding.NodableSegmentString.prototype.addIntersection = jsts.abstractFunc;
/* ======================================================================
    jsts/noding/NodedSegmentString.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Port source: /jts/jts/java/src/com/vividsolutions/jts/noding/NodedSegmentString.java
 * Revision: 478
 */

/**
 * @requires jsts/noding/NodableSegmentString.js
 */

/**
 * Represents a list of contiguous line segments, and supports noding the
 * segments. The line segments are represented by an array of {@link Coordinate}s.
 * Intended to optimize the noding of contiguous segments by reducing the number
 * of allocated objects. SegmentStrings can carry a context object, which is
 * useful for preserving topological or parentage information. All noded
 * substrings are initialized with the same context object.
 *
 * Creates a new segment string from a list of vertices.
 *
 * @param pts
 *          the vertices of the segment string.
 * @param data
 *          the user-defined data of this segment string (may be null).
 *
 * @constructor
 */
jsts.noding.NodedSegmentString = function(pts, data) {
  this.nodeList = new jsts.noding.SegmentNodeList(this);

  this.pts = pts;
  this.data = data;
};
jsts.noding.NodedSegmentString.prototype = new jsts.noding.NodableSegmentString();
jsts.noding.NodedSegmentString.constructor = jsts.noding.NodedSegmentString;


/**
 * Gets the {@link SegmentString}s which result from splitting this string at node points.
 *
 * @param {javascript.util.Collection}
 *          segStrings a Collection of NodedSegmentStrings.
 * @param {javascript.util.Collection} resultEdgelist
 *          a List which will collect the NodedSegmentStrings representing the
 *          substrings.
 * @return {Array} a Collection of NodedSegmentStrings representing the
 *         substrings.
 */
jsts.noding.NodedSegmentString.getNodedSubstrings = function(segStrings) {
  if (arguments.length === 2) {
    jsts.noding.NodedSegmentString.getNodedSubstrings2.apply(this, arguments);
    return;
  }

  var resultEdgelist = new javascript.util.ArrayList();
  jsts.noding.NodedSegmentString.getNodedSubstrings2(segStrings, resultEdgelist);
  return resultEdgelist;
};


/**
 * Adds the noded {@link SegmentString}s which result from splitting this string at node points.
 *
 * @param {javascript.util.Collection} segStrings
 *          a Collection of NodedSegmentStrings.
 * @param {javascript.util.Collection} resultEdgelist
 *          a List which will collect the NodedSegmentStrings representing the
 *          substrings.
 */
jsts.noding.NodedSegmentString.getNodedSubstrings2 = function(segStrings,
    resultEdgelist) {
  for (var i = segStrings.iterator(); i.hasNext(); ) {
    var ss = i.next();
    ss.getNodeList().addSplitEdges(resultEdgelist);
  }
};


/**
 * @type {jsts.noding.SegmentNodeList}
 * @private
 */
jsts.noding.NodedSegmentString.prototype.nodeList = null;


/**
 * @type {Array.<jsts.geom.Coordinate>}
 * @private
 */
jsts.noding.NodedSegmentString.prototype.pts = null;


/**
 * @type {Object}
 * @private
 */
jsts.noding.NodedSegmentString.prototype.data = null;


jsts.noding.NodedSegmentString.prototype.getData = function() {
  return this.data;
};
jsts.noding.NodedSegmentString.prototype.setData = function(data) {
  this.data = data;
};
jsts.noding.NodedSegmentString.prototype.getNodeList = function() {
  return this.nodeList;
};
jsts.noding.NodedSegmentString.prototype.size = function() {
  return this.pts.length;
};
jsts.noding.NodedSegmentString.prototype.getCoordinate = function(i) {
  return this.pts[i];
};
jsts.noding.NodedSegmentString.prototype.getCoordinates = function() {
  return this.pts;
};

jsts.noding.NodedSegmentString.prototype.isClosed = function() {
  return this.pts[0].equals(this.pts[this.pts.length - 1]);
};


/**
 * Gets the octant of the segment starting at vertex <code>index</code>.
 *
 * @param index
 *          the index of the vertex starting the segment. Must not be the last
 *          index in the vertex list.
 * @return the octant of the segment at the vertex.
 */
jsts.noding.NodedSegmentString.prototype.getSegmentOctant = function(index) {
  if (index === this.pts.length - 1)
    return -1;
  return this.safeOctant(this.getCoordinate(index), this.getCoordinate(index + 1));
};


/**
 * @private
 */
jsts.noding.NodedSegmentString.prototype.safeOctant = function(p0, p1) {
  if (p0.equals2D(p1))
    return 0;
  return jsts.noding.Octant.octant(p0, p1);
};


/**
 * Adds EdgeIntersections for one or both intersections found for a segment of
 * an edge to the edge intersection list.
 */
jsts.noding.NodedSegmentString.prototype.addIntersections = function(li,
    segmentIndex, geomIndex) {
  for (var i = 0; i < li.getIntersectionNum(); i++) {
    this.addIntersection(li, segmentIndex, geomIndex, i);
  }
};


/**
 * Add an SegmentNode for intersection intIndex. An intersection that falls
 * exactly on a vertex of the SegmentString is normalized to use the higher of
 * the two possible segmentIndexes
 */
jsts.noding.NodedSegmentString.prototype.addIntersection = function(li,
    segmentIndex, geomIndex, intIndex) {

  if (li instanceof jsts.geom.Coordinate) {
    this.addIntersection2.apply(this, arguments);
    return;
  }

  var intPt = new jsts.geom.Coordinate(li.getIntersection(intIndex));
  this.addIntersection2(intPt, segmentIndex);
};


/**
 * Adds an intersection node for a given point and segment to this segment
 * string.
 *
 * @param {jsts.geom.Coordinate} intPt
 *          the location of the intersection.
 * @param segmentIndex
 *          the index of the segment containing the intersection.
 */
jsts.noding.NodedSegmentString.prototype.addIntersection2 = function(intPt,
    segmentIndex) {
  this.addIntersectionNode(intPt, segmentIndex);
};


/**
 * Adds an intersection node for a given point and segment to this segment
 * string. If an intersection already exists for this exact location, the
 * existing node will be returned.
 *
 * @param {jsts.geom.Coordinate} intPt
 *          the location of the intersection.
 * @param segmentIndex
 *          the index of the segment containing the intersection.
 * @return {SegmentNode} the intersection node for the point.
 */
jsts.noding.NodedSegmentString.prototype.addIntersectionNode = function(intPt,
    segmentIndex) {
  var normalizedSegmentIndex = segmentIndex;
  // normalize the intersection point location
  var nextSegIndex = normalizedSegmentIndex + 1;
  if (nextSegIndex < this.pts.length) {
    var nextPt = this.pts[nextSegIndex];

    // Normalize segment index if intPt falls on vertex
    // The check for point equality is 2D only - Z values are ignored
    if (intPt.equals2D(nextPt)) {
      // Debug.println("normalized distance");
      normalizedSegmentIndex = nextSegIndex;
    }
  }
  /**
   * Add the intersection point to edge intersection list.
   */
  var ei = this.nodeList.add(intPt, normalizedSegmentIndex);
  return ei;
};

jsts.noding.NodedSegmentString.prototype.toString = function() {
  var geometryFactory = new jsts.geom.GeometryFactory();
  return new jsts.io.WKTWriter().write(geometryFactory.createLineString(this.pts));
};
/* ======================================================================
    jsts/index/chain/MonotoneChainBuilder.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Constructs {@link MonotoneChain}s for sequences of {@link Coordinate}s.
 *
 * @constructor
 */
jsts.index.chain.MonotoneChainBuilder = function() {

};

jsts.index.chain.MonotoneChainBuilder.toIntArray = function(list) {
  var array = [];
  for (var i = 0; i < list.length; i++) {
    array[i] = list[i];
  }
  return array;
};

jsts.index.chain.MonotoneChainBuilder.getChains = function(pts) {
  if (arguments.length === 2) {
    return jsts.index.chain.MonotoneChainBuilder.getChains2.apply(this, arguments);
  }

  return jsts.index.chain.MonotoneChainBuilder.getChains2(pts, null);
};

/**
 * Return a list of the {@link MonotoneChain}s for the given list of
 * coordinates.
 */
jsts.index.chain.MonotoneChainBuilder.getChains2 = function(pts, context) {
  var mcList = [];
  var startIndex = jsts.index.chain.MonotoneChainBuilder
      .getChainStartIndices(pts);
  for (var i = 0; i < startIndex.length - 1; i++) {
    var mc = new jsts.index.chain.MonotoneChain(pts, startIndex[i],
        startIndex[i + 1], context);
    mcList.push(mc);
  }
  return mcList;
};

/**
 * Return an array containing lists of start/end indexes of the monotone chains
 * for the given list of coordinates. The last entry in the array points to the
 * end point of the point array, for use as a sentinel.
 */
jsts.index.chain.MonotoneChainBuilder.getChainStartIndices = function(pts) {
  // find the startpoint (and endpoints) of all monotone chains in this edge
  var start = 0;
  var startIndexList = [];
  startIndexList.push(start);
  do {
    var last = jsts.index.chain.MonotoneChainBuilder.findChainEnd(pts, start);
    startIndexList.push(last);
    start = last;
  } while (start < pts.length - 1);
  // copy list to an array of ints, for efficiency
  var startIndex = jsts.index.chain.MonotoneChainBuilder
      .toIntArray(startIndexList);
  return startIndex;
};

/**
 * Finds the index of the last point in a monotone chain starting at a given
 * point. Any repeated points (0-length segments) will be included in the
 * monotone chain returned.
 *
 * @return the index of the last point in the monotone chain starting at
 *         <code>start</code>.
 * @private
 */
jsts.index.chain.MonotoneChainBuilder.findChainEnd = function(pts, start) {
  var safeStart = start;
  // skip any zero-length segments at the start of the sequence
  // (since they cannot be used to establish a quadrant)
  while (safeStart < pts.length - 1 &&
      pts[safeStart].equals2D(pts[safeStart + 1])) {
    safeStart++;
  }
  // check if there are NO non-zero-length segments
  if (safeStart >= pts.length - 1) {
    return pts.length - 1;
  }
  // determine overall quadrant for chain (which is the starting quadrant)
  var chainQuad = jsts.geomgraph.Quadrant.quadrant(pts[safeStart],
      pts[safeStart + 1]);
  var last = start + 1;
  while (last < pts.length) {
    // skip zero-length segments, but include them in the chain
    if (!pts[last - 1].equals2D(pts[last])) {
      // compute quadrant for next possible segment in chain
      var quad = jsts.geomgraph.Quadrant.quadrant(pts[last - 1],
          pts[last]);
      if (quad !== chainQuad)
        break;
    }
    last++;
  }
  return last - 1;
};
/* ======================================================================
    jsts/algorithm/LineIntersector.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * A LineIntersector is an algorithm that can both test whether two line
 * segments intersect and compute the intersection point if they do. The
 * intersection point may be computed in a precise or non-precise manner.
 * Computing it precisely involves rounding it to an integer. (This assumes that
 * the input coordinates have been made precise by scaling them to an integer
 * grid.)
 *
 * @constructor
 */
jsts.algorithm.LineIntersector = function() {
  this.inputLines = [[], []];
  this.intPt = [null, null];
  // alias the intersection points for ease of reference
  this.pa = this.intPt[0];
  this.pb = this.intPt[1];
  this.result = jsts.algorithm.LineIntersector.NO_INTERSECTION;
};


/**
 * Indicates that line segments do not intersect
 *
 * @type {int}
 */
jsts.algorithm.LineIntersector.NO_INTERSECTION = 0;


/**
 * Indicates that line segments intersect in a single point
 *
 * @type {int}
 */
jsts.algorithm.LineIntersector.POINT_INTERSECTION = 1;


/**
 * Indicates that line segments intersect in a line segment
 *
 * @type {int}
 */
jsts.algorithm.LineIntersector.COLLINEAR_INTERSECTION = 2;


/**
 * Force computed intersection to be rounded to a given precision model. No
 * getter is provided, because the precision model is not required to be
 * specified.
 *
 * @param precisionModel
 */
jsts.algorithm.LineIntersector.prototype.setPrecisionModel = function(
    precisionModel) {
  this.precisionModel = precisionModel;
};


/**
 * Gets an endpoint of an input segment.
 *
 * @param segmentIndex
 *          the index of the input segment (0 or 1).
 * @param ptIndex
 *          the index of the endpoint (0 or 1).
 * @return the specified endpoint.
 */
jsts.algorithm.LineIntersector.prototype.getEndpoint = function(segmentIndex,
    ptIndex) {
  return this.inputLines[segmentIndex][ptIndex];
};


/**
 * Computes the "edge distance" of an intersection point p along a segment. The
 * edge distance is a metric of the point along the edge. The metric used is a
 * robust and easy to compute metric function. It is <b>not</b> equivalent to
 * the usual Euclidean metric. It relies on the fact that either the x or the y
 * ordinates of the points in the edge are unique, depending on whether the edge
 * is longer in the horizontal or vertical direction.
 * <p>
 * NOTE: This function may produce incorrect distances for inputs where p is not
 * precisely on p1-p2 (E.g. p = (139,9) p1 = (139,10), p2 = (280,1) produces
 * distanct 0.0, which is incorrect.
 * <p>
 * My hypothesis is that the function is safe to use for points which are the
 * result of <b>rounding</b> points which lie on the line, but not safe to use
 * for <b>truncated</b> points.
 *
 * @param {Coordinate}
 *          p
 * @param {Coordinate}
 *          p0
 * @param {Coordinate}
 *          p1
 * @return {double}
 */
jsts.algorithm.LineIntersector.computeEdgeDistance = function(p, p0, p1) {
  var dx = Math.abs(p1.x - p0.x);
  var dy = Math.abs(p1.y - p0.y);

  var dist = -1.0; // sentinel value
  if (p.equals(p0)) {
    dist = 0.0;
  } else if (p.equals(p1)) {
    if (dx > dy) {
      dist = dx;
    } else {
      dist = dy;
    }
  } else {
    var pdx = Math.abs(p.x - p0.x);
    var pdy = Math.abs(p.y - p0.y);
    if (dx > dy) {
      dist = pdx;
    } else {
      dist = pdy;
    }
    // <FIX>
    // hack to ensure that non-endpoints always have a non-zero distance
    if (dist === 0.0 && !p.equals(p0)) {
      dist = Math.max(pdx, pdy);
    }
  }
  if (dist === 0.0 && !p.equals(p0)) {
    throw new jsts.error.IllegalArgumentError('Bad distance calculation');
  }
  return dist;
};


/**
 * This function is non-robust, since it may compute the square of large
 * numbers. Currently not sure how to improve this.
 *
 * @param {Coordinate}
 *          p
 * @param {Coordinate}
 *          p0
 * @param {Coordinate}
 *          p1
 * @return {double}
 */
jsts.algorithm.LineIntersector.nonRobustComputeEdgeDistance = function(p, p1,
    p2) {
  var dx = p.x - p1.x;
  var dy = p.y - p1.y;
  var dist = Math.sqrt(dx * dx + dy * dy); // dummy value
  if (!(dist === 0.0 && !p.equals(p1))) {
    throw new jsts.error.IllegalArgumentError('Invalid distance calculation');
  }
  return dist;
};


/**
 * @protected
 * @type {int}
 */
jsts.algorithm.LineIntersector.prototype.result = null;


/**
 * @protected
 * @type {Coordinate[][] }
 */
jsts.algorithm.LineIntersector.prototype.inputLines = null;


/**
 * @protected
 * @type {Coordinate[]}
 */
jsts.algorithm.LineIntersector.prototype.intPt = null;


/**
 * The indexes of the endpoints of the intersection lines, in order along the
 * corresponding line
 */
/**
 * @protected
 * @type {int[][]}
 */
jsts.algorithm.LineIntersector.prototype.intLineIndex = null;


/**
 * @protected
 * @type {boolean}
 */
jsts.algorithm.LineIntersector.prototype._isProper = null;


/**
 * @protected
 * @type {Coordinate}
 */
jsts.algorithm.LineIntersector.prototype.pa = null;


/**
 * @protected
 * @type {Coordinate}
 */
jsts.algorithm.LineIntersector.prototype.pb = null;


/**
 * @protected
 * @type {PrecisionModel}
 */
jsts.algorithm.LineIntersector.prototype.precisionModel = null;


/**
 * Compute the intersection of a point p and the line p1-p2. This function
 * computes the boolean value of the hasIntersection test. The actual value of
 * the intersection (if there is one) is equal to the value of <code>p</code>.
 *
 * @param {Coordinate}
 *          p
 * @param {Coordinate}
 *          p1
 * @param {Coordinate}
 *          p2
 */
jsts.algorithm.LineIntersector.prototype.computeIntersection = function(p, p1,
    p2) {
  throw new jsts.error.AbstractMethodInvocationError();
};


/**
 * @return {boolean}
 * @protected
 */
jsts.algorithm.LineIntersector.prototype.isCollinear = function() {
  return this.result === jsts.algorithm.LineIntersector.COLLINEAR_INTERSECTION;
};


/**
 * Computes the intersection of the lines p1-p2 and p3-p4. This function
 * computes both the boolean value of the hasIntersection test and the
 * (approximate) value of the intersection point itself (if there is one).
 *
 * @param {Coordinate}
 *          p1
 * @param {Coordinate}
 *          p2
 * @param {Coordinate}
 *          p3
 * @param {Coordinate}
 *          p4
 */
jsts.algorithm.LineIntersector.prototype.computeIntersection = function(p1, p2,
    p3, p4) {
  this.inputLines[0][0] = p1;
  this.inputLines[0][1] = p2;
  this.inputLines[1][0] = p3;
  this.inputLines[1][1] = p4;
  this.result = this.computeIntersect(p1, p2, p3, p4);
};


/**
 * @param {Coordinate}
 *          p1
 * @param {Coordinate}
 *          p2
 * @param {Coordinate}
 *          q1
 * @param {Coordinate}
 *          q2
 * @return {int}
 * @protected
 */
jsts.algorithm.LineIntersector.prototype.computeIntersect = function(p1, p2,
    q1, q2) {
  throw new jsts.error.AbstractMethodInvocationError();
};


/**
 * @return {boolean}
 * @protected
 */
jsts.algorithm.LineIntersector.prototype.isEndPoint = function() {
  return this.hasIntersection() && !this._isProper;
};


/**
 * Tests whether the input geometries intersect.
 *
 * @return {boolean} true if the input geometries intersect.
 */
jsts.algorithm.LineIntersector.prototype.hasIntersection = function() {
  return this.result !== jsts.algorithm.LineIntersector.NO_INTERSECTION;
};


/**
 * Returns the number of intersection points found. This will be either 0, 1 or
 * 2.
 *
 * @return {int}
 */
jsts.algorithm.LineIntersector.prototype.getIntersectionNum = function() {
  return this.result;
};


/**
 * Returns the intIndex'th intersection point
 *
 * @param {int}
 *          intIndex is 0 or 1.
 *
 * @return {Coordinate} the intIndex'th intersection point.
 */
jsts.algorithm.LineIntersector.prototype.getIntersection = function(intIndex) {
  return this.intPt[intIndex];
};


/**
 * @protected
 */
jsts.algorithm.LineIntersector.prototype.computeIntLineIndex = function() {
  if (this.intLineIndex === null) {
    this.intLineIndex = [[], []];
    this.computeIntLineIndex(0);
    this.computeIntLineIndex(1);
  }
};


/**
 * Test whether a point is a intersection point of two line segments. Note that
 * if the intersection is a line segment, this method only tests for equality
 * with the endpoints of the intersection segment. It does <b>not</b> return
 * true if the input point is internal to the intersection segment.
 *
 * @param {Coordinate}
 *          pt
 * @return {boolean} true if the input point is one of the intersection points.
 */
jsts.algorithm.LineIntersector.prototype.isIntersection = function(pt) {
  var i;
  for (i = 0; i < this.result; i++) {
    if (this.intPt[i].equals2D(pt)) {
      return true;
    }
  }
  return false;
};


/**
 * Tests whether either intersection point is an interior point of one of the
 * input segments.
 *
 * @return {boolean} <code>true</code> if either intersection point is in the
 *         interior of one of the input segments.
 */
jsts.algorithm.LineIntersector.prototype.isInteriorIntersection = function() {
  if (arguments.length === 1) {
    return this.isInteriorIntersection2.apply(this, arguments);
  }

  if (this.isInteriorIntersection(0)) {
    return true;
  }
  if (this.isInteriorIntersection(1)) {
    return true;
  }
  return false;
};


/**
 * Tests whether either intersection point is an interior point of the specified
 * input segment.
 *
 * @param {[]} inputLineIndex
 * @return {boolean} <code>true</code> if either intersection point is in the
 *         interior of the input segment.
 */
jsts.algorithm.LineIntersector.prototype.isInteriorIntersection2 = function(
    inputLineIndex) {
  var i;
  for (i = 0; i < this.result; i++) {
    if (!(this.intPt[i].equals2D(this.inputLines[inputLineIndex][0]) || this.intPt[i]
        .equals2D(this.inputLines[inputLineIndex][1]))) {
      return true;
    }
  }
  return false;
};


/**
 * Tests whether an intersection is proper. <br>
 * The intersection between two line segments is considered proper if they
 * intersect in a single point in the interior of both segments (e.g. the
 * intersection is a single point and is not equal to any of the endpoints).
 * <p>
 * The intersection between a point and a line segment is considered proper if
 * the point lies in the interior of the segment (e.g. is not equal to either of
 * the endpoints).
 *
 * @return {boolean} true if the intersection is proper.
 */
jsts.algorithm.LineIntersector.prototype.isProper = function() {
  return this.hasIntersection() && this._isProper;
};


/**
 * Computes the intIndex'th intersection point in the direction of a specified
 * input line segment
 *
 * @param {int}
 *          segmentIndex is 0 or 1.
 * @param {int}
 *          intIndex is 0 or 1.
 *
 * @return {Coordinate} the intIndex'th intersection point in the direction of
 *         the specified input line segment.
 */
jsts.algorithm.LineIntersector.prototype.getIntersectionAlongSegment = function(
    segmentIndex, intIndex) {
  // lazily compute int line array
  this.computeIntLineIndex();
  return this.intPt[intLineIndex[segmentIndex][intIndex]];
};


/**
 * Computes the index of the intIndex'th intersection point in the direction of
 * a specified input line segment
 *
 * @param {int}
 *          segmentIndex is 0 or 1.
 * @param {int}
 *          intIndex is 0 or 1.
 *
 * @return {int} the index of the intersection point along the segment (0 or 1).
 */
jsts.algorithm.LineIntersector.prototype.getIndexAlongSegment = function(
    segmentIndex, intIndex) {
  this.computeIntLineIndex();
  return this.intLineIndex[segmentIndex][intIndex];
};


/**
 * @param {int}
 *          segmentIndex
 * @protected
 */
jsts.algorithm.LineIntersector.prototype.computeIntLineIndex = function(
    segmentIndex) {
  var dist0 = this.getEdgeDistance(segmentIndex, 0);
  var dist1 = this.getEdgeDistance(segmentIndex, 1);
  if (dist0 > dist1) {
    this.intLineIndex[segmentIndex][0] = 0;
    this.intLineIndex[segmentIndex][1] = 1;
  } else {
    this.intLineIndex[segmentIndex][0] = 1;
    this.intLineIndex[segmentIndex][1] = 0;
  }
};


/**
 * Computes the "edge distance" of an intersection point along the specified
 * input line segment.
 *
 * @param {int}
 *          segmentIndex is 0 or 1.
 * @param {int}
 *          intIndex is 0 or 1.
 *
 * @return {double} the edge distance of the intersection point.
 */
jsts.algorithm.LineIntersector.prototype.getEdgeDistance = function(
    segmentIndex, intIndex) {
  var dist = jsts.algorithm.LineIntersector.computeEdgeDistance(
      this.intPt[intIndex], this.inputLines[segmentIndex][0],
      this.inputLines[segmentIndex][1]);
  return dist;
};
/* ======================================================================
    jsts/algorithm/RobustLineIntersector.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */


/**
 * @requires jsts/algorithm/LineIntersector.js
 */



/**
 * A robust version of {@LineIntersector}.
 *
 * @constructor
 * @augments jsts.algorithm.LineIntersector
 */
jsts.algorithm.RobustLineIntersector = function() {
  jsts.algorithm.RobustLineIntersector.prototype.constructor.call(this);
};

jsts.algorithm.RobustLineIntersector.prototype = new jsts.algorithm.LineIntersector();


/**
 * @param {Coordinate}
 *          p
 * @param {Coordinate}
 *          p1
 * @param {Coordinate}
 *          p2
 */
jsts.algorithm.RobustLineIntersector.prototype.computeIntersection = function(
    p, p1, p2) {

  if (arguments.length === 4) {
    jsts.algorithm.LineIntersector.prototype.computeIntersection.apply(this, arguments);
    return;
  }

  this._isProper = false;
  // do between check first, since it is faster than the orientation test
  if (jsts.geom.Envelope.intersects(p1, p2, p)) {
    if ((jsts.algorithm.CGAlgorithms.orientationIndex(p1, p2, p) === 0) &&
        (jsts.algorithm.CGAlgorithms.orientationIndex(p2, p1, p) === 0)) {
      this._isProper = true;
      if (p.equals(p1) || p.equals(p2)) {
        this._isProper = false;
      }
      this.result = jsts.algorithm.LineIntersector.POINT_INTERSECTION;
      return;
    }
  }
  this.result = jsts.algorithm.LineIntersector.NO_INTERSECTION;
};


/**
 * @param {Coordinate}
 *          p1
 * @param {Coordinate}
 *          p2
 * @param {Coordinate}
 *          q1
 * @param {Coordinate}
 *          q2
 * @return {Number}
 * @protected
 */
jsts.algorithm.RobustLineIntersector.prototype.computeIntersect = function(p1,
    p2, q1, q2) {
  this._isProper = false;

  // first try a fast test to see if the envelopes of the lines intersect
  if (!jsts.geom.Envelope.intersects(p1, p2, q1, q2)) {
    return jsts.algorithm.LineIntersector.NO_INTERSECTION;
  }

  // for each endpoint, compute which side of the other segment it lies
  // if both endpoints lie on the same side of the other segment,
  // the segments do not intersect
  var Pq1 = jsts.algorithm.CGAlgorithms.orientationIndex(p1, p2, q1);
  var Pq2 = jsts.algorithm.CGAlgorithms.orientationIndex(p1, p2, q2);

  if ((Pq1 > 0 && Pq2 > 0) || (Pq1 < 0 && Pq2 < 0)) {
    return jsts.algorithm.LineIntersector.NO_INTERSECTION;
  }

  var Qp1 = jsts.algorithm.CGAlgorithms.orientationIndex(q1, q2, p1);
  var Qp2 = jsts.algorithm.CGAlgorithms.orientationIndex(q1, q2, p2);

  if ((Qp1 > 0 && Qp2 > 0) || (Qp1 < 0 && Qp2 < 0)) {
    return jsts.algorithm.LineIntersector.NO_INTERSECTION;
  }

  var collinear = Pq1 === 0 && Pq2 === 0 && Qp1 === 0 && Qp2 === 0;
  if (collinear) {
    return this.computeCollinearIntersection(p1, p2, q1, q2);
  }

  /**
   * At this point we know that there is a single intersection point (since the
   * lines are not collinear).
   */

  /**
   * Check if the intersection is an endpoint. If it is, copy the endpoint as
   * the intersection point. Copying the point rather than computing it ensures
   * the point has the exact value, which is important for robustness. It is
   * sufficient to simply check for an endpoint which is on the other line,
   * since at this point we know that the inputLines must intersect.
   */
  if (Pq1 === 0 || Pq2 === 0 || Qp1 === 0 || Qp2 === 0) {
    this._isProper = false;

    /**
     * Check for two equal endpoints. This is done explicitly rather than by the
     * orientation tests below in order to improve robustness.
     *
     * [An example where the orientation tests fail to be consistent is the
     * following (where the true intersection is at the shared endpoint POINT
     * (19.850257749638203 46.29709338043669)
     *
     * LINESTRING ( 19.850257749638203 46.29709338043669, 20.31970698357233
     * 46.76654261437082 ) and LINESTRING ( -48.51001596420236
     * -22.063180333403878, 19.850257749638203 46.29709338043669 )
     *
     * which used to produce the INCORRECT result: (20.31970698357233,
     * 46.76654261437082, NaN)
     *
     */
    if (p1.equals2D(q1) || p1.equals2D(q2)) {
      this.intPt[0] = p1;
    } else if (p2.equals2D(q1) || p2.equals2D(q2)) {
      this.intPt[0] = p2;
    }

    /**
     * Now check to see if any endpoint lies on the interior of the other
     * segment.
     */
    else if (Pq1 === 0) {
      this.intPt[0] = new jsts.geom.Coordinate(q1);
    } else if (Pq2 === 0) {
      this.intPt[0] = new jsts.geom.Coordinate(q2);
    } else if (Qp1 === 0) {
      this.intPt[0] = new jsts.geom.Coordinate(p1);
    } else if (Qp2 === 0) {
      this.intPt[0] = new jsts.geom.Coordinate(p2);
    }
  } else {
    this._isProper = true;
    this.intPt[0] = this.intersection(p1, p2, q1, q2);
  }
  return jsts.algorithm.LineIntersector.POINT_INTERSECTION;
};


/**
 * @param {Coordinate}
 *          p1
 * @param {Coordinate}
 *          p2
 * @param {Coordinate}
 *          q1
 * @param {Coordinate}
 *          q2
 * @return {Number}
 * @private
 */
jsts.algorithm.RobustLineIntersector.prototype.computeCollinearIntersection = function(
    p1, p2, q1, q2) {
  var p1q1p2 = jsts.geom.Envelope.intersects(p1, p2, q1);
  var p1q2p2 = jsts.geom.Envelope.intersects(p1, p2, q2);
  var q1p1q2 = jsts.geom.Envelope.intersects(q1, q2, p1);
  var q1p2q2 = jsts.geom.Envelope.intersects(q1, q2, p2);

  if (p1q1p2 && p1q2p2) {
    this.intPt[0] = q1;
    this.intPt[1] = q2;
    return jsts.algorithm.LineIntersector.COLLINEAR_INTERSECTION;
  }
  if (q1p1q2 && q1p2q2) {
    this.intPt[0] = p1;
    this.intPt[1] = p2;
    return jsts.algorithm.LineIntersector.COLLINEAR_INTERSECTION;
  }
  if (p1q1p2 && q1p1q2) {
    this.intPt[0] = q1;
    this.intPt[1] = p1;
    return q1.equals(p1) && !p1q2p2 && !q1p2q2 ? jsts.algorithm.LineIntersector.POINT_INTERSECTION
        : jsts.algorithm.LineIntersector.COLLINEAR_INTERSECTION;
  }
  if (p1q1p2 && q1p2q2) {
    this.intPt[0] = q1;
    this.intPt[1] = p2;
    return q1.equals(p2) && !p1q2p2 && !q1p1q2 ? jsts.algorithm.LineIntersector.POINT_INTERSECTION
        : jsts.algorithm.LineIntersector.COLLINEAR_INTERSECTION;
  }
  if (p1q2p2 && q1p1q2) {
    this.intPt[0] = q2;
    this.intPt[1] = p1;
    return q2.equals(p1) && !p1q1p2 && !q1p2q2 ? jsts.algorithm.LineIntersector.POINT_INTERSECTION
        : jsts.algorithm.LineIntersector.COLLINEAR_INTERSECTION;
  }
  if (p1q2p2 && q1p2q2) {
    this.intPt[0] = q2;
    this.intPt[1] = p2;
    return q2.equals(p2) && !p1q1p2 && !q1p1q2 ? jsts.algorithm.LineIntersector.POINT_INTERSECTION
        : jsts.algorithm.LineIntersector.COLLINEAR_INTERSECTION;
  }
  return jsts.algorithm.LineIntersector.NO_INTERSECTION;
};


/**
 * This method computes the actual value of the intersection point. To obtain
 * the maximum precision from the intersection calculation, the coordinates are
 * normalized by subtracting the minimum ordinate values (in absolute value).
 * This has the effect of removing common significant digits from the
 * calculation to maintain more bits of precision.
 *
 * @param {Coordinate}
 *          p1
 * @param {Coordinate}
 *          p2
 * @param {Coordinate}
 *          q1
 * @param {Coordinate}
 *          q2
 * @return {Coordinate}
 * @private
 */
jsts.algorithm.RobustLineIntersector.prototype.intersection = function(p1, p2,
    q1, q2) {
  var intPt = this.intersectionWithNormalization(p1, p2, q1, q2);

  /**
   * Due to rounding it can happen that the computed intersection is outside the
   * envelopes of the input segments. Clearly this is inconsistent. This code
   * checks this condition and forces a more reasonable answer
   *
   * MD - May 4 2005 - This is still a problem. Here is a failure case:
   *
   * LINESTRING (2089426.5233462777 1180182.3877339689, 2085646.6891757075
   * 1195618.7333999649) LINESTRING (1889281.8148903656 1997547.0560044837,
   * 2259977.3672235999 483675.17050843034) int point =
   * (2097408.2633752143,1144595.8008114607)
   *
   * MD - Dec 14 2006 - This does not seem to be a failure case any longer
   */
  if (!this.isInSegmentEnvelopes(intPt)) {
    // System.out.println("Intersection outside segment envelopes: " + intPt);
    // System.out.println("Segments: " + this);
    // compute a safer result
    intPt = jsts.algorithm.CentralEndpointIntersector.getIntersection(p1, p2, q1, q2);
    // System.out.println("Snapped to " + intPt);
  }

  if (this.precisionModel !== null) {
    this.precisionModel.makePrecise(intPt);
  }

  return intPt;
};


/**
 * @param {Coordinate}
 *          p1
 * @param {Coordinate}
 *          p2
 * @param {Coordinate}
 *          q1
 * @param {Coordinate}
 *          q2
 * @return {Coordinate}
 * @private
 */
jsts.algorithm.RobustLineIntersector.prototype.intersectionWithNormalization = function(
    p1, p2, q1, q2) {
  var n1 = new jsts.geom.Coordinate(p1);
  var n2 = new jsts.geom.Coordinate(p2);
  var n3 = new jsts.geom.Coordinate(q1);
  var n4 = new jsts.geom.Coordinate(q2);
  var normPt = new jsts.geom.Coordinate();
  this.normalizeToEnvCentre(n1, n2, n3, n4, normPt);

  var intPt = this.safeHCoordinateIntersection(n1, n2, n3, n4);

  intPt.x += normPt.x;
  intPt.y += normPt.y;

  return intPt;
};


/**
 * Computes a segment intersection using homogeneous coordinates. Round-off
 * error can cause the raw computation to fail, (usually due to the segments
 * being approximately parallel). If this happens, a reasonable approximation is
 * computed instead.
 *
 * @param {Coordinate}
 *          p1 a segment endpoint.
 * @param {Coordinate}
 *          p2 a segment endpoint.
 * @param {Coordinate}
 *          q1 a segment endpoint.
 * @param {Coordinate}
 *          q2 a segment endpoint.
 * @return {Coordinate} the computed intersection point.
 * @private
 */
jsts.algorithm.RobustLineIntersector.prototype.safeHCoordinateIntersection = function(
    p1, p2, q1, q2) {
  var intPt = null;
  try {
    intPt = jsts.algorithm.HCoordinate.intersection(p1, p2, q1, q2);
  } catch (e) {
    if (e instanceof jsts.error.NotRepresentableError) {
      // System.out.println("Not calculable: " + this);
      // compute an approximate result
      intPt = jsts.algorithm.CentralEndpointIntersector.getIntersection(p1, p2,
          q1, q2);
      // System.out.println("Snapped to " + intPt);
    } else {
      throw e;
    }
  }

  return intPt;
};


/**
 * Normalize the supplied coordinates so that their minimum ordinate values lie
 * at the origin. NOTE: this normalization technique appears to cause large
 * errors in the position of the intersection point for some cases.
 *
 * @param {Coordinate}
 *          n1
 * @param {Coordinate}
 *          n2
 * @param {Coordinate}
 *          n3
 * @param {Coordinate}
 *          n4
 * @param {Coordinate}
 *          normPt
 */
jsts.algorithm.RobustLineIntersector.prototype.normalizeToMinimum = function(
    n1, n2, n3, n4, normPt) {
  normPt.x = this.smallestInAbsValue(n1.x, n2.x, n3.x, n4.x);
  normPt.y = this.smallestInAbsValue(n1.y, n2.y, n3.y, n4.y);
  n1.x -= normPt.x;
  n1.y -= normPt.y;
  n2.x -= normPt.x;
  n2.y -= normPt.y;
  n3.x -= normPt.x;
  n3.y -= normPt.y;
  n4.x -= normPt.x;
  n4.y -= normPt.y;
};


/**
 * Normalize the supplied coordinates to so that the midpoint of their
 * intersection envelope lies at the origin.
 *
 * @param {Coordinate}
 *          n00
 * @param {Coordinate}
 *          n01
 * @param {Coordinate}
 *          n10
 * @param {Coordinate}
 *          n11
 * @param {Coordinate}
 *          normPt
 */
jsts.algorithm.RobustLineIntersector.prototype.normalizeToEnvCentre = function(
    n00, n01, n10, n11, normPt) {
  var minX0 = n00.x < n01.x ? n00.x : n01.x;
  var minY0 = n00.y < n01.y ? n00.y : n01.y;
  var maxX0 = n00.x > n01.x ? n00.x : n01.x;
  var maxY0 = n00.y > n01.y ? n00.y : n01.y;

  var minX1 = n10.x < n11.x ? n10.x : n11.x;
  var minY1 = n10.y < n11.y ? n10.y : n11.y;
  var maxX1 = n10.x > n11.x ? n10.x : n11.x;
  var maxY1 = n10.y > n11.y ? n10.y : n11.y;

  var intMinX = minX0 > minX1 ? minX0 : minX1;
  var intMaxX = maxX0 < maxX1 ? maxX0 : maxX1;
  var intMinY = minY0 > minY1 ? minY0 : minY1;
  var intMaxY = maxY0 < maxY1 ? maxY0 : maxY1;

  var intMidX = (intMinX + intMaxX) / 2.0;
  var intMidY = (intMinY + intMaxY) / 2.0;
  normPt.x = intMidX;
  normPt.y = intMidY;

  /*
  // equilavalent code using more modular but slower method
  Envelope env0 = new Envelope(n00, n01);
  Envelope env1 = new Envelope(n10, n11);
  Envelope intEnv = env0.intersection(env1);
  Coordinate intMidPt = intEnv.centre();

  normPt.x = intMidPt.x;
  normPt.y = intMidPt.y;
  */

  n00.x -= normPt.x;
  n00.y -= normPt.y;
  n01.x -= normPt.x;
  n01.y -= normPt.y;
  n10.x -= normPt.x;
  n10.y -= normPt.y;
  n11.x -= normPt.x;
  n11.y -= normPt.y;
};


/**
 * @param {double}
 *          x1
 * @param {double}
 *          x2
 * @param {double}
 *          x3
 * @param {double}
 *          x4
 * @return {double}
 */
jsts.algorithm.RobustLineIntersector.prototype.smallestInAbsValue = function(
    x1, x2, x3, x4) {
  var x = x1;
  var xabs = Math.abs(x);
  if (Math.abs(x2) < xabs) {
    x = x2;
    xabs = Math.abs(x2);
  }
  if (Math.abs(x3) < xabs) {
    x = x3;
    xabs = Math.abs(x3);
  }
  if (Math.abs(x4) < xabs) {
    x = x4;
  }
  return x;
};


/**
 * Test whether a point lies in the envelopes of both input segments. A
 * correctly computed intersection point should return <code>true</code> for
 * this test. Since this test is for debugging purposes only, no attempt is made
 * to optimize the envelope test.
 *
 * @param {Coordinate}
 *          intPt
 * @return {boolean} <code>true</code> if the input point lies within both
 *         input segment envelopes.
 * @private
 */
jsts.algorithm.RobustLineIntersector.prototype.isInSegmentEnvelopes = function(
    intPt) {
  var env0 = new jsts.geom.Envelope(this.inputLines[0][0],
      this.inputLines[0][1]);
  var env1 = new jsts.geom.Envelope(this.inputLines[1][0],
      this.inputLines[1][1]);
  return env0.contains(intPt) && env1.contains(intPt);
};
/* ======================================================================
    jsts/algorithm/HCoordinate.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * Represents a homogeneous coordinate in a 2-D coordinate space. In JTS
 * {@link HCoordinate}s are used as a clean way of computing intersections
 * between line segments.
 *
 * Will call correct init* function depending on argument.
 *
 * @constructor
 */
jsts.algorithm.HCoordinate = function() {
  this.x = 0.0;
  this.y = 0.0;
  this.w = 1.0;

  if (arguments.length === 1) {
    this.initFrom1Coordinate(arguments[0]);
  } else if (arguments.length === 2 &&
      arguments[0] instanceof jsts.geom.Coordinate) {
    this.initFrom2Coordinates(arguments[0], arguments[1]);
  } else if (arguments.length === 2 &&
      arguments[0] instanceof jsts.algorithm.HCoordinate) {
    this.initFrom2HCoordinates(arguments[0], arguments[1]);
  } else if (arguments.length === 2) {
    this.initFromXY(arguments[0], arguments[1]);
  } else if (arguments.length === 3) {
    this.initFromXYW(arguments[0], arguments[1], arguments[2]);
  } else if (arguments.length === 4) {
    this.initFromXYW(arguments[0], arguments[1], arguments[2], arguments[3]);
  }
};


/**
 * Computes the (approximate) intersection point between two line segments using
 * homogeneous coordinates.
 * <p>
 * Note that this algorithm is not numerically stable; i.e. it can produce
 * intersection points which lie outside the envelope of the line segments
 * themselves. In order to increase the precision of the calculation input
 * points should be normalized before passing them to this routine.
 *
 * @param {jsts.geom.Coordinate}
 *          p1 first coordinate for the first line.
 * @param {jsts.geom.Coordinate}
 *          p2 second coordinate for the first line.
 * @param {jsts.geom.Coordinate}
 *          q1 first coordinate for the second line.
 * @param {jsts.geom.Coordinate}
 *          q2 second coordinate for the second line.
 * @return {jsts.geom.Coordinate} The coordinate of the intersection.
 */
jsts.algorithm.HCoordinate.intersection = function(p1, p2, q1, q2) {
  var px, py, pw, qx, qy, qw, x, y, w, xInt, yInt;

  // unrolled computation
  px = p1.y - p2.y;
  py = p2.x - p1.x;
  pw = p1.x * p2.y - p2.x * p1.y;

  qx = q1.y - q2.y;
  qy = q2.x - q1.x;
  qw = q1.x * q2.y - q2.x * q1.y;

  x = py * qw - qy * pw;
  y = qx * pw - px * qw;
  w = px * qy - qx * py;

  xInt = x / w;
  yInt = y / w;

  if (!isFinite(xInt) || !isFinite(yInt)) {
    throw new jsts.error.NotRepresentableError();
  }

  return new jsts.geom.Coordinate(xInt, yInt);
};


/**
 * Initializes a new HCoordinate from 1 Coordinate
 *
 * @param {jsts.geom.Coordinate}
 *          p the coordinate.
 */
jsts.algorithm.HCoordinate.prototype.initFrom1Coordinate = function(p) {
  this.x = p.x;
  this.y = p.y;
  this.w = 1.0;
};


/**
 * Constructs a homogeneous coordinate which is the intersection of the lines
 * define by the homogenous coordinates represented by two {@link Coordinate}s.
 *
 * @param {jsts.geom.Coordinate}
 *          p1 the first coordinate.
 * @param {jsts.geom.Coordinate}
 *          p2 the second coordinate.
 */
jsts.algorithm.HCoordinate.prototype.initFrom2Coordinates = function(p1, p2) {
  // optimization when it is known that w = 1
  this.x = p1.y - p2.y;
  this.y = p2.x - p1.x;
  this.w = p1.x * p2.y - p2.x * p1.y;
};


/**
 * Initializes from 2 HCoordinates
 *
 * @param {jsts.algorithm.HCoordinate}
 *          p1 the first HCoordinate.
 * @param {jsts.algorithm.HCoordinate}
 *          p2 the second HCoordinate.
 */
jsts.algorithm.HCoordinate.prototype.initFrom2HCoordinates = function(p1, p2) {
  this.x = p1.y * p2.w - p2.y * p1.w;
  this.y = p2.x * p1.w - p1.x * p2.w;
  this.w = p1.x * p2.y - p2.x * p1.y;
};


/**
 * Initializes from x,y,w
 *
 * @param {Number}
 *          x the x-value.
 * @param {Number}
 *          y the y-value.
 * @param {Number}
 *          w the w-value.
 */
jsts.algorithm.HCoordinate.prototype.initFromXYW = function(x, y, w) {
  this.x = x;
  this.y = y;
  this.w = w;
};


/**
 * Initializes from x,y
 *
 * @param {Number}
 *          x the x-value.
 * @param {Number}
 *          y the y-value.
 */
jsts.algorithm.HCoordinate.prototype.initFromXY = function(x, y) {
  this.x = x;
  this.y = y;
  this.w = 1.0;
};


/**
 * Initializes from 4 Coordinates
 *
 * @param {jsts.geom.Coordinate}
 *          p1 the first coordinate.
 * @param {jsts.geom.Coordinate}
 *          p2 the second coordinate.
 * @param {jsts.geom.Coordinate}
 *          q1 the first coordinate.
 * @param {jsts.geom.Coordinate}
 *          q2 the second coordinate.
 */
jsts.algorithm.HCoordinate.prototype.initFrom4Coordinates = function(p1, p2,
    q1, q2) {
  var px, py, pw, qx, qy, qw;
  // unrolled computation
  px = p1.y - p2.y;
  py = p2.x - p1.x;
  pw = p1.x * p2.y - p2.x * p1.y;

  qx = q1.y - q2.y;
  qy = q2.x - q1.x;
  qw = q1.x * q2.y - q2.x * q1.y;

  this.x = py * qw - qy * pw;
  this.y = qx * pw - px * qw;
  this.w = px * qy - qx * py;
};


/**
 * Gets x/w
 *
 * @return {Number} x/w.
 */
jsts.algorithm.HCoordinate.prototype.getX = function() {
  var a = this.x / this.w;

  if (!isFinite(a)) {
    throw new jsts.error.NotRepresentableError();
  }
  return a;
};


/**
 * Gets y/w
 *
 * @return {Number} y/w.
 */
jsts.algorithm.HCoordinate.prototype.getY = function() {
  var a = this.y / this.w;

  if (!isFinite(a)) {
    throw new jsts.error.NotRepresentableError();
  }
  return a;
};


/**
 * Gets a coordinate represented by this HCoordinate
 *
 * @return {jst.geom.Coordinate} The coordinate.
 */
jsts.algorithm.HCoordinate.prototype.getCoordinate = function() {
  var p = new jsts.geom.Coordinate();
  p.x = this.getX();
  p.y = this.getY();
  return p;
};
/* ======================================================================
    jsts/geom/LineSegment.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @requires jsts/geom/Coordinate.js
 * @requires jsts/algorithm/CGAlgorithms.js
 * @requires jsts/algorithm/RobustLineIntersector.js
 * @requires jsts/algorithm/HCoordinate.js
 */

/**
 * Represents a line segment defined by two {@link Coordinate}s. Provides
 * methods to compute various geometric properties and relationships of line
 * segments.
 * <p>
 * This class is designed to be easily mutable (to the extent of having its
 * contained points public). This supports a common pattern of reusing a single
 * LineSegment object as a way of computing segment properties on the segments
 * defined by arrays or lists of {@link Coordinate}s.
 *
 * @param {Coordinate}
 *          p0
 * @param {Coordinate}
 *          p1
 * @constructor
 */
jsts.geom.LineSegment = function () {
    if (arguments.length === 0) {
        this.p0 = new jsts.geom.Coordinate();
        this.p1 = new jsts.geom.Coordinate();
    } else if (arguments.length === 1) {
        this.p0 = arguments[0].p0;
        this.p1 = arguments[0].p1;
    } else if (arguments.length === 2) {
        this.p0 = arguments[0];
        this.p1 = arguments[1];
    } else if (arguments.length === 4) {
        this.p0 = new jsts.geom.Coordinate(arguments[0], arguments[1]);
        this.p1 = new jsts.geom.Coordinate(arguments[2], arguments[3]);
    }
};

/**
 * @type {Coordinate}
 */
jsts.geom.LineSegment.prototype.p0 = null;


/**
 * @type {Coordinate}
 */
jsts.geom.LineSegment.prototype.p1 = null;

/**
 * Computes the midpoint of a segment
 *
 * @param {jsts.geom.Coordinate} p0
 * @param {jsts.geom.Coordinate} p1
 * @return {jsts.geom.Coordinate} the midpoint of the segment
 */
jsts.geom.LineSegment.midPoint = function (p0, p1) {
    return new jsts.geom.Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2);
};

/**
 * @param {number} i
 * @return {jsts.geom.Coordinate}
 */
jsts.geom.LineSegment.prototype.getCoordinate = function (i) {
    if (i === 0) return this.p0;
    return this.p1;
};

/**
 * Computes the length of the line segment.
 *
 * @return {number} the length of the line segment.
 */
jsts.geom.LineSegment.prototype.getLength = function () {
    return this.p0.distance(this.p1);
};

/**
 * Tests whether the segment is horizontal.
 *
 * @return {boolean} <code>true</code> if the segment is horizontal.
 */
jsts.geom.LineSegment.prototype.isHorizontal = function () {
    return this.p0.y === this.p1.y;
};
/**
 * Tests whether the segment is vertical.
 *
 * @return {boolean} <code>true</code> if the segment is vertical.
 */
jsts.geom.LineSegment.prototype.isVertical = function () {
    return this.p0.x === this.p1.x;
};

jsts.geom.LineSegment.prototype.orientationIndex = function (arg) {
    if (arg instanceof jsts.geom.LineSegment) {
        return this.orientationIndex1(arg);
    } else if (arg instanceof jsts.geom.Coordinate) {
        return this.orientationIndex2(arg);
    }
};

/**
  * Determines the orientation of a LineSegment relative to this segment.
  * The concept of orientation is specified as follows:
  * Given two line segments A and L,
  * <ul>
  * <li>A is to the left of a segment L if A lies wholly in the
  * closed half-plane lying to the left of L
  * <li>A is to the right of a segment L if A lies wholly in the
  * closed half-plane lying to the right of L
  * <li>otherwise, A has indeterminate orientation relative to L. This
  * happens if A is collinear with L or if A crosses the line determined by L.
  * </ul>
  *
  * @param {jsts.geom.LineSegment} seg the LineSegment to compare
  *
  * @return 1 if <code>seg</code> is to the left of this segment<br />
  * -1 if <code>seg</code> is to the right of this segment<br />
  * 0 if <code>seg</code> has indeterminate orientation relative to this segment
  */
jsts.geom.LineSegment.prototype.orientationIndex1 = function (seg) {
    var orient0 = jsts.algorithm.CGAlgorithms.orientationIndex(this.p0, this.p1, seg.p0);
    var orient1 = jsts.algorithm.CGAlgorithms.orientationIndex(this.p0, this.p1, seg.p1);
    // this handles the case where the points are L or collinear
    if (orient0 >= 0 && orient1 >= 0) {
        return Math.max(orient0, orient1);
    }
    // this handles the case where the points are R or collinear
    if (orient0 <= 0 && orient1 <= 0) {
        return Math.max(orient0, orient1);
    }
    // points lie on opposite sides ==> indeterminate orientation
    return 0;
};

/**
 * Determines the orientation index of a {@link Coordinate} relative to this segment.
 * The orientation index is as defined in {@link CGAlgorithms#computeOrientation}.
 *
 * @param {jsts.geom.Coordinate} p the coordinate to compare
 *
 * @return 1 (LEFT) if <code>p</code> is to the left of this segment
 * @return -1 (RIGHT) if <code>p</code> is to the right of this segment
 * @return 0 (COLLINEAR) if <code>p</code> is collinear with this segment
 * 
 * @see CGAlgorithms#computeOrientation(Coordinate, Coordinate, Coordinate)
 */
jsts.geom.LineSegment.prototype.orientationIndex2 = function (p) {
    return jsts.algorithm.CGAlgorithms.orientationIndex(this.p0, this.p1, p);
};

/**
 * Reverses the direction of the line segment.
 */
jsts.geom.LineSegment.prototype.reverse = function () {
    var temp = this.p0;
    this.p0 = this.p1;
    this.p1 = temp;
};

/**
 * Puts the line segment into a normalized form.
 * This is useful for using line segments in maps and indexes when
 * topological equality rather than exact equality is desired.
 * A segment in normalized form has the first point smaller
 * than the second (according to the standard ordering on {@link Coordinate}).
 */
jsts.geom.LineSegment.prototype.normalize = function () {
    if (this.p1.compareTo(this.p0) < 0) this.reverse();
};

/**
 * Computes the angle that the vector defined by this segment
 * makes with the X-axis.
 * The angle will be in the range [ -PI, PI ] radians.
 *
 * @return {number} the angle this segment makes with the X-axis (in radians)
 */
jsts.geom.LineSegment.prototype.angle = function () {
    return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
};

/**
 * Computes the midpoint of the segment
 *
 * @return {jsts.geom.Coordinate} the midpoint of the segment
 */
jsts.geom.LineSegment.prototype.midPoint = function () {
    return jsts.geom.LineSegment.midPoint(this.p0, this.p1);
};

jsts.geom.LineSegment.prototype.distance = function (arg) {
    if (arg instanceof jsts.geom.LineSegment) {
        return this.distance1(arg);
    } else if (arg instanceof jsts.geom.Coordinate) {
        return this.distance2(arg);
    }
};

/**
 * Computes the distance between this line segment and another segment.
 *
 * @param {jsts.geom.LineSegment} ls
 * @return {number} the distance to the other segment
 */
jsts.geom.LineSegment.prototype.distance1 = function (ls) {
    return jsts.algorithm.CGAlgorithms.distanceLineLine(this.p0, this.p1, ls.p0, ls.p1);
};

/**
 * Computes the distance between this line segment and a given point.
 *
 * @param {jsts.geom.Coordinate}
 *          p the coordinate.
 * @return {number}
 *          the distance from this segment to the given point.
 */
jsts.geom.LineSegment.prototype.distance2 = function (p) {
    return jsts.algorithm.CGAlgorithms.distancePointLine(p, this.p0, this.p1);
};

/**
 * Computes the {@link Coordinate} that lies a given
 * fraction along the line defined by this segment.
 * A fraction of <code>0.0</code> returns the start point of the segment;
 * a fraction of <code>1.0</code> returns the end point of the segment.
 * If the fraction is < 0.0 or > 1.0 the point returned 
 * will lie before the start or beyond the end of the segment. 
 *
 * @param {number} segmentLengthFraction the fraction of the segment length along the line
 * @return {jsts.geom.Coordinate} the point at that distance
 */
jsts.geom.LineSegment.prototype.pointAlong = function (segmentLengthFraction) {
    var coord = new jsts.geom.Coordinate();
    coord.x = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);
    coord.y = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);
    return coord;
};

/**
 * Computes the {@link Coordinate} that lies a given
 * fraction along the line defined by this segment and offset from 
 * the segment by a given distance.
 * A fraction of <code>0.0</code> offsets from the start point of the segment;
 * a fraction of <code>1.0</code> offsets from the end point of the segment.
 * The computed point is offset to the left of the line if the offset distance is
 * positive, to the right if negative.
 *
 * @param {number} segmentLengthFraction the fraction of the segment length along the line
 * @param {number} offsetDistance the distance the point is offset from the segment
 *    (positive is to the left, negative is to the right)
 * @return {jsts.geom.Coordinate} the point at that distance and offset
 */
jsts.geom.LineSegment.prototype.pointAlongOffset = function (segmentLengthFraction, offsetDistance) {
    // the point on the segment line
    var segx = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);
    var segy = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);

    var dx = this.p1.x - this.p0.x;
    var dy = this.p1.y - this.p0.y;
    var len = Math.sqrt(dx * dx + dy * dy);
    var ux = 0;
    var uy = 0;
    if (offsetDistance !== 0) {
        if (len <= 0) {
            throw "Cannot compute offset from zero-length line segment";
        }

        // u is the vector that is the length of the offset, in the direction of the segment
        ux = offsetDistance * dx / len;
        uy = offsetDistance * dy / len;
    }

    // the offset point is the seg point plus the offset vector rotated 90 degrees CCW
    var offsetx = segx - uy;
    var offsety = segy + ux;

    var coord = new jsts.geom.Coordinate(offsetx, offsety);
    return coord;
};

/**
 * Computes the Projection Factor for the projection of the point p onto this
 * LineSegment. The Projection Factor is the constant r by which the vector for
 * this segment must be multiplied to equal the vector for the projection of
 * <tt>p<//t> on the line
 * defined by this segment.
 * <p>
 * The projection factor returned will be in the range <tt>(-inf, +inf)</tt>.
 *
 * @param {Coordinate} p the point to compute the factor for.
 * @return {double} the projection factor for the point.
 */
jsts.geom.LineSegment.prototype.projectionFactor = function (p) {
    if (p.equals(this.p0))
        return 0.0;
    if (p.equals(this.p1))
        return 1.0;
    // Otherwise, use comp.graphics.algorithms Frequently Asked Questions method
    /*            AC dot AB
                   r = ---------
                         ||AB||^2
                r has the following meaning:
                r=0 P = A
                r=1 P = B
                r<0 P is on the backward extension of AB
                r>1 P is on the forward extension of AB
                0<r<1 P is interior to AB
        */
    var dx = this.p1.x - this.p0.x;
    var dy = this.p1.y - this.p0.y;
    var len2 = dx * dx + dy * dy;
    var r = ((p.x - this.p0.x) * dx + (p.y - this.p0.y) * dy) / len2;
    return r;
};

/**
 * Computes the fraction of distance (in <tt>[0.0, 1.0]</tt>) 
 * that the projection of a point occurs along this line segment.
 * If the point is beyond either ends of the line segment,
 * the closest fractional value (<tt>0.0</tt> or <tt>1.0</tt>) is returned.
 * <p>
 * Essentially, this is the {@link #projectionFactor} clamped to 
 * the range <tt>[0.0, 1.0]</tt>.
 * If the segment has zero length, 1.0 is returned.
 *  
 * @param {jsts.geom.Coordinate} inputPt the point
 * @return {number} the fraction along the line segment the projection of the point occurs
 */
jsts.geom.LineSegment.prototype.segmentFraction = function (inputPt) {
    var segFrac = this.projectionFactor(inputPt);
    if (segFrac < 0) {
        segFrac = 0;
    } else if (segFrac > 1 || isNaN(segFrac)) {
        segFrac = 1;
    }
    return segFrac;
};

jsts.geom.LineSegment.prototype.project = function (arg) {
    if (arg instanceof jsts.geom.Coordinate) {
        return this.project1(arg);
    } else if (arg instanceof jsts.geom.LineSegment) {
        return this.project2(arg);
    }
};

/**
 * Compute the projection of a point onto the line determined
 * by this line segment.
 * <p>
 * Note that the projected point
 * may lie outside the line segment.  If this is the case,
 * the projection factor will lie outside the range [0.0, 1.0].
 * @param {jsts.geom.Coordinate} p
 * @return {jsts.geom.Coordinate}
 */
jsts.geom.LineSegment.prototype.project1 = function (p) {
    if (p.equals(this.p0) || p.equals(this.p1)) {
        return new jsts.geom.Coordinate(p);
    }

    var r = this.projectionFactor(p);
    var coord = new jsts.geom.Coordinate();
    coord.x = this.p0.x + r * (this.p1.x - this.p0.x);
    coord.y = this.p0.y + r * (this.p1.y - this.p0.y);
    return coord;
};

/**
 * Project a line segment onto this line segment and return the resulting
 * line segment.  The returned line segment will be a subset of
 * the target line line segment.  This subset may be null, if
 * the segments are oriented in such a way that there is no projection.
 * <p>
 * Note that the returned line may have zero length (i.e. the same endpoints).
 * This can happen for instance if the lines are perpendicular to one another.
 *
 * @param {jsts.geom.LineSegment} seg the line segment to project
 * @return {jsts.geom.LineSegment} the projected line segment, or <code>null</code> if there is no overlap
 */
jsts.geom.LineSegment.prototype.project2 = function (seg) {
    var pf0 = this.projectionFactor(seg.p0);
    var pf1 = this.projectionFactor(seg.p1);
    // check if segment projects at all
    if (pf0 >= 1 && pf1 >= 1) return null;
    if (pf0 <= 0 && pf1 <= 0) return null;

    var newp0 = this.project(seg.p0);
    if (pf0 < 0) newp0 = p0;
    if (pf0 > 1) newp0 = p1;

    var newp1 = this.project(seg.p1);
    if (pf1 < 0.0) newp1 = p0;
    if (pf1 > 1.0) newp1 = p1;

    return new jsts.geom.LineSegment(newp0, newp1);
};

/**
 * Computes the closest point on this line segment to another point.
 *
 * @param {Coordinate}
 *          p the point to find the closest point to.
 * @return {Coordinate} a Coordinate which is the closest point on the line
 *         segment to the point p.
 */
jsts.geom.LineSegment.prototype.closestPoint = function (p) {
    var factor = this.projectionFactor(p);
    if (factor > 0 && factor < 1) {
        return this.project(p);
    }
    var dist0 = this.p0.distance(p);
    var dist1 = this.p1.distance(p);
    if (dist0 < dist1)
        return this.p0;
    return this.p1;
};


/**
 * Computes the closest points on two line segments.
 *
 * @param {LineSegment}
 *          line the segment to find the closest point to.
 * @return {[]} a pair of Coordinates which are the closest points on the line
 *         segments.
 */
jsts.geom.LineSegment.prototype.closestPoints = function (line) {
    // test for intersection
    var intPt = this.intersection(line);
    if (intPt !== null) {
        return [intPt, intPt];
    }

    /**
     * if no intersection closest pair contains at least one endpoint. Test each
     * endpoint in turn.
     */
    var closestPt = [];
    var minDistance = Number.MAX_VALUE;
    var dist;

    var close00 = this.closestPoint(line.p0);
    minDistance = close00.distance(line.p0);
    closestPt[0] = close00;
    closestPt[1] = line.p0;

    var close01 = this.closestPoint(line.p1);
    dist = close01.distance(line.p1);
    if (dist < minDistance) {
        minDistance = dist;
        closestPt[0] = close01;
        closestPt[1] = line.p1;
    }

    var close10 = line.closestPoint(this.p0);
    dist = close10.distance(this.p0);
    if (dist < minDistance) {
        minDistance = dist;
        closestPt[0] = this.p0;
        closestPt[1] = close10;
    }

    var close11 = line.closestPoint(this.p1);
    dist = close11.distance(this.p1);
    if (dist < minDistance) {
        minDistance = dist;
        closestPt[0] = this.p1;
        closestPt[1] = close11;
    }

    return closestPt;
};


/**
 * Computes an intersection point between two line segments, if there is one.
 * There may be 0, 1 or many intersection points between two segments. If there
 * are 0, null is returned. If there is 1 or more, exactly one of them is
 * returned (chosen at the discretion of the algorithm). If more information is
 * required about the details of the intersection, the
 * {@link RobustLineIntersector} class should be used.
 *
 * @param {LineSegment}
 *          line a line segment.
 * @return {Coordinate} an intersection point, or <code>null</code> if there
 *         is none.
 *
 * @see RobustLineIntersector
 */
jsts.geom.LineSegment.prototype.intersection = function (line) {
    var li = new jsts.algorithm.RobustLineIntersector();
    li.computeIntersection(this.p0, this.p1, line.p0, line.p1);
    if (li.hasIntersection())
        return li.getIntersection(0);
    return null;
};

jsts.geom.LineSegment.prototype.setCoordinates = function (ls) {
    if (ls instanceof jsts.geom.Coordinate) {
        this.setCoordinates2.apply(this, arguments);
        return;
    }

    this.setCoordinates2(ls.p0, ls.p1);
};

jsts.geom.LineSegment.prototype.setCoordinates2 = function (p0, p1) {
    this.p0.x = p0.x;
    this.p0.y = p0.y;
    this.p1.x = p1.x;
    this.p1.y = p1.y;
};

/**
 * Computes the perpendicular distance between the (infinite) line defined
 * by this line segment and a point.
 *
 * @param {jsts.geom.Coordinate} p the coordinate
 * @return {number} the perpendicular distance between the defined line and the given point
 */
jsts.geom.LineSegment.prototype.distancePerpendicular = function (p) {
    return jsts.algorithm.CGAlgorithms.distancePointLinePerpendicular(p, this.p0, this.p1);
};

/**
 * Computes the intersection point of the lines of infinite extent defined
 * by two line segments (if there is one).
 * There may be 0, 1 or an infinite number of intersection points 
 * between two lines.
 * If there is a unique intersection point, it is returned. 
 * Otherwise, <tt>null</tt> is returned.
 * If more information is required about the details of the intersection,
 * the {@link RobustLineIntersector} class should be used.
 *
 * @param {jsts.geom.LineSegment} line a line segment defining an straight line with infinite extent
 * @return {jsts.geom.Coordinate} an intersection point, 
 * or <code>null</code> if there is no point of intersection
 * or an infinite number of intersection points
 * 
 * @see RobustLineIntersector
 */
jsts.geom.LineSegment.prototype.lineIntersection = function (line) {
    try {
        var intPt = jsts.algorithm.HCoordinate.intersection(this.p0, this.p1, line.p0, line.p1);
        return intPt;
    } catch (ex) {
        // eat this exception, and return null;
    }
    return null;
};

/**
 * Creates a LineString with the same coordinates as this segment
 * 
 * @param {jsts.geom.GeometryFactory} geomFactory the geometery factory to use
 * @return {jsts.geom.LineString} a LineString with the same geometry as this segment
 */
jsts.geom.LineSegment.prototype.toGeometry = function (geomFactory) {
    return geomFactory.createLineString([this.p0, this.p1]);
};

/**
 *  Returns <code>true</code> if <code>other</code> has the same values for
 *  its points.
 *
 * @param {Object} o a <code>LineSegment</code> with which to do the comparison.
 * @return {boolean} <code>true</code> if <code>other</code> is a <code>LineSegment</code>
 *      with the same values for the x and y ordinates.
 */
jsts.geom.LineSegment.prototype.equals = function (o) {
    if (!(o instanceof jsts.geom.LineSegment)) {
        return false;
    }
    return this.p0.equals(o.p0) && this.p1.equals(o.p1);
};

/**
 *  Compares this object with the specified object for order.
 *  Uses the standard lexicographic ordering for the points in the LineSegment.
 *
 *@param {Object} o  the <code>LineSegment</code> with which this <code>LineSegment</code>
 *      is being compared
 *@return {number} a negative integer, zero, or a positive integer as this <code>LineSegment</code>
 *      is less than, equal to, or greater than the specified <code>LineSegment</code>
 */
jsts.geom.LineSegment.prototype.compareTo = function (o) {
    var comp0 = this.p0.compareTo(o.p0);
    if (comp0 !== 0) return comp0;
    return this.p1.compareTo(o.p1);
};

/**
 *  Returns <code>true</code> if <code>other</code> is
 *  topologically equal to this LineSegment (e.g. irrespective
 *  of orientation).
 *
 * @param {jsts.geom.LineSegment} other  a <code>LineSegment</code> with which to do the comparison.
 * @return {boolean} <code>true</code> if <code>other</code> is a <code>LineSegment</code>
 *      with the same values for the x and y ordinates.
 */
jsts.geom.LineSegment.prototype.equalsTopo = function (other) {
    return this.p0.equals(other.p0) && this.p1.equals(other.p1)
        || this.p0.equals(other.p1) && this.p1.equals(other.p0);
};

jsts.geom.LineSegment.prototype.toString = function () {
    return "LINESTRING(" +
        this.p0.x + " " + this.p0.y
        + ", " +
        this.p1.x + " " + this.p1.y + ")";
};
/* ======================================================================
    jsts/index/chain/MonotoneChainOverlapAction.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @requires jsts/geom/Envelope.js
 * @requires jsts/geom/LineSegment.js
 */

/**
 * The action for the internal iterator for performing overlap queries on a
 * MonotoneChain
 *
 * @constructor
 */
jsts.index.chain.MonotoneChainOverlapAction = function() {
  this.tempEnv1 = new jsts.geom.Envelope();
  this.tempEnv2 = new jsts.geom.Envelope();
  this.overlapSeg1 = new jsts.geom.LineSegment();
  this.overlapSeg2 = new jsts.geom.LineSegment();
};

// these envelopes are used during the MonotoneChain search process
jsts.index.chain.MonotoneChainOverlapAction.prototype.tempEnv1 = null;
jsts.index.chain.MonotoneChainOverlapAction.prototype.tempEnv2 = null;

jsts.index.chain.MonotoneChainOverlapAction.prototype.overlapSeg1 = null;
jsts.index.chain.MonotoneChainOverlapAction.prototype.overlapSeg2 = null;

/**
 * This function can be overridden if the original chains are needed
 *
 * @param start1
 *          the index of the start of the overlapping segment from mc1.
 * @param start2
 *          the index of the start of the overlapping segment from mc2.
 */
jsts.index.chain.MonotoneChainOverlapAction.prototype.overlap = function(mc1,
    start1, mc2, start2) {
  this.mc1.getLineSegment(start1, this.overlapSeg1);
  this.mc2.getLineSegment(start2, this.overlapSeg2);
  this.overlap2(this.overlapSeg1, this.overlapSeg2);
};

/**
 * This is a convenience function which can be overridden to obtain the actual
 * line segments which overlap
 *
 * @param seg1
 * @param seg2
 */
jsts.index.chain.MonotoneChainOverlapAction.prototype.overlap2 = function(seg1,
    seg2) {
};
/* ======================================================================
    jsts/noding/MCIndexNoder.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * @requires jsts/noding/SinglePassNoder.js
   * @requires jsts/index/strtree/STRtree.js
   * @requires jsts/noding/NodedSegmentString.js
   * @requires jsts/index/chain/MonotoneChainBuilder.js
   * @requires jsts/index/chain/MonotoneChainOverlapAction.js
   */

  var MonotoneChainOverlapAction = jsts.index.chain.MonotoneChainOverlapAction;
  var SinglePassNoder = jsts.noding.SinglePassNoder;
  var STRtree = jsts.index.strtree.STRtree;
  var NodedSegmentString = jsts.noding.NodedSegmentString;
  var MonotoneChainBuilder = jsts.index.chain.MonotoneChainBuilder;

  /**
   * @constructor
   * @private
   */
  var SegmentOverlapAction = function(si) {
    this.si = si;

  };
  SegmentOverlapAction.prototype = new MonotoneChainOverlapAction();
  SegmentOverlapAction.constructor = SegmentOverlapAction;

  /**
   * @type {SegmentIntersector}
   * @private
   */
  SegmentOverlapAction.prototype.si = null;

  SegmentOverlapAction.prototype.overlap = function(mc1, start1, mc2, start2) {
    var ss1 = mc1.getContext();
    var ss2 = mc2.getContext();
    this.si.processIntersections(ss1, start1, ss2, start2);
  };

  /**
   * @constructor
   */
  jsts.noding.MCIndexNoder = function() {
    this.monoChains = [];
    this.index = new STRtree();
  };

  jsts.noding.MCIndexNoder.prototype = new SinglePassNoder();
  jsts.noding.MCIndexNoder.constructor = jsts.noding.MCIndexNoder;

  /**
   * @type {Array}
   * @private
   */
  jsts.noding.MCIndexNoder.prototype.monoChains = null;
  /**
   * @type {SpatialIndex}
   * @private
   */
  jsts.noding.MCIndexNoder.prototype.index = null;
  /**
   * @type {number}
   * @private
   */
  jsts.noding.MCIndexNoder.prototype.idCounter = 0;

  /**
   * @type {Array}
   * @private
   */
  jsts.noding.MCIndexNoder.prototype.nodedSegStrings = null;
  /**
   * statistics
   *
   * @type {number}
   * @private
   */
  jsts.noding.MCIndexNoder.prototype.nOverlaps = 0;


  jsts.noding.MCIndexNoder.prototype.getMonotoneChains = function() {
    return this.monoChains;
  };

  jsts.noding.MCIndexNoder.prototype.getIndex = function() {
    return this.index;
  };

  jsts.noding.MCIndexNoder.prototype.getNodedSubstrings = function() {
    return NodedSegmentString.getNodedSubstrings(this.nodedSegStrings);
  };

  jsts.noding.MCIndexNoder.prototype.computeNodes = function(inputSegStrings) {
    this.nodedSegStrings = inputSegStrings;
    for (var i = inputSegStrings.iterator(); i.hasNext(); ) {
      this.add(i.next());
    }
    this.intersectChains();
  };

  /**
   * @private
   */
  jsts.noding.MCIndexNoder.prototype.intersectChains = function() {
    var overlapAction = new SegmentOverlapAction(this.segInt);

    for (var i = 0; i < this.monoChains.length; i++) {
      var queryChain = this.monoChains[i];
      var overlapChains = this.index.query(queryChain.getEnvelope());
      for (var j = 0; j < overlapChains.length; j++) {
        var testChain = overlapChains[j];
        /**
         * following test makes sure we only compare each pair of chains once
         * and that we don't compare a chain to itself
         */
        if (testChain.getId() > queryChain.getId()) {
          queryChain.computeOverlaps(testChain, overlapAction);
          this.nOverlaps++;
        }
        // short-circuit if possible
        if (this.segInt.isDone())
          return;
      }
    }
  };

  /**
   * @private
   */
  jsts.noding.MCIndexNoder.prototype.add = function(segStr) {
    var segChains = MonotoneChainBuilder.getChains(segStr.getCoordinates(),
        segStr);
    for (var i = 0; i < segChains.length; i++) {
      var mc = segChains[i];
      mc.setId(this.idCounter++);
      this.index.insert(mc.getEnvelope(), mc);
      this.monoChains.push(mc);
    }
  };

})();
/* ======================================================================
    jsts/simplify/LineSegmentIndex.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */


/**
 * An spatial index on a set of {@link LineSegment}s. Supports adding and
 * removing items.
 *
 * @author Martin Davis
 */
jsts.simplify.LineSegmentIndex = function() {
  this.index = new jsts.index.quadtree.Quadtree();
};

/**
 * @private
 */
jsts.simplify.LineSegmentIndex.prototype.index = null;

/**
 * @param {TaggedLineString}
 *          line
 */
jsts.simplify.LineSegmentIndex.prototype.add = function(line) {
  if (line instanceof jsts.geom.LineSegment) {
    this.add2(line);
    return;
  }

  var segs = line.getSegments();
  for (var i = 0; i < segs.length; i++) {
    var seg = segs[i];
    this.add2(seg);
  }
};

/**
 * @param {LineSegment}
 *          seg
 */
jsts.simplify.LineSegmentIndex.prototype.add2 = function(seg) {
  this.index.insert(new jsts.geom.Envelope(seg.p0, seg.p1), seg);
};
/**
 * @param {LineSegment}
 *          seg
 */
jsts.simplify.LineSegmentIndex.prototype.remove = function(seg) {
  this.index.remove(new jsts.geom.Envelope(seg.p0, seg.p1), seg);
};

/**
 * @param {LineSegment}
 *          querySeg
 * @return {Array}
 */
jsts.simplify.LineSegmentIndex.prototype.query = function(querySeg) {
  var env = new jsts.geom.Envelope(querySeg.p0, querySeg.p1);

  var visitor = new jsts.simplify.LineSegmentIndex.LineSegmentVisitor(querySeg);
  this.index.query(env, visitor);
  var itemsFound = visitor.getItems();

  return itemsFound;
};


/**
 * @requires jsts/index/ItemVisitor.js
 */
/**
 * ItemVisitor subclass to reduce volume of query results.
 *
 * @implements {jsts.index.ItemVisitor}
 */
jsts.simplify.LineSegmentIndex.LineSegmentVisitor = function(querySeg) {
  this.items = [];

  this.querySeg = querySeg;
};


jsts.simplify.LineSegmentIndex.LineSegmentVisitor.prototype = new jsts.index.ItemVisitor();

// MD - only seems to make about a 10% difference in overall time.
jsts.simplify.LineSegmentIndex.LineSegmentVisitor.prototype.querySeg = null;
jsts.simplify.LineSegmentIndex.LineSegmentVisitor.prototype.items = null;

jsts.simplify.LineSegmentIndex.LineSegmentVisitor.prototype.visitItem = function(
    item) {
  var seg = item;
  if (jsts.geom.Envelope.intersects(seg.p0, seg.p1, this.querySeg.p0, this.querySeg.p1))
    this.items.push(item);
};

jsts.simplify.LineSegmentIndex.LineSegmentVisitor.prototype.getItems = function() {
  return this.items;
};
/* ======================================================================
    jsts/geomgraph/EdgeEndStar.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @requires jsts/geom/Location.js
 */



/**
 * A EdgeEndStar is an ordered list of EdgeEnds around a node. They are
 * maintained in CCW order (starting with the positive x-axis) around the node
 * for efficient lookup and topology building.
 *
 * @constructor
 */
jsts.geomgraph.EdgeEndStar = function() {
  this.edgeMap = new javascript.util.TreeMap();
  this.edgeList = null;
  this.ptInAreaLocation = [jsts.geom.Location.NONE, jsts.geom.Location.NONE];
};


/**
 * A map which maintains the edges in sorted order around the node
 *
 * NOTE: In In JSTS a JS object replaces TreeMap. Sorting is done when needed.
 *
 * @protected
 */
jsts.geomgraph.EdgeEndStar.prototype.edgeMap = null;


/**
 * A list of all outgoing edges in the result, in CCW order
 *
 * @protected
 */
jsts.geomgraph.EdgeEndStar.prototype.edgeList = null;


/**
 * The location of the point for this star in Geometry i Areas
 *
 * @private
 */
jsts.geomgraph.EdgeEndStar.prototype.ptInAreaLocation = null;


/**
 * Insert a EdgeEnd into this EdgeEndStar
 */
jsts.geomgraph.EdgeEndStar.prototype.insert = function(e) {
  throw new jsts.error.AbstractMethodInvocationError();
};


/**
 * Insert an EdgeEnd into the map, and clear the edgeList cache, since the list
 * of edges has now changed
 *
 * @protected
 */
jsts.geomgraph.EdgeEndStar.prototype.insertEdgeEnd = function(e, obj) {
  this.edgeMap.put(e, obj);
  this.edgeList = null; // edge list has changed - clear the cache
};


/**
 * @return the coordinate for the node this star is based at.
 */
jsts.geomgraph.EdgeEndStar.prototype.getCoordinate = function() {
  var it = this.iterator();
  if (!it.hasNext())
    return null;
  var e = it.next();
  return e.getCoordinate();
};
jsts.geomgraph.EdgeEndStar.prototype.getDegree = function() {
  return this.edgeMap.size();
};


/**
 * Iterator access to the ordered list of edges is optimized by copying the map
 * collection to a list. (This assumes that once an iterator is requested, it is
 * likely that insertion into the map is complete).
 */
jsts.geomgraph.EdgeEndStar.prototype.iterator = function() {
  return this.getEdges().iterator();
};

jsts.geomgraph.EdgeEndStar.prototype.getEdges = function() {
  if (this.edgeList === null) {
    this.edgeList = new javascript.util.ArrayList(this.edgeMap.values());
  }
  return this.edgeList;
};

jsts.geomgraph.EdgeEndStar.prototype.getNextCW = function(ee) {
  this.getEdges();
  var i = this.edgeList.indexOf(ee);
  var iNextCW = i - 1;
  if (i === 0)
    iNextCW = this.edgeList.length - 1;
  return this.edgeList[iNextCW];
};

jsts.geomgraph.EdgeEndStar.prototype.computeLabelling = function(geomGraph) {
  this.computeEdgeEndLabels(geomGraph[0].getBoundaryNodeRule());
  this.propagateSideLabels(0);
  this.propagateSideLabels(1);

  /**
   * If there are edges that still have null labels for a geometry this must be
   * because there are no area edges for that geometry incident on this node. In
   * this case, to label the edge for that geometry we must test whether the
   * edge is in the interior of the geometry. To do this it suffices to
   * determine whether the node for the edge is in the interior of an area. If
   * so, the edge has location INTERIOR for the geometry. In all other cases
   * (e.g. the node is on a line, on a point, or not on the geometry at all) the
   * edge has the location EXTERIOR for the geometry.
   * <p>
   * Note that the edge cannot be on the BOUNDARY of the geometry, since then
   * there would have been a parallel edge from the Geometry at this node also
   * labelled BOUNDARY and this edge would have been labelled in the previous
   * step.
   * <p>
   * This code causes a problem when dimensional collapses are present, since it
   * may try and determine the location of a node where a dimensional collapse
   * has occurred. The point should be considered to be on the EXTERIOR of the
   * polygon, but locate() will return INTERIOR, since it is passed the original
   * Geometry, not the collapsed version.
   *
   * If there are incident edges which are Line edges labelled BOUNDARY, then
   * they must be edges resulting from dimensional collapses. In this case the
   * other edges can be labelled EXTERIOR for this Geometry.
   *
   * MD 8/11/01 - NOT TRUE! The collapsed edges may in fact be in the interior
   * of the Geometry, which means the other edges should be labelled INTERIOR
   * for this Geometry. Not sure how solve this... Possibly labelling needs to
   * be split into several phases: area label propagation, symLabel merging,
   * then finally null label resolution.
   */
  var hasDimensionalCollapseEdge = [false, false];
  for (var it = this.iterator(); it.hasNext();) {
    var e = it.next();
    var label = e.getLabel();
    for (var geomi = 0; geomi < 2; geomi++) {
      if (label.isLine(geomi) &&
          label.getLocation(geomi) === jsts.geom.Location.BOUNDARY)
        hasDimensionalCollapseEdge[geomi] = true;
    }
  }
  for (var it = this.iterator(); it.hasNext();) {
    var e = it.next();
    var label = e.getLabel();
    for (var geomi = 0; geomi < 2; geomi++) {
      if (label.isAnyNull(geomi)) {
        var loc = jsts.geom.Location.NONE;
        if (hasDimensionalCollapseEdge[geomi]) {
          loc = jsts.geom.Location.EXTERIOR;
        } else {
          var p = e.getCoordinate();
          loc = this.getLocation(geomi, p, geomGraph);
        }
        label.setAllLocationsIfNull(geomi, loc);
      }
    }
  }
};


/**
 * @private
 */
jsts.geomgraph.EdgeEndStar.prototype.computeEdgeEndLabels = function(
    boundaryNodeRule) {
  // Compute edge label for each EdgeEnd
  for (var it = this.iterator(); it.hasNext();) {
    var ee = it.next();
    ee.computeLabel(boundaryNodeRule);
  }
};


/**
 * @private
 */
jsts.geomgraph.EdgeEndStar.prototype.getLocation = function(geomIndex, p, geom) {
  // compute location only on demand
  if (this.ptInAreaLocation[geomIndex] === jsts.geom.Location.NONE) {
    this.ptInAreaLocation[geomIndex] = jsts.algorithm.locate.SimplePointInAreaLocator
        .locate(p, geom[geomIndex].getGeometry());
  }
  return this.ptInAreaLocation[geomIndex];
};

jsts.geomgraph.EdgeEndStar.prototype.isAreaLabelsConsistent = function(
    geomGraph) {
  this.computeEdgeEndLabels(geomGraph.getBoundaryNodeRule());
  return this.checkAreaLabelsConsistent(0);
};


/**
 * @private
 */
jsts.geomgraph.EdgeEndStar.prototype.checkAreaLabelsConsistent = function(
    geomIndex) {
  // Since edges are stored in CCW order around the node,
  // As we move around the ring we move from the right to the left side of the
  // edge
  var edges = this.getEdges();
  // if no edges, trivially consistent
  if (edges.size() <= 0)
    return true;
  // initialize startLoc to location of last L side (if any)
  var lastEdgeIndex = edges.size() - 1;
  var startLabel = edges.get(lastEdgeIndex).getLabel();
  var startLoc = startLabel
      .getLocation(geomIndex, jsts.geomgraph.Position.LEFT);
  jsts.util.Assert.isTrue(startLoc != jsts.geom.Location.NONE,
      'Found unlabelled area edge');

  var currLoc = startLoc;
  for (var it = this.iterator(); it.hasNext();) {
    var e = it.next();
    var label = e.getLabel();
    // we assume that we are only checking a area
    jsts.util.Assert.isTrue(label.isArea(geomIndex), 'Found non-area edge');
    var leftLoc = label.getLocation(geomIndex, jsts.geomgraph.Position.LEFT);
    var rightLoc = label.getLocation(geomIndex, jsts.geomgraph.Position.RIGHT);
    // check that edge is really a boundary between inside and outside!
    if (leftLoc === rightLoc) {
      return false;
    }

    if (rightLoc !== currLoc) {
      return false;
    }
    currLoc = leftLoc;
  }
  return true;
};


/**
 * @private
 */
jsts.geomgraph.EdgeEndStar.prototype.propagateSideLabels = function(geomIndex) {
  // Since edges are stored in CCW order around the node,
  // As we move around the ring we move from the right to the left side of the
  // edge
  var startLoc = jsts.geom.Location.NONE;

  // initialize loc to location of last L side (if any)
  for (var it = this.iterator(); it.hasNext();) {
    var e = it.next();
    var label = e.getLabel();
    if (label.isArea(geomIndex) &&
        label.getLocation(geomIndex, jsts.geomgraph.Position.LEFT) !== jsts.geom.Location.NONE)
      startLoc = label.getLocation(geomIndex, jsts.geomgraph.Position.LEFT);
  }

  // no labelled sides found, so no labels to propagate
  if (startLoc === jsts.geom.Location.NONE)
    return;

  var currLoc = startLoc;
  for (var it = this.iterator(); it.hasNext();) {
    var e = it.next();
    var label = e.getLabel();
    // set null ON values to be in current location
    if (label.getLocation(geomIndex, jsts.geomgraph.Position.ON) === jsts.geom.Location.NONE)
      label.setLocation(geomIndex, jsts.geomgraph.Position.ON, currLoc);
    // set side labels (if any)
    if (label.isArea(geomIndex)) {
      var leftLoc = label.getLocation(geomIndex, jsts.geomgraph.Position.LEFT);
      var rightLoc = label
          .getLocation(geomIndex, jsts.geomgraph.Position.RIGHT);
      // if there is a right location, that is the next location to propagate
      if (rightLoc !== jsts.geom.Location.NONE) {
        if (rightLoc !== currLoc)
          throw new jsts.error.TopologyError('side location conflict', e
              .getCoordinate());
        if (leftLoc === jsts.geom.Location.NONE) {
          jsts.util.Assert.shouldNeverReachHere('found single null side (at ' +
              e.getCoordinate() + ')');
        }
        currLoc = leftLoc;
      } else {
        /**
         * RHS is null - LHS must be null too. This must be an edge from the
         * other geometry, which has no location labelling for this geometry.
         * This edge must lie wholly inside or outside the other geometry (which
         * is determined by the current location). Assign both sides to be the
         * current location.
         */
        jsts.util.Assert.isTrue(label.getLocation(geomIndex,
            jsts.geomgraph.Position.LEFT) === jsts.geom.Location.NONE,
            'found single null side');
        label.setLocation(geomIndex, jsts.geomgraph.Position.RIGHT, currLoc);
        label.setLocation(geomIndex, jsts.geomgraph.Position.LEFT, currLoc);
      }
    }
  }
};

jsts.geomgraph.EdgeEndStar.prototype.findIndex = function(eSearch) {
  this.iterator(); // force edgelist to be computed
  for (var i = 0; i < this.edgeList.size(); i++) {
    var e = this.edgeList.get(i);
    if (e === eSearch)
      return i;
  }
  return -1;
};
/* ======================================================================
    jsts/operation/relate/EdgeEndBundleStar.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.

/**
 * @requires jsts/geomgraph/EdgeEndStar.js
 */



/**
 * An ordered list of {@link EdgeEndBundle}s around a {@link RelateNode}.
 * They are maintained in CCW order (starting with the positive x-axis) around the node
 * for efficient lookup and topology building.
 *
 * @constructor
 */
jsts.operation.relate.EdgeEndBundleStar = function() {
  jsts.geomgraph.EdgeEndStar.apply(this, arguments);
};

jsts.operation.relate.EdgeEndBundleStar.prototype = new jsts.geomgraph.EdgeEndStar();


/**
 * Insert a EdgeEnd in order in the list. If there is an existing EdgeStubBundle
 * which is parallel, the EdgeEnd is added to the bundle. Otherwise, a new
 * EdgeEndBundle is created to contain the EdgeEnd. <br>
 */
jsts.operation.relate.EdgeEndBundleStar.prototype.insert = function(e) {
  var eb = this.edgeMap.get(e);
  if (eb === null) {
    eb = new jsts.operation.relate.EdgeEndBundle(e);
    this.insertEdgeEnd(e, eb);
  }
  else {
    eb.insert(e);
  }
};


/**
 * Update the IM with the contribution for the EdgeStubs around the node.
 */
jsts.operation.relate.EdgeEndBundleStar.prototype.updateIM = function(im) {
  for (var it = this.iterator(); it.hasNext(); ) {
    var esb = it.next();
    esb.updateIM(im);
  }
};
/* ======================================================================
    jsts/index/ArrayListVisitor.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
* Published under the LGPL 2.1 license.
* See /license-notice.txt for the full text of the license notice.
* See /license.txt for the full text of the license.
*/



/**
 * An array-visitor
 *
 * @constructor
 */
jsts.index.ArrayListVisitor = function() {
  this.items = [];
};


/**
 * Visits an item
 *
 * @param {Object}
 *          item the item to visit.
 */
jsts.index.ArrayListVisitor.prototype.visitItem = function(item) {
  this.items.push(item);
};


/**
 * Returns all visited items
 *
 * @return {Array} An array with all visited items.
 */
jsts.index.ArrayListVisitor.prototype.getItems = function() {
  return this.items;
};
/* ======================================================================
    jsts/algorithm/distance/DistanceToPoint.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Port source: /jts/jts/java/src/com/vividsolutions/jts/algorithm/distance/DistanceToPoint.java
 * Revision: 6
 */

/**
 * @requires jsts/geom/Polygon.js
 */

/**
 * Computes the Euclidean distance (L2 metric) from a Point to a Geometry. Also
 * computes two points which are separated by the distance.
 */
jsts.algorithm.distance.DistanceToPoint = function() {

};

jsts.algorithm.distance.DistanceToPoint.computeDistance = function(geom, pt,
    ptDist) {
  if (geom instanceof jsts.geom.LineString) {
    jsts.algorithm.distance.DistanceToPoint.computeDistance2(geom, pt, ptDist);
  } else if (geom instanceof jsts.geom.Polygon) {
    jsts.algorithm.distance.DistanceToPoint.computeDistance4(geom, pt, ptDist);
  } else if (geom instanceof jsts.geom.GeometryCollection) {
    var gc = geom;
    for (var i = 0; i < gc.getNumGeometries(); i++) {
      var g = gc.getGeometryN(i);
      jsts.algorithm.distance.DistanceToPoint.computeDistance(g, pt, ptDist);
    }
  } else { // assume geom is Point
    ptDist.setMinimum(geom.getCoordinate(), pt);
  }
};

jsts.algorithm.distance.DistanceToPoint.computeDistance2 = function(line, pt,
    ptDist) {
  var tempSegment = new jsts.geom.LineSegment();

  var coords = line.getCoordinates();
  for (var i = 0; i < coords.length - 1; i++) {
    tempSegment.setCoordinates(coords[i], coords[i + 1]);
    // this is somewhat inefficient - could do better
    var closestPt = tempSegment.closestPoint(pt);
    ptDist.setMinimum(closestPt, pt);
  }
};

jsts.algorithm.distance.DistanceToPoint.computeDistance3 = function(segment,
    pt, ptDist) {
  var closestPt = segment.closestPoint(pt);
  ptDist.setMinimum(closestPt, pt);
};

jsts.algorithm.distance.DistanceToPoint.computeDistance4 = function(poly, pt,
    ptDist) {
  jsts.algorithm.distance.DistanceToPoint.computeDistance2(poly
      .getExteriorRing(), pt, ptDist);
  for (var i = 0; i < poly.getNumInteriorRing(); i++) {
    jsts.algorithm.distance.DistanceToPoint.computeDistance2(poly
        .getInteriorRingN(i), pt, ptDist);
  }
};
/* ======================================================================
    jsts/index/strtree/ItemBoundable.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Boundable wrapper for a non-Boundable spatial object. Used internally by
 * AbstractSTRtree.
 *
 * @requires jsts/index/strtree/Boundable.js
 */



/**
 * @param {Object} bounds
 * @param {Object} item
 * @extends {jsts.index.strtree.Boundable}
 * @constructor
 */
jsts.index.strtree.ItemBoundable = function(bounds, item) {
  this.bounds = bounds;
  this.item = item;
};

jsts.index.strtree.ItemBoundable.prototype = new jsts.index.strtree.Boundable();
jsts.index.strtree.ItemBoundable.constructor = jsts.index.strtree.ItemBoundable;


/**
 * @type {Object}
 * @private
 */
jsts.index.strtree.ItemBoundable.prototype.bounds = null;


/**
 * @type {Object}
 * @private
 */
jsts.index.strtree.ItemBoundable.prototype.item = null;


/**
 * @return {Object}
 * @public
 */
jsts.index.strtree.ItemBoundable.prototype.getBounds = function() {
  return this.bounds;
};


/**
 * @return {Object}
 * @public
 */
jsts.index.strtree.ItemBoundable.prototype.getItem = function() {
  return this.item;
};
/* ======================================================================
    jsts/geomgraph/EdgeList.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */


(function() {

  /**
   * @requires jsts/util/Assert.js
   */

  var ArrayList = javascript.util.ArrayList;
  var TreeMap = javascript.util.TreeMap;

  /**
   * A EdgeList is a list of Edges. It supports locating edges that are
   * pointwise equals to a target edge.
   *
   * @constructor
   */
  jsts.geomgraph.EdgeList = function() {
    this.edges = new ArrayList();
    this.ocaMap = new TreeMap();
  };


  /**
   * @type {javascript.util.ArrayList}
   * @private
   */
  jsts.geomgraph.EdgeList.prototype.edges = null;


  /**
   * An index of the edges, for fast lookup.
   *
   * @type {javascript.util.HashMap}
   * @private
   */
  jsts.geomgraph.EdgeList.prototype.ocaMap = null;


  /**
   * Insert an edge unless it is already in the list
   */
  jsts.geomgraph.EdgeList.prototype.add = function(e) {
    this.edges.add(e);
    var oca = new jsts.noding.OrientedCoordinateArray(e.getCoordinates());
    this.ocaMap.put(oca, e);
  };

  jsts.geomgraph.EdgeList.prototype.addAll = function(edgeColl) {
    for (var i = edgeColl.iterator(); i.hasNext();) {
      this.add(i.next());
    }
  };


  /**
   * @return {javascript.util.List}
   */
  jsts.geomgraph.EdgeList.prototype.getEdges = function() {
    return this.edges;
  };


  /**
   * If there is an edge equal to e already in the list, return it. Otherwise
   * return null.
   *
   * @param {Edge}
   *          e
   * @return {Edge} equal edge, if there is one already in the list null
   *         otherwise.
   */
  jsts.geomgraph.EdgeList.prototype.findEqualEdge = function(e) {
    var oca = new jsts.noding.OrientedCoordinateArray(e.getCoordinates());
    // will return null if no edge matches
    var matchEdge = this.ocaMap.get(oca);
    return matchEdge;
  };

  jsts.geomgraph.EdgeList.prototype.getEdges = function() {
    return this.edges;
  };

  jsts.geomgraph.EdgeList.prototype.iterator = function() {
    return this.edges.iterator();
  };

  jsts.geomgraph.EdgeList.prototype.get = function(i) {
    return this.edges.get(i);
  };


  /**
   * If the edge e is already in the list, return its index.
   *
   * @return {Number} index, if e is already in the list -1 otherwise.
   */
  jsts.geomgraph.EdgeList.prototype.findEdgeIndex = function(e) {
    for (var i = 0; i < this.edges.size(); i++) {
      if (this.edges.get(i).equals(e))
        return i;
    }
    return -1;
  };

})();
/* ======================================================================
    jsts/operation/IsSimpleOp.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Tests whether a <code>Geometry</code> is simple.
 * In general, the SFS specification of simplicity
 * follows the rule:
 * <ul>
 *  <li>A Geometry is simple if and only if the only self-intersections are at
 *  boundary points.</li>
 * </ul>
 * This definition relies on the definition of boundary points.
 * The SFS uses the Mod-2 rule to determine which points are on the boundary of
 * lineal geometries, but this class supports
 * using other {@link BoundaryNodeRule}s as well.
 * <p>
 * Simplicity is defined for each {@link Geometry} subclass as follows:
 * <ul>
 * <li>Valid polygonal geometries are simple by definition, so
 * <code>isSimple</code> trivially returns true.
 * (Hint: in order to check if a polygonal geometry has self-intersections,
 * use {@link Geometry#isValid}).
 * <li>Linear geometries are simple iff they do not self-intersect at points
 * other than boundary points.
 * (Using the Mod-2 rule, this means that closed linestrings
 * cannot be touched at their endpoints, since these are
 * interior points, not boundary points).
 * <li>Zero-dimensional geometries (points) are simple iff they have no
 * repeated points.
 * <li>Empty <code>Geometry</code>s are always simple
 * </ul>
 *
 * @see BoundaryNodeRule
 */



/**
 * Creates a simplicity checker using the default SFS Mod-2 Boundary Node Rule
 *
 * @param {Geometry}
 *          geom the geometry to test.
 * @constructor
 */
jsts.operation.IsSimpleOp = function(geom) {
  this.geom = geom;
};


/**
 * @type {jsts.geom.Geometry}
 */
jsts.operation.IsSimpleOp.prototype.geom = null;


/**
 * @type {boolean}
 */
jsts.operation.IsSimpleOp.prototype.isClosedEndpointsInInterior = true;


/**
 * @type {jsts.geom.Coordinate}
 */
jsts.operation.IsSimpleOp.prototype.nonSimpleLocation = null;


/**
 * Creates a simplicity checker using the default SFS Mod-2 Boundary Node Rule
 *
 * @param {Geometry}
 *          geom the geometry to test.
 */
jsts.operation.IsSimpleOp.prototype.IsSimpleOp = function(geom) {
  this.geom = geom;
};


/**
 * Tests whether the geometry is simple.
 *
 * @return {boolean} true if the geometry is simple.
 */
jsts.operation.IsSimpleOp.prototype.isSimple = function() {
  this.nonSimpleLocation = null;
  if (this.geom instanceof jsts.geom.LineString) {
    return this.isSimpleLinearGeometry(this.geom);
  }
  if (this.geom instanceof jsts.geom.MultiLineString) {
    return this.isSimpleLinearGeometry(this.geom);
  }
  if (this.geom instanceof jsts.geom.MultiPoint) {
    return this.isSimpleMultiPoint(this.geom);
  }
  // all other geometry types are simple by definition
  return true;
};


/**
 * @param {MultiPoint}
 *          mp
 * @return {boolean} true if the geometry is simple.
 * @private
 */
jsts.operation.IsSimpleOp.prototype.isSimpleMultiPoint = function(mp) {
  if (mp.isEmpty())
    return true;
  var points = [];
  for (var i = 0; i < mp.getNumGeometries(); i++) {
    var pt = mp.getGeometryN(i);
    var p = pt.getCoordinate();
    for (var j = 0; j < points.length; j++) {
      var point = points[j];
      if (p.equals2D(point)) {
        this.nonSimpleLocation = p;
        return false;
      }
    }
    points.push(p);
  }
  return true;
};


/**
 * @param {Geometry}
 *          geom input geometry.
 * @return {boolean} true if the geometry is simple.
 * @private
 */
jsts.operation.IsSimpleOp.prototype.isSimpleLinearGeometry = function(geom) {
  if (geom.isEmpty())
    return true;
  var graph = new jsts.geomgraph.GeometryGraph(0, geom);
  var li = new jsts.algorithm.RobustLineIntersector();
  var si = graph.computeSelfNodes(li, true);
  // if no self-intersection, must be simple
  if (!si.hasIntersection())
    return true;
  if (si.hasProperIntersection()) {
    this.nonSimpleLocation = si.getProperIntersectionPoint();
    return false;
  }
  if (this.hasNonEndpointIntersection(graph))
    return false;
  if (this.isClosedEndpointsInInterior) {
    if (this.hasClosedEndpointIntersection(graph))
      return false;
  }
  return true;
};


/**
 * For all edges, check if there are any intersections which are NOT at an
 * endpoint. The Geometry is not simple if there are intersections not at
 * endpoints.
 *
 * @param {GeometryGraph}
 *          graph
 * @return {boolean}
 * @private
 */
jsts.operation.IsSimpleOp.prototype.hasNonEndpointIntersection = function(graph) {
  for (var i = graph.getEdgeIterator(); i.hasNext(); ) {
    var e = i.next();
    var maxSegmentIndex = e.getMaximumSegmentIndex();
    for (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext(); ) {
      var ei = eiIt.next();
      if (! ei.isEndPoint(maxSegmentIndex)) {
        this.nonSimpleLocation = ei.getCoordinate();
        return true;
      }
    }
  }
  return false;
};


/**
 * Tests that no edge intersection is the endpoint of a closed line. This
 * ensures that closed lines are not touched at their endpoint, which is an
 * interior point according to the Mod-2 rule To check this we compute the
 * degree of each endpoint. The degree of endpoints of closed lines must be
 * exactly 2.
 *
 * @param {GeometryGraph}
 *          graph
 * @return {boolean}
 * @private
 */
jsts.operation.IsSimpleOp.prototype.hasClosedEndpointIntersection = function(
    graph) {
  var endPoints = new javascript.util.TreeMap();
  for (var i = graph.getEdgeIterator(); i.hasNext(); ) {
    var e = i.next();
    var maxSegmentIndex = e.getMaximumSegmentIndex();
    var isClosed = e.isClosed();
    var p0 = e.getCoordinate(0);
    this.addEndpoint(endPoints, p0, isClosed);
    var p1 = e.getCoordinate(e.getNumPoints() - 1);
    this.addEndpoint(endPoints, p1, isClosed);
  }

  for (var i = endPoints.values().iterator(); i.hasNext(); ) {
    var eiInfo = i.next();
    if (eiInfo.isClosed && eiInfo.degree != 2) {
      this.nonSimpleLocation = eiInfo.getCoordinate();
      return true;
    }
  }
  return false;
};



/**
 * private
 *
 * @constructor
 */
jsts.operation.IsSimpleOp.EndpointInfo = function(pt) {

  this.pt = pt;
  this.isClosed = false;
  this.degree = 0;
};


/**
 * @type {Coordinate}
 * @private
 */
jsts.operation.IsSimpleOp.EndpointInfo.prototype.pt = null;


/**
 * @type {boolean}
 * @private
 */
jsts.operation.IsSimpleOp.EndpointInfo.prototype.isClosed = null;


/**
 * @type {int}
 * @private
 */
jsts.operation.IsSimpleOp.EndpointInfo.prototype.degree = null;


/**
 * @return {Coordinate}
 */
jsts.operation.IsSimpleOp.EndpointInfo.prototype.getCoordinate = function() {
  return this.pt;
};


/**
 * @param {boolean}
 *          isClosed
 */
jsts.operation.IsSimpleOp.EndpointInfo.prototype.addEndpoint = function(
    isClosed) {
  this.degree++;
  this.isClosed = this.isClosed || isClosed;
};


/**
 * Add an endpoint to the map, creating an entry for it if none exists
 *
 * @param {javascript.util.Map}
 *          endPoints
 * @param {jsts.geom.Coordinate}
 *          p
 * @param {boolean}
 *          isClosed
 * @private
 */
jsts.operation.IsSimpleOp.prototype.addEndpoint = function(endPoints, p,
    isClosed) {
  var eiInfo = endPoints.get(p);
  if (eiInfo === null) {
    eiInfo = new jsts.operation.IsSimpleOp.EndpointInfo(p);
    endPoints.put(p, eiInfo);
  }
  eiInfo.addEndpoint(isClosed);
};
/* ======================================================================
    jsts/operation/overlay/snap/LineStringSnapper.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */


/**
 * Snaps the vertices and segments of a {@link LineString} to a set of target
 * snap vertices. A snap distance tolerance is used to control where snapping is
 * performed.
 * <p>
 * The implementation handles empty geometry and empty snap vertex sets.
 *
 */

(function() {
  /**
   * Constructs a new LineStringSnapper based on provided arguments
   *
   * @constructor
   */
  var LineStringSnapper = function() {
    this.snapTolerance = 0.0;
    this.seg = new jsts.geom.LineSegment();
    this.allowSnappingToSourceVertices = false;
    this.isClosed = false;
    this.srcPts = [];

    if (arguments[0] instanceof jsts.geom.LineString) {
      this.initFromLine.apply(this, arguments);
    } else {
      this.initFromPoints.apply(this, arguments);
    }
  };

  /**
   * Creates a new snapper using the points in the given {@link LineString} as
   * source snap points.
   *
   * @param {jsts.geom.LineString}
   *          srcLine a LineString to snap (may be empty).
   * @param {Number}
   *          snapTolerance the snap tolerance to use.
   */
  LineStringSnapper.prototype.initFromLine = function(srcLine, snapTolerance) {
    this.initFromPoints(srcLine.getCoordinates(), snapTolerance);
  };

  /**
   * Creates a new snapper using the given points as source points to be
   * snapped.
   *
   * @param {Array{jsts.geom.Coordinate}}
   *          srcPts the points to snap
   * @param {Number}
   *          snapTolerance the snap tolerance to use.
   */
  LineStringSnapper.prototype.initFromPoints = function(srcPts, snapTolerance) {
    this.srcPts = srcPts;
    this.isClosed = this.calcIsClosed(srcPts);
    this.snapTolerance = snapTolerance;
  };

  LineStringSnapper.prototype.setAllowSnappingToSourceVertices = function(
      allowSnappingToSourceVertices) {
    this.allowSnappingToSourceVertices = allowSnappingToSourceVertices;
  };

  LineStringSnapper.prototype.calcIsClosed = function(pts) {
    if (pts.length <= 1) {
      return false;
    }

    return pts[0].equals(pts[pts.length - 1]);
  };

  /**
   * Snaps the vertices and segments of the source LineString to the given set
   * of snap vertices.
   *
   * @param {Array{Coordinate}}
   *          snapPts the vertices to snap to
   * @return {Array{Coordinate}} a list of the snapped points
   */
  LineStringSnapper.prototype.snapTo = function(snapPts) {
    var coordList = new jsts.geom.CoordinateList(this.srcPts);
    this.snapVertices(coordList, snapPts);
    this.snapSegments(coordList, snapPts);

    return coordList.toCoordinateArray();
  };

  /**
   * Snap source vertices to vertices in the target.
   *
   * @param {jsts.geom.CoordinateList}
   *          srcCoords the points to snap.
   * @param {Array{Coordinate}}
   *          snapPts the points to snap to
   */
  LineStringSnapper.prototype.snapVertices = function(srcCoords, snapPts) {
    // try snapping vertices
    // if src is a ring then don't snap final vertex
    var end = this.isClosed ? srcCoords.size() - 1 : srcCoords.size(), i = 0, srcPt, snapVert;
    for (i; i < end; i++) {
      srcPt = srcCoords.get(i);
      snapVert = this.findSnapForVertex(srcPt, snapPts);
      if (snapVert !== null) {
        // update src with snap pt
        srcCoords.set(i, new jsts.geom.Coordinate(snapVert));
        // keep final closing point in synch (rings only)
        if (i === 0 && this.isClosed)
          srcCoords.set(srcCoords.size() - 1, new jsts.geom.Coordinate(snapVert));
      }
    }
  };

  LineStringSnapper.prototype.findSnapForVertex = function(pt, snapPts) {
    var i = 0, il = snapPts.length;
    for (i = 0; i < il; i++) {
      // if point is already equal to a src pt, don't snap
      if (pt.equals(snapPts[i])) {
        return null;
      }

      if (pt.distance(snapPts[i]) < this.snapTolerance) {
        return snapPts[i];
      }
    }
    return null;
  };

  /**
   * Snap segments of the source to nearby snap vertices. Source segments are
   * "cracked" at a snap vertex. A single input segment may be snapped several
   * times to different snap vertices.
   * <p>
   * For each distinct snap vertex, at most one source segment is snapped to.
   * This prevents "cracking" multiple segments at the same point, which would
   * likely cause topology collapse when being used on polygonal linework.
   *
   * @param {jsts.geom.CoordinateList}
   *          srcCoords the coordinates of the source linestring to be snapped.
   * @param {Array{jsts.geom.Coordinate}}
   *          snapPts the target snap vertices
   */
  LineStringSnapper.prototype.snapSegments = function(srcCoords, snapPts) {
    // guard against empty input
    if (snapPts.length === 0) {
      return;
    }

    var distinctPtCount = snapPts.length, i, snapPt, index;

    // check for duplicate snap pts when they are sourced from a linear ring.
    // TODO: Need to do this better - need to check *all* snap points for dups
    // (using a Set?)
    if (snapPts.length>1 && snapPts[0].equals2D(snapPts[snapPts.length - 1])) {
      distinctPtCount = snapPts.length - 1;
    }

    i = 0;
    for (i; i < distinctPtCount; i++) {
      snapPt = snapPts[i];
      index = this.findSegmentIndexToSnap(snapPt, srcCoords);
      /**
       * If a segment to snap to was found, "crack" it at the snap pt. The new
       * pt is inserted immediately into the src segment list, so that
       * subsequent snapping will take place on the modified segments. Duplicate
       * points are not added.
       */
      if (index >= 0) {
        srcCoords.add(index + 1, new jsts.geom.Coordinate(snapPt), false);
      }
    }
  };

  /**
   * Finds a src segment which snaps to (is close to) the given snap point.
   * <p>
   * Only a single segment is selected for snapping. This prevents multiple
   * segments snapping to the same snap vertex, which would almost certainly
   * cause invalid geometry to be created. (The heuristic approach to snapping
   * used here is really only appropriate when snap pts snap to a unique spot on
   * the src geometry.)
   * <p>
   * Also, if the snap vertex occurs as a vertex in the src coordinate list, no
   * snapping is performed.
   *
   * @param {jsts.geom.Coordinate}
   *          snapPt the point to snap to.
   * @param {jsts.geom.CoordinateList}
   *          srcCoords the source segment coordinates.
   * @return {Number} the index of the snapped segment.
   * @return {Number} -1 if no segment snaps to the snap point.
   */
  LineStringSnapper.prototype.findSegmentIndexToSnap = function(snapPt,
      srcCoords) {
    var minDist = Number.MAX_VALUE, snapIndex = -1, i = 0, dist;
    for (i; i < srcCoords.size() - 1; i++) {
      this.seg.p0 = srcCoords.get(i);
      this.seg.p1 = srcCoords.get(i + 1);

      /**
       * Check if the snap pt is equal to one of the segment endpoints.
       *
       * If the snap pt is already in the src list, don't snap at all.
       */
      if (this.seg.p0.equals(snapPt) || this.seg.p1.equals(snapPt)) {
        if (this.allowSnappingToSourceVertices) {
          continue;
        } else {
          return -1;
        }
      }

      dist = this.seg.distance(snapPt);
      if (dist < this.snapTolerance && dist < minDist) {
        minDist = dist;
        snapIndex = i;
      }
    }
    return snapIndex;
  };

  jsts.operation.overlay.snap.LineStringSnapper = LineStringSnapper;
})();
/* ======================================================================
    jsts/operation/polygonize/Polygonizer.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Port source:
 * /jts/jts/java/src/com/vividsolutions/jts/operation/polygonize/Polygonizer.java
 * Revision: 6
 */

/**
 * @requires jsts/geom/GeometryComponentFilter.js
 * @requires jsts/geom/LineString.js
 * @requires jsts/operation/polygonize/EdgeRing.js
 * @requires jsts/operation/polygonize/PolygonizeGraph.js
 */

(function() {

  var ArrayList = javascript.util.ArrayList;
  var GeometryComponentFilter = jsts.geom.GeometryComponentFilter;
  var LineString = jsts.geom.LineString;
  var EdgeRing = jsts.operation.polygonize.EdgeRing;
  var PolygonizeGraph = jsts.operation.polygonize.PolygonizeGraph;


  /**
   * Polygonizes a set of {@link Geometry}s which contain linework that
   * represents the edges of a planar graph. All types of Geometry are accepted
   * as input; the constituent linework is extracted as the edges to be
   * polygonized. The processed edges must be correctly noded; that is, they
   * must only meet at their endpoints. The Polygonizer will run on incorrectly
   * noded input but will not form polygons from non-noded edges, and will
   * report them as errors.
   * <p>
   * The Polygonizer reports the follow kinds of errors:
   * <ul>
   * <li><b>Dangles</b> - edges which have one or both ends which are not
   * incident on another edge endpoint
   * <li><b>Cut Edges</b> - edges which are connected at both ends but which
   * do not form part of polygon
   * <li><b>Invalid Ring Lines</b> - edges which form rings which are invalid
   * (e.g. the component lines contain a self-intersection)
   * </ul>
   *
   * Create a polygonizer with the same {@link GeometryFactory} as the input
   * {@link Geometry}s
   */
  var Polygonizer = function() {
    var that = this;

    /**
     * Adds every linear element in a {@link Geometry} into the polygonizer graph.
     */
    var LineStringAdder = function() {

    };

    LineStringAdder.prototype = new GeometryComponentFilter();

    LineStringAdder.prototype.filter = function(g) {
      if (g instanceof LineString)
        that.add(g);
    };

    this.lineStringAdder = new LineStringAdder();
    this.dangles = new ArrayList();
    this.cutEdges = new ArrayList();
    this.invalidRingLines = new ArrayList();
  };



  // default factory
  Polygonizer.prototype.lineStringAdder = null;

  Polygonizer.prototype.graph = null;
  // initialize with empty collections, in case nothing is computed
  Polygonizer.prototype.dangles = null;
  Polygonizer.prototype.cutEdges = null;
  Polygonizer.prototype.invalidRingLines = null;

  Polygonizer.prototype.holeList = null;
  Polygonizer.prototype.shellList = null;
  Polygonizer.prototype.polyList = null;


  /**
   * Adds a collection of geometries to the edges to be polygonized. May be
   * called multiple times. Any dimension of Geometry may be added; the
   * constituent linework will be extracted and used.
   *
   * @param geomList
   *          a list of {@link Geometry} s with linework to be polygonized.
   */
  Polygonizer.prototype.add = function(geomList) {
    if (geomList instanceof jsts.geom.LineString) {
      return this.add3(geomList);
    } else if (geomList instanceof jsts.geom.Geometry) {
      return this.add2(geomList);
    }

    for (var i = geomList.iterator(); i.hasNext();) {
      var geometry = i.next();
      this.add2(geometry);
    }
  };

  /**
   * Add a {@link Geometry} to the edges to be polygonized. May be called
   * multiple times. Any dimension of Geometry may be added; the constituent
   * linework will be extracted and used
   *
   * @param g
   *          a {@link Geometry} with linework to be polygonized.
   */
  Polygonizer.prototype.add2 = function(g) {
    g.apply(this.lineStringAdder);
  };

  /**
   * Adds a linestring to the graph of polygon edges.
   *
   * @param line
   *          the {@link LineString} to add.
   */
  Polygonizer.prototype.add3 = function(line) {
    // create a new graph using the factory from the input Geometry
    if (this.graph == null)
      this.graph = new PolygonizeGraph(line.getFactory());
    this.graph.addEdge(line);
  };

  /**
   * Gets the list of polygons formed by the polygonization.
   *
   * @return a collection of {@link Polygon} s.
   */
  Polygonizer.prototype.getPolygons = function() {
    this.polygonize();
    return this.polyList;
  };

  /**
   * Gets the list of dangling lines found during polygonization.
   *
   * @return a collection of the input {@link LineString} s which are dangles.
   */
  Polygonizer.prototype.getDangles = function() {
    this.polygonize();
    return this.dangles;
  };

  /**
   * Gets the list of cut edges found during polygonization.
   *
   * @return a collection of the input {@link LineString} s which are cut edges.
   */
  Polygonizer.prototype.getCutEdges = function() {
    this.polygonize();
    return this.cutEdges;
  };

  /**
   * Gets the list of lines forming invalid rings found during polygonization.
   *
   * @return a collection of the input {@link LineString} s which form invalid
   *         rings.
   */
  Polygonizer.prototype.getInvalidRingLines = function() {
    this.polygonize();
    return this.invalidRingLines;
  };

  /**
   * Performs the polygonization, if it has not already been carried out.
   */
  Polygonizer.prototype.polygonize = function() {
    // check if already computed
    if (this.polyList != null)
      return;
    this.polyList = new ArrayList();

    // if no geometries were supplied it's possible that graph is null
    if (this.graph == null)
      return;

    this.dangles = this.graph.deleteDangles();
    this.cutEdges = this.graph.deleteCutEdges();
    var edgeRingList = this.graph.getEdgeRings();

    var validEdgeRingList = new ArrayList();
    this.invalidRingLines = new ArrayList();
    this.findValidRings(edgeRingList, validEdgeRingList, this.invalidRingLines);

    this.findShellsAndHoles(validEdgeRingList);
    Polygonizer.assignHolesToShells(this.holeList, this.shellList);

    this.polyList = new ArrayList();
    for (var i = this.shellList.iterator(); i.hasNext();) {
      var er = i.next();
      this.polyList.add(er.getPolygon());
    }
  };

  /**
   * @private
   */
  Polygonizer.prototype.findValidRings = function(edgeRingList,
      validEdgeRingList, invalidRingList) {
    for (var i = edgeRingList.iterator(); i.hasNext();) {
      var er = i.next();
      if (er.isValid())
        validEdgeRingList.add(er);
      else
        invalidRingList.add(er.getLineString());
    }
  };

  /**
   * @private
   */
  Polygonizer.prototype.findShellsAndHoles = function(edgeRingList) {
    this.holeList = new ArrayList();
    this.shellList = new ArrayList();
    for (var i = edgeRingList.iterator(); i.hasNext();) {
      var er = i.next();
      if (er.isHole())
        this.holeList.add(er);
      else
        this.shellList.add(er);
    }
  };

  /**
   * @private
   */
  Polygonizer.assignHolesToShells = function(holeList, shellList) {
    for (var i = holeList.iterator(); i.hasNext();) {
      var holeER = i.next();
      Polygonizer.assignHoleToShell(holeER, shellList);
    }
  };

  /**
   * @private
   */
  Polygonizer.assignHoleToShell = function(holeER, shellList) {
    var shell = EdgeRing.findEdgeRingContaining(holeER, shellList);
    if (shell != null)
      shell.addHole(holeER.getRing());
  };


  jsts.operation.polygonize.Polygonizer = Polygonizer;

})();
/* ======================================================================
    jsts/geom/util/GeometryTransformer.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Port source:
 * /jts/jts/java/src/com/vividsolutions/jts/geom/util/GeometryTransformer.java
 * Revision: 381
 */

/**
 * A framework for processes which transform an input {@link Geometry} into an
 * output {@link Geometry}, possibly changing its structure and type(s). This
 * class is a framework for implementing subclasses which perform
 * transformations on various different Geometry subclasses. It provides an easy
 * way of applying specific transformations to given geometry types, while
 * allowing unhandled types to be simply copied. Also, the framework ensures
 * that if subcomponents change type the parent geometries types change
 * appropriately to maintain valid structure. Subclasses will override whichever
 * <code>transformX</code> methods they need to to handle particular Geometry
 * types.
 * <p>
 * A typically usage would be a transformation class that transforms
 * <tt>Polygons</tt> into <tt>Polygons</tt>, <tt>LineStrings</tt> or
 * <tt>Points</tt>, depending on the geometry of the input (For instance, a
 * simplification operation). This class would likely need to override the
 * {@link #transformMultiPolygon(MultiPolygon, Geometry)transformMultiPolygon}
 * method to ensure that if input Polygons change type the result is a
 * <tt>GeometryCollection</tt>, not a <tt>MultiPolygon</tt>.
 * <p>
 * The default behaviour of this class is simply to recursively transform each
 * Geometry component into an identical object by deep copying down to the level
 * of, but not including, coordinates.
 * <p>
 * All <code>transformX</code> methods may return <code>null</code>, to
 * avoid creating empty or invalid geometry objects. This will be handled
 * correctly by the transformer. <code>transform<i>XXX</i></code> methods
 * should always return valid geometry - if they cannot do this they should
 * return <code>null</code> (for instance, it may not be possible for a
 * transformLineString implementation to return at least two points - in this
 * case, it should return <code>null</code>). The
 * {@link #transform(Geometry)transform} method itself will always return a
 * non-null Geometry object (but this may be empty).
 *
 * @see GeometryEditor
 */

(function() {

  var ArrayList = javascript.util.ArrayList;

  var GeometryTransformer = function() {

  };


  GeometryTransformer.prototype.inputGeom = null;

  GeometryTransformer.prototype.factory = null;

  // these could eventually be exposed to clients
  /**
   * <code>true</code> if empty geometries should not be included in the
   * result
   */
  GeometryTransformer.prototype.pruneEmptyGeometry = true;

  /**
   * <code>true</code> if a homogenous collection result from a
   * {@link GeometryCollection} should still be a general GeometryCollection
   */
  GeometryTransformer.prototype.preserveGeometryCollectionType = true;

  /**
   * <code>true</code> if the output from a collection argument should still
   * be a collection
   */
  GeometryTransformer.prototype.preserveCollections = false;

  /**
   * <code>true</code> if the type of the input should be preserved
   */
  GeometryTransformer.prototype.reserveType = false;

  /**
   * Utility function to make input geometry available
   *
   * @return the input geometry.
   */
  GeometryTransformer.prototype.getInputGeometry = function() {
    return this.inputGeom;
  };

  GeometryTransformer.prototype.transform = function(inputGeom) {
    this.inputGeom = inputGeom;
    this.factory = inputGeom.getFactory();

    if (inputGeom instanceof jsts.geom.Point)
      return this.transformPoint(inputGeom, null);
    if (inputGeom instanceof jsts.geom.MultiPoint)
      return this.transformMultiPoint(inputGeom, null);
    if (inputGeom instanceof jsts.geom.LinearRing)
      return this.transformLinearRing(inputGeom, null);
    if (inputGeom instanceof jsts.geom.LineString)
      return this.transformLineString(inputGeom, null);
    if (inputGeom instanceof jsts.geom.MultiLineString)
      return this.transformMultiLineString(inputGeom, null);
    if (inputGeom instanceof jsts.geom.Polygon)
      return this.transformPolygon(inputGeom, null);
    if (inputGeom instanceof jsts.geom.MultiPolygon)
      return this.transformMultiPolygon(inputGeom, null);
    if (inputGeom instanceof jsts.geom.GeometryCollection)
      return this.transformGeometryCollection(inputGeom, null);

    throw new jsts.error.IllegalArgumentException('Unknown Geometry subtype: ' +
        inputGeom.getClass().getName());
  };

  /**
   * Convenience method which provides standard way of creating a
   * {@link CoordinateSequence}
   *
   * @param coords
   *          the coordinate array to copy.
   * @return a coordinate sequence for the array.
   */
  GeometryTransformer.prototype.createCoordinateSequence = function(coords) {
    return this.factory.getCoordinateSequenceFactory().create(coords);
  };

  /**
   * Convenience method which provides statndard way of copying
   * {@link CoordinateSequence}s
   *
   * @param seq
   *          the sequence to copy.
   * @return a deep copy of the sequence.
   */
  GeometryTransformer.prototype.copy = function(seq) {
    return seq.clone();
  };

  /**
   * Transforms a {@link CoordinateSequence}. This method should always return
   * a valid coordinate list for the desired result type. (E.g. a coordinate
   * list for a LineString must have 0 or at least 2 points). If this is not
   * possible, return an empty sequence - this will be pruned out.
   *
   * @param coords
   *          the coordinates to transform.
   * @param parent
   *          the parent geometry.
   * @return the transformed coordinates.
   */
  GeometryTransformer.prototype.transformCoordinates = function(coords, parent) {
    return this.copy(coords);
  };

  GeometryTransformer.prototype.transformPoint = function(geom, parent) {
    return this.factory.createPoint(this.transformCoordinates(geom
        .getCoordinateSequence(), geom));
  };

  GeometryTransformer.prototype.transformMultiPoint = function(geom, parent) {
    var transGeomList = new ArrayList();
    for (var i = 0; i < geom.getNumGeometries(); i++) {
      var transformGeom = this.transformPoint(geom.getGeometryN(i), geom);
      if (transformGeom == null)
        continue;
      if (transformGeom.isEmpty())
        continue;
      transGeomList.add(transformGeom);
    }
    return this.factory.buildGeometry(transGeomList);
  };

  /**
   * Transforms a LinearRing. The transformation of a LinearRing may result in a
   * coordinate sequence which does not form a structurally valid ring (i.e. a
   * degnerate ring of 3 or fewer points). In this case a LineString is
   * returned. Subclasses may wish to override this method and check for this
   * situation (e.g. a subclass may choose to eliminate degenerate linear rings)
   *
   * @param geom
   *          the ring to simplify.
   * @param parent
   *          the parent geometry.
   * @return a LinearRing if the transformation resulted in a structurally valid
   *         ring.
   * @return a LineString if the transformation caused the LinearRing to
   *         collapse to 3 or fewer points.
   */
  GeometryTransformer.prototype.transformLinearRing = function(geom, parent) {
    var seq = this.transformCoordinates(geom.getCoordinateSequence(), geom);
    var seqSize = seq.length;
    // ensure a valid LinearRing
    if (seqSize > 0 && seqSize < 4 && !this.preserveType)
      return this.factory.createLineString(seq);
    return this.factory.createLinearRing(seq);

  };

  /**
   * Transforms a {@link LineString} geometry.
   *
   * @param geom
   * @param parent
   * @return
   */
  GeometryTransformer.prototype.transformLineString = function(geom, parent) {
    // should check for 1-point sequences and downgrade them to points
    return this.factory.createLineString(this.transformCoordinates(geom
        .getCoordinateSequence(), geom));
  };

  GeometryTransformer.prototype.transformMultiLineString = function(geom,
      parent) {
    var transGeomList = new ArrayList();
    for (var i = 0; i < geom.getNumGeometries(); i++) {
      var transformGeom = this.transformLineString(geom.getGeometryN(i), geom);
      if (transformGeom == null)
        continue;
      if (transformGeom.isEmpty())
        continue;
      transGeomList.add(transformGeom);
    }
    return this.factory.buildGeometry(transGeomList);
  };

  GeometryTransformer.prototype.transformPolygon = function(geom, parent) {
    var isAllValidLinearRings = true;
    var shell = this.transformLinearRing(geom.getExteriorRing(), geom);

    if (shell == null || !(shell instanceof jsts.geom.LinearRing) ||
        shell.isEmpty())
      isAllValidLinearRings = false;

    var holes = new ArrayList();
    for (var i = 0; i < geom.getNumInteriorRing(); i++) {
      var hole = this.transformLinearRing(geom.getInteriorRingN(i), geom);
      if (hole == null || hole.isEmpty()) {
        continue;
      }
      if (!(hole instanceof jsts.geom.LinearRing))
        isAllValidLinearRings = false;

      holes.add(hole);
    }

    if (isAllValidLinearRings)
      return this.factory.createPolygon(shell, holes.toArray());
    else {
      var components = new ArrayList();
      if (shell != null)
        components.add(shell);
      components.addAll(holes);
      return this.factory.buildGeometry(components);
    }
  };

  GeometryTransformer.prototype.transformMultiPolygon = function(geom, parent) {
    var transGeomList = new ArrayList();
    for (var i = 0; i < geom.getNumGeometries(); i++) {
      var transformGeom = this.transformPolygon(geom.getGeometryN(i), geom);
      if (transformGeom == null)
        continue;
      if (transformGeom.isEmpty())
        continue;
      transGeomList.add(transformGeom);
    }
    return this.factory.buildGeometry(transGeomList);
  };

  GeometryTransformer.prototype.transformGeometryCollection = function(geom,
      parent) {
    var transGeomList = new ArrayList();
    for (var i = 0; i < geom.getNumGeometries(); i++) {
      var transformGeom = this.transform(geom.getGeometryN(i));
      if (transformGeom == null)
        continue;
      if (this.pruneEmptyGeometry && transformGeom.isEmpty())
        continue;
      transGeomList.add(transformGeom);
    }
    if (this.preserveGeometryCollectionType)
      return this.factory.createGeometryCollection(GeometryFactory
          .toGeometryArray(transGeomList));
    return this.factory.buildGeometry(transGeomList);
  };

  jsts.geom.util.GeometryTransformer = GeometryTransformer;

})();
/* ======================================================================
    jsts/operation/overlay/snap/GeometrySnapper.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Port source:
 * /jts/jts/java/src/com/vividsolutions/jts/operation/overlay/snap/GeometrySnapper.java
 * Revision: 167
 */

/**
 * @requires jsts/operation/overlay/snap/LineStringSnapper.js
 * @requires jsts/geom/PrecisionModel.js
 * @requires jsts/geom/util/GeometryTransformer.js
 */

/**
 * Snaps the vertices and segments of a {@link Geometry} to another Geometry's
 * vertices. A snap distance tolerance is used to control where snapping is
 * performed. Snapping one geometry to another can improve robustness for
 * overlay operations by eliminating nearly-coincident edges (which cause
 * problems during noding and intersection calculation). Too much snapping can
 * result in invalid topology beging created, so the number and location of
 * snapped vertices is decided using heuristics to determine when it is safe to
 * snap. This can result in some potential snaps being omitted, however.
 */

(function() {

  var LineStringSnapper = jsts.operation.overlay.snap.LineStringSnapper;
  var PrecisionModel = jsts.geom.PrecisionModel;
  var TreeSet = javascript.util.TreeSet;

  /**
   * @constructor
   */
  var SnapTransformer = function(snapTolerance, snapPts, isSelfSnap) {
    this.snapTolerance = snapTolerance;
    this.snapPts = snapPts;
    this.isSelfSnap = isSelfSnap || false;
  };

  SnapTransformer.prototype = new jsts.geom.util.GeometryTransformer();

  SnapTransformer.prototype.snapTolerance = null;
  SnapTransformer.prototype.snapPts = null;
  SnapTransformer.prototype.isSelfSnap = false;


  SnapTransformer.prototype.transformCoordinates = function(coords, parent) {
    var srcPts = coords;
    var newPts = this.snapLine(srcPts, this.snapPts);
    return newPts;
  };

  SnapTransformer.prototype.snapLine = function(srcPts, snapPts) {
    var snapper = new LineStringSnapper(srcPts, this.snapTolerance);
    snapper.setAllowSnappingToSourceVertices(this.isSelfSnap);
    return snapper.snapTo(snapPts);
  };

  /**
   * Creates a new snapper acting on the given geometry
   *
   * @param srcGeom
   *          the geometry to snap.
   * @constructor
   */
  var GeometrySnapper = function(srcGeom) {
    this.srcGeom = srcGeom;
  };

  GeometrySnapper.SNAP_PRECISION_FACTOR = 1e-9;

  /**
   * Estimates the snap tolerance for a Geometry, taking into account its
   * precision model.
   *
   * @param g
   *          a Geometry.
   * @return the estimated snap tolerance.
   */
  GeometrySnapper.computeOverlaySnapTolerance = function(g) {
    if (arguments.length === 2) {
      return GeometrySnapper.computeOverlaySnapTolerance2.apply(this, arguments);
    }

    var snapTolerance = this.computeSizeBasedSnapTolerance(g);

    /**
     * Overlay is carried out in the precision model of the two inputs. If this
     * precision model is of type FIXED, then the snap tolerance must reflect
     * the precision grid size. Specifically, the snap tolerance should be at
     * least the distance from a corner of a precision grid cell to the centre
     * point of the cell.
     */
    var pm = g.getPrecisionModel();
    if (pm.getType() == PrecisionModel.FIXED) {
      var fixedSnapTol = (1 / pm.getScale()) * 2 / 1.415;
      if (fixedSnapTol > snapTolerance)
        snapTolerance = fixedSnapTol;
    }
    return snapTolerance;
  };

  GeometrySnapper.computeSizeBasedSnapTolerance = function(g) {
    var env = g.getEnvelopeInternal();
    var minDimension = Math.min(env.getHeight(), env.getWidth());
    var snapTol = minDimension * GeometrySnapper.SNAP_PRECISION_FACTOR;
    return snapTol;
  };

  GeometrySnapper.computeOverlaySnapTolerance2 = function(g0, g1) {
    return Math.min(this.computeOverlaySnapTolerance(g0), this
        .computeOverlaySnapTolerance(g1));
  };

  /**
   * Snaps two geometries together with a given tolerance.
   *
   * @param g0
   *          a geometry to snap.
   * @param g1
   *          a geometry to snap.
   * @param snapTolerance
   *          the tolerance to use.
   * @return the snapped geometries.
   */
  GeometrySnapper.snap = function(g0, g1, snapTolerance) {
    var snapGeom = [];
    var snapper0 = new GeometrySnapper(g0);
    snapGeom[0] = snapper0.snapTo(g1, snapTolerance);

    /**
     * Snap the second geometry to the snapped first geometry (this strategy
     * minimizes the number of possible different points in the result)
     */
    var snapper1 = new GeometrySnapper(g1);
    snapGeom[1] = snapper1.snapTo(snapGeom[0], snapTolerance);

    return snapGeom;
  };

  GeometrySnapper.snapToSelf = function(g0, snapTolerance, cleanResult) {
    var snapper0 = new GeometrySnapper(g0);
    return snapper0.snapToSelf(snapTolerance, cleanResult);
  };

  /**
   * @private
   */
  GeometrySnapper.prototype.srcGeom = null;

  /**
   * Snaps the vertices in the component {@link LineString}s of the source
   * geometry to the vertices of the given snap geometry.
   *
   * @param snapGeom
   *          a geometry to snap the source to.
   * @return a new snapped Geometry.
   */
  GeometrySnapper.prototype.snapTo = function(snapGeom, snapTolerance) {
    var snapPts = this.extractTargetCoordinates(snapGeom);

    var snapTrans = new SnapTransformer(snapTolerance, snapPts);
    return snapTrans.transform(this.srcGeom);
  };

  /**
   * Snaps the vertices in the component {@link LineString}s of the source
   * geometry to the vertices of the given snap geometry.
   *
   * @param snapGeom
   *          a geometry to snap the source to.
   * @return a new snapped Geometry.
   */
  GeometrySnapper.prototype.snapToSelf = function(snapTolerance, cleanResult) {
    var snapPts = this.extractTargetCoordinates(srcGeom);

    var snapTrans = new SnapTransformer(snapTolerance, snapPts, true);
    var snappedGeom = snapTrans.transform(srcGeom);
    var result = snappedGeom;
    if (cleanResult && result instanceof Polygonal) {
      // TODO: use better cleaning approach
      result = snappedGeom.buffer(0);
    }
    return result;
  };

  GeometrySnapper.prototype.extractTargetCoordinates = function(g) {
    // TODO: should do this more efficiently. Use CoordSeq filter to get points,
    // KDTree for uniqueness & queries
    var ptSet = new TreeSet();
    var pts = g.getCoordinates();
    for (var i = 0; i < pts.length; i++) {
      ptSet.add(pts[i]);
    }
    return ptSet.toArray();
  };

  /**
   * Computes the snap tolerance based on the input geometries.
   *
   * @param ringPts
   * @return
   */
  GeometrySnapper.prototype.computeSnapTolerance = function(ringPts) {
    var minSegLen = this.computeMinimumSegmentLength(ringPts);
    // use a small percentage of this to be safe
    var snapTol = minSegLen / 10;
    return snapTol;
  };

  GeometrySnapper.prototype.computeMinimumSegmentLength = function(pts) {
    var minSegLen = Number.MAX_VALUE;
    for (var i = 0; i < pts.length - 1; i++) {
      var segLen = pts[i].distance(pts[i + 1]);
      if (segLen < minSegLen)
        minSegLen = segLen;
    }
    return minSegLen;
  };

  jsts.operation.overlay.snap.GeometrySnapper = GeometrySnapper;

})();
/* ======================================================================
    jsts/algorithm/PointLocator.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * Computes the topological ({@link Location}) of a single point to a
 * {@link Geometry}. A {@link BoundaryNodeRule} may be specified to control the
 * evaluation of whether the point lies on the boundary or not The default rule
 * is to use the the <i>SFS Boundary Determination Rule</i>
 * <p>
 * Notes:
 * <ul>
 * <li>{@link LinearRing}s do not enclose any area - points inside the ring
 * are still in the EXTERIOR of the ring.
 * </ul>
 * Instances of this class are not reentrant.
 *
 * @constructor
 */
jsts.algorithm.PointLocator = function(boundaryRule) {
  this.boundaryRule = boundaryRule ? boundaryRule
      : jsts.algorithm.BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;
};


/**
 * default is to use OGC SFS rule
 *
 * @type {BoundaryNodeRule}
 * @private
 */
jsts.algorithm.PointLocator.prototype.boundaryRule = null;


/**
 * true if the point lies in or on any Geometry element
 *
 * @type {boolean}
 * @private
 */
jsts.algorithm.PointLocator.prototype.isIn = null;


/**
 * the number of sub-elements whose boundaries the point lies in
 *
 * @type {int}
 * @private
 */
jsts.algorithm.PointLocator.prototype.numBoundaries = null;


/**
 * Convenience method to test a point for intersection with a Geometry
 *
 * @param {Coordinate}
 *          p the coordinate to test.
 * @param {Geometry}
 *          geom the Geometry to test.
 * @return {boolean} <code>true</code> if the point is in the interior or
 *         boundary of the Geometry.
 */
jsts.algorithm.PointLocator.prototype.intersects = function(p, geom) {
  return this.locate(p, geom) !== jsts.geom.Location.EXTERIOR;
};


/**
 * Computes the topological relationship ({@link Location}) of a single point
 * to a Geometry. It handles both single-element and multi-element Geometries.
 * The algorithm for multi-part Geometries takes into account the SFS Boundary
 * Determination Rule.
 *
 * @param {Coordinate}
 *          p the coordinate to test.
 * @param {Geometry}
 *          geom the Geometry to test.
 * @return {int} the {@link Location} of the point relative to the input
 *         Geometry.
 */
jsts.algorithm.PointLocator.prototype.locate = function(p, geom) {
  if (geom.isEmpty())
    return jsts.geom.Location.EXTERIOR;

  if (geom instanceof jsts.geom.Point) {
    return this.locate2(p, geom);
  } else if (geom instanceof jsts.geom.LineString) {
    return this.locate3(p, geom);
  } else if (geom instanceof jsts.geom.Polygon) {
    return this.locate4(p, geom);
  }

  this.isIn = false;
  this.numBoundaries = 0;
  this.computeLocation(p, geom);
  if (this.boundaryRule.isInBoundary(this.numBoundaries))
    return jsts.geom.Location.BOUNDARY;
  if (this.numBoundaries > 0 || this.isIn)
    return jsts.geom.Location.INTERIOR;

  return jsts.geom.Location.EXTERIOR;
};


/**
 * @param {Coordinate}
 *          p the coordinate to test.
 * @param {Geometry}
 *          geom the Geometry to test.
 * @private
 */
jsts.algorithm.PointLocator.prototype.computeLocation = function(p, geom) {
  if (geom instanceof jsts.geom.Point || geom instanceof jsts.geom.LineString ||
      geom instanceof jsts.geom.Polygon) {
    this.updateLocationInfo(this.locate(p, geom));
  } else if (geom instanceof jsts.geom.MultiLineString) {
    var ml = geom;
    for (var i = 0; i < ml.getNumGeometries(); i++) {
      var l = ml.getGeometryN(i);
      this.updateLocationInfo(this.locate(p, l));
    }
  } else if (geom instanceof jsts.geom.MultiPolygon) {
    var mpoly = geom;
    for (var i = 0; i < mpoly.getNumGeometries(); i++) {
      var poly = mpoly.getGeometryN(i);
      this.updateLocationInfo(this.locate(p, poly));
    }
  } else if (geom instanceof jsts.geom.MultiPoint || geom instanceof jsts.geom.GeometryCollection) {
    for (var i = 0; i < geom.getNumGeometries(); i++) {
      var part = geom.getGeometryN(i);
      if (part !== geom) {
        this.computeLocation(p, part);
      }
    }
  }
};


/**
 * @param {int}
 *          loc
 * @return {int}
 * @private
 */
jsts.algorithm.PointLocator.prototype.updateLocationInfo = function(loc) {
  if (loc === jsts.geom.Location.INTERIOR)
    this.isIn = true;
  if (loc === jsts.geom.Location.BOUNDARY)
    this.numBoundaries++;
};


/**
 * @param {Coordinate}
 *          p the coordinate to test.
 * @param {Point}
 *          pt the Point to test.
 * @return {int}
 * @private
 */
jsts.algorithm.PointLocator.prototype.locate2 = function(p, pt) {
  // no point in doing envelope test, since equality test is just as fast

  var ptCoord = pt.getCoordinate();
  if (ptCoord.equals2D(p))
    return jsts.geom.Location.INTERIOR;
  return jsts.geom.Location.EXTERIOR;
};


/**
 * @param {Coordinate}
 *          p the coordinate to test.
 * @param {LineString}
 *          l the LineString to test.
 * @return {int}
 * @private
 */
jsts.algorithm.PointLocator.prototype.locate3 = function(p, l) {
  // bounding-box check
  if (!l.getEnvelopeInternal().intersects(p))
    return jsts.geom.Location.EXTERIOR;

  var pt = l.getCoordinates();
  if (!l.isClosed()) {
    if (p.equals(pt[0]) || p.equals(pt[pt.length - 1])) {
      return jsts.geom.Location.BOUNDARY;
    }
  }
  if (jsts.algorithm.CGAlgorithms.isOnLine(p, pt))
    return jsts.geom.Location.INTERIOR;
  return jsts.geom.Location.EXTERIOR;
};


/**
 * @param {Coordinate}
 *          p the coordinate to test.
 * @param {LinearRing}
 *          ring the LinearRing to test.
 * @return {int}
 * @private
 */
jsts.algorithm.PointLocator.prototype.locateInPolygonRing = function(p, ring) {
  // bounding-box check
  if (!ring.getEnvelopeInternal().intersects(p))
    return jsts.geom.Location.EXTERIOR;

  return jsts.algorithm.CGAlgorithms
      .locatePointInRing(p, ring.getCoordinates());
};


/**
 * @param {Coordinate}
 *          p the coordinate to test.
 * @param {Polygon}
 *          poly the LinearRing to test.
 * @return {int}
 * @private
 */
jsts.algorithm.PointLocator.prototype.locate4 = function(p, poly) {
  if (poly.isEmpty())
    return jsts.geom.Location.EXTERIOR;

  var shell = poly.getExteriorRing();

  var shellLoc = this.locateInPolygonRing(p, shell);
  if (shellLoc === jsts.geom.Location.EXTERIOR)
    return jsts.geom.Location.EXTERIOR;
  if (shellLoc === jsts.geom.Location.BOUNDARY)
    return jsts.geom.Location.BOUNDARY;
  // now test if the point lies in or on the holes
  for (var i = 0; i < poly.getNumInteriorRing(); i++) {
    var hole = poly.getInteriorRingN(i);
    var holeLoc = this.locateInPolygonRing(p, hole);
    if (holeLoc === jsts.geom.Location.INTERIOR)
      return jsts.geom.Location.EXTERIOR;
    if (holeLoc === jsts.geom.Location.BOUNDARY)
      return jsts.geom.Location.BOUNDARY;
  }
  return jsts.geom.Location.INTERIOR;
};
/* ======================================================================
    jsts/geomgraph/NodeMap.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * @requires jsts/geom/Location.js
   */

  var Location = jsts.geom.Location;
  var ArrayList = javascript.util.ArrayList;
  var TreeMap = javascript.util.TreeMap;

  /**
   * A map of nodes, indexed by the coordinate of the node.
   *
   * @constructor
   */
  jsts.geomgraph.NodeMap = function(nodeFactory) {
    this.nodeMap = new TreeMap();
    this.nodeFact = nodeFactory;
  };


  /**
   * NOTE: Seems like the index isn't functionally important, so in JSTS a JS
   * object replaces TreeMap. Sorting is done when needed.
   *
   * @type {javascript.util.HashMap}
   */
  jsts.geomgraph.NodeMap.prototype.nodeMap = null;

  jsts.geomgraph.NodeMap.prototype.nodeFact = null;


  /**
   * This method expects that a node has a coordinate value.
   *
   * In JSTS this replaces multiple overloaded methods from JTS.
   *
   * @param {jsts.geom.Coordinate/jsts.geomgraph.Node}
   *          arg
   * @return {jsts.geomgraph.Node}
   */
  jsts.geomgraph.NodeMap.prototype.addNode = function(arg) {
    var node, coord;

    if (arg instanceof jsts.geom.Coordinate) {
      coord = arg;
      node = this.nodeMap.get(coord);
      if (node === null) {
        node = this.nodeFact.createNode(coord);
        this.nodeMap.put(coord, node);
      }
      return node;
    } else if (arg instanceof jsts.geomgraph.Node) {
      var n = arg;
      coord = n.getCoordinate();
      node = this.nodeMap.get(coord);
      if (node === null) {
        this.nodeMap.put(coord, n);
        return n;
      }
      node.mergeLabel(n);
      return node;
    }
  };


  /**
   * Adds a node for the start point of this EdgeEnd (if one does not already
   * exist in this map). Adds the EdgeEnd to the (possibly new) node.
   *
   * @param {jsts.geomgraph.EdgeEnd}
   *          e
   */
  jsts.geomgraph.NodeMap.prototype.add = function(e) {
    var p = e.getCoordinate();
    var n = this.addNode(p);
    n.add(e);
  };


  /**
   * @param {jsts.geom.Coordinate}
   *          coord
   * @return {jsts.geomgraph.Node} the node if found; null otherwise.
   */
  jsts.geomgraph.NodeMap.prototype.find = function(coord) {
    return this.nodeMap.get(coord);
  };


  /**
   * @return {javascript.util.Collection}
   */
  jsts.geomgraph.NodeMap.prototype.values = function() {
    return this.nodeMap.values();
  };

  /**
   * @return {javascript.util.Collection}
   */
  jsts.geomgraph.NodeMap.prototype.iterator = function() {
    return this.values().iterator();
  };


  /**
   * @param {number}
   *          geomIndex
   * @return {Array.<Node>}
   */
  jsts.geomgraph.NodeMap.prototype.getBoundaryNodes = function(geomIndex) {
    var bdyNodes = new ArrayList();
    for (var i = this.iterator(); i.hasNext();) {
      var node = i.next();
      if (node.getLabel().getLocation(geomIndex) === Location.BOUNDARY) {
        bdyNodes.add(node);
      }
    }
    return bdyNodes;
  };

})();
/* ======================================================================
    jsts/geomgraph/PlanarGraph.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @requires jsts/geomgraph/NodeMap.js
 * @requires jsts/geomgraph/NodeFactory.js
 */

(function() {

  var ArrayList = javascript.util.ArrayList;

  /**
   * The computation of the <code>IntersectionMatrix</code> relies on the use
   * of a structure called a "topology graph". The topology graph contains nodes
   * and edges corresponding to the nodes and line segments of a
   * <code>Geometry</code>. Each node and edge in the graph is labeled with
   * its topological location relative to the source geometry.
   * <P>
   * Note that there is no requirement that points of self-intersection be a
   * vertex. Thus to obtain a correct topology graph, <code>Geometry</code>s
   * must be self-noded before constructing their graphs.
   * <P>
   * Two fundamental operations are supported by topology graphs:
   * <UL>
   * <LI>Computing the intersections between all the edges and nodes of a
   * single graph
   * <LI>Computing the intersections between the edges and nodes of two
   * different graphs
   * </UL>
   *
   * @constructor
   */
  jsts.geomgraph.PlanarGraph = function(nodeFactory) {
    this.edges = new ArrayList();
    this.edgeEndList = new ArrayList();
    this.nodes = new jsts.geomgraph.NodeMap(nodeFactory ||
        new jsts.geomgraph.NodeFactory());
  };


  /**
   * @type {javascript.util.ArrayList}
   * @protected
   */
  jsts.geomgraph.PlanarGraph.prototype.edges = null;


  /**
   * @type {jsts.geomgraph.NodeMap}
   * @protected
   */
  jsts.geomgraph.PlanarGraph.prototype.nodes = null;
  /**
   * @type {javascript.util.ArrayList}
   * @protected
   */
  jsts.geomgraph.PlanarGraph.prototype.edgeEndList = null;

  /**
   * For nodes in the Collection, link the DirectedEdges at the node that are in
   * the result. This allows clients to link only a subset of nodes in the
   * graph, for efficiency (because they know that only a subset is of
   * interest).
   */
  jsts.geomgraph.PlanarGraph.linkResultDirectedEdges = function(nodes) {
    for (var nodeit = nodes.iterator(); nodeit.hasNext();) {
      var node = nodeit.next();
      node.getEdges().linkResultDirectedEdges();
    }
  };


  jsts.geomgraph.PlanarGraph.prototype.getEdgeIterator = function() {
    return this.edges.iterator();
  };
  jsts.geomgraph.PlanarGraph.prototype.getEdgeEnds = function() {
    return this.edgeEndList;
  };

  jsts.geomgraph.PlanarGraph.prototype.isBoundaryNode = function(geomIndex,
      coord) {
    var node = this.nodes.find(coord);
    if (node === null)
      return false;
    var label = node.getLabel();
    if (label !== null &&
        label.getLocation(geomIndex) === jsts.geom.Location.BOUNDARY)
      return true;
    return false;
  };

  jsts.geomgraph.PlanarGraph.prototype.insertEdge = function(e) {
    this.edges.add(e);
  };

  jsts.geomgraph.PlanarGraph.prototype.add = function(e) {
    this.nodes.add(e);
    this.edgeEndList.add(e);
  };

  /**
   * @return {javascript.util.Iterator}
   */
  jsts.geomgraph.PlanarGraph.prototype.getNodeIterator = function() {
    return this.nodes.iterator();
  };

  /**
   * @return {javascript.util.Collection}
   */
  jsts.geomgraph.PlanarGraph.prototype.getNodes = function() {
    return this.nodes.values();
  };

  jsts.geomgraph.PlanarGraph.prototype.addNode = function(node) {
    return this.nodes.addNode(node);
  };

  /**
   * Add a set of edges to the graph. For each edge two DirectedEdges will be
   * created. DirectedEdges are NOT linked by this method.
   *
   * @param {javascript.util.List}
   *          edgedToAdd
   */
  jsts.geomgraph.PlanarGraph.prototype.addEdges = function(edgesToAdd) {
    // create all the nodes for the edges
    for (var it = edgesToAdd.iterator(); it.hasNext();) {
      var e = it.next();
      this.edges.add(e);

      var de1 = new jsts.geomgraph.DirectedEdge(e, true);
      var de2 = new jsts.geomgraph.DirectedEdge(e, false);
      de1.setSym(de2);
      de2.setSym(de1);

      this.add(de1);
      this.add(de2);
    }
  };

  jsts.geomgraph.PlanarGraph.prototype.linkResultDirectedEdges = function() {
    for (var nodeit = this.nodes.iterator(); nodeit.hasNext();) {
      var node = nodeit.next();
      node.getEdges().linkResultDirectedEdges();
    }
  };

  /**
   * Returns the edge which starts at p0 and whose first segment is parallel to
   * p1
   *
   * @return the edge, if found <code>null</code> if the edge was not found.
   */
  jsts.geomgraph.PlanarGraph.prototype.findEdgeInSameDirection = function(p0,
      p1) {
    var i = 0, il = this.edges.size(), e, eCoord;
    for (i; i < il; i++) {
      e = this.edges.get(i);
      eCoord = e.getCoordinates();

      if (this.matchInSameDirection(p0, p1, eCoord[0], eCoord[1])) {
        return e;
      }

      if (this.matchInSameDirection(p0, p1, eCoord[eCoord.length - 1],
          eCoord[eCoord.length - 2])) {
        return e;
      }
    }
    return null;
  };

  /**
   * The coordinate pairs match if they define line segments lying in the same
   * direction. E.g. the segments are parallel and in the same quadrant (as
   * opposed to parallel and opposite!).
   */
  jsts.geomgraph.PlanarGraph.prototype.matchInSameDirection = function(p0, p1,
      ep0, ep1) {
    if (!p0.equals(ep0)) {
      return false;
    }

    if (jsts.algorithm.CGAlgorithms.computeOrientation(p0, p1, ep1) === jsts.algorithm.CGAlgorithms.COLLINEAR &&
        jsts.geomgraph.Quadrant.quadrant(p0, p1) === jsts.geomgraph.Quadrant
            .quadrant(ep0, ep1)) {
      return true;
    }
    return false;
  };

  /**
   * Returns the EdgeEnd which has edge e as its base edge (MD 18 Feb 2002 -
   * this should return a pair of edges)
   *
   * @return the edge, if found <code>null</code> if the edge was not found.
   */
  jsts.geomgraph.PlanarGraph.prototype.findEdgeEnd = function(e) {
    for (var i = this.getEdgeEnds().iterator(); i.hasNext();) {
      var ee = i.next();
      if (ee.getEdge() === e) {
        return ee;
      }
    }
    return null;
  };
})();

// TODO: port rest of class
/* ======================================================================
    jsts/noding/SegmentIntersector.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Processes possible intersections detected by a {@link Noder}. The
 * {@link SegmentIntersector} is passed to a {@link Noder}. The
 * {@link addIntersections} method is called whenever the {@link Noder} detects
 * that two SegmentStrings <i>might</i> intersect. This class may be used
 * either to find all intersections, or to detect the presence of an
 * intersection. In the latter case, Noders may choose to short-circuit their
 * computation by calling the {@link isDone} method. This class is an example of
 * the <i>Strategy</i> pattern.
 *
 * @interface
 */
jsts.noding.SegmentIntersector = function() {

};

/**
 * This method is called by clients of the {@link SegmentIntersector} interface
 * to process intersections for two segments of the {@link SegmentString}s
 * being intersected.
 *
 * @param {SegmentString}
 *          e0
 * @param {number}
 *          segIndex0
 * @param {SegmentString}
 *          e1
 * @param {number}
 *          segIndex0
 */
jsts.noding.SegmentIntersector.prototype.processIntersections = jsts.abstractFunc;

/**
 * Reports whether the client of this class needs to continue testing all
 * intersections in an arrangement.
 *
 * @return {boolean} true if there is no need to continue testing segments.
 */
jsts.noding.SegmentIntersector.prototype.isDone = jsts.abstractFunc;
/* ======================================================================
    jsts/noding/InteriorIntersectionFinder.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * @requires jsts/noding/SegmentIntersector.js
   */

  var SegmentIntersector = jsts.noding.SegmentIntersector;
  var ArrayList = javascript.util.ArrayList;

  /**
   * Finds an interior intersection in a set of {@link SegmentString}s, if one
   * exists. Only the first intersection found is reported.
   *
   * Creates an intersection finder which finds an interior intersection if one
   * exists
   *
   * @param li
   *          the LineIntersector to use.
   * @constructor
   */
  jsts.noding.InteriorIntersectionFinder = function(li) {
    this.li = li;
    this.intersections = new ArrayList();
    this.interiorIntersection = null;
  };

  jsts.noding.InteriorIntersectionFinder.prototype = new SegmentIntersector();
  jsts.noding.InteriorIntersectionFinder.constructor = jsts.noding.InteriorIntersectionFinder;

  jsts.noding.InteriorIntersectionFinder.prototype.findAllIntersections = false;
  jsts.noding.InteriorIntersectionFinder.prototype.isCheckEndSegmentsOnly = false;
  jsts.noding.InteriorIntersectionFinder.prototype.li = null;
  jsts.noding.InteriorIntersectionFinder.prototype.interiorIntersection = null;
  jsts.noding.InteriorIntersectionFinder.prototype.intSegments = null;
  jsts.noding.InteriorIntersectionFinder.prototype.intersections = null;


  jsts.noding.InteriorIntersectionFinder.prototype.setFindAllIntersections = function(
      findAllIntersections) {
    this.findAllIntersections = findAllIntersections;
  };

  jsts.noding.InteriorIntersectionFinder.prototype.getIntersections = function() {
    return intersections;
  };

  /**
   * Sets whether only end segments should be tested for interior intersection.
   * This is a performance optimization that may be used if the segments have
   * been previously noded by an appropriate algorithm. It may be known that any
   * potential noding failures will occur only in end segments.
   *
   * @param isCheckEndSegmentsOnly
   *          whether to test only end segments.
   */
  jsts.noding.InteriorIntersectionFinder.prototype.setCheckEndSegmentsOnly = function(
      isCheckEndSegmentsOnly) {
    this.isCheckEndSegmentsOnly = isCheckEndSegmentsOnly;
  }

  /**
   * Tests whether an intersection was found.
   *
   * @return true if an intersection was found.
   */
  jsts.noding.InteriorIntersectionFinder.prototype.hasIntersection = function() {
    return this.interiorIntersection != null;
  };

  /**
   * Gets the computed location of the intersection. Due to round-off, the
   * location may not be exact.
   *
   * @return the coordinate for the intersection location.
   */
  jsts.noding.InteriorIntersectionFinder.prototype.getInteriorIntersection = function() {
    return this.interiorIntersection;
  };

  /**
   * Gets the endpoints of the intersecting segments.
   *
   * @return an array of the segment endpoints (p00, p01, p10, p11).
   */
  jsts.noding.InteriorIntersectionFinder.prototype.getIntersectionSegments = function() {
    return this.intSegments;
  };

  /**
   * This method is called by clients of the {@link SegmentIntersector} class to
   * process intersections for two segments of the {@link SegmentString}s being
   * intersected. Note that some clients (such as {@link MonotoneChain}s) may
   * optimize away this call for segment pairs which they have determined do not
   * intersect (e.g. by an disjoint envelope test).
   */
  jsts.noding.InteriorIntersectionFinder.prototype.processIntersections = function(
      e0, segIndex0, e1, segIndex1) {
    // short-circuit if intersection already found
    if (this.hasIntersection())
      return;

    // don't bother intersecting a segment with itself
    if (e0 == e1 && segIndex0 == segIndex1)
      return;

    /**
     * If enabled, only test end segments (on either segString).
     *
     */
    if (this.isCheckEndSegmentsOnly) {
      var isEndSegPresent = this.isEndSegment(e0, segIndex0) ||
          isEndSegment(e1, segIndex1);
      if (!isEndSegPresent)
        return;
    }

    var p00 = e0.getCoordinates()[segIndex0];
    var p01 = e0.getCoordinates()[segIndex0 + 1];
    var p10 = e1.getCoordinates()[segIndex1];
    var p11 = e1.getCoordinates()[segIndex1 + 1];

    this.li.computeIntersection(p00, p01, p10, p11);
    // if (li.hasIntersection() && li.isProper()) Debug.println(li);

    if (this.li.hasIntersection()) {
      if (this.li.isInteriorIntersection()) {
        this.intSegments = [];
        this.intSegments[0] = p00;
        this.intSegments[1] = p01;
        this.intSegments[2] = p10;
        this.intSegments[3] = p11;

        this.interiorIntersection = this.li.getIntersection(0);
        this.intersections.add(this.interiorIntersection);
      }
    }
  };

  /**
   * Tests whether a segment in a {@link SegmentString} is an end segment.
   * (either the first or last).
   *
   * @param segStr
   *          a segment string.
   * @param index
   *          the index of a segment in the segment string.
   * @return true if the segment is an end segment.
   * @private
   */
  jsts.noding.InteriorIntersectionFinder.prototype.isEndSegment = function(
      segStr, index) {
    if (index == 0)
      return true;
    if (index >= segStr.size() - 2)
      return true;
    return false;
  };

  jsts.noding.InteriorIntersectionFinder.prototype.isDone = function() {
    if (this.findAllIntersections)
      return false;
    return this.interiorIntersection != null;
  };

})();
/* ======================================================================
    jsts/noding/FastNodingValidator.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * @requires jsts/algorithm/RobustLineIntersector.js
   * @requires jsts/noding/InteriorIntersectionFinder.js
   * @requires jsts/noding/MCIndexNoder.js
   */

  var RobustLineIntersector = jsts.algorithm.RobustLineIntersector;
  var InteriorIntersectionFinder = jsts.noding.InteriorIntersectionFinder;
  var MCIndexNoder = jsts.noding.MCIndexNoder;

  /**
   * Validates that a collection of {@link SegmentString}s is correctly noded.
   * Indexing is used to improve performance. In the most common use case,
   * validation stops after a single non-noded intersection is detected. Does
   * NOT check a-b-a collapse situations. Also does not check for
   * endpoint-interior vertex intersections. This should not be a problem, since
   * the noders should be able to compute intersections between vertices
   * correctly.
   * <p>
   * The client may either test the {@link #isValid} condition, or request that
   * a suitable {@link TopologyException} be thrown.
   *
   * Creates a new noding validator for a given set of linework.
   *
   * @param segStrings
   *          a collection of {@link SegmentString} s.
   */
  jsts.noding.FastNodingValidator = function(segStrings) {
    this.li = new RobustLineIntersector();

    this.segStrings = segStrings;
  };

  jsts.noding.FastNodingValidator.prototype.li = null;

  jsts.noding.FastNodingValidator.prototype.segStrings = null;
  jsts.noding.FastNodingValidator.prototype.findAllIntersections = false;
  jsts.noding.FastNodingValidator.prototype.segInt = null;
  jsts.noding.FastNodingValidator.prototype._isValid = true;

  jsts.noding.FastNodingValidator.prototype.setFindAllIntersections = function(
      findAllIntersections) {
    this.findAllIntersections = findAllIntersections;
  };

  jsts.noding.FastNodingValidator.prototype.getIntersections = function() {
    return segInt.getIntersections();
  };

  /**
   * Checks for an intersection and reports if one is found.
   *
   * @return true if the arrangement contains an interior intersection.
   */
  jsts.noding.FastNodingValidator.prototype.isValid = function() {
    this.execute();
    return this._isValid;
  };

  /**
   * Returns an error message indicating the segments containing the
   * intersection.
   *
   * @return an error message documenting the intersection location.
   */
  jsts.noding.FastNodingValidator.prototype.getErrorMessage = function() {
    if (this._isValid)
      return 'no intersections found';

    var intSegs = this.segInt.getIntersectionSegments();
    return 'found non-noded intersection between ' +
        jsts.io.WKTWriter.toLineString(intSegs[0], intSegs[1]) + ' and ' +
        jsts.io.WKTWriter.toLineString(intSegs[2], intSegs[3]);
  };

  /**
   * Checks for an intersection and throws a TopologyException if one is found.
   *
   * @throws TopologyException
   *           if an intersection is found
   */
  jsts.noding.FastNodingValidator.prototype.checkValid = function() {
    this.execute();
    if (!this._isValid)
      throw new jsts.error.TopologyError(this.getErrorMessage(), this.segInt
          .getInteriorIntersection());
  };

  /**
   * @private
   */
  jsts.noding.FastNodingValidator.prototype.execute = function() {
    if (this.segInt != null)
      return;
    this.checkInteriorIntersections();
  };

  /**
   * @private
   */
  jsts.noding.FastNodingValidator.prototype.checkInteriorIntersections = function() {
    /**
     * MD - It may even be reliable to simply check whether end segments (of
     * SegmentStrings) have an interior intersection, since noding should have
     * split any true interior intersections already.
     */
    this._isValid = true;
    this.segInt = new InteriorIntersectionFinder(this.li);
    this.segInt.setFindAllIntersections(this.findAllIntersections);
    var noder = new MCIndexNoder();
    noder.setSegmentIntersector(this.segInt);
    noder.computeNodes(this.segStrings);
    if (this.segInt.hasIntersection()) {
      this._isValid = false;
      return;
    }
  };

})();
/* ======================================================================
    jsts/noding/BasicSegmentString.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * Represents a list of contiguous line segments, and supports noding the
   * segments. The line segments are represented by an array of
   * {@link Coordinate}s. Intended to optimize the noding of contiguous
   * segments by reducing the number of allocated objects. SegmentStrings can
   * carry a context object, which is useful for preserving topological or
   * parentage information. All noded substrings are initialized with the same
   * context object.
   *
   * Creates a new segment string from a list of vertices.
   *
   * @param pts
   *          the vertices of the segment string.
   * @param data
   *          the user-defined data of this segment string (may be null).
   * @constructor
   */
  jsts.noding.BasicSegmentString = function(pts, data) {
    this.pts = pts;
    this.data = data;
  };
  jsts.noding.BasicSegmentString.prototype = new jsts.noding.SegmentString();


  jsts.noding.BasicSegmentString.prototype.pts = null;
  jsts.noding.BasicSegmentString.prototype.data = null;


  /**
   * Gets the user-defined data for this segment string.
   *
   * @return the user-defined data.
   */
  jsts.noding.BasicSegmentString.prototype.getData = function() {
    return this.data;
  }

  /**
   * Sets the user-defined data for this segment string.
   *
   * @param data
   *          an Object containing user-defined data.
   */
  jsts.noding.BasicSegmentString.prototype.setData = function(data) {
    this.data = data;
  };

  jsts.noding.BasicSegmentString.prototype.size = function() {
    return this.pts.length;
  };

  jsts.noding.BasicSegmentString.prototype.getCoordinate = function(i) {
    return this.pts[i];
  };

  jsts.noding.BasicSegmentString.prototype.getCoordinates = function() {
    return this.pts;
  };

  jsts.noding.BasicSegmentString.prototype.isClosed = function() {
    return this.pts[0].equals(this.pts[this.pts.length - 1]);
  };

  /**
   * Gets the octant of the segment starting at vertex <code>index</code>.
   *
   * @param index
   *          the index of the vertex starting the segment. Must not be the last
   *          index in the vertex list.
   * @return the octant of the segment at the vertex.
   */
  jsts.noding.BasicSegmentString.prototype.getSegmentOctant = function(index) {
    if (index == this.pts.length - 1)
      return -1;
    return jsts.noding.Octant.octant(this.getCoordinate(index), this
        .getCoordinate(index + 1));
  };

})();
/* ======================================================================
    jsts/geomgraph/EdgeNodingValidator.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * @requires jsts/noding/FastNodingValidator.js
   * @requires jsts/noding/BasicSegmentString.js
   */

  var FastNodingValidator = jsts.noding.FastNodingValidator;
  var BasicSegmentString = jsts.noding.BasicSegmentString;
  var ArrayList = javascript.util.ArrayList;

  /**
   * Validates that a collection of {@link Edge}s is correctly noded. Throws an
   * appropriate exception if an noding error is found.
   *
   * Creates a new validator for the given collection of {@link Edge}s.
   *
   * @param edges
   *          a collection of Edges.
   */
  jsts.geomgraph.EdgeNodingValidator = function(edges) {
    this.nv = new FastNodingValidator(jsts.geomgraph.EdgeNodingValidator
        .toSegmentStrings(edges));
  };

  /**
   * Checks whether the supplied {@link Edge}s are correctly noded. Throws a
   * {@link TopologyException} if they are not.
   *
   * @param edges
   *          a collection of Edges.
   * @throws TopologyException
   *           if the SegmentStrings are not correctly noded
   *
   */
  jsts.geomgraph.EdgeNodingValidator.checkValid = function(edges) {
    var validator = new jsts.geomgraph.EdgeNodingValidator(edges);
    validator.checkValid();
  };

  jsts.geomgraph.EdgeNodingValidator.toSegmentStrings = function(edges) {
    // convert Edges to SegmentStrings
    var segStrings = new ArrayList();
    for (var i = edges.iterator(); i.hasNext();) {
      var e = i.next();
      segStrings.add(new BasicSegmentString(e.getCoordinates(), e));
    }
    return segStrings;
  };

  /**
   * @type {jsts.noding.FastNodingValidator}
   * @private
   */
  jsts.geomgraph.EdgeNodingValidator.prototype.nv = null;


  /**
   * Checks whether the supplied edges are correctly noded. Throws an exception
   * if they are not.
   *
   * @throws TopologyException
   *           if the SegmentStrings are not correctly noded
   *
   */
  jsts.geomgraph.EdgeNodingValidator.prototype.checkValid = function() {
    this.nv.checkValid();
  };

})();
/* ======================================================================
    jsts/operation/GeometryGraphOperation.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * The base class for operations that require {@link GeometryGraph}s.
 *
 * @param {Geometry}
 *          g0
 * @param {Geometry}
 *          g1
 * @param {BoundaryNodeRule}
 *          boundaryNodeRule
 * @constructor
 */
jsts.operation.GeometryGraphOperation = function(g0, g1, boundaryNodeRule) {
  this.li = new jsts.algorithm.RobustLineIntersector();
  this.arg = [];

  if (g0 === undefined) {
    return;
  }

  if (g1 === undefined) {
    this.setComputationPrecision(g0.getPrecisionModel());

    this.arg[0] = new jsts.geomgraph.GeometryGraph(0, g0);
    return;
  }

  boundaryNodeRule = boundaryNodeRule ||
      jsts.algorithm.BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;

  // use the most precise model for the result
  if (g0.getPrecisionModel().compareTo(g1.getPrecisionModel()) >= 0)
    this.setComputationPrecision(g0.getPrecisionModel());
  else
    this.setComputationPrecision(g1.getPrecisionModel());

  this.arg[0] = new jsts.geomgraph.GeometryGraph(0, g0, boundaryNodeRule);
  this.arg[1] = new jsts.geomgraph.GeometryGraph(1, g1, boundaryNodeRule);
};


/**
 * @type {LineIntersector}
 * @protected
 */
jsts.operation.GeometryGraphOperation.prototype.li = null;


/**
 * @type {PrecisionModel}
 * @protected
 */
jsts.operation.GeometryGraphOperation.prototype.resultPrecisionModel = null;


/**
 * The operation args into an array so they can be accessed by index
 *
 * @type {GeometryGraph[]}
 * @protected
 */
jsts.operation.GeometryGraphOperation.prototype.arg = null;


/**
 * @param {int}
 *          i
 * @return {Geometry}
 */
jsts.operation.GeometryGraphOperation.prototype.getArgGeometry = function(i) {
  return arg[i].getGeometry();
};


/**
 * @param {PrecisionModel}
 *          pm
 * @protected
 */
jsts.operation.GeometryGraphOperation.prototype.setComputationPrecision = function(pm) {
  this.resultPrecisionModel = pm;
  this.li.setPrecisionModel(this.resultPrecisionModel);
};
/* ======================================================================
    jsts/operation/overlay/OverlayNodeFactory.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @requires jsts/geomgraph/NodeFactory.js
 */

/**
 * Creates nodes for use in the {@link PlanarGraph}s constructed during overlay
 * operations.
 *
 * @constructor
 * @extends jsts.geomgraph.NodeFactory
 */
jsts.operation.overlay.OverlayNodeFactory = function() {

};
jsts.operation.overlay.OverlayNodeFactory.prototype = new jsts.geomgraph.NodeFactory();
jsts.operation.overlay.OverlayNodeFactory.constructor = jsts.operation.overlay.OverlayNodeFactory;

jsts.operation.overlay.OverlayNodeFactory.prototype.createNode = function(coord) {
  return new jsts.geomgraph.Node(coord, new jsts.geomgraph.DirectedEdgeStar());
};
/* ======================================================================
    jsts/operation/overlay/PolygonBuilder.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Forms {@link Polygon}s out of a graph of {@link DirectedEdge}s. The edges
 * to use are marked as being in the result Area.
 * <p>
 */
jsts.operation.overlay.PolygonBuilder = function(geometryFactory) {
  this.shellList = [];
  this.geometryFactory = geometryFactory;
};

/**
 * @private
 */
jsts.operation.overlay.PolygonBuilder.prototype.geometryFactory = null;

/**
 * @private
 */
jsts.operation.overlay.PolygonBuilder.prototype.shellList = null;


/**
 * Add a complete graph. The graph is assumed to contain one or more polygons,
 * possibly with holes.
 *
 * @param {jsts.geomgraph.PlanarGraph}
 *          graph
 */
jsts.operation.overlay.PolygonBuilder.prototype.add = function(graph) {
  if (arguments.length === 2) {
    this.add2.apply(this, arguments);
    return;
  }

  this.add2(graph.getEdgeEnds(), graph.getNodes());
};

/**
 * Add a set of edges and nodes, which form a graph. The graph is assumed to
 * contain one or more polygons, possibly with holes.
 */
jsts.operation.overlay.PolygonBuilder.prototype.add2 = function(dirEdges, nodes) {
  jsts.geomgraph.PlanarGraph.linkResultDirectedEdges(nodes);
  var maxEdgeRings = this.buildMaximalEdgeRings(dirEdges);
  var freeHoleList = [];
  var edgeRings = this.buildMinimalEdgeRings(maxEdgeRings, this.shellList,
      freeHoleList);
  this.sortShellsAndHoles(edgeRings, this.shellList, freeHoleList);
  this.placeFreeHoles(this.shellList, freeHoleList);
};

jsts.operation.overlay.PolygonBuilder.prototype.getPolygons = function() {
  var resultPolyList = this.computePolygons(this.shellList);
  return resultPolyList;
};


/**
 * for all DirectedEdges in result, form them into MaximalEdgeRings
 *
 * @private
 */
jsts.operation.overlay.PolygonBuilder.prototype.buildMaximalEdgeRings = function(
    dirEdges) {
  var maxEdgeRings = [];
  for (var it = dirEdges.iterator(); it.hasNext(); ) {
    var de = it.next();
    if (de.isInResult() && de.getLabel().isArea()) {
      // if this edge has not yet been processed
      if (de.getEdgeRing() == null) {
        var er = new jsts.operation.overlay.MaximalEdgeRing(de, this.geometryFactory);
        maxEdgeRings.push(er);
        er.setInResult();
        // System.out.println("max node degree = " + er.getMaxDegree());
      }
    }
  }
  return maxEdgeRings;
};

/**
 * @private
 */
jsts.operation.overlay.PolygonBuilder.prototype.buildMinimalEdgeRings = function(
    maxEdgeRings, shellList, freeHoleList) {
  var edgeRings = [];
  for (var i = 0; i < maxEdgeRings.length; i++) {
    var er = maxEdgeRings[i];
    if (er.getMaxNodeDegree() > 2) {
      er.linkDirectedEdgesForMinimalEdgeRings();
      var minEdgeRings = er.buildMinimalRings();
      // at this point we can go ahead and attempt to place holes, if this
      // EdgeRing is a polygon
      var shell = this.findShell(minEdgeRings);
      if (shell !== null) {
        this.placePolygonHoles(shell, minEdgeRings);
        shellList.push(shell);
      } else {
        minEdgeRings.forEach(function(ring) { freeHoleList.push(ring); });
      }
    } else {
      edgeRings.push(er);
    }
  }
  return edgeRings;
};

/**
 * This method takes a list of MinimalEdgeRings derived from a MaximalEdgeRing,
 * and tests whether they form a Polygon. This is the case if there is a single
 * shell in the list. In this case the shell is returned. The other possibility
 * is that they are a series of connected holes, in which case no shell is
 * returned.
 *
 * @return {EdgeRing} the shell EdgeRing, if there is one or null, if all the
 *         rings are holes.
 * @private
 */
jsts.operation.overlay.PolygonBuilder.prototype.findShell = function(
    minEdgeRings) {
  var shellCount = 0;
  var shell = null;
  for (var i = 0; i < minEdgeRings.length; i++) {
    var er = minEdgeRings[i];
    if (!er.isHole()) {
      shell = er;
      shellCount++;
    }
  }
  jsts.util.Assert.isTrue(shellCount <= 1, 'found two shells in MinimalEdgeRing list');
  return shell;
};
/**
 * This method assigns the holes for a Polygon (formed from a list of
 * MinimalEdgeRings) to its shell. Determining the holes for a MinimalEdgeRing
 * polygon serves two purposes:
 * <ul>
 * <li>it is faster than using a point-in-polygon check later on.
 * <li>it ensures correctness, since if the PIP test was used the point chosen
 * might lie on the shell, which might return an incorrect result from the PIP
 * test
 * </ul>
 *
 * @param {EdgeRing}
 *          shell
 * @param {Array}
 *          minEdgeRings
 * @private
 */
jsts.operation.overlay.PolygonBuilder.prototype.placePolygonHoles = function(
    shell, minEdgeRings) {
  for (var i = 0; i < minEdgeRings.length; i++) {
    var er = minEdgeRings[i];
    if (er.isHole()) {
      er.setShell(shell);
    }
  }
};
/**
 * For all rings in the input list, determine whether the ring is a shell or a
 * hole and add it to the appropriate list. Due to the way the DirectedEdges
 * were linked, a ring is a shell if it is oriented CW, a hole otherwise.
 *
 * @private
 */
jsts.operation.overlay.PolygonBuilder.prototype.sortShellsAndHoles = function(
    edgeRings, shellList, freeHoleList) {
  for (var i = 0; i < edgeRings.length; i++) {
    var er = edgeRings[i];
    if (er.isHole()) {
      freeHoleList.push(er);
    } else {
      shellList.push(er);
    }
  }
};
/**
 * This method determines finds a containing shell for all holes which have not
 * yet been assigned to a shell. These "free" holes should all be <b>properly</b>
 * contained in their parent shells, so it is safe to use the
 * <code>findEdgeRingContaining</code> method. (This is the case because any
 * holes which are NOT properly contained (i.e. are connected to their parent
 * shell) would have formed part of a MaximalEdgeRing and been handled in a
 * previous step).
 *
 * @throws TopologyException
 *           if a hole cannot be assigned to a shell
 * @private
 */
jsts.operation.overlay.PolygonBuilder.prototype.placeFreeHoles = function(
    shellList, freeHoleList) {
  for (var i = 0; i < freeHoleList.length; i++) {
    var hole = freeHoleList[i];
    // only place this hole if it doesn't yet have a shell
    if (hole.getShell() == null) {
      var shell = this.findEdgeRingContaining(hole, shellList);
      if (shell === null)
        throw new jsts.error.TopologyError('unable to assign hole to a shell',
            hole.getCoordinate(0));
      hole.setShell(shell);
    }
  }
};

/**
 * Find the innermost enclosing shell EdgeRing containing the argument EdgeRing,
 * if any. The innermost enclosing ring is the <i>smallest</i> enclosing ring.
 * The algorithm used depends on the fact that: <br>
 * ring A contains ring B iff envelope(ring A) contains envelope(ring B) <br>
 * This routine is only safe to use if the chosen point of the hole is known to
 * be properly contained in a shell (which is guaranteed to be the case if the
 * hole does not touch its shell)
 *
 * @return containing EdgeRing, if there is one.
 * @return null if no containing EdgeRing is found.
 * @private
 */
jsts.operation.overlay.PolygonBuilder.prototype.findEdgeRingContaining = function(
    testEr, shellList) {
  var testRing = testEr.getLinearRing();
  var testEnv = testRing.getEnvelopeInternal();
  var testPt = testRing.getCoordinateN(0);

  var minShell = null;
  var minEnv = null;
  for (var i = 0; i < shellList.length; i++) {
    var tryShell = shellList[i];
    var tryRing = tryShell.getLinearRing();
    var tryEnv = tryRing.getEnvelopeInternal();
    if (minShell !== null)
      minEnv = minShell.getLinearRing().getEnvelopeInternal();
    var isContained = false;
    if (tryEnv.contains(testEnv) &&
        jsts.algorithm.CGAlgorithms.isPointInRing(testPt, tryRing
            .getCoordinates()))
      isContained = true;
    // check if this new containing ring is smaller than the current minimum
    // ring
    if (isContained) {
      if (minShell == null || minEnv.contains(tryEnv)) {
        minShell = tryShell;
      }
    }
  }
  return minShell;
};

/**
 * @private
 */
jsts.operation.overlay.PolygonBuilder.prototype.computePolygons = function(
    shellList) {
  var resultPolyList = new javascript.util.ArrayList();
  // add Polygons for all shells
  for (var i = 0; i < shellList.length; i++) {
    var er = shellList[i];
    var poly = er.toPolygon(this.geometryFactory);
    resultPolyList.add(poly);
  }
  return resultPolyList;
};

/**
 * Checks the current set of shells (with their associated holes) to see if any
 * of them contain the point.
 *
 * @return {boolean}
 */
jsts.operation.overlay.PolygonBuilder.prototype.containsPoint = function(p) {
  for (var i = 0; i < this.shellList.length; i++) {
    var er = this.shellList[i];
    if (er.containsPoint(p))
      return true;
  }
  return false;
};
/* ======================================================================
    jsts/operation/overlay/LineBuilder.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * @requires jsts/util/Assert.js
   */

  var Assert = jsts.util.Assert;
  var ArrayList = javascript.util.ArrayList;


  /**
   * Forms JTS LineStrings out of a the graph of {@link DirectedEdge}s created
   * by an {@link OverlayOp}.
   */
  var LineBuilder = function(op, geometryFactory, ptLocator) {
    this.lineEdgesList = new ArrayList();
    this.resultLineList = new ArrayList();

    this.op = op;
    this.geometryFactory = geometryFactory;
    this.ptLocator = ptLocator;
  };

  LineBuilder.prototype.op = null;
  LineBuilder.prototype.geometryFactory = null;
  LineBuilder.prototype.ptLocator = null;

  LineBuilder.prototype.lineEdgesList = null;
  LineBuilder.prototype.resultLineList = null;

  /**
   * @return a list of the LineStrings in the result of the specified overlay
   *         operation.
   */
  LineBuilder.prototype.build = function(opCode) {
    this.findCoveredLineEdges();
    this.collectLines(opCode);
    this.buildLines(opCode);
    return this.resultLineList;
  };
  /**
   * Find and mark L edges which are "covered" by the result area (if any). L
   * edges at nodes which also have A edges can be checked by checking their
   * depth at that node. L edges at nodes which do not have A edges can be
   * checked by doing a point-in-polygon test with the previously computed
   * result areas.
   *
   * @private
   */
  LineBuilder.prototype.findCoveredLineEdges = function() {
    // first set covered for all L edges at nodes which have A edges too
    for (var nodeit = this.op.getGraph().getNodes().iterator(); nodeit
        .hasNext();) {
      var node = nodeit.next();
      node.getEdges().findCoveredLineEdges();
    }

    /**
     * For all L edges which weren't handled by the above, use a point-in-poly
     * test to determine whether they are covered
     */
    for (var it = this.op.getGraph().getEdgeEnds().iterator(); it.hasNext();) {
      var de = it.next();
      var e = de.getEdge();
      if (de.isLineEdge() && !e.isCoveredSet()) {
        var isCovered = this.op.isCoveredByA(de.getCoordinate());
        e.setCovered(isCovered);
      }
    }
  };

  /**
   * @private
   */
  LineBuilder.prototype.collectLines = function(opCode) {
    for (var it = this.op.getGraph().getEdgeEnds().iterator(); it.hasNext();) {
      var de = it.next();
      this.collectLineEdge(de, opCode, this.lineEdgesList);
      this.collectBoundaryTouchEdge(de, opCode, this.lineEdgesList);
    }
  };

  /**
   * Collect line edges which are in the result. Line edges are in the result if
   * they are not part of an area boundary, if they are in the result of the
   * overlay operation, and if they are not covered by a result area.
   *
   * @param de
   *          the directed edge to test.
   * @param opCode
   *          the overlap operation.
   * @param edges
   *          the list of included line edges.
   * @private
   */
  LineBuilder.prototype.collectLineEdge = function(de, opCode, edges) {
    var label = de.getLabel();
    var e = de.getEdge();
    // include L edges which are in the result
    if (de.isLineEdge()) {
      if (!de.isVisited() && jsts.operation.overlay.OverlayOp.isResultOfOp(label, opCode) &&
          !e.isCovered()) {

        edges.add(e);
        de.setVisitedEdge(true);
      }
    }
  };

  /**
   * Collect edges from Area inputs which should be in the result but which have
   * not been included in a result area. This happens ONLY:
   * <ul>
   * <li>during an intersection when the boundaries of two areas touch in a
   * line segment
   * <li> OR as a result of a dimensional collapse.
   * </ul>
   *
   * @private
   */
  LineBuilder.prototype.collectBoundaryTouchEdge = function(de, opCode, edges) {
    var label = de.getLabel();
    if (de.isLineEdge())
      return; // only interested in area edges
    if (de.isVisited())
      return; // already processed
    if (de.isInteriorAreaEdge())
      return; // added to handle dimensional collapses
    if (de.getEdge().isInResult())
      return; // if the edge linework is already included, don't include it
    // again

    // sanity check for labelling of result edgerings
    Assert.isTrue(!(de.isInResult() || de.getSym().isInResult()) ||
        !de.getEdge().isInResult());

    // include the linework if it's in the result of the operation
    if (jsts.operation.overlay.OverlayOp.isResultOfOp(label, opCode) &&
        opCode === jsts.operation.overlay.OverlayOp.INTERSECTION) {
      edges.add(de.getEdge());
      de.setVisitedEdge(true);
    }
  };

  /**
   * @private
   */
  LineBuilder.prototype.buildLines = function(opCode) {
    for (var it = this.lineEdgesList.iterator(); it.hasNext();) {
      var e = it.next();
      var label = e.getLabel();
      var line = this.geometryFactory.createLineString(e.getCoordinates());
      this.resultLineList.add(line);
      e.setInResult(true);
    }
  };

  /**
   * @private
   */
  LineBuilder.prototype.labelIsolatedLines = function(edgesList) {
    for (var it = edgesList.iterator(); it.hasNext();) {
      var e = it.next();
      var label = e.getLabel();
      // n.print(System.out);
      if (e.isIsolated()) {
        if (label.isNull(0))
          this.labelIsolatedLine(e, 0);
        else
          this.labelIsolatedLine(e, 1);
      }
    }
  };

  /**
   * Label an isolated node with its relationship to the target geometry.
   *
   * @private
   */
  LineBuilder.prototype.labelIsolatedLine = function(e, targetIndex) {
    var loc = ptLocator.locate(e.getCoordinate(), op
        .getArgGeometry(targetIndex));
    e.getLabel().setLocation(targetIndex, loc);
  };

  jsts.operation.overlay.LineBuilder = LineBuilder;

})();
/* ======================================================================
    jsts/operation/overlay/PointBuilder.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  var ArrayList = javascript.util.ArrayList;

  /**
   * Constructs {@link Point}s from the nodes of an overlay graph.
   */
  var PointBuilder = function(op, geometryFactory, ptLocator) {
    this.resultPointList = new ArrayList();

    this.op = op;
    this.geometryFactory = geometryFactory;
  };

  PointBuilder.prototype.op = null;
  PointBuilder.prototype.geometryFactory = null;

  PointBuilder.prototype.resultPointList = null;

  /**
   * Computes the Point geometries which will appear in the result, given the
   * specified overlay operation.
   *
   * @return a list of the Points objects in the result.
   */
  PointBuilder.prototype.build = function(opCode) {
    this.extractNonCoveredResultNodes(opCode);
    /**
     * It can happen that connected result nodes are still covered by result
     * geometries, so must perform this filter. (For instance, this can happen
     * during topology collapse).
     */
    return this.resultPointList;
  };

  /**
   * Determines nodes which are in the result, and creates {@link Point}s for
   * them.
   *
   * This method determines nodes which are candidates for the result via their
   * labelling and their graph topology.
   *
   * @param opCode
   *          the overlay operation.
   * @private
   */
  PointBuilder.prototype.extractNonCoveredResultNodes = function(opCode) {
    // testing only
    // if (true) return resultNodeList;

    for (var nodeit = this.op.getGraph().getNodes().iterator(); nodeit
        .hasNext();) {
      var n = nodeit.next();

      // filter out nodes which are known to be in the result
      if (n.isInResult())
        continue;
      // if an incident edge is in the result, then the node coordinate is
      // included already
      if (n.isIncidentEdgeInResult())
        continue;
      if (n.getEdges().getDegree() === 0 || opCode === jsts.operation.overlay.OverlayOp.INTERSECTION) {

        /**
         * For nodes on edges, only INTERSECTION can result in edge nodes being
         * included even if none of their incident edges are included
         */
        var label = n.getLabel();
        if (jsts.operation.overlay.OverlayOp.isResultOfOp(label, opCode)) {
          this.filterCoveredNodeToPoint(n);
        }
      }
    }
  };

  /**
   * Converts non-covered nodes to Point objects and adds them to the result.
   *
   * A node is covered if it is contained in another element Geometry with
   * higher dimension (e.g. a node point might be contained in a polygon, in
   * which case the point can be eliminated from the result).
   *
   * @param n
   *          the node to test.
   * @private
   */
  PointBuilder.prototype.filterCoveredNodeToPoint = function(n) {
    var coord = n.getCoordinate();
    if (!this.op.isCoveredByLA(coord)) {
      var pt = this.geometryFactory.createPoint(coord);
      this.resultPointList.add(pt);
    }
  };

  jsts.operation.overlay.PointBuilder = PointBuilder;

})();
/* ======================================================================
    jsts/operation/overlay/OverlayOp.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * @requires jsts/algorithm/PointLocator.js
   * @requires jsts/geom/Location.js
   * @requires jsts/geomgraph/EdgeList.js
   * @requires jsts/geomgraph/Label.js
   * @requires jsts/geomgraph/PlanarGraph.js
   * @requires jsts/geomgraph/Position.js
   * @requires jsts/geomgraph/EdgeNodingValidator.js
   * @requires jsts/operation/GeometryGraphOperation.js
   * @requires jsts/operation/overlay/OverlayNodeFactory.js
   * @requires jsts/operation/overlay/PolygonBuilder.js
   * @requires jsts/operation/overlay/LineBuilder.js
   * @requires jsts/operation/overlay/PointBuilder.js
   * @requires jsts/util/Assert.js
   */

  var PointLocator = jsts.algorithm.PointLocator;
  var Location = jsts.geom.Location;
  var EdgeList = jsts.geomgraph.EdgeList;
  var Label = jsts.geomgraph.Label;
  var PlanarGraph = jsts.geomgraph.PlanarGraph;
  var Position = jsts.geomgraph.Position;
  var EdgeNodingValidator = jsts.geomgraph.EdgeNodingValidator;
  var GeometryGraphOperation = jsts.operation.GeometryGraphOperation;
  var OverlayNodeFactory = jsts.operation.overlay.OverlayNodeFactory;
  var PolygonBuilder = jsts.operation.overlay.PolygonBuilder;
  var LineBuilder = jsts.operation.overlay.LineBuilder;
  var PointBuilder = jsts.operation.overlay.PointBuilder;
  var Assert = jsts.util.Assert;
  var ArrayList = javascript.util.ArrayList;

  /**
   * Computes the overlay of two {@link Geometry}s. The overlay can be used to
   * determine any boolean combination of the geometries.
   */
  jsts.operation.overlay.OverlayOp = function(g0, g1) {
    this.ptLocator = new PointLocator();
    this.edgeList = new EdgeList();
    this.resultPolyList = new ArrayList();
    this.resultLineList = new ArrayList();
    this.resultPointList = new ArrayList();

    GeometryGraphOperation.call(this, g0, g1);
    this.graph = new PlanarGraph(new OverlayNodeFactory());
    /**
     * Use factory of primary geometry. Note that this does NOT handle
     * mixed-precision arguments where the second arg has greater precision than
     * the first.
     */
    this.geomFact = g0.getFactory();
  };
  jsts.operation.overlay.OverlayOp.prototype = new GeometryGraphOperation();
  jsts.operation.overlay.OverlayOp.constructor = jsts.operation.overlay.OverlayOp;

  /**
   * The spatial functions supported by this class. These operations implement
   * various boolean combinations of the resultants of the overlay.
   */
  jsts.operation.overlay.OverlayOp.INTERSECTION = 1;
  jsts.operation.overlay.OverlayOp.UNION = 2;
  jsts.operation.overlay.OverlayOp.DIFFERENCE = 3;
  jsts.operation.overlay.OverlayOp.SYMDIFFERENCE = 4;

  jsts.operation.overlay.OverlayOp.overlayOp = function(geom0, geom1, opCode) {
    var gov = new jsts.operation.overlay.OverlayOp(geom0, geom1);
    var geomOv = gov.getResultGeometry(opCode);
    return geomOv;
  }

  jsts.operation.overlay.OverlayOp.isResultOfOp = function(label, opCode) {
    if (arguments.length === 3) {
      return jsts.operation.overlay.OverlayOp.isResultOfOp2.apply(this,
          arguments);
    }
    var loc0 = label.getLocation(0);
    var loc1 = label.getLocation(1);
    return jsts.operation.overlay.OverlayOp.isResultOfOp2(loc0, loc1, opCode);
  }

  /**
   * This method will handle arguments of Location.NONE correctly
   *
   * @return true if the locations correspond to the opCode.
   */
  jsts.operation.overlay.OverlayOp.isResultOfOp2 = function(loc0, loc1, opCode) {
    if (loc0 == Location.BOUNDARY)
      loc0 = Location.INTERIOR;
    if (loc1 == Location.BOUNDARY)
      loc1 = Location.INTERIOR;
    switch (opCode) {
    case jsts.operation.overlay.OverlayOp.INTERSECTION:
      return loc0 == Location.INTERIOR && loc1 == Location.INTERIOR;
    case jsts.operation.overlay.OverlayOp.UNION:
      return loc0 == Location.INTERIOR || loc1 == Location.INTERIOR;
    case jsts.operation.overlay.OverlayOp.DIFFERENCE:
      return loc0 == Location.INTERIOR && loc1 != Location.INTERIOR;
    case jsts.operation.overlay.OverlayOp.SYMDIFFERENCE:
      return (loc0 == Location.INTERIOR && loc1 != Location.INTERIOR) ||
          (loc0 != Location.INTERIOR && loc1 == Location.INTERIOR);
    }
    return false;
  }

  jsts.operation.overlay.OverlayOp.prototype.ptLocator = null;
  jsts.operation.overlay.OverlayOp.prototype.geomFact = null;
  jsts.operation.overlay.OverlayOp.prototype.resultGeom = null;

  jsts.operation.overlay.OverlayOp.prototype.graph = null;
  jsts.operation.overlay.OverlayOp.prototype.edgeList = null;

  jsts.operation.overlay.OverlayOp.prototype.resultPolyList = null;
  jsts.operation.overlay.OverlayOp.prototype.resultLineList = null;
  jsts.operation.overlay.OverlayOp.prototype.resultPointList = null;


  jsts.operation.overlay.OverlayOp.prototype.getResultGeometry = function(
      funcCode) {
    this.computeOverlay(funcCode);
    return this.resultGeom;
  }

  jsts.operation.overlay.OverlayOp.prototype.getGraph = function() {
    return this.graph;
  }

  /**
   * @private
   */
  jsts.operation.overlay.OverlayOp.prototype.computeOverlay = function(opCode) {
    // copy points from input Geometries.
    // This ensures that any Point geometries
    // in the input are considered for inclusion in the result set
    this.copyPoints(0);
    this.copyPoints(1);

    // node the input Geometries
    this.arg[0].computeSelfNodes(this.li, false);
    this.arg[1].computeSelfNodes(this.li, false);

    // compute intersections between edges of the two input geometries
    this.arg[0].computeEdgeIntersections(this.arg[1], this.li, true);

    var baseSplitEdges = new ArrayList();
    this.arg[0].computeSplitEdges(baseSplitEdges);
    this.arg[1].computeSplitEdges(baseSplitEdges);
    var splitEdges = baseSplitEdges;
    // add the noded edges to this result graph
    this.insertUniqueEdges(baseSplitEdges);

    this.computeLabelsFromDepths();
    this.replaceCollapsedEdges();

    /**
     * Check that the noding completed correctly.
     *
     * This test is slow, but necessary in order to catch robustness failure
     * situations. If an exception is thrown because of a noding failure, then
     * snapping will be performed, which will hopefully avoid the problem. In
     * the future hopefully a faster check can be developed.
     *
     */
    EdgeNodingValidator.checkValid(this.edgeList.getEdges());

    this.graph.addEdges(this.edgeList.getEdges());
    this.computeLabelling();
    this.labelIncompleteNodes();

    /**
     * The ordering of building the result Geometries is important. Areas must
     * be built before lines, which must be built before points. This is so that
     * lines which are covered by areas are not included explicitly, and
     * similarly for points.
     */
    this.findResultAreaEdges(opCode);
    this.cancelDuplicateResultEdges();

    var polyBuilder = new PolygonBuilder(this.geomFact);
    polyBuilder.add(this.graph);
    this.resultPolyList = polyBuilder.getPolygons();

    var lineBuilder = new LineBuilder(this, this.geomFact, this.ptLocator);
    this.resultLineList = lineBuilder.build(opCode);

    var pointBuilder = new PointBuilder(this, this.geomFact, this.ptLocator);
    this.resultPointList = pointBuilder.build(opCode);

    // gather the results from all calculations into a single Geometry for the
    // result set
    this.resultGeom = this.computeGeometry(this.resultPointList,
        this.resultLineList, this.resultPolyList, opCode);
  }

  /**
   * @private
   */
  jsts.operation.overlay.OverlayOp.prototype.insertUniqueEdges = function(edges) {
    for (var i = edges.iterator(); i.hasNext();) {
      var e = i.next();
      this.insertUniqueEdge(e);
    }
  }
  /**
   * Insert an edge from one of the noded input graphs. Checks edges that are
   * inserted to see if an identical edge already exists. If so, the edge is not
   * inserted, but its label is merged with the existing edge.
   *
   * @protected
   */
  jsts.operation.overlay.OverlayOp.prototype.insertUniqueEdge = function(e) {
    // <FIX> MD 8 Oct 03 speed up identical edge lookup
    // fast lookup
    var existingEdge = this.edgeList.findEqualEdge(e);

    // If an identical edge already exists, simply update its label
    if (existingEdge !== null) {
      var existingLabel = existingEdge.getLabel();

      var labelToMerge = e.getLabel();
      // check if new edge is in reverse direction to existing edge
      // if so, must flip the label before merging it
      if (!existingEdge.isPointwiseEqual(e)) {
        labelToMerge = new Label(e.getLabel());
        labelToMerge.flip();
      }
      var depth = existingEdge.getDepth();
      // if this is the first duplicate found for this edge, initialize the
      // depths
      // /*
      if (depth.isNull()) {
        depth.add(existingLabel);
      }
      // */
      depth.add(labelToMerge);
      existingLabel.merge(labelToMerge);

    } else { // no matching existing edge was found
      // add this new edge to the list of edges in this graph
      // e.setName(name + edges.size());
      // e.getDepth().add(e.getLabel());
      this.edgeList.add(e);
    }
  };


  /**
   * Update the labels for edges according to their depths. For each edge, the
   * depths are first normalized. Then, if the depths for the edge are equal,
   * this edge must have collapsed into a line edge. If the depths are not
   * equal, update the label with the locations corresponding to the depths
   * (i.e. a depth of 0 corresponds to a Location of EXTERIOR, a depth of 1
   * corresponds to INTERIOR)
   *
   * @private
   */
  jsts.operation.overlay.OverlayOp.prototype.computeLabelsFromDepths = function() {
    for (var it = this.edgeList.iterator(); it.hasNext();) {
      var e = it.next();
      var lbl = e.getLabel();
      var depth = e.getDepth();
      /**
       * Only check edges for which there were duplicates, since these are the
       * only ones which might be the result of dimensional collapses.
       */
      if (!depth.isNull()) {
        depth.normalize();
        for (var i = 0; i < 2; i++) {
          if (!lbl.isNull(i) && lbl.isArea() && !depth.isNull(i)) {
            /**
             * if the depths are equal, this edge is the result of the
             * dimensional collapse of two or more edges. It has the same
             * location on both sides of the edge, so it has collapsed to a
             * line.
             */
            if (depth.getDelta(i) == 0) {
              lbl.toLine(i);
            } else {
              /**
               * This edge may be the result of a dimensional collapse, but it
               * still has different locations on both sides. The label of the
               * edge must be updated to reflect the resultant side locations
               * indicated by the depth values.
               */
              Assert.isTrue(!depth.isNull(i, Position.LEFT),
                  'depth of LEFT side has not been initialized');
              lbl.setLocation(i, Position.LEFT, depth.getLocation(i,
                  Position.LEFT));
              Assert.isTrue(!depth.isNull(i, Position.RIGHT),
                  'depth of RIGHT side has not been initialized');
              lbl.setLocation(i, Position.RIGHT, depth.getLocation(i,
                  Position.RIGHT));
            }
          }
        }
      }
    }
  }
  /**
   * If edges which have undergone dimensional collapse are found, replace them
   * with a new edge which is a L edge
   *
   * @private
   */
  jsts.operation.overlay.OverlayOp.prototype.replaceCollapsedEdges = function() {
    var newEdges = new ArrayList();
    for (var it = this.edgeList.iterator(); it.hasNext();) {
      var e = it.next();
      if (e.isCollapsed()) {
        it.remove();
        newEdges.add(e.getCollapsedEdge());
      }
    }
    this.edgeList.addAll(newEdges);
  }
  /**
   * Copy all nodes from an arg geometry into this graph. The node label in the
   * arg geometry overrides any previously computed label for that argIndex.
   * (E.g. a node may be an intersection node with a previously computed label
   * of BOUNDARY, but in the original arg Geometry it is actually in the
   * interior due to the Boundary Determination Rule)
   *
   * @private
   */
  jsts.operation.overlay.OverlayOp.prototype.copyPoints = function(argIndex) {
    for (var i = this.arg[argIndex].getNodeIterator(); i.hasNext();) {
      var graphNode = i.next();
      var newNode = this.graph.addNode(graphNode.getCoordinate());
      newNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));
    }
  }

  /**
   * Compute initial labelling for all DirectedEdges at each node. In this step,
   * DirectedEdges will acquire a complete labelling (i.e. one with labels for
   * both Geometries) only if they are incident on a node which has edges for
   * both Geometries
   *
   * @private
   */
  jsts.operation.overlay.OverlayOp.prototype.computeLabelling = function() {
    for (var nodeit = this.graph.getNodes().iterator(); nodeit.hasNext();) {
      var node = nodeit.next();
      node.getEdges().computeLabelling(this.arg);
    }
    this.mergeSymLabels();
    this.updateNodeLabelling();
  }
  /**
   * For nodes which have edges from only one Geometry incident on them, the
   * previous step will have left their dirEdges with no labelling for the other
   * Geometry. However, the sym dirEdge may have a labelling for the other
   * Geometry, so merge the two labels.
   *
   * @private
   */
  jsts.operation.overlay.OverlayOp.prototype.mergeSymLabels = function() {
    for (var nodeit = this.graph.getNodes().iterator(); nodeit.hasNext();) {
      var node = nodeit.next();
      node.getEdges().mergeSymLabels();
    }
  }

  /**
   * @private
   */
  jsts.operation.overlay.OverlayOp.prototype.updateNodeLabelling = function() {
    // update the labels for nodes
    // The label for a node is updated from the edges incident on it
    // (Note that a node may have already been labelled
    // because it is a point in one of the input geometries)
    for (var nodeit = this.graph.getNodes().iterator(); nodeit.hasNext();) {
      var node = nodeit.next();
      var lbl = node.getEdges().getLabel();
      node.getLabel().merge(lbl);
    }
  }

  /**
   * Incomplete nodes are nodes whose labels are incomplete. (e.g. the location
   * for one Geometry is null). These are either isolated nodes, or nodes which
   * have edges from only a single Geometry incident on them.
   *
   * Isolated nodes are found because nodes in one graph which don't intersect
   * nodes in the other are not completely labelled by the initial process of
   * adding nodes to the nodeList. To complete the labelling we need to check
   * for nodes that lie in the interior of edges, and in the interior of areas.
   * <p>
   * When each node labelling is completed, the labelling of the incident edges
   * is updated, to complete their labelling as well.
   *
   * @private
   */
  jsts.operation.overlay.OverlayOp.prototype.labelIncompleteNodes = function() {
    var nodeCount = 0;
    for (var ni = this.graph.getNodes().iterator(); ni.hasNext();) {
      var n = ni.next();
      var label = n.getLabel();
      if (n.isIsolated()) {
        nodeCount++;
        if (label.isNull(0))
          this.labelIncompleteNode(n, 0);
        else
          this.labelIncompleteNode(n, 1);
      }
      // now update the labelling for the DirectedEdges incident on this node
      n.getEdges().updateLabelling(label);
    }
  };

  /**
   * Label an isolated node with its relationship to the target geometry.
   *
   * @private
   */
  jsts.operation.overlay.OverlayOp.prototype.labelIncompleteNode = function(n,
      targetIndex) {
    var loc = this.ptLocator.locate(n.getCoordinate(), this.arg[targetIndex]
        .getGeometry());

    // MD - 2008-10-24 - experimental for now
    // int loc = arg[targetIndex].locate(n.getCoordinate());
    n.getLabel().setLocation(targetIndex, loc);
  };

  /**
   * Find all edges whose label indicates that they are in the result area(s),
   * according to the operation being performed. Since we want polygon shells to
   * be oriented CW, choose dirEdges with the interior of the result on the RHS.
   * Mark them as being in the result. Interior Area edges are the result of
   * dimensional collapses. They do not form part of the result area boundary.
   *
   * @private
   */
  jsts.operation.overlay.OverlayOp.prototype.findResultAreaEdges = function(
      opCode) {
    for (var it = this.graph.getEdgeEnds().iterator(); it.hasNext();) {
      var de = it.next();
      // mark all dirEdges with the appropriate label
      var label = de.getLabel();
      if (label.isArea() &&
          !de.isInteriorAreaEdge() &&
          jsts.operation.overlay.OverlayOp.isResultOfOp(label.getLocation(0,
              Position.RIGHT), label.getLocation(1, Position.RIGHT), opCode)) {
        de.setInResult(true);
      }
    }
  };
  /**
   * If both a dirEdge and its sym are marked as being in the result, cancel
   * them out.
   *
   * @private
   */
  jsts.operation.overlay.OverlayOp.prototype.cancelDuplicateResultEdges = function() {
    // remove any dirEdges whose sym is also included
    // (they "cancel each other out")
    for (var it = this.graph.getEdgeEnds().iterator(); it.hasNext();) {
      var de = it.next();
      var sym = de.getSym();
      if (de.isInResult() && sym.isInResult()) {
        de.setInResult(false);
        sym.setInResult(false);
      }
    }
  };
  /**
   * This method is used to decide if a point node should be included in the
   * result or not.
   *
   * @return {boolean} true if the coord point is covered by a result Line or
   *         Area geometry.
   */
  jsts.operation.overlay.OverlayOp.prototype.isCoveredByLA = function(coord) {
    if (this.isCovered(coord, this.resultLineList))
      return true;
    if (this.isCovered(coord, this.resultPolyList))
      return true;
    return false;
  };
  /**
   * This method is used to decide if an L edge should be included in the result
   * or not.
   *
   * @return true if the coord point is covered by a result Area geometry.
   */
  jsts.operation.overlay.OverlayOp.prototype.isCoveredByA = function(coord) {
    if (this.isCovered(coord, this.resultPolyList))
      return true;
    return false;
  };
  /**
   * @return true if the coord is located in the interior or boundary of a
   *         geometry in the list.
   * @private
   */
  jsts.operation.overlay.OverlayOp.prototype.isCovered = function(coord,
      geomList) {
    for (var it = geomList.iterator(); it.hasNext();) {
      var geom = it.next();
      var loc = this.ptLocator.locate(coord, geom);
      if (loc != Location.EXTERIOR)
        return true;
    }
    return false;
  };

  /**
   * @private
   */
  jsts.operation.overlay.OverlayOp.prototype.computeGeometry = function(
      resultPointList, resultLineList, resultPolyList, opcode) {
    var geomList = new ArrayList();
    // element geometries of the result are always in the order P,L,A
    geomList.addAll(resultPointList);
    geomList.addAll(resultLineList);
    geomList.addAll(resultPolyList);

    /*
    if (geomList.isEmpty())
      return createEmptyResult(opcode);
    */

    // build the most specific geometry possible
    return this.geomFact.buildGeometry(geomList);
  };

  /**
   * @private
   */
  jsts.operation.overlay.OverlayOp.prototype.createEmptyResult = function(
      opCode) {
    var result = null;
    switch (resultDimension(opCode, this.arg[0].getGeometry(), this.arg[1]
        .getGeometry())) {
    case -1:
      result = geomFact.createGeometryCollection();
      break;
    case 0:
      result = geomFact.createPoint(null);
      break;
    case 1:
      result = geomFact.createLineString(null);
      break;
    case 2:
      result = geomFact.createPolygon(null, null);
      break;
    }
    return result;
  };

  /**
   * @private
   */
  jsts.operation.overlay.OverlayOp.prototype.resultDimension = function(opCode,
      g0, g1) {
    var dim0 = g0.getDimension();
    var dim1 = g1.getDimension();

    var resultDimension = -1;
    switch (opCode) {
    case jsts.operation.overlay.OverlayOp.INTERSECTION:
      resultDimension = Math.min(dim0, dim1);
      break;
    case jsts.operation.overlay.OverlayOp.UNION:
      resultDimension = Math.max(dim0, dim1);
      break;
    case jsts.operation.overlay.OverlayOp.DIFFERENCE:
      resultDimension = dim0;
      break;
    case jsts.operation.overlay.OverlayOp.SYMDIFFERENCE:
      resultDimension = Math.max(dim0, dim1);
      break;
    }
    return resultDimension;
  };

})();
/* ======================================================================
    jsts/operation/overlay/snap/SnapOverlayOp.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Port source:
 * /jts/jts/java/src/com/vividsolutions/jts/operation/overlay/snap/SnapOverlayOp.java
 * Revision: 150
 */

/**
 * @requires jsts/operation/overlay/snap/GeometrySnapper.js
 * @requires jsts/operation/overlay/OverlayOp.js
 * TODO: reenable when ported: requires jsts/precision/CommonBitsRemover.js
 */

/**
 * Performs an overlay operation using snapping and enhanced precision to
 * improve the robustness of the result. This class <i>always</i> uses
 * snapping. This is less performant than the standard JTS overlay code, and may
 * even introduce errors which were not present in the original data. For this
 * reason, this class should only be used if the standard overlay code fails to
 * produce a correct result.
 */

(function() {

  var OverlayOp = jsts.operation.overlay.OverlayOp;
  var GeometrySnapper = jsts.operation.overlay.snap.GeometrySnapper;

  /**
   * @constructor
   */
  var SnapOverlayOp = function(g1, g2) {
    this.geom = [];
    this.geom[0] = g1;
    this.geom[1] = g2;
    this.computeSnapTolerance();
  };

  SnapOverlayOp.overlayOp = function(g0, g1, opCode) {
    var op = new SnapOverlayOp(g0, g1);
    return op.getResultGeometry(opCode);
  };

  SnapOverlayOp.intersection = function(g0, g1) {
    return this.overlayOp(g0, g1, OverlayOp.INTERSECTION);
  };

  SnapOverlayOp.union = function(g0, g1) {
    return this.overlayOp(g0, g1, OverlayOp.UNION);
  };

  SnapOverlayOp.difference = function(g0, g1) {
    return overlayOp(g0, g1, OverlayOp.DIFFERENCE);
  };

  SnapOverlayOp.symDifference = function(g0, g1) {
    return overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE);
  };


  SnapOverlayOp.prototype.geom = null;
  SnapOverlayOp.prototype.snapTolerance = null;

  /**
   * @private
   */
  SnapOverlayOp.prototype.computeSnapTolerance = function() {
    this.snapTolerance = GeometrySnapper.computeOverlaySnapTolerance(
        this.geom[0], this.geom[1]);
  };

  SnapOverlayOp.prototype.getResultGeometry = function(opCode) {
    var prepGeom = this.snap(this.geom);
    var result = OverlayOp.overlayOp(prepGeom[0], prepGeom[1], opCode);
    return this.prepareResult(result);
  };

  /**
   * @private
   */
  SnapOverlayOp.prototype.selfSnap = function(geom) {
    var snapper0 = new GeometrySnapper(geom);
    var snapGeom = snapper0.snapTo(geom, this.snapTolerance);
    return snapGeom;
  };

  /**
   * @private
   */
  SnapOverlayOp.prototype.snap = function(geom) {
    // TODO: CommonBitsRemover isn't ported yet...
    var remGeom = geom;//this.removeCommonBits(geom);

    var snapGeom = GeometrySnapper.snap(remGeom[0], remGeom[1],
        this.snapTolerance);

    return snapGeom;
  };

  /**
   * @private
   */
  SnapOverlayOp.prototype.prepareResult = function(geom) {
 // TODO: CommonBitsRemover isn't ported yet...
    //this.cbr.addCommonBits(geom);
    return geom;
  };

  /**
   * @private
   * @type {CommonBitsRemover}
   */
  SnapOverlayOp.prototype.cbr = null;

  /**
   * @private
   */
  SnapOverlayOp.prototype.removeCommonBits = function(geom) {
    this.cbr = new jsts.precision.CommonBitsRemover();
    this.cbr.add(this.geom[0]);
    this.cbr.add(this.geom[1]);
    var remGeom = [];
    remGeom[0] = cbr.removeCommonBits(this.geom[0].clone());
    remGeom[1] = cbr.removeCommonBits(this.geom[1].clone());
    return remGeom;
  };

  jsts.operation.overlay.snap.SnapOverlayOp = SnapOverlayOp;

})();
/* ======================================================================
    jsts/geomgraph/index/EdgeSetIntersector.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * @constructor
 */
jsts.geomgraph.index.EdgeSetIntersector = function() {

};


/**
 * Computes all self-intersections between edges in a set of edges, allowing
 * client to choose whether self-intersections are computed.
 *
 * @param {javascript.util.List}
 *          edges a list of edges to test for intersections.
 * @param {SegmentIntersector}
 *          si the SegmentIntersector to use.
 * @param {boolean}
 *          testAllSegments true if self-intersections are to be tested as well.
 */
jsts.geomgraph.index.EdgeSetIntersector.prototype.computeIntersections = function(
    edges, si, testAllSegments) {
  throw new jsts.error.AbstractMethodInvocationError();
};


/**
 * Computes all mutual intersections between two sets of edges.
 *
 * @param {javascript.util.List}
 *          edges0 a list of edges to test for intersections.
 * @param {javascript.util.List}
 *          edges1 a list of edges to test for intersections.
 * @param {SegmentIntersector}
 *          si the SegmentIntersector to use.
 */
jsts.geomgraph.index.EdgeSetIntersector.prototype.computeIntersections2 = function(
    edges0, edges1, si) {
  throw new jsts.error.AbstractMethodInvocationError();
};
/* ======================================================================
    jsts/geomgraph/index/SimpleMCSweepLineIntersector.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @requires jsts/geomgraph/index/EdgeSetIntersector.js
 */



/**
 * Finds all intersections in one or two sets of edges,
 * using an x-axis sweepline algorithm in conjunction with Monotone Chains.
 * While still O(n^2) in the worst case, this algorithm
 * drastically improves the average-case time.
 * The use of MonotoneChains as the items in the index
 * seems to offer an improvement in performance over a sweep-line alone.
 * 
 * A SimpleMCSweepLineIntersector creates monotone chains from the edges
 * and compares them using a simple sweep-line along the x-axis.
 * @constructor
 */
jsts.geomgraph.index.SimpleMCSweepLineIntersector = function() {
  this.events = [];
};


jsts.geomgraph.index.SimpleMCSweepLineIntersector.prototype = new jsts.geomgraph.index.EdgeSetIntersector();


/**
 * @type {array} 
 */
jsts.geomgraph.index.SimpleMCSweepLineIntersector.prototype.events = null;

/**
 * statistics information
 * 
 * @type {int} 
 */
jsts.geomgraph.index.SimpleMCSweepLineIntersector.prototype.nOverlaps = 0;

/**
 * @param {javascript.util.List}
 *          edges
 * @param {SegmentIntersector}
 *          si
 * @param {boolean}
 *          testAllSegments
 */
jsts.geomgraph.index.SimpleMCSweepLineIntersector.prototype.computeIntersections = function(
    edges, si, testAllSegments) {

  if (si instanceof javascript.util.List) {
  	this.computeIntersections2.apply(this, arguments);
  	return;
  }

  if (testAllSegments) {
  	this.addList2(edges, null);
  } else {
  	this.addList(edges);
  }
  this.computeIntersections3(si);
};

/**
 * @param {javascript.util.List}
 *          edges0
 * @param {javascript.util.List}
 *          edges1
 * @param {SegmentIntersector}
 *          si
 */
jsts.geomgraph.index.SimpleMCSweepLineIntersector.prototype.computeIntersections2 = function(
    edges0, edges1, si) {
  this.addList2(edges0, edges0);
  this.addList2(edges1, edges1);
  this.computeIntersections3(si);  	
};

/** 
 * @param {Edge}
 *          edge
 * @param {Object}
 *          edgeSet
 */
jsts.geomgraph.index.SimpleMCSweepLineIntersector.prototype.add = function(
    edge, edgeSet) {

  if (edge instanceof javascript.util.List) {
  	this.addList.apply(this, arguments);
  	return;
  }

  var mce = edge.getMonotoneChainEdge();
  var startIndex = mce.getStartIndexes();
  for (var i = 0; i < startIndex.length - 1; i++) {
    var mc = new jsts.geomgraph.index.MonotoneChain(mce, i);
    var insertEvent = new jsts.geomgraph.index.SweepLineEvent(mce.getMinX(i), mc, edgeSet);
    this.events.push(insertEvent);
    this.events.push(new jsts.geomgraph.index.SweepLineEvent(mce.getMaxX(i), insertEvent));
  }
};

/**
 * @param {javascript.util.List}
 *          edges
 * @param {Object}
 *          edgeSet 
 */
jsts.geomgraph.index.SimpleMCSweepLineIntersector.prototype.addList = function(
    edges) {
  for (var i = edges.iterator(); i.hasNext(); ) {
    var edge = i.next();
    this.add(edge, edge);
  }
};
/**
 * @param {javascript.util.List}
 *          edges
 * @param {Object}
 *          edgeSet 
 */
jsts.geomgraph.index.SimpleMCSweepLineIntersector.prototype.addList2 = function(
    edges, edgeSet) {
  for (var i = edges.iterator(); i.hasNext(); ) {
    var edge = i.next();
    this.add(edge, edgeSet);
  }
};

/**
 * Because Delete Events have a link to their corresponding Insert event,
 * it is possible to compute exactly the range of events which must be
 * compared to a given Insert event object. 
 */
jsts.geomgraph.index.SimpleMCSweepLineIntersector.prototype.prepareEvents = function() {
  this.events.sort(function(a,b) {
    return a.compareTo(b);
  });

  // set DELETE event indexes
  for (var i = 0; i < this.events.length; i++) {
    var ev = this.events[i];
    if (ev.isDelete()) {
      ev.getInsertEvent().setDeleteEventIndex(i);
    }
  }
};

/**
 * @param {SegmentIntersector}
 *          si 
 */
jsts.geomgraph.index.SimpleMCSweepLineIntersector.prototype.computeIntersections3 = function(
    si) {
  this.nOverlaps = 0;
  this.prepareEvents();
  
  for (var i = 0; i < this.events.length; i++) {
  	var ev = this.events[i];
  	if (ev.isInsert()) {
  	  this.processOverlaps(i, ev.getDeleteEventIndex(), ev, si);
  	}
  }
};

/**
 * @param {int}
 *          start
 * @param {int}
 *          end
 * @param {SweepLineEvent}
 *          ev0
 * @param {SegmentIntersector}
 *          si 
 */
jsts.geomgraph.index.SimpleMCSweepLineIntersector.prototype.processOverlaps = function(
    start, end, ev0, si) {
  var mc0 = ev0.getObject();

  /**
   * Since we might need to test for self-intersections,
   * include current INSERT event object in list of event objects to test.
   * Last index can be skipped, because it must be a Delete event. 
   */
  for (var i = start; i < end; i++) {
    var ev1 = this.events[i];
    if (ev1.isInsert()) {
      var mc1 = ev1.getObject();
      // don't compare edges in same group, if labels are present
      if (!ev0.isSameLabel(ev1)) {
        mc0.computeIntersections(mc1, si);
        this.nOverlaps++;
      }
    }
  }
};
/* ======================================================================
    jsts/algorithm/locate/SimplePointInAreaLocator.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * Computes the location of points relative to a {@link Polygonal}
 * {@link Geometry}, using a simple O(n) algorithm. This algorithm is suitable
 * for use in cases where only one or a few points will be tested against a
 * given area.
 * <p>
 * The algorithm used is only guaranteed to return correct results for points
 * which are <b>not</b> on the boundary of the Geometry.
 *
 * @constructor
 * @augments {PointOnGeometryLocator}
 */
jsts.algorithm.locate.SimplePointInAreaLocator = function(geom) {
  this.geom = geom;
};


/**
 * Determines the {@link Location} of a point in an areal {@link Geometry}.
 * Currently this will never return a value of BOUNDARY.
 *
 * @param p
 *          the point to test.
 * @param geom
 *          the areal geometry to test.
 * @return the Location of the point in the geometry.
 */
jsts.algorithm.locate.SimplePointInAreaLocator.locate = function(p, geom) {
  if (geom.isEmpty())
    return jsts.geom.Location.EXTERIOR;

  if (jsts.algorithm.locate.SimplePointInAreaLocator.containsPoint(p, geom))
    return jsts.geom.Location.INTERIOR;
  return jsts.geom.Location.EXTERIOR;
};

jsts.algorithm.locate.SimplePointInAreaLocator.containsPoint = function(p, geom) {
  if (geom instanceof jsts.geom.Polygon) {
    return jsts.algorithm.locate.SimplePointInAreaLocator
        .containsPointInPolygon(p, geom);
  } else if (geom instanceof jsts.geom.GeometryCollection ||
      geom instanceof jsts.geom.MultiPoint ||
      geom instanceof jsts.geom.MultiLineString ||
      geom instanceof jsts.geom.MultiPolygon) {
    for (var i = 0; i < geom.geometries.length; i++) {
      var g2 = geom.geometries[i];
      if (g2 !== geom)
        if (jsts.algorithm.locate.SimplePointInAreaLocator.containsPoint(p, g2))
          return true;
    }
  }
  return false;
};

jsts.algorithm.locate.SimplePointInAreaLocator.containsPointInPolygon = function(
    p, poly) {
  if (poly.isEmpty())
    return false;
  var shell = poly.getExteriorRing();
  if (!jsts.algorithm.locate.SimplePointInAreaLocator.isPointInRing(p, shell))
    return false;
  // now test if the point lies in or on the holes
  for (var i = 0; i < poly.getNumInteriorRing(); i++) {
    var hole = poly.getInteriorRingN(i);
    if (jsts.algorithm.locate.SimplePointInAreaLocator.isPointInRing(p, hole))
      return false;
  }
  return true;
};


/**
 * Determines whether a point lies in a LinearRing, using the ring envelope to
 * short-circuit if possible.
 *
 * @param p
 *          the point to test.
 * @param ring
 *          a linear ring.
 * @return true if the point lies inside the ring.
 */
jsts.algorithm.locate.SimplePointInAreaLocator.isPointInRing = function(p, ring) {
  // short-circuit if point is not in ring envelope
  if (!ring.getEnvelopeInternal().intersects(p))
    return false;
  return jsts.algorithm.CGAlgorithms.isPointInRing(p, ring.getCoordinates());
};

jsts.algorithm.locate.SimplePointInAreaLocator.prototype.geom = null;


jsts.algorithm.locate.SimplePointInAreaLocator.prototype.locate = function(p) {
  return jsts.algorithm.locate.SimplePointInAreaLocator.locate(p, geom);
};
/* ======================================================================
    jsts/geomgraph/DirectedEdgeStar.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * @requires jsts/geom/Location.js
   * @requires jsts/geomgraph/Position.js
   * @requires jsts/geomgraph/EdgeEndStar.js
   * @requires jsts/util/Assert.js
   */

  var Location = jsts.geom.Location;
  var Position = jsts.geomgraph.Position;
  var EdgeEndStar = jsts.geomgraph.EdgeEndStar;
  var Assert = jsts.util.Assert;


  /**
   * A DirectedEdgeStar is an ordered list of <b>outgoing</b> DirectedEdges
   * around a node. It supports labelling the edges as well as linking the edges
   * to form both MaximalEdgeRings and MinimalEdgeRings.
   *
   * @constructor
   * @extends jsts.geomgraph.EdgeEnd
   */
  jsts.geomgraph.DirectedEdgeStar = function() {
    jsts.geomgraph.EdgeEndStar.call(this);
  };
  jsts.geomgraph.DirectedEdgeStar.prototype = new EdgeEndStar();
  jsts.geomgraph.DirectedEdgeStar.constructor = jsts.geomgraph.DirectedEdgeStar;


  /**
   * A list of all outgoing edges in the result, in CCW order
   *
   * @private
   */
  jsts.geomgraph.DirectedEdgeStar.prototype.resultAreaEdgeList = null;
  jsts.geomgraph.DirectedEdgeStar.prototype.label = null;

  /**
   * Insert a directed edge in the list
   */
  jsts.geomgraph.DirectedEdgeStar.prototype.insert = function(ee) {
    var de = ee;
    this.insertEdgeEnd(de, de);
  };

  jsts.geomgraph.DirectedEdgeStar.prototype.getLabel = function() {
    return this.label;
  };

  jsts.geomgraph.DirectedEdgeStar.prototype.getOutgoingDegree = function() {
    var degree = 0;
    for (var it = this.iterator(); it.hasNext();) {
      var de = it.next();
      if (de.isInResult())
        degree++;
    }
    return degree;
  };
  jsts.geomgraph.DirectedEdgeStar.prototype.getOutgoingDegree = function(er) {
    var degree = 0;
    for (var it = this.iterator(); it.hasNext();) {
      var de = it.next();
      if (de.getEdgeRing() === er)
        degree++;
    }
    return degree;
  };

  jsts.geomgraph.DirectedEdgeStar.prototype.getRightmostEdge = function() {
    var edges = this.getEdges();
    var size = edges.size();
    if (size < 1)
      return null;
    var de0 = edges.get(0);
    if (size == 1)
      return de0;
    var deLast = edges.get(size - 1);

    var quad0 = de0.getQuadrant();
    var quad1 = deLast.getQuadrant();
    if (jsts.geomgraph.Quadrant.isNorthern(quad0) &&
        jsts.geomgraph.Quadrant.isNorthern(quad1))
      return de0;
    else if (!jsts.geomgraph.Quadrant.isNorthern(quad0) &&
        !jsts.geomgraph.Quadrant.isNorthern(quad1))
      return deLast;
    else {
      // edges are in different hemispheres - make sure we return one that is
      // non-horizontal
      var nonHorizontalEdge = null;
      if (de0.getDy() != 0)
        return de0;
      else if (deLast.getDy() != 0)
        return deLast;
    }
    Assert.shouldNeverReachHere('found two horizontal edges incident on node');
    return null;
  };
  /**
   * Compute the labelling for all dirEdges in this star, as well as the overall
   * labelling
   */
  jsts.geomgraph.DirectedEdgeStar.prototype.computeLabelling = function(geom) {
    EdgeEndStar.prototype.computeLabelling.call(this, geom);

    // determine the overall labelling for this DirectedEdgeStar
    // (i.e. for the node it is based at)
    this.label = new jsts.geomgraph.Label(Location.NONE);
    for (var it = this.iterator(); it.hasNext();) {
      var ee = it.next();
      var e = ee.getEdge();
      var eLabel = e.getLabel();
      for (var i = 0; i < 2; i++) {
        var eLoc = eLabel.getLocation(i);
        if (eLoc === Location.INTERIOR || eLoc === Location.BOUNDARY)
          this.label.setLocation(i, Location.INTERIOR);
      }
    }
  };

  /**
   * For each dirEdge in the star, merge the label from the sym dirEdge into the
   * label
   */
  jsts.geomgraph.DirectedEdgeStar.prototype.mergeSymLabels = function() {
    for (var it = this.iterator(); it.hasNext();) {
      var de = it.next();
      var label = de.getLabel();
      label.merge(de.getSym().getLabel());
    }
  };

  /**
   * Update incomplete dirEdge labels from the labelling for the node
   */
  jsts.geomgraph.DirectedEdgeStar.prototype.updateLabelling = function(nodeLabel) {
    for (var it = this.iterator(); it.hasNext();) {
      var de = it.next();
      var label = de.getLabel();
      label.setAllLocationsIfNull(0, nodeLabel.getLocation(0));
      label.setAllLocationsIfNull(1, nodeLabel.getLocation(1));
    }
  };

  /**
   * @private
   */
  jsts.geomgraph.DirectedEdgeStar.prototype.getResultAreaEdges = function() {
    if (this.resultAreaEdgeList !== null)
      return this.resultAreaEdgeList;
    this.resultAreaEdgeList = new javascript.util.ArrayList();
    for (var it = this.iterator(); it.hasNext();) {
      var de = it.next();
      if (de.isInResult() || de.getSym().isInResult())
        this.resultAreaEdgeList.add(de);
    }
    return this.resultAreaEdgeList;

  };

  /**
   * @private
   */
  jsts.geomgraph.DirectedEdgeStar.prototype.SCANNING_FOR_INCOMING = 1;
  /**
   * @private
   */
  jsts.geomgraph.DirectedEdgeStar.prototype.LINKING_TO_OUTGOING = 2;
  /**
   * Traverse the star of DirectedEdges, linking the included edges together. To
   * link two dirEdges, the <next> pointer for an incoming dirEdge is set to the
   * next outgoing edge.
   * <p>
   * DirEdges are only linked if:
   * <ul>
   * <li>they belong to an area (i.e. they have sides)
   * <li>they are marked as being in the result
   * </ul>
   * <p>
   * Edges are linked in CCW order (the order they are stored). This means that
   * rings have their face on the Right (in other words, the topological
   * location of the face is given by the RHS label of the DirectedEdge)
   * <p>
   * PRECONDITION: No pair of dirEdges are both marked as being in the result
   */
  jsts.geomgraph.DirectedEdgeStar.prototype.linkResultDirectedEdges = function() {
    // make sure edges are copied to resultAreaEdges list
    this.getResultAreaEdges();
    // find first area edge (if any) to start linking at
    var firstOut = null;
    var incoming = null;
    var state = this.SCANNING_FOR_INCOMING;
    // link edges in CCW order
    for (var i = 0; i < this.resultAreaEdgeList.size(); i++) {
      var nextOut = this.resultAreaEdgeList.get(i);
      var nextIn = nextOut.getSym();

      // skip de's that we're not interested in
      if (!nextOut.getLabel().isArea())
        continue;

      // record first outgoing edge, in order to link the last incoming edge
      if (firstOut === null && nextOut.isInResult())
        firstOut = nextOut;
      // assert: sym.isInResult() == false, since pairs of dirEdges should have
      // been removed already

      switch (state) {
      case this.SCANNING_FOR_INCOMING:
        if (!nextIn.isInResult())
          continue;
        incoming = nextIn;
        state = this.LINKING_TO_OUTGOING;
        break;
      case this.LINKING_TO_OUTGOING:
        if (!nextOut.isInResult())
          continue;
        incoming.setNext(nextOut);
        state = this.SCANNING_FOR_INCOMING;
        break;
      }
    }
    if (state === this.LINKING_TO_OUTGOING) {
      if (firstOut === null)
        throw new jsts.error.TopologyError('no outgoing dirEdge found', this
            .getCoordinate());
      Assert.isTrue(firstOut.isInResult(),
          'unable to link last incoming dirEdge');
      incoming.setNext(firstOut);
    }
  };
  jsts.geomgraph.DirectedEdgeStar.prototype.linkMinimalDirectedEdges = function(er) {
    // find first area edge (if any) to start linking at
    var firstOut = null;
    var incoming = null;
    var state = this.SCANNING_FOR_INCOMING;
    // link edges in CW order
    for (var i = this.resultAreaEdgeList.size() - 1; i >= 0; i--) {
      var nextOut = this.resultAreaEdgeList.get(i);
      var nextIn = nextOut.getSym();

      // record first outgoing edge, in order to link the last incoming edge
      if (firstOut === null && nextOut.getEdgeRing() === er)
        firstOut = nextOut;

      switch (state) {
      case this.SCANNING_FOR_INCOMING:
        if (nextIn.getEdgeRing() != er)
          continue;
        incoming = nextIn;
        state = this.LINKING_TO_OUTGOING;
        break;
      case this.LINKING_TO_OUTGOING:
        if (nextOut.getEdgeRing() !== er)
          continue;
        incoming.setNextMin(nextOut);
        state = this.SCANNING_FOR_INCOMING;
        break;
      }
    }
    if (state === this.LINKING_TO_OUTGOING) {
      Assert.isTrue(firstOut !== null, 'found null for first outgoing dirEdge');
      Assert.isTrue(firstOut.getEdgeRing() === er,
          'unable to link last incoming dirEdge');
      incoming.setNextMin(firstOut);
    }
  };
  jsts.geomgraph.DirectedEdgeStar.prototype.linkAllDirectedEdges = function() {
    this.getEdges();
    // find first area edge (if any) to start linking at
    var prevOut = null;
    var firstIn = null;
    // link edges in CW order
    for (var i = this.edgeList.size() - 1; i >= 0; i--) {
      var nextOut = this.edgeList.get(i);
      var nextIn = nextOut.getSym();
      if (firstIn === null)
        firstIn = nextIn;
      if (prevOut !== null)
        nextIn.setNext(prevOut);
      // record outgoing edge, in order to link the last incoming edge
      prevOut = nextOut;
    }
    firstIn.setNext(prevOut);
  };

  /**
   * Traverse the star of edges, maintaing the current location in the result
   * area at this node (if any). If any L edges are found in the interior of the
   * result, mark them as covered.
   */
  jsts.geomgraph.DirectedEdgeStar.prototype.findCoveredLineEdges = function() {
    // Since edges are stored in CCW order around the node,
    // as we move around the ring we move from the right to the left side of the
    // edge

    /**
     * Find first DirectedEdge of result area (if any). The interior of the
     * result is on the RHS of the edge, so the start location will be: -
     * INTERIOR if the edge is outgoing - EXTERIOR if the edge is incoming
     */
    var startLoc = Location.NONE;
    for (var it = this.iterator(); it.hasNext();) {
      var nextOut = it.next();
      var nextIn = nextOut.getSym();
      if (!nextOut.isLineEdge()) {
        if (nextOut.isInResult()) {
          startLoc = Location.INTERIOR;
          break;
        }
        if (nextIn.isInResult()) {
          startLoc = Location.EXTERIOR;
          break;
        }
      }
    }
    // no A edges found, so can't determine if L edges are covered or not
    if (startLoc === Location.NONE)
      return;

    /**
     * move around ring, keeping track of the current location (Interior or
     * Exterior) for the result area. If L edges are found, mark them as covered
     * if they are in the interior
     */
    var currLoc = startLoc;

    for (var it = this.iterator(); it.hasNext();) {
      var nextOut = it.next();
      var nextIn = nextOut.getSym();
      if (nextOut.isLineEdge()) {
        nextOut.getEdge().setCovered(currLoc === Location.INTERIOR);
      } else { // edge is an Area edge
        if (nextOut.isInResult())
          currLoc = Location.EXTERIOR;
        if (nextIn.isInResult())
          currLoc = Location.INTERIOR;
      }
    }
  };

  jsts.geomgraph.DirectedEdgeStar.prototype.computeDepths = function(de) {
    if (arguments.length === 2) {
      this.computeDepths2.apply(this, arguments);
      // NOTE: intentional, this function returns void
      return;
    }

    var edgeIndex = this.findIndex(de);
    var label = de.getLabel();
    var startDepth = de.getDepth(Position.LEFT);
    var targetLastDepth = de.getDepth(Position.RIGHT);
    // compute the depths from this edge up to the end of the edge array
    var nextDepth = this.computeDepths2(edgeIndex + 1, this.edgeList.size(),
        startDepth);
    // compute the depths for the initial part of the array
    var lastDepth = this.computeDepths2(0, edgeIndex, nextDepth);
    if (lastDepth != targetLastDepth)
      throw new jsts.error.TopologyError('depth mismatch at ' +
          de.getCoordinate());
  };

  /**
   * Compute the DirectedEdge depths for a subsequence of the edge array.
   *
   * @return the last depth assigned (from the R side of the last edge visited).
   * @private
   */
  jsts.geomgraph.DirectedEdgeStar.prototype.computeDepths2 = function(startIndex, endIndex,
      startDepth) {
    var currDepth = startDepth;
    for (var i = startIndex; i < endIndex; i++) {
      var nextDe = this.edgeList.get(i);
      var label = nextDe.getLabel();
      nextDe.setEdgeDepths(Position.RIGHT, currDepth);
      currDepth = nextDe.getDepth(Position.LEFT);
    }
    return currDepth;
  };

})();
/* ======================================================================
    jsts/algorithm/CentroidLine.js
   ====================================================================== */

/**
 * Computes the centroid of a linear geometry.
 * <h2>Algorithm</h2>
 * Compute the average of the midpoints of all line segments weighted by the
 * segment length.
 *
 * @version 1.7
 */
jsts.algorithm.CentroidLine = function() {
  this.centSum = new jsts.geom.Coordinate();
};


/**
 * @type {jsts.geom.Coordinate}
 * @private
 */
jsts.algorithm.CentroidLine.prototype.centSum = null;


/**
 * @type {double}
 * @private
 */
jsts.algorithm.CentroidLine.prototype.totalLength = 0.0;


/**
 * Adds the linear components of by a Geometry to the centroid total. If the
 * geometry has no linear components it does not contribute to the centroid,
 *
 * @param geom
 *          the geometry to add.
 */
jsts.algorithm.CentroidLine.prototype.add = function(geom) {
  if (geom instanceof Array) {
    this.add2.apply(this, arguments);
    return;
  }

  if (geom instanceof jsts.geom.LineString) {
    this.add(geom.getCoordinates());
  } else if (geom instanceof jsts.geom.Polygon) {
    var poly = geom;
    // add linear components of a polygon
    this.add(poly.getExteriorRing().getCoordinates());
    for (var i = 0; i < poly.getNumInteriorRing(); i++) {
      this.add(poly.getInteriorRingN(i).getCoordinates());
    }
  } else if (geom instanceof jsts.geom.GeometryCollection ||
      geom instanceof jsts.geom.MultiPoint ||
      geom instanceof jsts.geom.MultiLineString ||
      geom instanceof jsts.geom.MultiPolygon) {
    var gc = geom;
    for (var i = 0; i < gc.getNumGeometries(); i++) {
      this.add(gc.getGeometryN(i));
    }
  }
};

jsts.algorithm.CentroidLine.prototype.getCentroid = function() {
  var cent = new jsts.geom.Coordinate();
  cent.x = this.centSum.x / this.totalLength;
  cent.y = this.centSum.y / this.totalLength;
  return cent;
};


/**
 * Adds the length defined by an array of coordinates.
 *
 * @param pts
 *          an array of {@link Coordinate} s.
 */
jsts.algorithm.CentroidLine.prototype.add2 = function(pts) {
  for (var i = 0; i < pts.length - 1; i++) {
    var segmentLen = pts[i].distance(pts[i + 1]);
    this.totalLength += segmentLen;

    var midx = (pts[i].x + pts[i + 1].x) / 2;
    this.centSum.x += segmentLen * midx;
    var midy = (pts[i].y + pts[i + 1].y) / 2;
    this.centSum.y += segmentLen * midy;
  }
};
/* ======================================================================
    jsts/index/IntervalSize.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
*/



/**
 * Provides a test for whether an interval is so small it should be considered
 * as zero for the purposes of inserting it into a binary tree. The reason this
 * check is necessary is that round-off error can cause the algorithm used to
 * subdivide an interval to fail, by computing a midpoint value which does not
 * lie strictly between the endpoints.
 *
 * @constructor
 */
jsts.index.IntervalSize = function() {

};


/**
 * This value is chosen to be a few powers of 2 less than the number of bits
 * available in the double representation (i.e. 53). This should allow enough
 * extra precision for simple computations to be correct, at least for
 * comparison purposes.
 */
jsts.index.IntervalSize.MIN_BINARY_EXPONENT = -50;


/**
 * Computes whether the interval [min, max] is effectively zero width. I.e. the
 * width of the interval is so much less than the location of the interval that
 * the midpoint of the interval cannot be represented precisely.
 *
 * @param {Number}
 *          min the min-value in the interval.
 * @param {Number}
 *          max the max-value in the interval.
 * @return {Boolean} true if the interval should be considered zero.
 */
jsts.index.IntervalSize.isZeroWidth = function(min, max) {
  var width = max - min;
  if (width === 0.0) {
    return true;
  }

  var maxAbs, scaledInterval, level;
  maxAbs = Math.max(Math.abs(min), Math.abs(max));
  scaledInterval = width / maxAbs;

  level = jsts.index.DoubleBits.exponent(scaledInterval);
  return level <= jsts.index.IntervalSize.MIN_BINARY_EXPONENT;
};
/* ======================================================================
    jsts/geomgraph/index/SimpleEdgeSetIntersector.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @requires jsts/geomgraph/index/EdgeSetIntersector.js
 */



/**
 * Finds all intersections in one or two sets of edges, using the
 * straightforward method of comparing all segments. This algorithm is too slow
 * for production use, but is useful for testing purposes.
 *
 * @constructor
 */
jsts.geomgraph.index.SimpleEdgeSetIntersector = function() {

};

jsts.geomgraph.index.SimpleEdgeSetIntersector.prototype = new jsts.geomgraph.index.EdgeSetIntersector();


/**
 * statistics information
 *
 * @type {int}
 */
jsts.geomgraph.index.SimpleEdgeSetIntersector.prototype.nOverlaps = 0;


/**
 * @param {javascript.util.List}
 *          edges
 * @param {SegmentIntersector}
 *          si
 * @param {boolean}
 *          testAllSegments
 */
jsts.geomgraph.index.SimpleEdgeSetIntersector.prototype.computeIntersections = function(
    edges, si, testAllSegments) {

  if (si instanceof javascript.util.List) {
    this.computeIntersections2.apply(this, arguments);
    return;
  }

  this.nOverlaps = 0;

  for (var i0 = edges.iterator(); i0.hasNext(); ) {
    var edge0 = i0.next();
    for (var i1 = edges.iterator(); i1.hasNext(); ) {
      var edge1 = i1.next();
      if (testAllSegments || edge0 != edge1)
        this.computeIntersects(edge0, edge1, si);
    }
  }
};


/**
 * @param {javascript.util.List}
 *          edges0
 * @param {javascript.util.List}
 *          edges1
 * @param {SegmentIntersector}
 *          si
 */
jsts.geomgraph.index.SimpleEdgeSetIntersector.prototype.computeIntersections2 = function(
    edges0, edges1, si) {
  this.nOverlaps = 0;

  for (var i0 = edges0.iterator(); i0.hasNext(); ) {
    var edge0 = i0.next();
    for (var i1 = edges1.iterator(); i1.hasNext(); ) {
      var edge1 = i1.next();
      this.computeIntersects(edge0, edge1, si);
    }
  }
};


/**
 * Performs a brute-force comparison of every segment in each Edge. This has n^2
 * performance, and is about 100 times slower than using monotone chains.
 *
 * @param {Edge}
 *          e0
 * @param {Edge}
 *          e1
 * @param {SegmentIntersector}
 *          si
 */
jsts.geomgraph.index.SimpleEdgeSetIntersector.prototype.computeIntersects = function(
    e0, e1, si) {
  var pts0 = e0.getCoordinates();
  var pts1 = e1.getCoordinates();
  var i0, i1;
  for (i0 = 0; i0 < pts0.length - 1; i0++) {
    for (i1 = 0; i1 < pts1.length - 1; i1++) {
      si.addIntersections(e0, i0, e1, i1);
    }
  }
};
/* ======================================================================
    jsts/geomgraph/Edge.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @requires jsts/geomgraph/GraphComponent.js
 */



/**
 * @param {Coordinate[]}
 *          pts
 * @param {Label}
 *          label
 * @augments jsts.geomgraph.GraphComponent
 * @constructor
 */
jsts.geomgraph.Edge = function(pts, label) {
  this.pts = pts;
  this.label = label;
  this.eiList = new jsts.geomgraph.EdgeIntersectionList(this);
  this.depth = new jsts.geomgraph.Depth();
};

jsts.geomgraph.Edge.prototype = new jsts.geomgraph.GraphComponent();
jsts.geomgraph.Edge.constructor = jsts.geomgraph.Edge;

/**
 * Updates an IM from the label for an edge. Handles edges from both L and A
 * geometries.
 */
jsts.geomgraph.Edge.updateIM = function(label, im) {
  im.setAtLeastIfValid(label.getLocation(0, jsts.geomgraph.Position.ON), label
      .getLocation(1, jsts.geomgraph.Position.ON), 1);
  if (label.isArea()) {
    im.setAtLeastIfValid(label.getLocation(0, jsts.geomgraph.Position.LEFT),
        label.getLocation(1, jsts.geomgraph.Position.LEFT), 2);
    im.setAtLeastIfValid(label.getLocation(0, jsts.geomgraph.Position.RIGHT),
        label.getLocation(1, jsts.geomgraph.Position.RIGHT), 2);
  }
};


/**
 * @private
 */
jsts.geomgraph.Edge.prototype.pts = null;


/**
 * @private
 */
jsts.geomgraph.Edge.prototype.env = null;


/**
 * @private
 */
jsts.geomgraph.Edge.prototype.name = null;


/**
 * @type {MonotoneChainEdge}
 * @private
 */
jsts.geomgraph.Edge.prototype.mce = null;


/**
 * @private
 */
jsts.geomgraph.Edge.prototype._isIsolated = true;


/**
 * @type {Depth}
 * @private
 */
jsts.geomgraph.Edge.prototype.depth = null;


/**
 * // the change in area depth from the R to L side of this edge
 */
jsts.geomgraph.Edge.prototype.depthDelta = 0;


/**
 * @type {jsts.geomgraph.EdgeIntersectionList}
 * @private
 */
jsts.geomgraph.Edge.prototype.eiList = null;


/**
 * @return {int}
 */
jsts.geomgraph.Edge.prototype.getNumPoints = function() {
  return this.pts.length;
};


jsts.geomgraph.Edge.prototype.getEnvelope = function() {
  // compute envelope lazily
  if (this.env === null) {
    this.env = new jsts.geom.Envelope();
    for (var i = 0; i < this.pts.length; i++) {
      this.env.expandToInclude(pts[i]);
    }
  }
  return env;
};

jsts.geomgraph.Edge.prototype.getDepth = function() {
  return this.depth;
};

/**
 * The depthDelta is the change in depth as an edge is crossed from R to L
 *
 * @return the change in depth as the edge is crossed from R to L.
 */
jsts.geomgraph.Edge.prototype.getDepthDelta = function() {
  return this.depthDelta;
};
jsts.geomgraph.Edge.prototype.setDepthDelta = function(depthDelta) {
  this.depthDelta = depthDelta;
};

/**
 * @return {Coordinate[]}
 */
jsts.geomgraph.Edge.prototype.getCoordinates = function() {
  return this.pts;
};


/**
 * @param {int}
 *          i
 * @return {Coordinate}
 */
jsts.geomgraph.Edge.prototype.getCoordinate = function(i) {
  if (i === undefined) {
    if (this.pts.length > 0) {
      return this.pts[0];
    } else {
      return null;
    }
  }

  return this.pts[i];
};


/**
 * @return {boolean}
 */
jsts.geomgraph.Edge.prototype.isClosed = function() {
  return this.pts[0].equals(this.pts[this.pts.length - 1]);
};


jsts.geomgraph.Edge.prototype.setIsolated = function(isIsolated) {
  this._isIsolated = isIsolated;
};
jsts.geomgraph.Edge.prototype.isIsolated = function() {
  return this._isIsolated;
};


/**
 * Adds EdgeIntersections for one or both intersections found for a segment of
 * an edge to the edge intersection list.
 *
 * @param {LineIntersector}
 *          li
 * @param {int}
 *          segmentIndex
 * @param {int}
 *          geomIndex
 */
jsts.geomgraph.Edge.prototype.addIntersections = function(li, segmentIndex,
    geomIndex) {
  for (var i = 0; i < li.getIntersectionNum(); i++) {
    this.addIntersection(li, segmentIndex, geomIndex, i);
  }
};


/**
 * Add an EdgeIntersection for intersection intIndex. An intersection that falls
 * exactly on a vertex of the edge is normalized to use the higher of the two
 * possible segmentIndexes
 *
 * @param {LineIntersector}
 *          li
 * @param {int}
 *          segmentIndex
 * @param {int}
 *          geomIndex
 * @param {int}
 *          intIndex
 */
jsts.geomgraph.Edge.prototype.addIntersection = function(li, segmentIndex,
    geomIndex, intIndex) {
  var intPt = new jsts.geom.Coordinate(li.getIntersection(intIndex));
  var normalizedSegmentIndex = segmentIndex;
  var dist = li.getEdgeDistance(geomIndex, intIndex);
  // normalize the intersection point location
  var nextSegIndex = normalizedSegmentIndex + 1;
  if (nextSegIndex < this.pts.length) {
    var nextPt = this.pts[nextSegIndex];

    // Normalize segment index if intPt falls on vertex
    // The check for point equality is 2D only - Z values are ignored
    if (intPt.equals2D(nextPt)) {
      normalizedSegmentIndex = nextSegIndex;
      dist = 0.0;
    }
  }
  /**
   * Add the intersection point to edge intersection list.
   */
  var ei = this.eiList.add(intPt, normalizedSegmentIndex, dist);
};


/**
 * @return {int}
 */
jsts.geomgraph.Edge.prototype.getMaximumSegmentIndex = function() {
  return this.pts.length - 1;
};

jsts.geomgraph.Edge.prototype.getEdgeIntersectionList = function() {
  return this.eiList;
};

jsts.geomgraph.Edge.prototype.getMonotoneChainEdge = function() {
  if (this.mce == null) {
    this.mce = new jsts.geomgraph.index.MonotoneChainEdge(this);
  }
  return this.mce;
};

jsts.geomgraph.Edge.prototype.isClosed = function()
{
  return this.pts[0].equals(this.pts[this.pts.length - 1]);
};
/**
 * An Edge is collapsed if it is an Area edge and it consists of
 * two segments which are equal and opposite (eg a zero-width V).
 */
jsts.geomgraph.Edge.prototype.isCollapsed = function()
{
  if (! this.label.isArea()) return false;
  if (this.pts.length != 3) return false;
  if (this.pts[0].equals(this.pts[2])) return true;
  return false;
};
jsts.geomgraph.Edge.prototype.getCollapsedEdge = function()
{
  var newPts = [];
  newPts[0] = this.pts[0];
  newPts[1] = this.pts[1];
  var newe = new jsts.geomgraph.Edge(newPts, jsts.geomgraph.Label.toLineLabel(this.label));
  return newe;
};


/**
 * Update the IM with the contribution for this component. A component only
 * contributes if it has a labelling for both parent geometries
 */
jsts.geomgraph.Edge.prototype.computeIM = function(im) {
  jsts.geomgraph.Edge.updateIM(this.label, im);
};

/**
 * @return true if the coordinate sequences of the Edges are identical.
 */
jsts.geomgraph.Edge.prototype.isPointwiseEqual = function(e)
{
  if (this.pts.length != e.pts.length) return false;

  for (var i = 0; i < this.pts.length; i++) {
    if (! this.pts[i].equals2D(e.pts[i])) {
       return false;
    }
  }
  return true;
};

// TODO: port rest..
/* ======================================================================
    jsts/noding/Octant.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * Methods for computing and working with octants of the Cartesian plane
 * Octants are numbered as follows:
 * <pre>
 *  \2|1/
 * 3 \|/ 0
 * ---+--
 * 4 /|\ 7
 *  /5|6\
 * <pre>
 * If line segments lie along a coordinate axis, the octant is the lower of the two
 * possible values.
 *
 * @constructor
 */
jsts.noding.Octant = function() {
  throw jsts.error.AbstractMethodInvocationError();
};


/**
 * Returns the octant of a directed line segment (specified as x and y
 * displacements, which cannot both be 0).
 */
jsts.noding.Octant.octant = function(dx,  dy)  {
  if (dx instanceof jsts.geom.Coordinate) {
    return jsts.noding.Octant.octant2.apply(this, arguments);
  }

  if (dx === 0.0 && dy === 0.0)
    throw new jsts.error.IllegalArgumentError('Cannot compute the octant for point ( ' + dx + ', ' + dy + ' )');

  var adx = Math.abs(dx);
  var ady = Math.abs(dy);

  if (dx >= 0) {
    if (dy >= 0) {
      if (adx >= ady)
        return 0;
      else
        return 1;
    }
    else { // dy < 0
      if (adx >= ady)
        return 7;
      else
        return 6;
    }
  }
  else { // dx < 0
    if (dy >= 0) {
      if (adx >= ady)
        return 3;
      else
        return 2;
    }
    else { // dy < 0
      if (adx >= ady)
        return 4;
      else
        return 5;
    }
  }
};


/**
 * Returns the octant of a directed line segment from p0 to p1.
 */
jsts.noding.Octant.octant2 = function(p0,  p1)  {
  var dx = p1.x - p0.x;
  var dy = p1.y - p0.y;
  if (dx === 0.0 && dy === 0.0)
    throw new jsts.error.IllegalArgumentError('Cannot compute the octant for two identical points ' + p0);
  return jsts.noding.Octant.octant(dx, dy);
};
/* ======================================================================
    jsts/operation/union/UnionInteracting.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Experimental code to union MultiPolygons
 * with processing limited to the elements which actually interact.
 *
 * Not currently used, since it doesn't seem to offer much of a performance advantage.
 *
 */



/**
 * @param {jsts.geom.Geometry} g0
 * @param {jsts.geom.Geometry} g1
 * @constructor
 */
jsts.operation.union.UnionInteracting = function(g0, g1) {
  this.g0 = g0;
  this.g1 = g1;
  this.geomFactory = g0.getFactory();
  this.interacts0 = [];
  this.interacts1 = [];
};


/**
 * @param {jsts.geom.Geometry} g0
 * @param {jsts.geom.Geometry} g1
 * @return {jsts.geom.Geometry}
 */
jsts.operation.union.UnionInteracting.union = function(g0, g1) {
  var uue = new jsts.operation.union.UnionInteracting(g0, g1);
  return uue.union();
};


/**
 * @type {jsts.geom.GeometryFactory}
 */
jsts.operation.union.UnionInteracting.prototype.geomFactory = null;


/**
 * @type {jsts.geom.Geometry}
 */
jsts.operation.union.UnionInteracting.prototype.g0 = null;


/**
 * @type {jsts.geom.Geometry}
 */
jsts.operation.union.UnionInteracting.prototype.g1 = null;


/**
 * @type {Array.<boolean>}
 */
jsts.operation.union.UnionInteracting.prototype.interacts0 = null;


/**
 * @type {Array.<boolean>}
 */
jsts.operation.union.UnionInteracting.prototype.interacts1 = null;


/**
 * @return {jsts.geom.Geometry}
 */
jsts.operation.union.UnionInteracting.prototype.union = function() {
  this.computeInteracting();

  //check for all interacting or none interacting!
  var int0 = this.extractElements(this.g0, this.interacts0, true);
  var int1 = this.extractElements(this.g1, this.interacts1, true);

  //TODO: Guess we don't need this here
  if (int0.isEmpty() || int1.isEmpty()) {
    // console.log("found empty!");
  }

  var union = in0.union(int1);

  var disjoint0 = this.extractElements(this.g0, this.interacts0, false);
  var disjoint1 = this.extractElements(this.g1, this.interacts1, false);

  var overallUnion = jsts.geom.util.GeometryCombiner.combine(union, disjoint0, disjoint1);

  return overallUnion;
};


/**
 * @param {jsts.geom.Geometry} g0
 * @param {jsts.geom.Geometry} g1
 * @return {jsts.geom.Geometry}
 * @private
 */
jsts.operation.union.UnionInteracting.prototype.bufferUnion = function(g0, g1) {
  var factory = g0.getFactory();
  var gColl = factory.createGeometryCollection([g0, g1]);
  var unionAll = gColl.buffer(0.0);
  return unionAll;
};


/**
 * @param {jsts.geom.Geometry} [elem0].
 * @return {?boolean}
 * @private
 */
jsts.operation.union.UnionInteracting.prototype.computeInteracting = function(elem0) {
  if (!elem0) {
    for (var i = 0, l = this.g0.getNumGeometries(); i < l; i++) {
      var elem = this.g0.getGeometryN(i);
      this.interacts0[i] = this.computeInteracting(elem);
    }
  }
  else {
    var interactsWithAny = false;
    for (var i = 0, l = g1.getNumGeometries(); i < l; i++) {
      var elem1 = this.g1.getGeometryN(i);
      var interacts = elem1.getEnvelopeInternal().intersects(elem0.getEnvelopeInternal());
      if (interacts) {
        this.interacts1[i] = true;
        interactsWithAny = true;
      }
    }
    return interactsWithAny;
  }
};


/**
 * @param {jsts.geom.Geometry} geom
 * @param {Array.<boolean>} interacts
 * @param {boolean} isInteracting
 * @return {jsts.geom.Geometry}
 * @private
 */
jsts.operation.union.UnionInteracting.prototype.extractElements = function(geom, interacts, isInteracting) {
  var extractedGeoms = [];
  for (var i = 0, l = geom.getNumGeometries(); i < l; i++) {
    var elem = geom.getGeometryN(i);
    if (interacts[i] === isInteracting) {
      extractedGeoms.push(elem);
    }
  }
  return this.geomFactory.buildGeometry(extractedGeoms);
};

/* ======================================================================
    jsts/triangulate/quadedge/TrianglePredicate.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * Algorithms for computing values and predicates associated with triangles.
 *
 * For some algorithms extended-precision implementations are provided, which
 * are more robust (i.e. they produce correct answers in more cases). Also, some
 * more robust formulations of some algorithms are provided, which utilize
 * normalization to the origin.
 *
 * @constructor
 */
jsts.triangulate.quadedge.TrianglePredicate = function() {

};


/**
 * Tests if a point is inside the circle defined by the points a, b, c. This
 * test uses simple double-precision arithmetic, and thus may not be robust.
 *
 * @param {jsts.geom.Coordinate}
 *          a a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          b a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          c a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          p the point to test.
 * @return {Boolean} true if this point is inside the circle defined by the
 *         points a, b, c.
 */
jsts.triangulate.quadedge.TrianglePredicate.isInCircleNonRobust = function(a,
    b, c, p) {
  var isInCircle = (a.x * a.x + a.y * a.y) *
      jsts.triangulate.quadedge.TrianglePredicate.triArea(b, c, p) -
      (b.x * b.x + b.y * b.y) *
      jsts.triangulate.quadedge.TrianglePredicate.triArea(a, c, p) +
      (c.x * c.x + c.y * c.y) *
      jsts.triangulate.quadedge.TrianglePredicate.triArea(a, b, p) -
      (p.x * p.x + p.y * p.y) *
      jsts.triangulate.quadedge.TrianglePredicate.triArea(a, b, c) > 0;

  return isInCircle;
};


/**
 * Tests if a point is inside the circle defined by the points a, b, c. This
 * test uses simple double-precision arithmetic, and thus is not 10% robust.
 * However, by using normalization to the origin it provides improved robustness
 * and increased performance.
 * <p>
 * Based on code by J.R.Shewchuk.
 *
 *
 * @param {jsts.geom.Coordinate}
 *          a a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          b a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          c a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          p the point to test.
 * @return {Boolean} true if this point is inside the circle defined by the
 *         points a, b, c.
 */
jsts.triangulate.quadedge.TrianglePredicate.isInCircleNormalized = function(a,
    b, c, p) {
  var adx, ady, bdx, bdy, cdx, cdy, abdet, bcdet, cadet, alift, blift, clift, disc;

  adx = a.x - p.x;
  ady = a.y - p.y;
  bdx = b.x - p.x;
  bdy = b.y - p.y;
  cdx = c.x - p.x;
  cdy = c.y - p.y;

  abdet = adx * bdy - bdx * ady;
  bcdet = bdx * cdy - cdx * bdy;
  cadet = cdx * ady - adx * cdy;
  alift = adx * adx + ady * ady;
  blift = bdx * bdx + bdy * bdy;
  clift = cdx * cdx + cdy * cdy;

  disc = alift * bcdet + blift * cadet + clift * abdet;
  return disc > 0;
};


/**
 * Computes twice the area of the oriented triangle (a, b, c), i.e. the area is
 * positive if the triangle is oriented counterclockwise.
 *
 * @param {jsts.geom.Coordinate}
 *          a a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          b a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          c a vertex of the triangle.
 * @return {Number} The calculated area.
 */
jsts.triangulate.quadedge.TrianglePredicate.triArea = function(a, b, c) {
  return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
};


/**
 * Tests if a point is inside the circle defined by the points a, b, c. This
 * method uses more robust computation.
 *
 * @param {jsts.geom.Coordinate}
 *          a a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          b a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          c a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          p the point to test.
 * @return {Boolean} true if this point is inside the circle defined by the
 *         points a, b, c.
 */
jsts.triangulate.quadedge.TrianglePredicate.isInCircleRobust = function(a, b,
    c, p) {
  return jsts.triangulate.quadedge.TrianglePredicate.isInCircleNormalized(a, b,
      c, p);
};


/**
 * Tests if a point is inside the circle defined by the points a, b, c. The
 * computation uses {@link DD} arithmetic for robustness.
 *
 * @param {jsts.geom.Coordinate}
 *          a a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          b a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          c a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          p the point to test.
 * @return {Boolean} true if this point is inside the circle defined by the
 *         points a, b, c.
 */
jsts.triangulate.quadedge.TrianglePredicate.isInCircleDDSlow = function(a, b,
    c, p) {
  var px, py, ax, ay, bx, by, cx, cy, aTerm, bTerm, cTerm, pTerm, sum, isInCircle;

  px = jsts.math.DD.valueOf(p.x);
  py = jsts.math.DD.valueOf(p.y);
  ax = jsts.math.DD.valueOf(a.x);
  ay = jsts.math.DD.valueOf(a.y);
  bx = jsts.math.DD.valueOf(b.x);
  by = jsts.math.DD.valueOf(b.y);
  cx = jsts.math.DD.valueOf(c.x);
  cy = jsts.math.DD.valueOf(c.y);

  aTerm = (ax.multiply(ax).add(ay.multiply(ay)))
      .multiply(jsts.triangulate.quadedge.TrianglePredicate.triAreaDDSlow(bx,
          by, cx, cy, px, py));
  bTerm = (bx.multiply(bx).add(by.multiply(by)))
      .multiply(jsts.triangulate.quadedge.TrianglePredicate.triAreaDDSlow(ax,
          ay, cx, cy, px, py));
  cTerm = (cx.multiply(cx).add(cy.multiply(cy)))
      .multiply(jsts.triangulate.quadedge.TrianglePredicate.triAreaDDSlow(ax,
          ay, bx, by, px, py));
  pTerm = (px.multiply(px).add(py.multiply(py)))
      .multiply(jsts.triangulate.quadedge.TrianglePredicate.triAreaDDSlow(ax,
          ay, bx, by, cx, cy));

  sum = aTerm.subtract(bTerm).add(cTerm).subtract(pTerm);
  isInCircle = sum.doubleValue() > 0;

  return isInCircle;
};


/**
 * Computes twice the area of the oriented triangle (a, b, c), i.e., the area is
 * positive if the triangle is oriented counterclockwise. The computation uses
 * {@link DD} arithmetic for robustness.
 *
 * @param {jsts.math.DD}
 *          ax the x ordinate of a vertex of the triangle.
 * @param {jsts.math.DD}
 *          ay the y ordinate of a vertex of the triangle.
 * @param {jsts.math.DD}
 *          bx the x ordinate of a vertex of the triangle.
 * @param {jsts.math.DD}
 *          by the y ordinate of a vertex of the triangle.
 * @param {jsts.math.DD}
 *          cx the x ordinate of a vertex of the triangle.
 * @param {jsts.math.DD}
 *          cy the y ordinate of a vertex of the triangle.
 * @return {jsts.math.DD} The calculated area.
 */
jsts.triangulate.quadedge.TrianglePredicate.triAreaDDSlow = function(ax, ay,
    bx, by, cx, cy) {
  return (bx.subtract(ax).multiply(cy.subtract(ay)).subtract(by.subtract(ay)
      .multiply(cx.subtract(ax))));
};


/**
 * Tests if a point is inside the circle defined by the points a, b, c. The
 * computation uses {@link DD} arithmetic for robustness.
 *
 * @param {jsts.geom.Coordinate}
 *          a a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          b a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          c a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          p the point to test.
 * @return {Boolean} true if this point is inside the circle defined by the
 *         points a, b, c.
 */
jsts.triangulate.quadedge.TrianglePredicate.isInCircleDDFast = function(a, b,
    c, p) {
  var aTerm, bTerm, cTerm, pTerm, sum, isInCircle;

  aTerm = (jsts.math.DD.sqr(a.x).selfAdd(jsts.math.DD.sqr(a.y)))
      .selfMultiply(jsts.triangulate.quadedge.TrianglePredicate.triAreaDDFast(
          b, c, p));
  bTerm = (jsts.math.DD.sqr(b.x).selfAdd(jsts.math.DD.sqr(b.y)))
      .selfMultiply(jsts.triangulate.quadedge.TrianglePredicate.triAreaDDFast(
          a, c, p));
  cTerm = (jsts.math.DD.sqr(c.x).selfAdd(jsts.math.DD.sqr(c.y)))
      .selfMultiply(jsts.triangulate.quadedge.TrianglePredicate.triAreaDDFast(
          a, b, p));
  pTerm = (jsts.math.DD.sqr(p.x).selfAdd(jsts.math.DD.sqr(p.y)))
      .selfMultiply(jsts.triangulate.quadedge.TrianglePredicate.triAreaDDFast(
          a, b, c));

  sum = aTerm.selfSubtract(bTerm).selfAdd(cTerm).selfSubtract(pTerm);
  isInCircle = sum.doubleValue() > 0;

  return isInCircle;
};


/**
 * Computes twice the area of the oriented triangle (a, b, c), i.e., the area is
 * positive if the triangle is oriented counterclockwise. The computation uses
 * {@link DD} arithmetic for robustness.
 *
 * @param {jsts.geom.Coordinate}
 *          a a vertex in the triangle.
 * @param {jsts.geom.Coordinate}
 *          b a vertex in the triangle.
 * @param {jsts.geom.Coordinate}
 *          c a vertex in the triangle.
 * @return {jsts.math.DD} The calculated area.
 */
jsts.triangulate.quadedge.TrianglePredicate.triAreaDDFast = function(a, b, c) {
  var t1, t2;

  t1 = jsts.math.DD.valueOf(b.x).selfSubtract(a.x).selfMultiply(
      jsts.math.DD.valueOf(c.y).selfSubtract(a.y));

  t2 = jsts.math.DD.valueOf(b.y).selSubtract(a.y).selfMultiply(
      jsts.math.DD.valueOf(c.x).selfSubtract(a.x));

  return t1.selfSubtract(t2);
};


/**
 * Tests if a point is inside the circle defined by the points a, b, c. This
 * test uses double-double precision arithmetic.
 *
 * @param {jsts.geom.Coordinate}
 *          a a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          b a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          c a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          p the point to test.
 * @return {Boolean} true if this point is inside the circle defined by the
 *         points a, b, c.
 */
jsts.triangulate.quadedge.TrianglePredicate.isInCircleDDNormalized = function(
    a, b, c, p) {
  var adx, ady, bdx, bdy, cdx, cdy, abdet, bcdet, cadet, alift, blift, clift, sum, isInCircle;

  adx = jsts.math.DD.valueOf(a.x).selfSubtract(p.x);
  ady = jsts.math.DD.valueOf(a.y).selfSubtract(p.y);
  bdx = jsts.math.DD.valueOf(b.x).selfSubtract(p.x);
  bdx = jsts.math.DD.valueOf(b.y).selfSubtract(p.y);
  cdx = jsts.math.DD.valueOf(c.x).selfSubtract(p.x);
  cdx = jsts.math.DD.valueOf(c.y).selfSubtract(p.y);

  abdet = adx.multiply(bdy).selfSubtract(bdx.multiply(ady));
  bcdet = bdx.multiply(cdy).selfSubtract(cdx.multiply(bdy));
  cadet = cdx.multiply(ady).selfSubtract(adx.multiply(cdy));
  alift = adx.multiply(adx).selfAdd(ady.multiply(ady));
  blift = bdx.multiply(bdx).selfAdd(bdy.multiply(bdy));
  clift = cdx.multiply(cdx).selfAdd(cdy.multiply(cdy));

  sum = alift.selfMultiply(bcdet).selfAdd(blift.selfMultiply(cadet)).selfAdd(
      clift.selfMultiply(abdet));

  isInCircle = sum.doubleValue() > 0;

  return isInCircle;
};


/**
 * Computes the inCircle test using distance from the circumcentre. Uses
 * standard double-precision arithmetic.
 * <p>
 * In general this doesn't appear to be any more robust than the standard
 * calculation. However, there is at least one case where the test point is far
 * enough from the circumcircle that this test gives the correct answer.
 *
 * <pre>
 * LINESTRING
 * (1507029.9878 518325.7547, 1507022.1120341457 518332.8225183258,
 * 1507029.9833 518325.7458, 1507029.9896965567 518325.744909031)
 * </pre>
 *
 * @param {jsts.geom.Coordinate}
 *          a a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          b a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          c a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          p the point to test.
 * @return {Boolean} true if this point is inside the circle defined by the
 *         points a, b, c.
 */
jsts.triangulate.quadedge.TrianglePredicate.isInCircleCC = function(a, b, c, p) {
  var cc, ccRadius, pRadiusDiff;

  cc = jsts.geom.Triangle.circumcentre(a, b, c);
  ccRadius = a.distance(cc);
  pRadiusDiff = p.distance(cc) - ccRadius;

  return pRadiusDiff <= 0;
};
/* ======================================================================
    jsts/operation/union/PointGeometryUnion.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */
/**
 * Computes the union of a {@link Puntal} geometry with
 * another arbitrary {@link Geometry}.
 * Does not copy any component geometries.
 *
 * @requires jsts/algorithm/PointLocator.js
 *
 */



//TODO: How do we treat Puntal?
/**
 * @param {jsts.geom.Puntal} pointGeom
 * @param {jsts.geom.Geometry} otherGeom
 * @constructor
 */
jsts.operation.union.PointGeometryUnion = function(pointGeom, otherGeom) {
  this.pointGeom = pointGeom;
  this.otherGeom = otherGeom;
  this.geomFact = otherGeom.getFactory();
};


/**
 * @param {jsts.geom.Puntal} pointGeom
 * @param {jsts.geom.Geometry} otherGeom
 * @return {jsts.geom.Geometry}
 *
 * @public
 */
jsts.operation.union.PointGeometryUnion.union = function(pointGeom, otherGeom) {
  var unioner = new jsts.operation.union.PointGeometryUnion(pointGeom, otherGeom);
  return unioner.union();
};


/**
 * @type {jsts.geom.Geometry}
 * @private
 */
jsts.operation.union.PointGeometryUnion.prototype.pointGeom = null;


/**
 * @type {jsts.geom.Geometry}
 * @private
 */
jsts.operation.union.PointGeometryUnion.prototype.otherGeom = null;


/**
 * @type {jsts.geom.GeometryFactory}
 * @private
 */
jsts.operation.union.PointGeometryUnion.prototype.geomFact = null;


/**
 *
 * @return {jsts.geom.Geometry}
 */
jsts.operation.union.PointGeometryUnion.prototype.union = function() {
  var locator = new jsts.algorithm.PointLocator();
  // use a set to eliminate duplicates, as required for union
  // Should be a tree set. So we have to check for uniqueness and sort it.
  var exteriorCoords = [];

  for (var i = 0, l = this.pointGeom.getNumGeometries(); i < l; i++) {
    var point = this.pointGeom.getGeometryN(i);
    var coord = point.getCoordinate();
    var loc = locator.locate(coord, this.otherGeom);

    if (loc === jsts.geom.Location.EXTERIOR) {

      // TreeSet: check for uniqueness
      var include = true;
      for (var j = exteriorCoords.length; i--;) {
        if (exteriorCoords[j].equals(coord)) {
          include = false;
          break;
        }
      }

      if (include) {
        exteriorCoords.push(coord);
      }
    }
  }

  //TreeSet: sort ascending
  exteriorCoords.sort(function(x, y) {
    return x.compareTo(y);
  });

  //if no points are in exterior, return the other geom
  if (exteriorCoords.length === 0) {
    return this.otherGeom;
  }

  //make a puntal geometry of appropriate size
  var ptComp = null;
  var coords = jsts.geom.CoordinateArrays.toCoordinateArray(exteriorCoords);
  if (coords.length === 1) {
    ptComp = this.geomFact.createPoint(coords[0]);
  }
  else {
    ptComp = this.geomFact.createMultiPoint(coords);
  }

  //add point component to the other geometry
  return jsts.geom.util.GeometryCombiner.combine(ptComp, this.otherGeom);
};
/* ======================================================================
    jsts/algorithm/locate/PointOnGeometryLocator.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

// TODO: port!
/* ======================================================================
    jsts/noding/IntersectionFinderAdder.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Port source:
 * /jts/jts/java/src/com/vividsolutions/jts/noding/IntersectionFinderAdder.java
 * Revision: 108
 */

/**
 * Finds proper and interior intersections in a set of SegmentStrings,
 * and adds them as nodes.
 */

/**
 * Creates an intersection finder which finds all proper intersections
 *
 * @param li
 *          the LineIntersector to use.
 */
jsts.noding.IntersectionFinderAdder = function(li) {
  this.li = li;
  this.interiorIntersections = new javascript.util.ArrayList();
};

jsts.noding.IntersectionFinderAdder.prototype = new jsts.noding.SegmentIntersector();
jsts.noding.IntersectionFinderAdder.constructor = jsts.noding.IntersectionFinderAdder;


jsts.noding.IntersectionFinderAdder.prototype.li = null;
jsts.noding.IntersectionFinderAdder.prototype.interiorIntersections = null;


jsts.noding.IntersectionFinderAdder.prototype.getInteriorIntersections = function() {
  return this.interiorIntersections;
};

/**
 * This method is called by clients of the {@link SegmentIntersector} class to
 * process intersections for two segments of the {@link SegmentString}s being
 * intersected. Note that some clients (such as {@link MonotoneChain}s) may
 * optimize away this call for segment pairs which they have determined do not
 * intersect (e.g. by an disjoint envelope test).
 */
jsts.noding.IntersectionFinderAdder.prototype.processIntersections = function(
    e0, segIndex0, e1, segIndex1) {
  // don't bother intersecting a segment with itself
  if (e0 === e1 && segIndex0 === segIndex1)
    return;

  var p00 = e0.getCoordinates()[segIndex0];
  var p01 = e0.getCoordinates()[segIndex0 + 1];
  var p10 = e1.getCoordinates()[segIndex1];
  var p11 = e1.getCoordinates()[segIndex1 + 1];

  this.li.computeIntersection(p00, p01, p10, p11);

  if (this.li.hasIntersection()) {
    if (this.li.isInteriorIntersection()) {
      for (var intIndex = 0; intIndex < this.li.getIntersectionNum(); intIndex++) {
        this.interiorIntersections.add(this.li.getIntersection(intIndex));
      }
      e0.addIntersections(this.li, segIndex0, 0);
      e1.addIntersections(this.li, segIndex1, 1);
    }
  }
};

/**
 * Always process all intersections
 *
 * @return false always.
 */
jsts.noding.IntersectionFinderAdder.prototype.isDone = function() {
  return false;
};
/* ======================================================================
    jsts/noding/snapround/MCIndexSnapRounder.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Port source: /jts/jts/java/src/com/vividsolutions/jts/noding/snapround/MCIndexSnapRounder.java
 * Revision: 486
 */

/**
 * @requires jsts/algorithm/RobustLineIntersector.js
 * @requires jsts/noding/Noder.js
 */

/**
 * Uses Snap Rounding to compute a rounded, fully noded arrangement from a set
 * of {@link SegmentString}s. Implements the Snap Rounding technique described
 * in papers by Hobby, Guibas & Marimont, and Goodrich et al. Snap Rounding
 * assumes that all vertices lie on a uniform grid; hence the precision model of
 * the input must be fixed precision, and all the input vertices must be rounded
 * to that precision.
 * <p>
 * This implementation uses a monotone chains and a spatial index to speed up
 * the intersection tests.
 * <p>
 * This implementation appears to be fully robust using an integer precision
 * model. It will function with non-integer precision models, but the results
 * are not 100% guaranteed to be correctly noded.
 */
jsts.noding.snapround.MCIndexSnapRounder = function(pm) {
  this.pm = pm;
  this.li = new jsts.algorithm.RobustLineIntersector();
  this.li.setPrecisionModel(pm);
  this.scaleFactor = pm.getScale();
};

jsts.noding.snapround.MCIndexSnapRounder.prototype = new jsts.noding.Noder();
jsts.noding.snapround.MCIndexSnapRounder.constructor = jsts.noding.snapround.MCIndexSnapRounder;


jsts.noding.snapround.MCIndexSnapRounder.prototype.pm = null;
jsts.noding.snapround.MCIndexSnapRounder.prototype.li = null;
jsts.noding.snapround.MCIndexSnapRounder.prototype.scaleFactor = null;
jsts.noding.snapround.MCIndexSnapRounder.prototype.noder = null;
jsts.noding.snapround.MCIndexSnapRounder.prototype.pointSnapper = null;
jsts.noding.snapround.MCIndexSnapRounder.prototype.nodedSegStrings = null;

jsts.noding.snapround.MCIndexSnapRounder.prototype.getNodedSubstrings = function() {
  return jsts.noding.NodedSegmentString
      .getNodedSubstrings(this.nodedSegStrings);
};

jsts.noding.snapround.MCIndexSnapRounder.prototype.computeNodes = function(
    inputSegmentStrings) {
  this.nodedSegStrings = inputSegmentStrings;
  this.noder = new jsts.noding.MCIndexNoder();
  this.pointSnapper = new jsts.noding.snapround.MCIndexPointSnapper(this.noder
      .getIndex());
  this.snapRound(inputSegmentStrings, this.li);
};

/**
 * @private
 */
jsts.noding.snapround.MCIndexSnapRounder.prototype.snapRound = function(
    segStrings, li) {
  var intersections = this.findInteriorIntersections(segStrings, li);
  this.computeIntersectionSnaps(intersections);
  this.computeVertexSnaps(segStrings);
};

/**
 * Computes all interior intersections in the collection of
 * {@link SegmentString}s, and returns their
 *
 * @link Coordinate}s.
 *
 * Does NOT node the segStrings.
 *
 * @return a list of Coordinates for the intersections.
 * @private
 */
jsts.noding.snapround.MCIndexSnapRounder.prototype.findInteriorIntersections = function(
    segStrings, li) {
  var intFinderAdder = new jsts.noding.IntersectionFinderAdder(li);
  this.noder.setSegmentIntersector(intFinderAdder);
  this.noder.computeNodes(segStrings);
  return intFinderAdder.getInteriorIntersections();
};

/**
 * Computes nodes introduced as a result of snapping segments to snap points
 * (hot pixels)
 *
 * @private
 */
jsts.noding.snapround.MCIndexSnapRounder.prototype.computeIntersectionSnaps = function(
    snapPts) {
  for (var it = snapPts.iterator(); it.hasNext();) {
    var snapPt = it.next();
    var hotPixel = new jsts.noding.snapround.HotPixel(snapPt, this.scaleFactor,
        this.li);
    this.pointSnapper.snap(hotPixel);
  }
};

/**
 * Computes nodes introduced as a result of snapping segments to vertices of
 * other segments
 *
 * @param edges
 *          the list of segment strings to snap together.
 */
jsts.noding.snapround.MCIndexSnapRounder.prototype.computeVertexSnaps = function(
    edges) {
  if (edges instanceof jsts.noding.NodedSegmentString) {
    this.computeVertexSnaps2.apply(this, arguments);
    return;
  }

  for (var i0 = edges.iterator(); i0.hasNext();) {
    var edge0 = i0.next();
    this.computeVertexSnaps(edge0);
  }
};

/**
 * Performs a brute-force comparison of every segment in each
 * {@link SegmentString}. This has n^2 performance.
 *
 * @private
 */
jsts.noding.snapround.MCIndexSnapRounder.prototype.computeVertexSnaps2 = function(
    e) {
  var pts0 = e.getCoordinates();
  for (var i = 0; i < pts0.length - 1; i++) {
    var hotPixel = new jsts.noding.snapround.HotPixel(pts0[i],
        this.scaleFactor, this.li);
    var isNodeAdded = this.pointSnapper.snap(hotPixel, e, i);
    // if a node is created for a vertex, that vertex must be noded too
    if (isNodeAdded) {
      e.addIntersection(pts0[i], i);
    }
  }
};
/* ======================================================================
    jsts/operation/valid/ConnectedInteriorTester.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * This class tests that the interior of an area {@link Geometry} (
 * {@link Polygon} or {@link MultiPolygon} ) is connected. This can happen if:
 * <ul>
 * <li>a shell self-intersects
 * <li>one or more holes form a connected chain touching a shell at two
 * different points
 * <li>one or more holes form a ring around a subset of the interior
 * </ul>
 * If a disconnected situation is found the location of the problem is recorded.
 *
 * @version 1.7
 * @constructor
 */
jsts.operation.valid.ConnectedInteriorTester = function(geomGraph) {
  this.geomGraph = geomGraph;
  this.geometryFactory = new jsts.geom.GeometryFactory();

  // save a coordinate for any disconnected interior found
  // the coordinate will be somewhere on the ring surrounding the disconnected
  // interior
  this.disconnectedRingcoord = null;
};

/**
 * @param {jsts.geom.Coordinate[]}
 *          coord A coordinate array.
 * @param {jsts.geom.Coordinate}
 *          pt
 * @return {jsts.geom.Coordinate}
 */
jsts.operation.valid.ConnectedInteriorTester.findDifferentPoint = function(
    coord, pt) {
  var i = 0, il = coord.length;
  for (i; i < il; i++) {
    if (!coord[i].equals(pt))
      return coord[i];
  }
  return null;
};

/**
 * Returns the coordinate for a disconnected interior
 *
 * @return {jsts.geom.Coordinate} the coordinate.
 */
jsts.operation.valid.ConnectedInteriorTester.prototype.getCoordinate = function() {
  return this.disconnectedRingcoord;
};

/**
 * @return {Boolean}
 */
jsts.operation.valid.ConnectedInteriorTester.prototype.isInteriorsConnected = function() {
  // node the edges, in case holes touch the shell
  var splitEdges = new javascript.util.ArrayList();
  this.geomGraph.computeSplitEdges(splitEdges);

  // form the edges into rings
  var graph = new jsts.geomgraph.PlanarGraph(
      new jsts.operation.overlay.OverlayNodeFactory());
  graph.addEdges(splitEdges);

  this.setInteriorEdgesInResult(graph);
  graph.linkResultDirectedEdges();

  var edgeRings = this.buildEdgeRings(graph.getEdgeEnds());

  /**
   *
   * Mark all the edges for the edgeRings corresponding to the shells
   *
   * of the input polygons. Note only ONE ring gets marked for each shell.
   *
   */

  this.visitShellInteriors(this.geomGraph.getGeometry(), graph);


  /**
   *
   * If there are any unvisited shell edges
   *
   * (i.e. a ring which is not a hole and which has the interior
   *
   * of the parent area on the RHS)
   *
   * this means that one or more holes must have split the interior of the
   *
   * polygon into at least two pieces. The polygon is thus invalid.
   *
   */

  return !this.hasUnvisitedShellEdge(edgeRings);
};

jsts.operation.valid.ConnectedInteriorTester.prototype.setInteriorEdgesInResult = function(
    graph) {
  var it = graph.getEdgeEnds().iterator(), de;

  while (it.hasNext()) {
    de = it.next();
    if (de.getLabel().getLocation(0, jsts.geomgraph.Position.RIGHT) == jsts.geom.Location.INTERIOR) {
      de.setInResult(true);
    }
  }
};

/**
 *
 * Form DirectedEdges in graph into Minimal EdgeRings. (Minimal Edgerings must
 * be used, because only they are guaranteed to provide a correct isHole
 * computation)
 *
 */
jsts.operation.valid.ConnectedInteriorTester.prototype.buildEdgeRings = function(
    dirEdges) {
  var edgeRings = new javascript.util.ArrayList();
  for (var it = dirEdges.iterator(); it.hasNext();) {

    var de = it.next();

    // if this edge has not yet been processed
    if (de.isInResult()

    && de.getEdgeRing() == null) {

      var er = new jsts.operation.overlay.MaximalEdgeRing(de,
          this.geometryFactory);
      er.linkDirectedEdgesForMinimalEdgeRings();

      var minEdgeRings = er.buildMinimalRings();

      var i = 0, il = minEdgeRings.length;
      for (i; i < il; i++) {
        edgeRings.add(minEdgeRings[i]);
      }
    }
  }

  return edgeRings;
};

/**
 *
 * Mark all the edges for the edgeRings corresponding to the shells of the input
 * polygons. Only ONE ring gets marked for each shell - if there are others
 * which remain unmarked this indicates a disconnected interior.
 *
 */
jsts.operation.valid.ConnectedInteriorTester.prototype.visitShellInteriors = function(
    g, graph) {
  if (g instanceof jsts.geom.Polygon) {
    var p = g;
    this.visitInteriorRing(p.getExteriorRing(), graph);
  }

  if (g instanceof jsts.geom.MultiPolygon) {
    var mp = g;
    for (var i = 0; i < mp.getNumGeometries(); i++) {
      var p = mp.getGeometryN(i);
      this.visitInteriorRing(p.getExteriorRing(), graph);
    }
  }
};

jsts.operation.valid.ConnectedInteriorTester.prototype.visitInteriorRing = function(
    ring, graph) {

  var pts = ring.getCoordinates();
  var pt0 = pts[0];

  /**
   *
   * Find first point in coord list different to initial point. Need special
   * check since the first point may be repeated.
   *
   */
  var pt1 = jsts.operation.valid.ConnectedInteriorTester.findDifferentPoint(
      pts, pt0);
  var e = graph.findEdgeInSameDirection(pt0, pt1);
  var de = graph.findEdgeEnd(e);
  var intDe = null;

  if (de.getLabel().getLocation(0, jsts.geomgraph.Position.RIGHT) == jsts.geom.Location.INTERIOR) {
    intDe = de;
  } else if (de.getSym().getLabel().getLocation(0,
      jsts.geomgraph.Position.RIGHT) == jsts.geom.Location.INTERIOR) {
    intDe = de.getSym();
  }

  this.visitLinkedDirectedEdges(intDe);
};

jsts.operation.valid.ConnectedInteriorTester.prototype.visitLinkedDirectedEdges = function(
    start) {
  var startDe = start;
  var de = start;
  do {
    de.setVisited(true);
    de = de.getNext();
  } while (de != startDe);
};

/**
 *
 * Check if any shell ring has an unvisited edge. A shell ring is a ring which
 * is not a hole and which has the interior of the parent area on the RHS. (Note
 * that there may be non-hole rings with the interior on the LHS, since the
 * interior of holes will also be polygonized into CW rings by the
 * linkAllDirectedEdges() step)
 *
 * @return {Boolean} true if there is an unvisited edge in a non-hole ring.
 */

jsts.operation.valid.ConnectedInteriorTester.prototype.hasUnvisitedShellEdge = function(
    edgeRings) {
  for (var i = 0; i < edgeRings.size(); i++) {
    var er = edgeRings.get(i);

    // don't check hole rings
    if (er.isHole()) {
      continue;
    }

    var edges = er.getEdges();
    var de = edges[0];

    // don't check CW rings which are holes
    // (MD - this check may now be irrelevant)
    if (de.getLabel().getLocation(0, jsts.geomgraph.Position.RIGHT) != jsts.geom.Location.INTERIOR) {
      continue;
    }

    /**
     *
     * the edgeRing is CW ring which surrounds the INT of the area, so check all
     *
     * edges have been visited. If any are unvisited, this is a disconnected
     * part of the interior
     *
     */

    for (var j = 0; j < edges.length; j++) {
      de = edges[j];
      if (!de.isVisited()) {
        disconnectedRingcoord = de.getCoordinate();
        return true;
      }
    }
  }
  return false;
};
/* ======================================================================
    jsts/algorithm/InteriorPointLine.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * Computes a point in the interior of an linear geometry.
 * <h2>Algorithm</h2>
 * <ul>
 * <li>Find an interior vertex which is closest to
 * the centroid of the linestring.
 * <li>If there is no interior vertex, find the endpoint which is
 * closest to the centroid.
 * </ul>
 *
 * @version 1.7
 *
 * @constructor
 */
jsts.algorithm.InteriorPointLine = function(geometry) {
 
    this.centroid;
    this.minDistance = Number.MAX_VALUE;
    this.interiorPoint = null;
    
    this.centroid = geometry.getCentroid().getCoordinate();
    this.addInterior(geometry);
    if (this.interiorPoint == null) {
        this.addEndpoints(geometry);
    }
};

jsts.algorithm.InteriorPointLine.prototype.getInteriorPoint = function() {
    return this.interiorPoint;
};

/**
 * Tests the interior vertices (if any)
 * defined by a linear Geometry for the best inside point.
 * If a Geometry is not of dimension 1 it is not tested.
 * @param {jsts.geom.Coordinate} geometry the geometry to add
 * @private
 */
jsts.algorithm.InteriorPointLine.prototype.addInterior = function(geometry) {
    if (geometry instanceof jsts.geom.LineString) {
        this.addInteriorCoord(geometry.getCoordinates());
    } else if (geometry instanceof jsts.geom.GeometryCollection) {
        for (var i = 0; i < geometry.getNumGeometries(); i++) {
            this.addInterior(geometry.getGeometryN(i));
        }
    }
};

/**
 * @private
 */
jsts.algorithm.InteriorPointLine.prototype.addInteriorCoord = function(pts) {
    for (var i = 1; i < pts.length - 1; i++) {
        this.add(pts[i]);
    }
};

/**
 * Tests the endpoint vertices
 * defined by a linear Geometry for the best inside point.
 * If a Geometry is not of dimension 1 it is not tested.
 * @param geom the geometry to add
 * @private
 */
jsts.algorithm.InteriorPointLine.prototype.addEndpoints = function(geometry) {
    if (geometry instanceof jsts.geom.LineString) {
        this.addEndpointsCoord(geometry.getCoordinates());
    } else if (geometry instanceof jsts.geom.GeometryCollection) {
        for (var i = 0; i < geometry.getNumGeometries(); i++) {
            this.addEndpoints(geometry.getGeometryN(i));
        }
    }
};

/**
 * @private
 */
jsts.algorithm.InteriorPointLine.prototype.addEndpointsCoord = function(pts) {
    this.add(pts[0]);
    this.add(pts[pts.length - 1]);
};

/**
 * @private
 */
jsts.algorithm.InteriorPointLine.prototype.add = function(point) {
    var dist = point.distance(this.centroid);
    if (dist < this.minDistance) {
        this.interiorPoint = new jsts.geom.Coordinate(point);
        this.minDistance = dist;
    }
};
/* ======================================================================
    jsts/index/chain/MonotoneChainSelectAction.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @requires jsts/geom/Envelope.js
 * @requires jsts/geom/LineSegment.js
 */

/**
 * The action for the internal iterator for performing envelope select queries
 * on a MonotoneChain
 *
 * @constructor
 */
jsts.index.chain.MonotoneChainSelectAction = function() {
  this.tempEnv1 = new jsts.geom.Envelope();
  this.selectedSegment = new jsts.geom.LineSegment();
};



jsts.index.chain.MonotoneChainSelectAction.prototype.tempEnv1 = null;

jsts.index.chain.MonotoneChainSelectAction.prototype.selectedSegment = null;

/**
 * This function can be overridden if the original chain is needed.
 */
jsts.index.chain.MonotoneChainSelectAction.prototype.select = function(mc,
    start) {
  mc.getLineSegment(start, this.selectedSegment);
  this.select2(this.selectedSegment);
};

/**
 * This is a convenience function which can be overridden to obtain the actual
 * line segment which is selected.
 *
 * @param seg
 */
jsts.index.chain.MonotoneChainSelectAction.prototype.select2 = function(seg) {};
/* ======================================================================
    jsts/algorithm/MCPointInRing.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @requires jsts/index/chain/MonotoneChainSelectAction.js
 */

/**
 * Implements {@link PointInRing} using {@link MonotoneChain}s and a
 * {@link Bintree} index to increase performance.
 *
 * @see IndexedPointInAreaLocator for more general functionality
 */
jsts.algorithm.MCPointInRing = function(ring) {
  this.ring = ring;
  this.tree = null;
  this.crossings = 0;
  this.interval = new jsts.index.bintree.Interval();
  this.buildIndex();
};

/**
 *
 * @param {jsts.geom.Coordinate}
 *          p the input coordinate.
 * @return {jsts.algorithm.MCPointInRing.MCSelecter}
 * @constructor
 */
jsts.algorithm.MCPointInRing.MCSelecter = function(p,parent) {
  this.parent = parent; //To be used instead of inner-class function calls
  this.p = p;
};

jsts.algorithm.MCPointInRing.MCSelecter.prototype = new jsts.index.chain.MonotoneChainSelectAction;
jsts.algorithm.MCPointInRing.MCSelecter.prototype.constructor = jsts.algorithm.MCPointInRing.MCSelecter;

jsts.algorithm.MCPointInRing.MCSelecter.prototype.select2 = function(ls) {
  this.parent.testLineSegment.apply(this.parent, [this.p, ls]);
  //this.testLineSegment(this.p, ls);
};

jsts.algorithm.MCPointInRing.prototype.buildIndex = function() {
  this.tree = new jsts.index.bintree.Bintree();

  var pts = jsts.geom.CoordinateArrays.removeRepeatedPoints(this.ring
      .getCoordinates());

  var mcList = jsts.index.chain.MonotoneChainBuilder.getChains(pts);

  for (var i = 0; i < mcList.length; i++) {
    var mc = mcList[i];
    var mcEnv = mc.getEnvelope();
    this.interval.min = mcEnv.getMinY();
    this.interval.max = mcEnv.getMaxY();
    this.tree.insert(this.interval, mc);
  }
};

jsts.algorithm.MCPointInRing.prototype.isInside = function(pt) {
  this.crossings = 0;

  // test all segments intersected by ray from pt in positive x direction
  var rayEnv = new jsts.geom.Envelope(-Number.MAX_VALUE, Number.MAX_VALUE, pt.y,
      pt.y);

  this.interval.min = pt.y;
  this.interval.max = pt.y;

  var segs = this.tree.query(this.interval);

  var mcSelecter = new jsts.algorithm.MCPointInRing.MCSelecter(pt, this);

  for (var i = segs.iterator(); i.hasNext();) {
    var mc = i.next();
    this.testMonotoneChain(rayEnv, mcSelecter, mc);
  }

  /*
   *  p is inside if number of crossings is odd.
   */
  if ((this.crossings % 2) == 1) {
    return true;
  }
  return false;

};

jsts.algorithm.MCPointInRing.prototype.testMonotoneChain = function(rayEnv,
    mcSelecter, mc) {
  mc.select(rayEnv, mcSelecter);
};

jsts.algorithm.MCPointInRing.prototype.testLineSegment = function(p, seg) {
  var xInt, x1, y1, x2, y2, p1, p2;

  /*
   *  Test if segment crosses ray from test point in positive x direction.
   */
  p1 = seg.p0;
  p2 = seg.p1;

  x1 = p1.x - p.x;
  y1 = p1.y - p.y;
  x2 = p2.x - p.x;
  y2 = p2.y - p.y;

  if (((y1 > 0) && (y2 <= 0)) || ((y2 > 0) && (y1 <= 0))) {
    /*
     *  segment straddles x axis, so compute intersection.
     */
    xInt = jsts.algorithm.RobustDeterminant.signOfDet2x2(x1, y1, x2, y2) /
        (y2 - y1);
    // xsave = xInt;
    /*
     *  crosses ray if strictly positive intersection.
     */
    if (0.0 < xInt) {
      this.crossings++;
    }
  }
};
/* ======================================================================
    jsts/operation/valid/TopologyValidationError.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * Contains information about the nature and location of a {@link Geometry}
 * validation error
 *
 * @version 1.7
 */

/**
 *
 * Creates a validation error with the given type and location
 *
 * @param errorType
 *          the type of the error.
 *
 * @param pt
 *          the location of the error.
 *
 */
jsts.operation.valid.TopologyValidationError = function(errorType, pt) {
  this.errorType = errorType;
  this.pt = null;

  if (pt != null) {
    this.pt = pt.clone();
  }
};

/**
 *
 * Indicates that a hole of a polygon lies partially or completely in the
 * exterior of the shell
 *
 */
jsts.operation.valid.TopologyValidationError.HOLE_OUTSIDE_SHELL = 2;

/**
 *
 * Indicates that a hole lies in the interior of another hole in the same
 * polygon
 *
 */
jsts.operation.valid.TopologyValidationError.NESTED_HOLES = 3;

/**
 *
 * Indicates that the interior of a polygon is disjoint
 *
 * (often caused by set of contiguous holes splitting the polygon into two
 * parts)
 *
 */
jsts.operation.valid.TopologyValidationError.DISCONNECTED_INTERIOR = 4;

/**
 *
 * Indicates that two rings of a polygonal geometry intersect
 *
 */
jsts.operation.valid.TopologyValidationError.SELF_INTERSECTION = 5;

/**
 *
 * Indicates that a ring self-intersects
 *
 */
jsts.operation.valid.TopologyValidationError.RING_SELF_INTERSECTION = 6;

/**
 *
 * Indicates that a polygon component of a MultiPolygon lies inside another
 * polygonal component
 *
 */
jsts.operation.valid.TopologyValidationError.NESTED_SHELLS = 7;

/**
 *
 * Indicates that a polygonal geometry contains two rings which are identical
 *
 */
jsts.operation.valid.TopologyValidationError.DUPLICATE_RINGS = 8;

/**
 *
 * Indicates that either
 * <ul>
 * <li>a LineString contains a single point
 * <li>a LinearRing contains 2 or 3 points
 * </ul>
 *
 */
jsts.operation.valid.TopologyValidationError.TOO_FEW_POINTS = 9;

/**
 *
 * Indicates that the <code>X</code> or <code>Y</code> ordinate of
 * a Coordinate is not a valid numeric value (e.g. {@link Double#NaN} )
 *
 */
jsts.operation.valid.TopologyValidationError.INVALID_COORDINATE = 10;

/**
 *
 * Indicates that a ring is not correctly closed
 * (the first and the last coordinate are different)
 *
 */
jsts.operation.valid.TopologyValidationError.RING_NOT_CLOSED = 11;

/**
 *
 * Messages corresponding to error codes
 *
 */
jsts.operation.valid.TopologyValidationError.prototype.errMsg = [
'Topology Validation Error',
'Repeated Point',
'Hole lies outside shell',
'Holes are nested',
'Interior is disconnected',
'Self-intersection',
'Ring Self-intersection',
'Nested shells',
'Duplicate Rings',
'Too few distinct points in geometry component',
'Invalid Coordinate',
'Ring is not closed'
];

/**
 * Creates a validation error of the given type with a null location
 *
 * @param errorType
 *          the type of the error
 *
 * jsts.operation.valid.TopologyValidationError(int errorType) // cannot
 * overload constructors, use above with null as arg 2
 *  {
 * this(errorType, null);
 *  }
 */

/**
 *
 * Returns the location of this error (on the {@link Geometry} containing the
 * error).
 *
 *
 *
 * @return a {@link Coordinate} on the input geometry.
 *
 */
jsts.operation.valid.TopologyValidationError.prototype.getCoordinate = function() {
  return this.pt;
};

/**
 *
 * Gets the type of this error.
 * @return the error type.
 *
 */
jsts.operation.valid.TopologyValidationError.prototype.getErrorType = function() {
  return this.errorType;
};

/**
 *
 * Gets an error message describing this error.
 * The error message does not describe the location of the error.
 * @return the error message.
 *
 */
jsts.operation.valid.TopologyValidationError.prototype.getMessage = function() {
  return this.errMsg[this.errorType];
};

/**
 *
 * Gets a message describing the type and location of this error.
 * @return the error message.
 *
 */
jsts.operation.valid.TopologyValidationError.prototype.toString = function() {
  var locStr = '';
  if (this.pt != null) {
    locStr = ' at or near point ' + this.pt;
    return this.getMessage() + locStr;
  }
  return locStr;
};
/* ======================================================================
    jsts/geom/MultiPolygon.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * @requires jsts/geom/GeometryCollection.js
   */

  /**
   * @constructor
   * @extends jsts.geom.GeometryCollection
   */
  jsts.geom.MultiPolygon = function(geometries, factory) {
    this.geometries = geometries || [];
    this.factory = factory;
  };

  jsts.geom.MultiPolygon.prototype = new jsts.geom.GeometryCollection();
  jsts.geom.MultiPolygon.constructor = jsts.geom.MultiPolygon;

  /**
   * Computes the boundary of this geometry
   *
   * @return {Geometry} a lineal geometry (which may be empty).
   * @see Geometry#getBoundary
   */
  jsts.geom.MultiPolygon.prototype.getBoundary = function() {
    if (this.isEmpty()) {
      return this.getFactory().createMultiLineString(null);
    }
    var allRings = [];
    for (var i = 0; i < this.geometries.length; i++) {
      var polygon = this.geometries[i];
      var rings = polygon.getBoundary();
      for (var j = 0; j < rings.getNumGeometries(); j++) {
        allRings.push(rings.getGeometryN(j));
      }
    }
    return this.getFactory().createMultiLineString(allRings);
  };


  /**
   * @param {Geometry}
   *          other
   * @param {double}
   *          tolerance
   * @return {boolean}
   */
  jsts.geom.MultiPolygon.prototype.equalsExact = function(other, tolerance) {
    if (!this.isEquivalentClass(other)) {
      return false;
    }
    return jsts.geom.GeometryCollection.prototype.equalsExact.call(this, other,
        tolerance);
  };

  jsts.geom.MultiPolygon.prototype.CLASS_NAME = 'jsts.geom.MultiPolygon';

})();
/* ======================================================================
    jsts/geom/CoordinateSequenceFilter.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Port source:
 * /jts/jts/java/src/com/vividsolutions/jts/geom/CoordinateSequenceFilter.js
 * Revision: 6
 */


/**
 * Interface for classes which provide operations that can be applied to the
 * coordinates in a {@link CoordinateSequence}. A CoordinateSequence filter can
 * either record information about each coordinate or change the coordinate in
 * some way. CoordinateSequence filters can be used to implement such things as
 * coordinate transformations, centroid and envelope computation, and many other
 * functions. For maximum efficiency, the execution of filters can be
 * short-circuited. {@link Geometry} classes support the concept of applying a
 * <code>CoordinateSequenceFilter</code> to each {@link CoordinateSequence}s
 * they contain.
 * <p>
 * <code>CoordinateSequenceFilter</code> is an example of the Gang-of-Four
 * Visitor pattern.
 *
 * @see Geometry#apply(CoordinateSequenceFilter)
 */
jsts.geom.CoordinateSequenceFilter = function() {

};

/**
 * Performs an operation on a coordinate in a {@link CoordinateSequence}.
 *
 * @param seq
 *          the <code>CoordinateSequence</code> to which the filter is applied.
 * @param i
 *          the index of the coordinate to apply the filter to.
 */
jsts.geom.CoordinateSequenceFilter.prototype.filter = jsts.abstractFunc;

/**
 * Reports whether the application of this filter can be terminated. Once this
 * method returns <tt>false</tt>, it should continue to return <tt>false</tt>
 * on every subsequent call.
 *
 * @return true if the application of this filter can be terminated.
 */
jsts.geom.CoordinateSequenceFilter.prototype.isDone = jsts.abstractFunc;

/**
 * Reports whether the execution of this filter has modified the coordinates of
 * the geometry. If so, {@link Geometry#geometryChanged} will be executed after
 * this filter has finished being executed.
 * <p>
 * Most filters can simply return a constant value reflecting whether they are
 * able to change the coordinates.
 *
 * @return true if this filter has changed the coordinates of the geometry.
 */
jsts.geom.CoordinateSequenceFilter.prototype.isGeometryChanged = jsts.abstractFunc;
/* ======================================================================
    jsts/index/bintree/Interval.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Represents an (1-dimensional) closed interval on the Real number line.
 *
 */
(function() {
  /**
   * Constructs a new Interval and initializes it if arguments is provided
   *
   * @constructor
   * @param {None}
   *          If no argument is specified, it will be initialized with 0.0, 0.0.
   * @param {Number},
   *          { Number } min, max It can be initialized with min <-> max.
   * @param {jsts.index.bintree.Interval}
   *          It can also be initialized with another interval.
   */
  var Interval = function() {
    this.min = 0.0;
    this.max = 0.0;

    if (arguments.length === 1) {
      var interval = arguments[0];
      this.init(interval.min, interval.max);
    }else if (arguments.length === 2) {
      this.init(arguments[0], arguments[1]);
    }
  };

  /**
   * Initializes the interval
   *
   * @param {Number}
   *          min
   * @param {Number}
   *          max
   */
  Interval.prototype.init = function(min, max) {
    this.min = min;
    this.max = max;
    if (min > max) {
      this.min = max;
      this.max = min;
    }
  };

  Interval.prototype.getMin = function() {
    return this.min;
  };

  Interval.prototype.getMax = function() {
    return this.max;
  };

  Interval.prototype.getWidth = function() {
    return (this.max - this.min);
  };

  /**
   * Expands this interval to include another interval
   *
   * @param {jsts.index.bintree.Interval}
   *          interval the interval to include.
   */
  Interval.prototype.expandToInclude = function(interval) {
    if (interval.max > this.max) {
      this.max = interval.max;
    }
    if (interval.min < this.min) {
      this.min = interval.min;
    }
  };

  /**
   * Checks if this interval overlaps. Calls correct overlaps- function based on
   * arguments
   *
   * @return {Boolean} true if the interval overlaps.
   */
  Interval.prototype.overlaps = function() {
    if (arguments.length === 1) {
      return this.overlapsInterval.apply(this, arguments);
    }else {
      return this.overlapsMinMax.apply(this, arguments);
    }
  };

  /**
   * Checks if this inteval overlaps another interval
   *
   * @param {jsts.index.bintree.Interval}
   *          interval the interval to check.
   * @return {Boolean} true if the interval overlaps.
   */
  Interval.prototype.overlapsInterval = function(interval) {
    return this.overlaps(interval.min, interval.max);
  };

  /**
   * Checks if this inteval overlaps the specified min/max values
   *
   * @param {Number}
   *          min minimum.
   * @param {Number}
   *          max maximum.
   * @return {Boolean} true if the interval overlaps.
   */
  Interval.prototype.overlapsMinMax = function(min, max) {
    if (this.min > max || this.max < min) {
      return false;
    }
    return true;
  };

  /**
   * Checks if this interval contains an interval, min -max pair or a point
   *
   * @return {Boolean} true if this interval contains the specified argument.
   */
  Interval.prototype.contains = function() {
    var interval;
    if (arguments[0] instanceof jsts.index.bintree.Interval) {
      interval = arguments[0];
      return this.containsMinMax(interval.min, interval.max);
    }else if (arguments.length === 1) {
      return this.containsPoint(arguments[0]);
    }else {
      return this.containsMinMax(arguments[0], arguments[1]);
    }
  };

  /**
   * Checks if this interval contains the min- and max-point provided
   *
   * @param {Number}
   *          min the minpoint.
   * @param {Number}
   *          max the maxpoint.
   */
  Interval.prototype.containsMinMax = function(min, max) {
    return (min >= this.min && max <= this.max);
  };

  /**
   * Checks if this interval contains the specified point
   *
   * @param {Number}
   *          p the point to check.
   */
  Interval.prototype.containsPoint = function(p) {
    return (p >= this.min && p <= this.max);
  };

  jsts.index.bintree.Interval = Interval;
})();
/* ======================================================================
    jsts/index/DoubleBits.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * DoubleBits manipulates Double numbers by using bit manipulation and bit-field
 * extraction. For some operations (such as determining the exponent) this is
 * more accurate than using mathematical operations (which suffer from round-off
 * error).
 * <p>
 * The algorithms and constants in this class apply only to IEEE-754
 * double-precision floating point format.
 *
 * NOTE: Since the only numberformat in JavaScript is IEEE-754 the code in
 * DoubleBits could not be easily ported.
 *
 * Instead, using algorithms found here:
 * http://www.merlyn.demon.co.uk/js-exact.htm
 *
 * @constructor
 */
jsts.index.DoubleBits = function() {

};


/**
 * Calculates the power of two for a number
 *
 * @param {Number}
 *          exp value to pow.
 * @return {Number} the pow'ed value.
 */
jsts.index.DoubleBits.powerOf2 = function(exp) {
  // TODO: Make sure the accuracy of this is sufficient (why else would JTS have
  // this in DoubleBits?)
  return Math.pow(2, exp);
};


/**
 * Calculates the exponent-part of the bit-pattern for a number
 *
 * @param {Number}
 *          d the IEEE-754-value to calculate the exponent for.
 * @return {Number} the exponent part of the bit-mask.
 */
jsts.index.DoubleBits.exponent = function(d) {
  return jsts.index.DoubleBits.CVTFWD(64, d) - 1023;
};


/**
 * Calculates the exponent of the bit-pattern for a number. Uses code from:
 * http://www.merlyn.demon.co.uk/js-exact.htm
 *
 * @param {Number}
 *          NumW 32 or 64 to denote the number of bits.
 * @param {Number}
 *          Qty the number to calculate the bit pattern for.
 * @return {Number} The integer value of the exponent.
 */
jsts.index.DoubleBits.CVTFWD = function(NumW, Qty) {
  var Sign, Expo, Mant, Bin, nb01 = ''; // , OutW = NumW/4
  var Inf = {
    32: {
      d: 0x7F,
      c: 0x80,
      b: 0,
      a: 0
    },
    64: {
      d: 0x7FF0,
      c: 0,
      b: 0,
      a: 0
    }
  };
  var ExW = {
    32: 8,
    64: 11
  }[NumW], MtW = NumW - ExW - 1;

  if (!Bin) {
    Sign = Qty < 0 || 1 / Qty < 0; // OK for +-0
    if (!isFinite(Qty)) {
      Bin = Inf[NumW];
      if (Sign) {
        Bin.d += 1 << (NumW / 4 - 1);
      }
      Expo = Math.pow(2, ExW) - 1;
      Mant = 0;
    }
  }

  if (!Bin) {
    Expo = {
      32: 127,
      64: 1023
    }[NumW];
    Mant = Math.abs(Qty);
    while (Mant >= 2) {
      Expo++;
      Mant /= 2;
    }
    while (Mant < 1 && Expo > 0) {
      Expo--;
      Mant *= 2;
    }
    if (Expo <= 0) {
      Mant /= 2;
      nb01 = 'Zero or Denormal';
    }
    if (NumW === 32 && Expo > 254) {
      nb01 = 'Too big for Single';
      Bin = {
        d: Sign ? 0xFF : 0x7F,
        c: 0x80,
        b: 0,
        a: 0
      };
      Expo = Math.pow(2, ExW) - 1;
      Mant = 0;
    }
  }

  return Expo;
};
/* ======================================================================
    jsts/index/bintree/Key.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * A Key is a unique identifier for a node in a tree. It contains a lower-left
 * point and a level number. The level number is the power of two for the size
 * of the node envelope
 */
(function() {

  /**
   * @requires jsts/index/bintree/Interval.js
   * @requires jsts/index/DoubleBits.js
   */

  var DoubleBits = jsts.index.DoubleBits;
  var Interval = jsts.index.bintree.Interval;

  /**
   * Constructs a new Key
   *
   * @constructor
   * @param {jsts.index.bintree.Interval}
   *          interval the interval to compute the key from.
   */
  var Key = function(interval) {
    this.pt = 0.0;
    this.level = 0;

    this.computeKey(interval);
  };

  /**
   * Computes the level for an interval
   *
   * @param {jsts.index.bintree.Interval}
   *          interval the interval.
   * @results {Number} the calculated level
   */
  Key.computeLevel = function(interval) {
    var dx = interval.getWidth(), level;

    level = DoubleBits.exponent(dx) + 1;
    return level;
  };

  /**
   * Returns the point
   *
   * @return {Number} point.
   */
  Key.prototype.getPoint = function() {
    return this.pt;
  };

  /**
   * Returns the level
   *
   * @return {Number} level.
   */
  Key.prototype.getLevel = function() {
    return this.level;
  };

  /**
   * Returns the interval
   *
   * @return {jsts.index.bintree.Interval}
   */
  Key.prototype.getInterval = function() {
    return this.interval;
  };

  /**
   * Calculates the key
   *
   * @param {jsts.index.bintree.Interval}
   *          itemInterval the interval.
   */
  Key.prototype.computeKey = function(itemInterval) {
    this.level = Key.computeLevel(itemInterval);
    this.interval = new Interval();
    this.computeInterval(this.level, itemInterval);
    // MD - would be nice to have a non-iterative form of this algorithm
    while (!this.interval.contains(itemInterval)) {
      this.level += 1;
      this.computeInterval(this.level, itemInterval);
    }
  };

  /**
   * Computes the interval
   *
   * @param {Number}
   *          level the level.
   * @param {jsts.index.bintree.Interval}
   *          itemInterval an interval.
   */
  Key.prototype.computeInterval = function(level, itemInterval) {
    var size = DoubleBits.powerOf2(level);

    this.pt = Math.floor(itemInterval.getMin() / size) * size;
    this.interval.init(this.pt, this.pt + size);
  };

  jsts.index.bintree.Key = Key;
})();
/* ======================================================================
    jsts/operation/buffer/SubgraphDepthLocater.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Locates a subgraph inside a set of subgraphs, in order to determine the
 * outside depth of the subgraph. The input subgraphs are assumed to have had
 * depths already calculated for their edges.
 *
 * @constructor
 */
jsts.operation.buffer.SubgraphDepthLocater = function(subgraphs) {
  this.subgraphs = [];
  this.seg = new jsts.geom.LineSegment();

  this.subgraphs = subgraphs;
};

jsts.operation.buffer.SubgraphDepthLocater.prototype.subgraphs = null;
jsts.operation.buffer.SubgraphDepthLocater.prototype.seg = null;


jsts.operation.buffer.SubgraphDepthLocater.prototype.getDepth = function(p) {
  var stabbedSegments = this.findStabbedSegments(p);
  // if no segments on stabbing line subgraph must be outside all others.
  if (stabbedSegments.length === 0)
    return 0;
  stabbedSegments.sort();
  var ds = stabbedSegments[0];
  return ds.leftDepth;
};

/**
 * Finds all non-horizontal segments intersecting the stabbing line. The
 * stabbing line is the ray to the right of stabbingRayLeftPt.
 *
 * @param stabbingRayLeftPt
 *          the left-hand origin of the stabbing line.
 * @return a List of {@link DepthSegments} intersecting the stabbing line.
 * @private
 */
jsts.operation.buffer.SubgraphDepthLocater.prototype.findStabbedSegments = function(
    stabbingRayLeftPt) {

  if (arguments.length === 3) {
    this.findStabbedSegments2.apply(this, arguments);
    return;
  }

  var stabbedSegments = [];
  for (var i = 0; i < this.subgraphs.length; i++) {
    var bsg = this.subgraphs[i];

    // optimization - don't bother checking subgraphs which the ray does not
    // intersect
    var env = bsg.getEnvelope();
    if (stabbingRayLeftPt.y < env.getMinY() ||
        stabbingRayLeftPt.y > env.getMaxY())
      continue;

    this.findStabbedSegments2(stabbingRayLeftPt, bsg.getDirectedEdges(),
        stabbedSegments);
  }
  return stabbedSegments;
};

/**
 * Finds all non-horizontal segments intersecting the stabbing line in the list
 * of dirEdges. The stabbing line is the ray to the right of stabbingRayLeftPt.
 *
 * @param stabbingRayLeftPt
 *          the left-hand origin of the stabbing line.
 * @param stabbedSegments
 *          the current list of {@link DepthSegments} intersecting the stabbing
 *          line.
 * @private
 */
jsts.operation.buffer.SubgraphDepthLocater.prototype.findStabbedSegments2 = function(
    stabbingRayLeftPt, dirEdges, stabbedSegments) {

  if (arguments[1] instanceof jsts.geomgraph.DirectedEdge) {
    this.findStabbedSegments3(stabbingRayLeftPt, dirEdges, stabbedSegments);
    return;
  }

  /**
   * Check all forward DirectedEdges only. This is still general, because each
   * Edge has a forward DirectedEdge.
   */
  for (var i = dirEdges.iterator(); i.hasNext();) {
    var de = i.next();
    if (! de.isForward())
      continue;
    this.findStabbedSegments3(stabbingRayLeftPt, de, stabbedSegments);
  }
};

/**
 * Finds all non-horizontal segments intersecting the stabbing line in the input
 * dirEdge. The stabbing line is the ray to the right of stabbingRayLeftPt.
 *
 * @param stabbingRayLeftPt
 *          the left-hand origin of the stabbing line.
 * @param stabbedSegments
 *          the current list of {@link DepthSegments} intersecting the stabbing
 *          line.
 * @private
 */
jsts.operation.buffer.SubgraphDepthLocater.prototype.findStabbedSegments3 = function(
    stabbingRayLeftPt, dirEdge, stabbedSegments) {
  var pts = dirEdge.getEdge().getCoordinates();
  for (var i = 0; i < pts.length - 1; i++) {
    this.seg.p0 = pts[i];
    this.seg.p1 = pts[i + 1];
    // ensure segment always points upwards
    if (this.seg.p0.y > this.seg.p1.y)
      this.seg.reverse();

    // skip segment if it is left of the stabbing line
    var maxx = Math.max(this.seg.p0.x, this.seg.p1.x);
    if (maxx < stabbingRayLeftPt.x)
      continue;

    // skip horizontal segments (there will be a non-horizontal one carrying the
    // same depth info
    if (this.seg.isHorizontal())
      continue;

    // skip if segment is above or below stabbing line
    if (stabbingRayLeftPt.y < this.seg.p0.y || stabbingRayLeftPt.y > this.seg.p1.y)
      continue;

    // skip if stabbing ray is right of the segment
    if (jsts.algorithm.CGAlgorithms.computeOrientation(this.seg.p0, this.seg.p1,
        stabbingRayLeftPt) === jsts.algorithm.CGAlgorithms.RIGHT)
      continue;

    // stabbing line cuts this segment, so record it
    var depth = dirEdge.getDepth(jsts.geomgraph.Position.LEFT);
    // if segment direction was flipped, use RHS depth instead
    if (!this.seg.p0.equals(pts[i]))
      depth = dirEdge.getDepth(jsts.geomgraph.Position.RIGHT);
    var ds = new jsts.operation.buffer.SubgraphDepthLocater.DepthSegment(this.seg, depth);
    stabbedSegments.push(ds);
  }
};


/**
 * A segment from a directed edge which has been assigned a depth value for its
 * sides.
 */
jsts.operation.buffer.SubgraphDepthLocater.DepthSegment = function(seg, depth) {
  // input seg is assumed to be normalized
  this.upwardSeg = new jsts.geom.LineSegment(seg);
  // upwardSeg.normalize();
  this.leftDepth = depth;
};
jsts.operation.buffer.SubgraphDepthLocater.DepthSegment.prototype.upwardSeg = null;
jsts.operation.buffer.SubgraphDepthLocater.DepthSegment.prototype.leftDepth = null;

/**
 * Defines a comparision operation on DepthSegments which orders them left to
 * right
 *
 * <pre>
 * DS1 &lt; DS2   if   DS1.seg is left of DS2.seg
 * DS1 &gt; DS2   if   DS1.seg is right of DS2.seg
 * </pre>
 *
 * @param obj
 * @return
 */
jsts.operation.buffer.SubgraphDepthLocater.DepthSegment.prototype.compareTo = function(
    obj) {
  var other = obj;
  /**
   * try and compute a determinate orientation for the segments. Test returns 1
   * if other is left of this (i.e. this > other)
   */
  var orientIndex = this.upwardSeg.orientationIndex(other.upwardSeg);

  /**
   * If comparison between this and other is indeterminate, try the opposite
   * call order. orientationIndex value is 1 if this is left of other, so have
   * to flip sign to get proper comparison value of -1 if this is leftmost
   */
  if (orientIndex === 0)
    orientIndex = -1 * other.upwardSeg.orientationIndex(upwardSeg);

  // if orientation is determinate, return it
  if (orientIndex !== 0)
    return orientIndex;

  // otherwise, segs must be collinear - sort based on minimum X value
  return this.compareX(this.upwardSeg, other.upwardSeg);
};

/**
 * Compare two collinear segments for left-most ordering. If segs are vertical,
 * use vertical ordering for comparison. If segs are equal, return 0. Segments
 * are assumed to be directed so that the second coordinate is >= to the first
 * (e.g. up and to the right).
 *
 * @param seg0
 *          a segment to compare.
 * @param seg1
 *          a segment to compare.
 * @return
 */
jsts.operation.buffer.SubgraphDepthLocater.DepthSegment.prototype.compareX = function(
    seg0, seg1) {
  var compare0 = seg0.p0.compareTo(seg1.p0);
  if (compare0 !== 0)
    return compare0;
  return seg0.p1.compareTo(seg1.p1);

};
/* ======================================================================
    jsts/noding/snapround/HotPixel.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Port source:
 * /jts/jts/java/src/com/vividsolutions/jts/noding/snapround/HotPixel.java
 * Revision: 143
 */

/**
 * Implements a "hot pixel" as used in the Snap Rounding algorithm.
 * A hot pixel contains the interior of the tolerance square and
 * the boundary
 * <b>minus</b> the top and right segments.
 * <p>
 * The hot pixel operations are all computed in the integer domain
 * to avoid rounding problems.
 */

/**
 * Creates a new hot pixel.
 *
 * @param pt
 *          the coordinate at the centre of the pixel.
 * @param scaleFactor
 *          the scaleFactor determining the pixel size.
 * @param li
 *          the intersector to use for testing intersection with line segments.
 */
jsts.noding.snapround.HotPixel = function(pt, scaleFactor, li) {
  this.corner = [];

  this.originalPt = pt;
  this.pt = pt;
  this.scaleFactor = scaleFactor;
  this.li = li;
  if (this.scaleFactor !== 1.0) {
    this.pt = new jsts.geom.Coordinate(this.scale(pt.x), this.scale(pt.y));
    this.p0Scaled = new jsts.geom.Coordinate();
    this.p1Scaled = new jsts.geom.Coordinate();
  }
  this.initCorners(this.pt);
};

jsts.noding.snapround.HotPixel.prototype.li = null;

jsts.noding.snapround.HotPixel.prototype.pt = null;
jsts.noding.snapround.HotPixel.prototype.originalPt = null;
jsts.noding.snapround.HotPixel.prototype.ptScaled = null;

jsts.noding.snapround.HotPixel.prototype.p0Scaled = null;
jsts.noding.snapround.HotPixel.prototype.p1Scaled = null;

jsts.noding.snapround.HotPixel.prototype.scaleFactor = undefined;

jsts.noding.snapround.HotPixel.prototype.minx = undefined;
jsts.noding.snapround.HotPixel.prototype.maxx = undefined;
jsts.noding.snapround.HotPixel.prototype.miny = undefined;
jsts.noding.snapround.HotPixel.prototype.maxy = undefined;

/**
 * The corners of the hot pixel, in the order: 10 23
 */
jsts.noding.snapround.HotPixel.prototype.corner = null;

jsts.noding.snapround.HotPixel.prototype.safeEnv = null;


/**
 * Gets the coordinate this hot pixel is based at.
 *
 * @return the coordinate of the pixel.
 */
jsts.noding.snapround.HotPixel.prototype.getCoordinate = function() {
  return this.originalPt;
};

jsts.noding.snapround.HotPixel.SAFE_ENV_EXPANSION_FACTOR = 0.75;

/**
 * Returns a "safe" envelope that is guaranteed to contain the hot pixel. The
 * envelope returned will be larger than the exact envelope of the pixel.
 *
 * @return an envelope which contains the hot pixel.
 */
jsts.noding.snapround.HotPixel.prototype.getSafeEnvelope = function() {
  if (this.safeEnv === null) {
    var safeTolerance = jsts.noding.snapround.HotPixel.SAFE_ENV_EXPANSION_FACTOR /
        this.scaleFactor;
    this.safeEnv = new jsts.geom.Envelope(this.originalPt.x - safeTolerance,
        this.originalPt.x + safeTolerance, this.originalPt.y - safeTolerance,
        this.originalPt.y + safeTolerance);
  }
  return this.safeEnv;
};

jsts.noding.snapround.HotPixel.prototype.initCorners = function(pt) {
  var tolerance = 0.5;
  this.minx = pt.x - tolerance;
  this.maxx = pt.x + tolerance;
  this.miny = pt.y - tolerance;
  this.maxy = pt.y + tolerance;

  this.corner[0] = new jsts.geom.Coordinate(this.maxx, this.maxy);
  this.corner[1] = new jsts.geom.Coordinate(this.minx, this.maxy);
  this.corner[2] = new jsts.geom.Coordinate(this.minx, this.miny);
  this.corner[3] = new jsts.geom.Coordinate(this.maxx, this.miny);
};

/**
 * @private
 */
jsts.noding.snapround.HotPixel.prototype.scale = function(val) {
  return Math.round(val * this.scaleFactor);
};

/**
 * Tests whether the line segment (p0-p1) intersects this hot pixel.
 *
 * @param p0
 *          the first coordinate of the line segment to test.
 * @param p1
 *          the second coordinate of the line segment to test.
 * @return true if the line segment intersects this hot pixel.
 */
jsts.noding.snapround.HotPixel.prototype.intersects = function(p0, p1) {
  if (this.scaleFactor === 1.0)
    return this.intersectsScaled(p0, p1);

  this.copyScaled(p0, this.p0Scaled);
  this.copyScaled(p1, this.p1Scaled);
  return this.intersectsScaled(this.p0Scaled, this.p1Scaled);
};

/**
 * @private
 */
jsts.noding.snapround.HotPixel.prototype.copyScaled = function(p, pScaled) {
  pScaled.x = this.scale(p.x);
  pScaled.y = this.scale(p.y);
};

/**
 * @private
 */
jsts.noding.snapround.HotPixel.prototype.intersectsScaled = function(p0, p1) {
  var segMinx = Math.min(p0.x, p1.x);
  var segMaxx = Math.max(p0.x, p1.x);
  var segMiny = Math.min(p0.y, p1.y);
  var segMaxy = Math.max(p0.y, p1.y);

  var isOutsidePixelEnv = this.maxx < segMinx || this.minx > segMaxx ||
      this.maxy < segMiny || this.miny > segMaxy;
  if (isOutsidePixelEnv)
    return false;
  var intersects = this.intersectsToleranceSquare(p0, p1);

  jsts.util.Assert.isTrue(!(isOutsidePixelEnv && intersects),
      'Found bad envelope test');

  return intersects;
};

/**
 * Tests whether the segment p0-p1 intersects the hot pixel tolerance square.
 * Because the tolerance square point set is partially open (along the top and
 * right) the test needs to be more sophisticated than simply checking for any
 * intersection. However, it can take advantage of the fact that because the hot
 * pixel edges do not lie on the coordinate grid. It is sufficient to check if
 * there is at least one of:
 * <ul>
 * <li>a proper intersection with the segment and any hot pixel edge
 * <li>an intersection between the segment and both the left and bottom edges
 * <li>an intersection between a segment endpoint and the hot pixel coordinate
 * </ul>
 *
 * @param p0
 * @param p1
 * @return
 * @private
 */
jsts.noding.snapround.HotPixel.prototype.intersectsToleranceSquare = function(
    p0, p1) {
  var intersectsLeft = false;
  var intersectsBottom = false;

  this.li.computeIntersection(p0, p1, this.corner[0], this.corner[1]);
  if (this.li.isProper())
    return true;

  this.li.computeIntersection(p0, p1, this.corner[1], this.corner[2]);
  if (this.li.isProper())
    return true;
  if (this.li.hasIntersection())
    intersectsLeft = true;

  this.li.computeIntersection(p0, p1, this.corner[2], this.corner[3]);
  if (this.li.isProper())
    return true;
  if (this.li.hasIntersection())
    intersectsBottom = true;

  this.li.computeIntersection(p0, p1, this.corner[3], this.corner[0]);
  if (this.li.isProper())
    return true;

  if (intersectsLeft && intersectsBottom)
    return true;

  if (p0.equals(this.pt))
    return true;
  if (p1.equals(this.pt))
    return true;

  return false;
};
/**
 * Test whether the given segment intersects the closure of this hot pixel. This
 * is NOT the test used in the standard snap-rounding algorithm, which uses the
 * partially closed tolerance square instead. This routine is provided for
 * testing purposes only.
 *
 * @param p0
 *          the start point of a line segment.
 * @param p1
 *          the end point of a line segment.
 * @return <code>true</code> if the segment intersects the closure of the
 *         pixel's tolerance square.
 * @private
 */
jsts.noding.snapround.HotPixel.prototype.intersectsPixelClosure = function(p0,
    p1) {
  this.li.computeIntersection(p0, p1, this.corner[0], this.corner[1]);
  if (this.li.hasIntersection())
    return true;
  this.li.computeIntersection(p0, p1, this.corner[1], this.corner[2]);
  if (this.li.hasIntersection())
    return true;
  this.li.computeIntersection(p0, p1, this.corner[2], this.corner[3]);
  if (this.li.hasIntersection())
    return true;
  this.li.computeIntersection(p0, p1, this.corner[3], this.corner[0]);
  if (this.li.hasIntersection())
    return true;

  return false;
};

/**
 * Adds a new node (equal to the snap pt) to the specified segment if the
 * segment passes through the hot pixel
 *
 * @param segStr
 * @param segIndex
 * @return true if a node was added to the segment.
 */
jsts.noding.snapround.HotPixel.prototype.addSnappedNode = function(segStr,
    segIndex) {
  var p0 = segStr.getCoordinate(segIndex);
  var p1 = segStr.getCoordinate(segIndex + 1);

  if (this.intersects(p0, p1)) {
    segStr.addIntersection(this.getCoordinate(), segIndex);

    return true;
  }
  return false;
};
/* ======================================================================
    jsts/operation/buffer/BufferInputLineSimplifier.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * Simplifies a buffer input line to remove concavities with shallow depth.
 * <p>
 * The most important benefit of doing this is to reduce the number of points
 * and the complexity of shape which will be buffered. It also reduces the risk
 * of gores created by the quantized fillet arcs (although this issue should be
 * eliminated in any case by the offset curve generation logic).
 * <p>
 * A key aspect of the simplification is that it affects inside (concave or
 * inward) corners only. Convex (outward) corners are preserved, since they are
 * required to ensure that the generated buffer curve lies at the correct
 * distance from the input geometry.
 * <p>
 * Another important heuristic used is that the end segments of the input are
 * never simplified. This ensures that the client buffer code is able to
 * generate end caps faithfully.
 * <p>
 * No attempt is made to avoid self-intersections in the output. This is
 * acceptable for use for generating a buffer offset curve, since the buffer
 * algorithm is insensitive to invalid polygonal geometry. However, this means
 * that this algorithm cannot be used as a general-purpose polygon
 * simplification technique.
 *
 * @constructor
 */
jsts.operation.buffer.BufferInputLineSimplifier = function(inputLine) {
  this.inputLine = inputLine;
};


/**
 * Simplify the input coordinate list. If the distance tolerance is positive,
 * concavities on the LEFT side of the line are simplified. If the supplied
 * distance tolerance is negative, concavities on the RIGHT side of the line are
 * simplified.
 *
 * @param inputLine
 *          the coordinate list to simplify.
 * @param distanceTol
 *          simplification distance tolerance to use.
 * @return the simplified coordinate list.
 */
jsts.operation.buffer.BufferInputLineSimplifier.simplify = function(inputLine,
    distanceTol) {
  var simp = new jsts.operation.buffer.BufferInputLineSimplifier(inputLine);
  return simp.simplify(distanceTol);
};


/**
 * @private
 */
jsts.operation.buffer.BufferInputLineSimplifier.INIT = 0;


/**
 * @private
 */
jsts.operation.buffer.BufferInputLineSimplifier.DELETE = 1;


/**
 * @private
 */
jsts.operation.buffer.BufferInputLineSimplifier.KEEP = 1;


/**
 * @private
 */
jsts.operation.buffer.BufferInputLineSimplifier.prototype.inputLine = null;


/**
 * @private
 */
jsts.operation.buffer.BufferInputLineSimplifier.prototype.distanceTol = null;


/**
 * @type {Array}
 * @private
 */
jsts.operation.buffer.BufferInputLineSimplifier.prototype.isDeleted = null;


/**
 * @private
 */
jsts.operation.buffer.BufferInputLineSimplifier.prototype.angleOrientation = jsts.algorithm.CGAlgorithms.COUNTERCLOCKWISE;


/**
 * Simplify the input coordinate list. If the distance tolerance is positive,
 * concavities on the LEFT side of the line are simplified. If the supplied
 * distance tolerance is negative, concavities on the RIGHT side of the line are
 * simplified.
 *
 * @param distanceTol
 *          simplification distance tolerance to use.
 * @return the simplified coordinate list.
 */
jsts.operation.buffer.BufferInputLineSimplifier.prototype.simplify = function(
    distanceTol) {
  this.distanceTol = Math.abs(distanceTol);
  if (distanceTol < 0)
    this.angleOrientation = jsts.algorithm.CGAlgorithms.CLOCKWISE;

  // rely on fact that boolean array is filled with false value
  this.isDeleted = [];
  this.isDeleted.length = this.inputLine.length;

  var isChanged = false;
  do {
    isChanged = this.deleteShallowConcavities();
  } while (isChanged);

  return this.collapseLine();
};


/**
 * Uses a sliding window containing 3 vertices to detect shallow angles in which
 * the middle vertex can be deleted, since it does not affect the shape of the
 * resulting buffer in a significant way.
 *
 * @return
 * @private
 */
jsts.operation.buffer.BufferInputLineSimplifier.prototype.deleteShallowConcavities = function() {
  /**
   * Do not simplify end line segments of the line string. This ensures that end
   * caps are generated consistently.
   */
  var index = 1;
  var maxIndex = this.inputLine.length - 1;

  var midIndex = this.findNextNonDeletedIndex(index);
  var lastIndex = this.findNextNonDeletedIndex(midIndex);

  var isChanged = false;
  while (lastIndex < this.inputLine.length) {
    // test triple for shallow concavity
    var isMiddleVertexDeleted = false;
    if (this.isDeletable(index, midIndex, lastIndex, this.distanceTol)) {
      this.isDeleted[midIndex] = jsts.operation.buffer.BufferInputLineSimplifier.DELETE;
      isMiddleVertexDeleted = true;
      isChanged = true;
    }
    // move simplification window forward
    if (isMiddleVertexDeleted)
      index = lastIndex;
    else
      index = midIndex;

    midIndex = this.findNextNonDeletedIndex(index);
    lastIndex = this.findNextNonDeletedIndex(midIndex);
  }
  return isChanged;
};


/**
 * Finds the next non-deleted index, or the end of the point array if none
 *
 * @param index
 * @return the next non-deleted index, if any.
 * @return inputLine.length if there are no more non-deleted indices.
 * @private
 */
jsts.operation.buffer.BufferInputLineSimplifier.prototype.findNextNonDeletedIndex = function(
    index) {
  var next = index + 1;
  while (next < this.inputLine.length &&
      this.isDeleted[next] === jsts.operation.buffer.BufferInputLineSimplifier.DELETE)
    next++;
  return next;
};


/**
 * @private
 */
jsts.operation.buffer.BufferInputLineSimplifier.prototype.collapseLine = function() {
  var coordList = [];
  for (var i = 0; i < this.inputLine.length; i++) {
    if (this.isDeleted[i] !== jsts.operation.buffer.BufferInputLineSimplifier.DELETE)
      coordList.push(this.inputLine[i]);
  }

  return coordList;
};


/**
 * @private
 */
jsts.operation.buffer.BufferInputLineSimplifier.prototype.isDeletable = function(
    i0, i1, i2, distanceTol) {
  var p0 = this.inputLine[i0];
  var p1 = this.inputLine[i1];
  var p2 = this.inputLine[i2];

  if (!this.isConcave(p0, p1, p2))
    return false;
  if (!this.isShallow(p0, p1, p2, distanceTol))
    return false;

  return this.isShallowSampled(p0, p1, i0, i2, distanceTol);
};


/**
 * @private
 */
jsts.operation.buffer.BufferInputLineSimplifier.prototype.isShallowConcavity = function(
    p0, p1, p2, distanceTol) {
  var orientation = jsts.algorithm.CGAlgorithms.computeOrientation(p0, p1, p2);
  var isAngleToSimplify = (orientation === this.angleOrientation);
  if (!isAngleToSimplify)
    return false;

  var dist = jsts.algorithm.CGAlgorithms.distancePointLine(p1, p0, p2);
  return dist < distanceTol;
};


/**
 * @private
 */
jsts.operation.buffer.BufferInputLineSimplifier.NUM_PTS_TO_CHECK = 10;


/**
 * Checks for shallowness over a sample of points in the given section. This
 * helps prevents the siplification from incrementally "skipping" over points
 * which are in fact non-shallow.
 *
 * @param p0
 *          start coordinate of section.
 * @param p2
 *          end coordinate of section.
 * @param i0
 *          start index of section.
 * @param i2
 *          end index of section.
 * @param distanceTol
 *          distance tolerance.
 * @return
 * @private
 */
jsts.operation.buffer.BufferInputLineSimplifier.prototype.isShallowSampled = function(
    p0, p2, i0, i2, distanceTol) {
  // check every n'th point to see if it is within tolerance
  var inc = parseInt((i2 - i0) /
      jsts.operation.buffer.BufferInputLineSimplifier.NUM_PTS_TO_CHECK);
  if (inc <= 0)
    inc = 1;

  for (var i = i0; i < i2; i += inc) {
    if (!this.isShallow(p0, p2, this.inputLine[i], distanceTol))
      return false;
  }
  return true;
};


/**
 * @private
 */
jsts.operation.buffer.BufferInputLineSimplifier.prototype.isShallow = function(
    p0, p1, p2, distanceTol) {
  var dist = jsts.algorithm.CGAlgorithms.distancePointLine(p1, p0, p2);
  return dist < distanceTol;
};


/**
 * @private
 */
jsts.operation.buffer.BufferInputLineSimplifier.prototype.isConcave = function(
    p0, p1, p2) {
  var orientation = jsts.algorithm.CGAlgorithms.computeOrientation(p0, p1, p2);
  var isConcave = (orientation === this.angleOrientation);
  return isConcave;
};
/* ======================================================================
    jsts/geomgraph/index/SweepLineEvent.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @param {double}
 *          x
 * @param {Object}
 *          obj
 * @param {Object}
 *          label
 * @constructor
 */
jsts.geomgraph.index.SweepLineEvent = function(
    x, obj, label) {
  // label can be null, so check object to handle overloading
  if (!(obj instanceof jsts.geomgraph.index.SweepLineEvent)) {
    this.eventType = jsts.geomgraph.index.SweepLineEvent.INSERT;
    this.label = label;
    this.xValue = x;
    this.obj = obj;
    return;
  }

  this.eventType = jsts.geomgraph.index.SweepLineEvent.DELETE;
  this.xValue = x;
  this.insertEvent = obj;
};

/**
 * @type {int} 
 */
jsts.geomgraph.index.SweepLineEvent.INSERT = 1;

/**
 * @type {int} 
 */
jsts.geomgraph.index.SweepLineEvent.DELETE = 2;

/**
 * used for red-blue intersection detection 
 *
 * @type {Object} 
 */
jsts.geomgraph.index.SweepLineEvent.prototype.label = null;

/**
 * @type {double} 
 */
jsts.geomgraph.index.SweepLineEvent.prototype.xValue = null;

/**
 * @type {int} 
 */
jsts.geomgraph.index.SweepLineEvent.prototype.eventType = null;

/**
 * null if this is an INSERT event 
 *
 * @type {SweepLineEvent} 
 */
jsts.geomgraph.index.SweepLineEvent.prototype.insertEvent = null;

/**
 * @type {int} 
 */
jsts.geomgraph.index.SweepLineEvent.prototype.deleteEventIndex = null;

/**
 * @type {Object} 
 */
jsts.geomgraph.index.SweepLineEvent.prototype.obj = null;

/**
 * @return {boolean} 
 */
jsts.geomgraph.index.SweepLineEvent.prototype.isInsert = function() {
  return this.eventType == jsts.geomgraph.index.SweepLineEvent.INSERT;
};

/**
 * @return {boolean} 
 */
jsts.geomgraph.index.SweepLineEvent.prototype.isDelete = function() {
  return this.eventType == jsts.geomgraph.index.SweepLineEvent.DELETE;
};

/**
 * @return {SweepLineEvent} 
 */
jsts.geomgraph.index.SweepLineEvent.prototype.getInsertEvent = function() {
  return this.insertEvent;
};

/**
 * @return {int} 
 */
jsts.geomgraph.index.SweepLineEvent.prototype.getDeleteEventIndex = function() {
  return this.deleteEventIndex;
};

/**
 * @param {int}
 *          deleteEventIndex 
 */
jsts.geomgraph.index.SweepLineEvent.prototype.setDeleteEventIndex = function(
    deleteEventIndex) {
  this.deleteEventIndex = deleteEventIndex;
};

/**
 * @return {Object} 
 */
jsts.geomgraph.index.SweepLineEvent.prototype.getObject = function() {
  return this.obj;
};

/**
 * @param {SweepLineEvent}
 *          ev
 * @return {boolean} 
 */
jsts.geomgraph.index.SweepLineEvent.prototype.isSameLabel = function(
    ev) {
  // no label set indicates single group
  if (this.label == null) {
    return false;
  }
  return this.label == ev.label;
};

/**
 * Events are ordered first by their x-value, and then by their eventType.
 * Insert events are sorted before Delete events, so that
 * items whose Insert and Delete events occur at the same x-value will be
 * correctly handled.
 * 
 * @param {Object}
 *          o
 * @return {SweepLineEvent}
 */
jsts.geomgraph.index.SweepLineEvent.prototype.compareTo = function(
    pe) {
  if (this.xValue < pe.xValue) {
    return -1;
  }
  if (this.xValue > pe.xValue) {
    return 1;
  }
  if (this.eventType < pe.eventType) {
    return -1;
  }
  if (this.eventType > pe.eventType) {
    return 1;
  }
  return 0;
};
/* ======================================================================
    jsts/geom/CoordinateList.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * Constructs a new list from an array of Coordinates, allowing caller to
 * specify if repeated points are to be removed.
 *
 * @param {Array.<jsts.geom.Coordinate>}
 *          coord the array of coordinates to load into the list.
 * @param {boolean}
 *          allowRepeated if <code>false</code>, repeated points are removed.
 *
 * @constructor
 */
jsts.geom.CoordinateList = function(coord, allowRepeated) {
  this.array = [];
  
  allowRepeated = (allowRepeated === undefined) ? true : allowRepeated;

  if (coord !== undefined) {
    this.add(coord, allowRepeated);
  }
};

jsts.geom.CoordinateList.prototype = new javascript.util.ArrayList();

jsts.geom.CoordinateList.prototype.iterator = null;
jsts.geom.CoordinateList.prototype.remove = null;

jsts.geom.CoordinateList.prototype.get = function(i) {
    return this.array[i];
};

jsts.geom.CoordinateList.prototype.set = function(i, e) {
    var o = this.array[i];
    this.array[i] = e;
    return o;
};

jsts.geom.CoordinateList.prototype.size = function() {
    return this.array.length;
};

// simulate overloaded methods...
jsts.geom.CoordinateList.prototype.add = function() {
    if (arguments.length>1) {
        return this.addCoordinates.apply(this, arguments);
    } else {
        return this.array.push(arguments[0]);
    }
};

/**
 * Adds an array of coordinates to the list.
 *
 * @param {Array.<jsts.geom.Coordinate>}
 *          coord The coordinates.
 * @param {boolean}
 *          allowRepeated if set to false, repeated coordinates are collapsed.
 * @param {boolean}
 *          direction if false, the array is added in reverse order.
 * @return {boolean} true (as by general collection contract).
 */
jsts.geom.CoordinateList.prototype.addCoordinates = function(coord, allowRepeated,
    direction) {
  if (coord instanceof jsts.geom.Coordinate) {
    return this.addCoordinate.apply(this, arguments);
  } else if (typeof coord === 'number') {
    return this.insertCoordinate.apply(this, arguments);
  }

  direction = direction || true;

  if (direction) {
    for (var i = 0; i < coord.length; i++) {
      this.addCoordinate(coord[i], allowRepeated);
    }
  } else {
    for (var i = coord.length - 1; i >= 0; i--) {
      this.addCoordinate(coord[i], allowRepeated);
    }
  }
  return true;
};


/**
 * Adds a coordinate to the end of the list.
 *
 * @param {Coordinate}
 *          coord The coordinates.
 * @param {boolean}
 *          allowRepeated if set to false, repeated coordinates are collapsed.
 */
jsts.geom.CoordinateList.prototype.addCoordinate = function(coord,
    allowRepeated) {
  // don't add duplicate coordinates
  if (!allowRepeated) {
    if (this.size() >= 1) {
      var last = this.get(this.size() - 1);
      if (last.equals2D(coord)) return;
    }
  }
  this.add(coord);
};

/**
 * Inserts a coordinate at the specified place in the list
 *
 * @param {Number}
 *          index The index where to insert the coordinate.
 * @param {Coordinate}
 *          coord The coordinate.
 * @param {boolean}
 *          allowRepeated if set to false, repeated coordinates are collapsed.
 */
jsts.geom.CoordinateList.prototype.insertCoordinate = function(index, coord,
    allowRepeated) {
  // don't add duplicate coordinates
  if (!allowRepeated) {
    var before = index > 0 ? index - 1 : -1;
    if (before !== -1 && this.get(before).equals2D(coord)) {
      return;
    }

    var after = index < this.size() - 1 ? index + 1 : -1;
    if (after !== -1 && this.get(after).equals2D(coord)) {
      return;
    }
  }
  this.array.splice(index, 0, coord);
};

/**
 * Ensure this coordList is a ring, by adding the start point if necessary
 */
jsts.geom.CoordinateList.prototype.closeRing = function() {
  if (this.size() > 0) {
    this.addCoordinate(new jsts.geom.Coordinate(this.get(0)), false);
  }
};

/**
 * Creates a standard javascript-array from the contents of this list
 *
 * @return {Array}
 *            the created array.
 */
jsts.geom.CoordinateList.prototype.toArray = function() {
  return this.array;
};

/** Returns the Coordinates in this collection.
*
* @return the coordinates.
*/
jsts.geom.CoordinateList.prototype.toCoordinateArray = function() {
  return this.array;
};

// TODO: port rest?
/* ======================================================================
    jsts/operation/buffer/OffsetSegmentGenerator.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */


/**
 * Generates segments which form an offset curve. Supports all end cap and join
 * options provided for buffering. Implements various heuristics to produce
 * smoother, simpler curves which are still within a reasonable tolerance of the
 * true curve.
 * @constructor
 */
jsts.operation.buffer.OffsetSegmentGenerator = function(precisionModel,
    bufParams, distance) {
  this.seg0 = new jsts.geom.LineSegment();
  this.seg1 = new jsts.geom.LineSegment();
  this.offset0 = new jsts.geom.LineSegment();
  this.offset1 = new jsts.geom.LineSegment();

  this.precisionModel = precisionModel;
  this.bufParams = bufParams;

  // compute intersections in full precision, to provide accuracy
  // the points are rounded as they are inserted into the curve line
  this.li = new jsts.algorithm.RobustLineIntersector();
  this.filletAngleQuantum = Math.PI / 2.0 / bufParams.getQuadrantSegments();

  /**
   * Non-round joins cause issues with short closing segments, so don't use
   * them. In any case, non-round joins only really make sense for relatively
   * small buffer distances.
   */
  if (this.bufParams.getQuadrantSegments() >= 8 &&
      this.bufParams.getJoinStyle() === jsts.operation.buffer.BufferParameters.JOIN_ROUND) {
    this.closingSegLengthFactor = jsts.operation.buffer.OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR;
  }
  this.init(distance);
};


/**
 * Factor which controls how close offset segments can be to skip adding a
 * filler or mitre.
 *
 * @private
 */
jsts.operation.buffer.OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR = 1.0E-3;


/**
 * Factor which controls how close curve vertices on inside turns can be to be
 * snapped
 *
 * @private
 */
jsts.operation.buffer.OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = 1.0E-3;


/**
 * Factor which controls how close curve vertices can be to be snapped
 *
 * @private
 */
jsts.operation.buffer.OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1.0E-6;


/**
 * Factor which determines how short closing segs can be for round buffers *
 *
 * @private
 */
jsts.operation.buffer.OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR = 80;


/**
 * the max error of approximation (distance) between a quad segment and the true
 * fillet curve
 *
 * @private
 */
jsts.operation.buffer.OffsetSegmentGenerator.prototype.maxCurveSegmentError = 0.0;


/**
 * The angle quantum with which to approximate a fillet curve (based on the
 * input # of quadrant segments)
 *
 * @private
 */
jsts.operation.buffer.OffsetSegmentGenerator.prototype.filletAngleQuantum = null;


/**
 * The Closing Segment Length Factor controls how long "closing segments" are.
 * Closing segments are added at the middle of inside corners to ensure a
 * smoother boundary for the buffer offset curve. In some cases (particularly
 * for round joins with default-or-better quantization) the closing segments can
 * be made quite short. This substantially improves performance (due to fewer
 * intersections being created).
 *
 * A closingSegFactor of 0 results in lines to the corner vertex A
 * closingSegFactor of 1 results in lines halfway to the corner vertex A
 * closingSegFactor of 80 results in lines 1/81 of the way to the corner vertex
 * (this option is reasonable for the very common default situation of round
 * joins and quadrantSegs >= 8)
 *
 * @private
 */
jsts.operation.buffer.OffsetSegmentGenerator.prototype.closingSegLengthFactor = 1;


/**
 * @type {OffsetSegmentString}
 * @private
 */
jsts.operation.buffer.OffsetSegmentGenerator.prototype.segList = null;


/**
 * @private
 */
jsts.operation.buffer.OffsetSegmentGenerator.prototype.distance = 0.0;


/**
 * @private
 */
jsts.operation.buffer.OffsetSegmentGenerator.prototype.precisionModel = null;


/**
 * @private
 */
jsts.operation.buffer.OffsetSegmentGenerator.prototype.bufParams = null;


/**
 * @private
 */
jsts.operation.buffer.OffsetSegmentGenerator.prototype.li = null;


/**
 * @type {Coordinate}
 * @private
 */
jsts.operation.buffer.OffsetSegmentGenerator.prototype.s0 = null;


/**
 * @type {Coordinate}
 * @private
 */
jsts.operation.buffer.OffsetSegmentGenerator.prototype.s1 = null;


/**
 * @type {Coordinate}
 * @private
 */
jsts.operation.buffer.OffsetSegmentGenerator.prototype.s2 = null;


/**
 * @type {LineSegment}
 * @private
 */
jsts.operation.buffer.OffsetSegmentGenerator.prototype.seg0 = null;


/**
 * @type {LineSegment}
 * @private
 */
jsts.operation.buffer.OffsetSegmentGenerator.prototype.seg1 = null;


/**
 * @type {LineSegment}
 * @private
 */
jsts.operation.buffer.OffsetSegmentGenerator.prototype.offset0 = null;


/**
 * @type {LineSegment}
 * @private
 */
jsts.operation.buffer.OffsetSegmentGenerator.prototype.offset1 = null;


/**
 * @type {number}
 * @private
 */
jsts.operation.buffer.OffsetSegmentGenerator.prototype.side = 0;


/**
 * @type {boolean}
 * @private
 */
jsts.operation.buffer.OffsetSegmentGenerator.prototype.hasNarrowConcaveAngle = false;


/**
 * Tests whether the input has a narrow concave angle (relative to the offset
 * distance). In this case the generated offset curve will contain
 * self-intersections and heuristic closing segments. This is expected behaviour
 * in the case of buffer curves. For pure offset curves, the output needs to be
 * further treated before it can be used.
 *
 * @return true if the input has a narrow concave angle.
 */
jsts.operation.buffer.OffsetSegmentGenerator.prototype.hasNarrowConcaveAngle = function() {
  return this.hasNarrowConcaveAngle;
};


/**
 * @private
 */
jsts.operation.buffer.OffsetSegmentGenerator.prototype.init = function(distance) {
  this.distance = distance;
  this.maxCurveSegmentError = this.distance *
      (1 - Math.cos(this.filletAngleQuantum / 2.0));
  this.segList = new jsts.operation.buffer.OffsetSegmentString();
  this.segList.setPrecisionModel(this.precisionModel);
  /**
   * Choose the min vertex separation as a small fraction of the offset
   * distance.
   */
  this.segList
      .setMinimumVertexDistance(this.distance *
          jsts.operation.buffer.OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
};


jsts.operation.buffer.OffsetSegmentGenerator.prototype.initSideSegments = function(
    s1, s2, side) {
  this.s1 = s1;
  this.s2 = s2;
  this.side = side;
  this.seg1.setCoordinates(this.s1, this.s2);
  this.computeOffsetSegment(this.seg1, this.side, this.distance, this.offset1);
};

jsts.operation.buffer.OffsetSegmentGenerator.prototype.getCoordinates = function() {
  return this.segList.getCoordinates();
};

jsts.operation.buffer.OffsetSegmentGenerator.prototype.closeRing = function() {
  this.segList.closeRing();
};

jsts.operation.buffer.OffsetSegmentGenerator.prototype.addSegments = function(
    pt, isForward) {
  this.segList.addPts(pt, isForward);
};

jsts.operation.buffer.OffsetSegmentGenerator.prototype.addFirstSegment = function() {
  this.segList.addPt(this.offset1.p0);
};


/**
 * Add last offset point
 */
jsts.operation.buffer.OffsetSegmentGenerator.prototype.addLastSegment = function() {
  this.segList.addPt(this.offset1.p1);
};

jsts.operation.buffer.OffsetSegmentGenerator.prototype.addNextSegment = function(
    p, addStartPoint) {
  // s0-s1-s2 are the coordinates of the previous segment and the current one
  this.s0 = this.s1;
  this.s1 = this.s2;
  this.s2 = p;
  this.seg0.setCoordinates(this.s0, this.s1);
  this.computeOffsetSegment(this.seg0, this.side, this.distance, this.offset0);
  this.seg1.setCoordinates(this.s1, this.s2);
  this.computeOffsetSegment(this.seg1, this.side, this.distance, this.offset1);

  // do nothing if points are equal
  if (this.s1.equals(this.s2))
    return;

  var orientation = jsts.algorithm.CGAlgorithms.computeOrientation(this.s0,
      this.s1, this.s2);
  var outsideTurn = (orientation === jsts.algorithm.CGAlgorithms.CLOCKWISE && this.side === jsts.geomgraph.Position.LEFT) ||
      (orientation === jsts.algorithm.CGAlgorithms.COUNTERCLOCKWISE && this.side === jsts.geomgraph.Position.RIGHT);

  if (orientation == 0) { // lines are collinear
    this.addCollinear(addStartPoint);
  } else if (outsideTurn) {
    this.addOutsideTurn(orientation, addStartPoint);
  } else { // inside turn
    this.addInsideTurn(orientation, addStartPoint);
  }
};


/**
 * @private
 */
jsts.operation.buffer.OffsetSegmentGenerator.prototype.addCollinear = function(
    addStartPoint) {
  /**
   * This test could probably be done more efficiently, but the situation of
   * exact collinearity should be fairly rare.
   */
  this.li.computeIntersection(this.s0, this.s1, this.s1, this.s2);
  var numInt = this.li.getIntersectionNum();
  /**
   * if numInt is < 2, the lines are parallel and in the same direction. In this
   * case the point can be ignored, since the offset lines will also be
   * parallel.
   */
  if (numInt >= 2) {
    /**
     * segments are collinear but reversing. Add an "end-cap" fillet all the way
     * around to other direction This case should ONLY happen for LineStrings,
     * so the orientation is always CW. (Polygons can never have two consecutive
     * segments which are parallel but reversed, because that would be a self
     * intersection.
     *
     */
    if (this.bufParams.getJoinStyle() === jsts.operation.buffer.BufferParameters.JOIN_BEVEL ||
        this.bufParams.getJoinStyle() === jsts.operation.buffer.BufferParameters.JOIN_MITRE) {
      if (addStartPoint)
        this.segList.addPt(this.offset0.p1);
      this.segList.addPt(this.offset1.p0);
    } else {
      this.addFillet(this.s1, this.offset0.p1, this.offset1.p0,
          jsts.algorithm.CGAlgorithms.CLOCKWISE, this.distance);
    }
  }
};


/**
 * Adds the offset points for an outside (convex) turn
 *
 * @param orientation
 * @param addStartPoint
 * @private
 */
jsts.operation.buffer.OffsetSegmentGenerator.prototype.addOutsideTurn = function(
    orientation, addStartPoint) {
  /**
   * Heuristic: If offset endpoints are very close together, just use one of
   * them as the corner vertex. This avoids problems with computing mitre
   * corners in the case where the two segments are almost parallel (which is
   * hard to compute a robust intersection for).
   */
  if (this.offset0.p1.distance(this.offset1.p0) < this.distance *
      jsts.operation.buffer.OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR) {
    this.segList.addPt(this.offset0.p1);
    return;
  }

  if (this.bufParams.getJoinStyle() === jsts.operation.buffer.BufferParameters.JOIN_MITRE) {
    this.addMitreJoin(this.s1, this.offset0, this.offset1, this.distance);
  } else if (this.bufParams.getJoinStyle() === jsts.operation.buffer.BufferParameters.JOIN_BEVEL) {
    this.addBevelJoin(this.offset0, this.offset1);
  } else {
    // add a circular fillet connecting the endpoints of the offset segments
    if (addStartPoint)
      this.segList.addPt(this.offset0.p1);
    // TESTING - comment out to produce beveled joins
    this.addFillet(this.s1, this.offset0.p1, this.offset1.p0, orientation,
        this.distance);
    this.segList.addPt(this.offset1.p0);
  }
};


/**
 * Adds the offset points for an inside (concave) turn.
 *
 * @param orientation
 * @param addStartPoint
 * @private
 */
jsts.operation.buffer.OffsetSegmentGenerator.prototype.addInsideTurn = function(
    orientation, addStartPoint) {
  /**
   * add intersection point of offset segments (if any)
   */
  this.li.computeIntersection(this.offset0.p0, this.offset0.p1, this.offset1.p0, this.offset1.p1);
  if (this.li.hasIntersection()) {
    this.segList.addPt(this.li.getIntersection(0));
  } else {
    /**
     * If no intersection is detected, it means the angle is so small and/or the
     * offset so large that the offsets segments don't intersect. In this case
     * we must add a "closing segment" to make sure the buffer curve is
     * continuous, fairly smooth (e.g. no sharp reversals in direction) and
     * tracks the buffer correctly around the corner. The curve connects the
     * endpoints of the segment offsets to points which lie toward the centre
     * point of the corner. The joining curve will not appear in the final
     * buffer outline, since it is completely internal to the buffer polygon.
     *
     * In complex buffer cases the closing segment may cut across many other
     * segments in the generated offset curve. In order to improve the
     * performance of the noding, the closing segment should be kept as short as
     * possible. (But not too short, since that would defeat its purpose). This
     * is the purpose of the closingSegFactor heuristic value.
     */

    /**
     * The intersection test above is vulnerable to robustness errors; i.e. it
     * may be that the offsets should intersect very close to their endpoints,
     * but aren't reported as such due to rounding. To handle this situation
     * appropriately, we use the following test: If the offset points are very
     * close, don't add closing segments but simply use one of the offset points
     */
    this.hasNarrowConcaveAngle = true;
    // System.out.println("NARROW ANGLE - distance = " + distance);
    if (this.offset0.p1.distance(this.offset1.p0) < this.distance *
        jsts.operation.buffer.OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) {
      this.segList.addPt(this.offset0.p1);
    } else {
      // add endpoint of this segment offset
      this.segList.addPt(this.offset0.p1);

      /**
       * Add "closing segment" of required length.
       */
      if (this.closingSegLengthFactor > 0) {
        var mid0 = new jsts.geom.Coordinate((this.closingSegLengthFactor *
            this.offset0.p1.x + this.s1.x) /
            (this.closingSegLengthFactor + 1), (this.closingSegLengthFactor *
            this.offset0.p1.y + this.s1.y) /
            (this.closingSegLengthFactor + 1));
        this.segList.addPt(mid0);
        var mid1 = new jsts.geom.Coordinate((this.closingSegLengthFactor *
            this.offset1.p0.x + this.s1.x) /
            (this.closingSegLengthFactor + 1), (this.closingSegLengthFactor *
            this.offset1.p0.y + this.s1.y) /
            (this.closingSegLengthFactor + 1));
        this.segList.addPt(mid1);
      } else {
        /**
         * This branch is not expected to be used except for testing purposes.
         * It is equivalent to the JTS 1.9 logic for closing segments (which
         * results in very poor performance for large buffer distances)
         */
        this.segList.addPt(this.s1);
      }

      // */
      // add start point of next segment offset
      this.segList.addPt(this.offset1.p0);
    }
  }
};


/**
 * Compute an offset segment for an input segment on a given side and at a given
 * distance. The offset points are computed in full double precision, for
 * accuracy.
 *
 * @param seg
 *          the segment to offset.
 * @param side
 *          the side of the segment ( {@link Position} ) the offset lies on.
 * @param distance
 *          the offset distance.
 * @param offset
 *          the points computed for the offset segment.
 * @private
 */
jsts.operation.buffer.OffsetSegmentGenerator.prototype.computeOffsetSegment = function(
    seg, side, distance, offset) {
  var sideSign = side === jsts.geomgraph.Position.LEFT ? 1 : -1;
  var dx = seg.p1.x - seg.p0.x;
  var dy = seg.p1.y - seg.p0.y;
  var len = Math.sqrt(dx * dx + dy * dy);
  // u is the vector that is the length of the offset, in the direction of the
  // segment
  var ux = sideSign * distance * dx / len;
  var uy = sideSign * distance * dy / len;
  offset.p0.x = seg.p0.x - uy;
  offset.p0.y = seg.p0.y + ux;
  offset.p1.x = seg.p1.x - uy;
  offset.p1.y = seg.p1.y + ux;
};


/**
 * Add an end cap around point p1, terminating a line segment coming from p0
 */
jsts.operation.buffer.OffsetSegmentGenerator.prototype.addLineEndCap = function(
    p0, p1) {
  var seg = new jsts.geom.LineSegment(p0, p1);

  var offsetL = new jsts.geom.LineSegment();
  this.computeOffsetSegment(seg, jsts.geomgraph.Position.LEFT, this.distance,
      offsetL);
  var offsetR = new jsts.geom.LineSegment();
  this.computeOffsetSegment(seg, jsts.geomgraph.Position.RIGHT, this.distance,
      offsetR);

  var dx = p1.x - p0.x;
  var dy = p1.y - p0.y;
  var angle = Math.atan2(dy, dx);

  switch (this.bufParams.getEndCapStyle()) {
    case jsts.operation.buffer.BufferParameters.CAP_ROUND:
      // add offset seg points with a fillet between them
      this.segList.addPt(offsetL.p1);
      this.addFillet(p1, angle + Math.PI / 2, angle - Math.PI / 2,
          jsts.algorithm.CGAlgorithms.CLOCKWISE, this.distance);
      this.segList.addPt(offsetR.p1);
      break;
    case jsts.operation.buffer.BufferParameters.CAP_FLAT:
      // only offset segment points are added
      this.segList.addPt(offsetL.p1);
      this.segList.addPt(offsetR.p1);
      break;
    case jsts.operation.buffer.BufferParameters.CAP_SQUARE:
      // add a square defined by extensions of the offset segment endpoints
      var squareCapSideOffset = new jsts.geom.Coordinate();
      squareCapSideOffset.x = Math.abs(this.distance) * Math.cos(angle);
      squareCapSideOffset.y = Math.abs(this.distance) * Math.sin(angle);

      var squareCapLOffset = new jsts.geom.Coordinate(offsetL.p1.x +
          squareCapSideOffset.x, offsetL.p1.y + squareCapSideOffset.y);
      var squareCapROffset = new jsts.geom.Coordinate(offsetR.p1.x +
          squareCapSideOffset.x, offsetR.p1.y + squareCapSideOffset.y);
      this.segList.addPt(squareCapLOffset);
      this.segList.addPt(squareCapROffset);
      break;

  }
};


/**
 * Adds a mitre join connecting the two reflex offset segments. The mitre will
 * be beveled if it exceeds the mitre ratio limit.
 *
 * @param offset0
 *          the first offset segment.
 * @param offset1
 *          the second offset segment.
 * @param distance
 *          the offset distance.
 * @private
 */
jsts.operation.buffer.OffsetSegmentGenerator.prototype.addMitreJoin = function(
    p, offset0, offset1, distance) {
  var isMitreWithinLimit = true;
  var intPt = null;

  /**
   * This computation is unstable if the offset segments are nearly collinear.
   * Howver, this situation should have been eliminated earlier by the check for
   * whether the offset segment endpoints are almost coincident
   */
  try {
    intPt = jsts.algorithm.HCoordinate.intersection(offset0.p0, offset0.p1,
        offset1.p0, offset1.p1);

    var mitreRatio = distance <= 0.0 ? 1.0 : intPt.distance(p) /
        Math.abs(distance);

    if (mitreRatio > this.bufParams.getMitreLimit())
      this.isMitreWithinLimit = false;
  } catch (e) {
    if (e instanceof jsts.error.NotRepresentableError) {
      intPt = new jsts.geom.Coordinate(0, 0);
      this.isMitreWithinLimit = false;
    }
  }

  if (isMitreWithinLimit) {
    this.segList.addPt(intPt);
  } else {
    this.addLimitedMitreJoin(offset0, offset1, distance, bufParams
        .getMitreLimit());
    // addBevelJoin(offset0, offset1);
  }
};


/**
 * Adds a limited mitre join connecting the two reflex offset segments. A
 * limited mitre is a mitre which is beveled at the distance determined by the
 * mitre ratio limit.
 *
 * @param offset0
 *          the first offset segment.
 * @param offset1
 *          the second offset segment.
 * @param distance
 *          the offset distance.
 * @param mitreLimit
 *          the mitre limit ratio.
 * @private
 */
jsts.operation.buffer.OffsetSegmentGenerator.prototype.addLimitedMitreJoin = function(
    offset0, offset1, distance, mitreLimit) {
  var basePt = this.seg0.p1;

  var ang0 = jsts.algorithm.Angle.angle(basePt, this.seg0.p0);
  var ang1 = jsts.algorithm.Angle.angle(basePt, this.seg1.p1);

  // oriented angle between segments
  var angDiff = jsts.algorithm.Angle.angleBetweenOriented(this.seg0.p0, basePt,
      this.seg1.p1);
  // half of the interior angle
  var angDiffHalf = angDiff / 2;

  // angle for bisector of the interior angle between the segments
  var midAng = jsts.algorithm.Angle.normalize(ang0 + angDiffHalf);
  // rotating this by PI gives the bisector of the reflex angle
  var mitreMidAng = jsts.algorithm.Angle.normalize(midAng + Math.PI);

  // the miterLimit determines the distance to the mitre bevel
  var mitreDist = mitreLimit * distance;
  // the bevel delta is the difference between the buffer distance
  // and half of the length of the bevel segment
  var bevelDelta = mitreDist * Math.abs(Math.sin(angDiffHalf));
  var bevelHalfLen = distance - bevelDelta;

  // compute the midpoint of the bevel segment
  var bevelMidX = basePt.x + mitreDist * Math.cos(mitreMidAng);
  var bevelMidY = basePt.y + mitreDist * Math.sin(mitreMidAng);
  var bevelMidPt = new jsts.geom.Coordinate(bevelMidX, bevelMidY);

  // compute the mitre midline segment from the corner point to the bevel
  // segment midpoint
  var mitreMidLine = new jsts.geom.LineSegment(basePt, bevelMidPt);

  // finally the bevel segment endpoints are computed as offsets from
  // the mitre midline
  var bevelEndLeft = mitreMidLine.pointAlongOffset(1.0, bevelHalfLen);
  var bevelEndRight = mitreMidLine.pointAlongOffset(1.0, -bevelHalfLen);

  if (this.side == jsts.geomgraph.Position.LEFT) {
    this.segList.addPt(bevelEndLeft);
    this.segList.addPt(bevelEndRight);
  } else {
    this.segList.addPt(bevelEndRight);
    this.segList.addPt(bevelEndLeft);
  }
};


/**
 * Adds a bevel join connecting the two offset segments around a reflex corner.
 *
 * @param {LineSegment}
 *          offset0 the first offset segment.
 * @param {LineSegment}
 *          offset1 the second offset segment.
 * @private
 */
jsts.operation.buffer.OffsetSegmentGenerator.prototype.addBevelJoin = function(
    offset0, offset1) {
  this.segList.addPt(offset0.p1);
  this.segList.addPt(offset1.p0);
};


/**
 * Add points for a circular fillet around a reflex corner. Adds the start and
 * end points
 *
 * @param p
 *          base point of curve.
 * @param p0
 *          start point of fillet curve.
 * @param p1
 *          endpoint of fillet curve.
 * @param direction
 *          the orientation of the fillet.
 * @param radius
 *          the radius of the fillet.
 * @private
 */
jsts.operation.buffer.OffsetSegmentGenerator.prototype.addFillet = function(p,
    p0, p1, direction, radius) {
  if (!(p1 instanceof jsts.geom.Coordinate)) {
    this.addFillet2.apply(this, arguments);
    return;
  }

  var dx0 = p0.x - p.x;
  var dy0 = p0.y - p.y;
  var startAngle = Math.atan2(dy0, dx0);
  var dx1 = p1.x - p.x;
  var dy1 = p1.y - p.y;
  var endAngle = Math.atan2(dy1, dx1);

  if (direction === jsts.algorithm.CGAlgorithms.CLOCKWISE) {
    if (startAngle <= endAngle)
      startAngle += 2.0 * Math.PI;
  } else { // direction == COUNTERCLOCKWISE
    if (startAngle >= endAngle)
      startAngle -= 2.0 * Math.PI;
  }
  this.segList.addPt(p0);
  this.addFillet(p, startAngle, endAngle, direction, radius);
  this.segList.addPt(p1);
};


/**
 * Adds points for a circular fillet arc between two specified angles. The start
 * and end point for the fillet are not added - the caller must add them if
 * required.
 *
 * @param direction
 *          is -1 for a CW angle, 1 for a CCW angle.
 * @param radius
 *          the radius of the fillet.
 * @private
 */
jsts.operation.buffer.OffsetSegmentGenerator.prototype.addFillet2 = function(p,
    startAngle, endAngle, direction, radius) {
  var directionFactor = direction === jsts.algorithm.CGAlgorithms.CLOCKWISE ? -1
      : 1;

  var totalAngle = Math.abs(startAngle - endAngle);
  var nSegs = parseInt((totalAngle / this.filletAngleQuantum + 0.5));

  if (nSegs < 1)
    return; // no segments because angle is less than increment - nothing to do!

  var initAngle, currAngleInc;

  // choose angle increment so that each segment has equal length
  initAngle = 0.0;
  currAngleInc = totalAngle / nSegs;

  var currAngle = initAngle;
  var pt = new jsts.geom.Coordinate();
  while (currAngle < totalAngle) {
    var angle = startAngle + directionFactor * currAngle;
    pt.x = p.x + radius * Math.cos(angle);
    pt.y = p.y + radius * Math.sin(angle);
    this.segList.addPt(pt);
    currAngle += currAngleInc;
  }
};


/**
 * Creates a CW circle around a point
 */
jsts.operation.buffer.OffsetSegmentGenerator.prototype.createCircle = function(
    p) {
  // add start point
  var pt = new jsts.geom.Coordinate(p.x + this.distance, p.y);
  this.segList.addPt(pt);
  this.addFillet(p, 0.0, 2.0 * Math.PI, -1, this.distance);
  this.segList.closeRing();
};


/**
 * Creates a CW square around a point
 */
jsts.operation.buffer.OffsetSegmentGenerator.prototype.createSquare = function(
    p) {
  this.segList.addPt(new jsts.geom.Coordinate(p.x + distance, p.y + distance));
  this.segList.addPt(new jsts.geom.Coordinate(p.x + distance, p.y - distance));
  this.segList.addPt(new jsts.geom.Coordinate(p.x - distance, p.y - distance));
  this.segList.addPt(new jsts.geom.Coordinate(p.x - distance, p.y + distance));
  this.segList.closeRing();
};
/* ======================================================================
    jsts/operation/overlay/MaximalEdgeRing.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @requires jsts/geomgraph/EdgeRing.js
 */

/**
 * A ring of {@link DirectedEdge}s which may contain nodes of degree > 2.
 * A <tt>MaximalEdgeRing</tt> may represent two different spatial entities:
 * <ul>
 * <li>a single polygon possibly containing inversions (if the ring is oriented CW)
 * <li>a single hole possibly containing exversions (if the ring is oriented CCW)
 * </ul>
 * If the MaximalEdgeRing represents a polygon,
 * the interior of the polygon is strongly connected.
 * <p>
 * These are the form of rings used to define polygons under some spatial data models.
 * However, under the OGC SFS model, {@link MinimalEdgeRing}s are required.
 * A MaximalEdgeRing can be converted to a list of MinimalEdgeRings using the
 * {@link #buildMinimalRings() } method.
 *
 * @extends jsts.geomgraph.EdgeRing
 * @constructor
 */
jsts.operation.overlay.MaximalEdgeRing = function(start, geometryFactory) {
  jsts.geomgraph.EdgeRing.call(this, start, geometryFactory);

};
jsts.operation.overlay.MaximalEdgeRing.prototype = new jsts.geomgraph.EdgeRing();
jsts.operation.overlay.MaximalEdgeRing.constructor = jsts.operation.overlay.MaximalEdgeRing;


jsts.operation.overlay.MaximalEdgeRing.prototype.getNext = function(de)
  {
    return de.getNext();
  };
jsts.operation.overlay.MaximalEdgeRing.prototype.setEdgeRing = function(de, er)
  {
    de.setEdgeRing(er);
  };

  /**
   * For all nodes in this EdgeRing,
   * link the DirectedEdges at the node to form minimalEdgeRings
   */
jsts.operation.overlay.MaximalEdgeRing.prototype.linkDirectedEdgesForMinimalEdgeRings = function()
  {
    var de = this.startDe;
    do {
      var node = de.getNode();
      node.getEdges().linkMinimalDirectedEdges(this);
      de = de.getNext();
    } while (de != this.startDe);
  };

jsts.operation.overlay.MaximalEdgeRing.prototype.buildMinimalRings = function()
  {
    var minEdgeRings = [];
    var de = this.startDe;
    do {
      if (de.getMinEdgeRing() === null) {
        var minEr = new jsts.operation.overlay.MinimalEdgeRing(de, this.geometryFactory);
        minEdgeRings.push(minEr);
      }
      de = de.getNext();
    } while (de != this.startDe);
    return minEdgeRings;
  };
/* ======================================================================
    jsts/algorithm/CentroidPoint.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */


/**
 * Computes the centroid of a point geometry.
 * <h2>Algorithm</h2>
 * Compute the average of all points.
 *
 * @version 1.7
 */
jsts.algorithm.CentroidPoint = function() {
  this.centSum = new jsts.geom.Coordinate();
};


/**
 * @type {int}
 * @private
 */
jsts.algorithm.CentroidPoint.prototype.ptCount = 0;


/**
 * @type {jsts.geom.Coordinate}
 * @private
 */
jsts.algorithm.CentroidPoint.prototype.centSum = null;


/**
 * Adds the point(s) defined by a Geometry to the centroid total. If the
 * geometry is not of dimension 0 it does not contribute to the centroid.
 *
 * @param {Geometry}
 *          geom the geometry to add.
 */
jsts.algorithm.CentroidPoint.prototype.add = function(geom) {
  if (geom instanceof jsts.geom.Point) {
    this.add2(geom.getCoordinate());
  } else if (geom instanceof jsts.geom.GeometryCollection ||
      geom instanceof jsts.geom.MultiPoint ||
      geom instanceof jsts.geom.MultiLineString ||
      geom instanceof jsts.geom.MultiPolygon) {
    var gc = geom;
    for (var i = 0; i < gc.getNumGeometries(); i++) {
      this.add(gc.getGeometryN(i));
    }
  }
};


/**
 * Adds the length defined by an array of coordinates.
 *
 * @param {jsts.geom.Coordinate}
 *          pts an array of {@link Coordinate}s.
 */
jsts.algorithm.CentroidPoint.prototype.add2 = function(pt) {
  this.ptCount += 1;
  this.centSum.x += pt.x;
  this.centSum.y += pt.y;
};


/**
 * @return {jsts.geom.Coordinate}
 */
jsts.algorithm.CentroidPoint.prototype.getCentroid = function() {
  var cent = new jsts.geom.Coordinate();
  cent.x = this.centSum.x / this.ptCount;
  cent.y = this.centSum.y / this.ptCount;
  return cent;
};
/* ======================================================================
    jsts/operation/distance/ConnectedElementLocationFilter.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @requires jsts/geom/GeometryFilter.js
 */



/**
 * A ConnectedElementPointFilter extracts a single point from each connected
 * element in a Geometry (e.g. a polygon, linestring or point) and returns them
 * in a list. The elements of the list are
 * {@link com.vividsolutions.jts.operation.distance.GeometryLocation}s.
 *
 * @param {[]}
 *          locations
 * @augments jsts.geom.GeometryFilter
 * @constructor
 */
jsts.operation.distance.ConnectedElementLocationFilter = function(locations) {
  this.locations = locations;
};

jsts.operation.distance.ConnectedElementLocationFilter.prototype = new jsts.geom.GeometryFilter();


/**
 * @type {[]}
 * @private
 */
jsts.operation.distance.ConnectedElementLocationFilter.prototype.locations = null;


/**
 * Returns a list containing a point from each Polygon, LineString, and Point
 * found inside the specified geometry. Thus, if the specified geometry is not a
 * GeometryCollection, an empty list will be returned. The elements of the list
 * are {@link com.vividsolutions.jts.operation.distance.GeometryLocation}s.
 *
 * @param {Geometry}
 *          geom
 * @return {[]}
 */
jsts.operation.distance.ConnectedElementLocationFilter.getLocations = function(
    geom) {
  var locations = [];
  geom.apply(new jsts.operation.distance.ConnectedElementLocationFilter(
      locations));
  return locations;
};


/**
 * @param {Geometry}
 *          geom
 */
jsts.operation.distance.ConnectedElementLocationFilter.prototype.filter = function(
    geom) {
  if (geom instanceof jsts.geom.Point || geom instanceof jsts.geom.LineString ||
      geom instanceof jsts.geom.Polygon)
    this.locations.push(new jsts.operation.distance.GeometryLocation(geom, 0,
        geom.getCoordinate()));
};
/* ======================================================================
    jsts/geomgraph/index/MonotoneChainEdge.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * MonotoneChains are a way of partitioning the segments of an edge to
 * allow for fast searching of intersections.
 * They have the following properties:
 * <ol>
 * <li>the segments within a monotone chain will never intersect each other
 * <li>the envelope of any contiguous subset of the segments in a monotone chain
 * is simply the envelope of the endpoints of the subset.
 * </ol>
 * Property 1 means that there is no need to test pairs of segments from
 * the same monotone chain for intersection.
 * Property 2 allows
 * binary search to be used to find the intersection points of two monotone chains.
 * For many types of real-world data, these properties eliminate a large number of
 * segment comparisons, producing substantial speed gains.
 */

/**
 * @param {Edge} 
 *          e
 * @constructor 
 */
jsts.geomgraph.index.MonotoneChainEdge = function(e) {
  this.e = e;
  this.pts = e.getCoordinates();
  var mcb = new jsts.geomgraph.index.MonotoneChainIndexer();
  this.startIndex = mcb.getChainStartIndices(this.pts);
};

/**
 * @type {Edge} 
 */
jsts.geomgraph.index.MonotoneChainEdge.prototype.e = null;

/**
 * cache a reference to the coord array, for efficiency 
 *
 * @type {Coordinate[]} 
 */
jsts.geomgraph.index.MonotoneChainEdge.prototype.pts = null;

/**
 * the lists of start/end indexes of the monotone chains.
 * Includes the end point of the edge as a sentinel
 * 
 * @type {int[]} 
 */
jsts.geomgraph.index.MonotoneChainEdge.prototype.startIndex = null;

/**
 * these envelopes are created once and reused
 * 
 * @type {Envelope} 
 */
jsts.geomgraph.index.MonotoneChainEdge.prototype.env1 = new jsts.geom.Envelope();
jsts.geomgraph.index.MonotoneChainEdge.prototype.env2 = new jsts.geom.Envelope();

jsts.geomgraph.index.MonotoneChainEdge.prototype.getCoordinates = function() {
	return this.pts;
};

jsts.geomgraph.index.MonotoneChainEdge.prototype.getStartIndexes = function() {
	return this.startIndex;
};

/**
 * @param {int}
 *          chainIndex
 * @return {double} 
 */
jsts.geomgraph.index.MonotoneChainEdge.prototype.getMinX = function(
    chainIndex) {
  var x1 = this.pts[this.startIndex[chainIndex]].x;
  var x2 = this.pts[this.startIndex[chainIndex + 1]].x;
  if (x1 < x2) {
  	return x1;
  }
  return x2;
};

/**
 * @param {int}
 *          chainIndex
 * @return {double} 
 */
jsts.geomgraph.index.MonotoneChainEdge.prototype.getMaxX = function(
    chainIndex) {
  var x1 = this.pts[this.startIndex[chainIndex]].x;
  var x2 = this.pts[this.startIndex[chainIndex + 1]].x;
  if (x1 > x2) {
  	return x1;
  }
  return x2;
};

/**
 * @param {MonotoneChainEdge}
 *          mce
 * @param {SegmentIntersector}
 *          si 
 */
jsts.geomgraph.index.MonotoneChainEdge.prototype.computeIntersects = function(
    mce, si) {
  for (var i = 0; i < this.startIndex.length - 1; i++) {
    for (var j = 0; j < mce.startIndex.length - 1; j++) {
    	this.computeIntersectsForChain(i, mce, j, si);
    }
  }
};

/**
 * @param {int}
 *          chainIndex0
 * @param {MonotoneChainEdge}
 *          mce
 * @param {int}
 *          chainIndex1
 * @param {SegmentIntersector}
 *          si 
 */
jsts.geomgraph.index.MonotoneChainEdge.prototype.computeIntersectsForChain = function(
    chainIndex0, mce, chainIndex1, si) {
  this.computeIntersectsForChain2(this.startIndex[chainIndex0], this.startIndex[chainIndex0 + 1],
                                  mce,
                                  mce.startIndex[chainIndex1], mce.startIndex[chainIndex1 + 1],
                                  si);
};

/**
 * @param {int}
 *          start0
 * @param {int}
 *          end0
 * @param {MonotoneChainEdge}
 *          mce
 * @param {int}
 *          start1
 * @param {int}
 *          end1
 * @param {SegmentIntersector}
 *          ei 
 */
jsts.geomgraph.index.MonotoneChainEdge.prototype.computeIntersectsForChain2 = function(
    start0, end0, mce, start1, end1, ei) {
  var p00 = this.pts[start0];
  var p01 = this.pts[end0];
  var p10 = mce.pts[start1];
  var p11 = mce.pts[end1];
  
  //console.log("computeIntersectsForChain2:" + p00 + p01 + p10 + p11);
  // terminating condition for the recursion
  if (end0 - start0 == 1 && end1 - start1 == 1) {
    ei.addIntersections(this.e, start0, mce.e, start1);
    return;
  }

  // nothing to do if the envelopes of these chains don't overlap
  this.env1.init(p00, p01);
  this.env2.init(p10, p11);
  if (!this.env1.intersects(this.env2)) {
    return;
  }

  // the chains overlap, so split each in half and iterate (binary search)
  var mid0 = Math.floor((start0 + end0) / 2);
  var mid1 = Math.floor((start1 + end1) / 2);

  // Assert: mid != start or end (since we checked above for end - start <= 1)
  // check terminating conditions before recursing
  if (start0 < mid0) {
    if (start1 < mid1) {
      this.computeIntersectsForChain2(start0, mid0, mce, start1, mid1, ei);
    }
    if (mid1 < end1) {
      this.computeIntersectsForChain2(start0, mid0, mce, mid1, end1, ei);
    }
  }
  if (mid0 < end0) {
    if (start1 < mid1) {
      this.computeIntersectsForChain2(mid0, end0, mce, start1, mid1, ei);
    }
    if (mid1 < end1) {
      this.computeIntersectsForChain2(mid0, end0, mce, mid1, end1, ei);
    }
  }
};
/* ======================================================================
    jsts/operation/relate/EdgeEndBuilder.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * @requires jsts/util/Assert.js
   */

  var ArrayList = javascript.util.ArrayList;


  /**
   * An EdgeEndBuilder creates EdgeEnds for all the "split edges" created by the
   * intersections determined for an Edge.
   *
   * Computes the {@link EdgeEnd}s which arise from a noded {@link Edge}.
   *
   * @constructor
   */
  jsts.operation.relate.EdgeEndBuilder = function() {

  };


  jsts.operation.relate.EdgeEndBuilder.prototype.computeEdgeEnds = function(edges) {
    if (arguments.length == 2) {
      this.computeEdgeEnds2.apply(this, arguments);
      return;
    }

    var l = new ArrayList();
    for (var i = edges; i.hasNext();) {
      var e = i.next();
      this.computeEdgeEnds2(e, l);
    }
    return l;
  };


  /**
   * Creates stub edges for all the intersections in this Edge (if any) and
   * inserts them into the graph.
   */
  jsts.operation.relate.EdgeEndBuilder.prototype.computeEdgeEnds2 = function(edge, l) {
    var eiList = edge.getEdgeIntersectionList();
    // ensure that the list has entries for the first and last point of the edge
    eiList.addEndpoints();

    var it = eiList.iterator();
    var eiPrev = null;
    var eiCurr = null;
    // no intersections, so there is nothing to do
    if (!it.hasNext())
      return;
    var eiNext = it.next();
    do {
      eiPrev = eiCurr;
      eiCurr = eiNext;
      eiNext = null;
      if (it.hasNext())
        eiNext = it.next();

      if (eiCurr !== null) {
        this.createEdgeEndForPrev(edge, l, eiCurr, eiPrev);
        this.createEdgeEndForNext(edge, l, eiCurr, eiNext);
      }

    } while (eiCurr !== null);
  };


  /**
   * Create a EdgeStub for the edge before the intersection eiCurr. The previous
   * intersection is provided in case it is the endpoint for the stub edge.
   * Otherwise, the previous point from the parent edge will be the endpoint.
   * <br>
   * eiCurr will always be an EdgeIntersection, but eiPrev may be null.
   *
   * @private
   */
  jsts.operation.relate.EdgeEndBuilder.prototype.createEdgeEndForPrev = function(edge, l, eiCurr,
      eiPrev) {

    var iPrev = eiCurr.segmentIndex;
    if (eiCurr.dist === 0.0) {
      // if at the start of the edge there is no previous edge
      if (iPrev === 0)
        return;
      iPrev--;
    }
    var pPrev = edge.getCoordinate(iPrev);
    // if prev intersection is past the previous vertex, use it instead
    if (eiPrev !== null && eiPrev.segmentIndex >= iPrev)
      pPrev = eiPrev.coord;

    var label = new jsts.geomgraph.Label(edge.getLabel());
    // since edgeStub is oriented opposite to it's parent edge, have to flip
    // sides
    // for edge label
    label.flip();
    var e = new jsts.geomgraph.EdgeEnd(edge, eiCurr.coord, pPrev, label);
    // e.print(System.out); System.out.println();
    l.add(e);
  };


  /**
   * Create a StubEdge for the edge after the intersection eiCurr. The next
   * intersection is provided in case it is the endpoint for the stub edge.
   * Otherwise, the next point from the parent edge will be the endpoint. <br>
   * eiCurr will always be an EdgeIntersection, but eiNext may be null.
   *
   * @private
   */
  jsts.operation.relate.EdgeEndBuilder.prototype.createEdgeEndForNext = function(edge, l, eiCurr,
      eiNext) {

    var iNext = eiCurr.segmentIndex + 1;
    // if there is no next edge there is nothing to do
    if (iNext >= edge.getNumPoints() && eiNext === null)
      return;

    var pNext = edge.getCoordinate(iNext);

    // if the next intersection is in the same segment as the current, use it as
    // the endpoint
    if (eiNext !== null && eiNext.segmentIndex === eiCurr.segmentIndex)
      pNext = eiNext.coord;

    var e = new jsts.geomgraph.EdgeEnd(edge, eiCurr.coord, pNext,
        new jsts.geomgraph.Label(edge.getLabel()));
    l.add(e);
  };


})();
/* ======================================================================
    jsts/util/UniqueCoordinateArrayFilter.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * @requires jsts/geom/CoordinateFilter.js
   */

  var ArrayList = javascript.util.ArrayList;
  var TreeSet = javascript.util.TreeSet;

  var CoordinateFilter = jsts.geom.CoordinateFilter;

  /**
   * A {@link CoordinateFilter} that builds a set of <code>Coordinate</code>s.
   * The set of coordinates contains no duplicate points.
   *
   * @constructor
   */
  jsts.util.UniqueCoordinateArrayFilter = function() {
    this.treeSet = new TreeSet();
    this.list = new ArrayList();
  };


  jsts.util.UniqueCoordinateArrayFilter.prototype = new CoordinateFilter();

  jsts.util.UniqueCoordinateArrayFilter.prototype.treeSet = null;
  jsts.util.UniqueCoordinateArrayFilter.prototype.list = null;


  /**
   * Returns the gathered <code>Coordinate</code>s.
   *
   * @return the <code>Coordinate</code>s collected by this
   *         <code>CoordinateArrayFilter.</code>
   */
  jsts.util.UniqueCoordinateArrayFilter.prototype.getCoordinates = function() {
    return this.list.toArray();
  };

  jsts.util.UniqueCoordinateArrayFilter.prototype.filter = function(coord) {
    if (!this.treeSet.contains(coord)) {
      this.list.add(coord);
      this.treeSet.add(coord);
    }
  };
})();
/* ======================================================================
    jsts/algorithm/ConvexHull.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * @requires jsts/algorithm/CGAlgorithms.js
   * @requires jsts/util/UniqueCoordinateArrayFilter.js
   * @requires jsts/util/Assert.js
   */

  var CGAlgorithms = jsts.algorithm.CGAlgorithms;
  var UniqueCoordinateArrayFilter = jsts.util.UniqueCoordinateArrayFilter;
  var Assert = jsts.util.Assert;
  var Stack = javascript.util.Stack;
  var ArrayList = javascript.util.ArrayList;
  var Arrays = javascript.util.Arrays;

  /**
   * Compares {@link Coordinate}s for their angle and distance relative to an
   * origin.
   *
   * @private
   */
  var RadialComparator = function(origin) {
    this.origin = origin;
  };

  RadialComparator.prototype.origin = null;

  RadialComparator.prototype.compare = function(o1, o2) {
    var p1 = o1;
    var p2 = o2;
    return RadialComparator.polarCompare(this.origin, p1, p2);
  };

  /**
   * Given two points p and q compare them with respect to their radial ordering
   * about point o. First checks radial ordering. If points are collinear, the
   * comparison is based on their distance to the origin.
   * <p>
   * p < q iff
   * <ul>
   * <li>ang(o-p) < ang(o-q) (e.g. o-p-q is CCW)
   * <li>or ang(o-p) == ang(o-q) && dist(o,p) < dist(o,q)
   * </ul>
   *
   * @param o
   *          the origin.
   * @param p
   *          a point.
   * @param q
   *          another point.
   * @return -1, 0 or 1 depending on whether p is less than, equal to or greater
   *         than q.
   */
  RadialComparator.polarCompare = function(o, p, q) {
    var dxp = p.x - o.x;
    var dyp = p.y - o.y;
    var dxq = q.x - o.x;
    var dyq = q.y - o.y;

    var orient = CGAlgorithms.computeOrientation(o, p, q);

    if (orient == CGAlgorithms.COUNTERCLOCKWISE)
      return 1;
    if (orient == CGAlgorithms.CLOCKWISE)
      return -1;

    // points are collinear - check distance
    var op = dxp * dxp + dyp * dyp;
    var oq = dxq * dxq + dyq * dyq;
    if (op < oq) {
      return -1;
    }
    if (op > oq) {
      return 1;
    }
    return 0;
  };

  /**
   * Computes the convex hull of a {@link Geometry}. The convex hull is the
   * smallest convex Geometry that contains all the points in the input
   * Geometry.
   * <p>
   * Uses the Graham Scan algorithm.
   *
   * @constructor
   */
  jsts.algorithm.ConvexHull = function() {
    if (arguments.length === 1) {
      var geometry = arguments[0];

      this.inputPts = jsts.algorithm.ConvexHull.extractCoordinates(geometry);
      this.geomFactory = geometry.getFactory();
    } else {
      this.pts = arguments[0];
      this.geomFactory = arguments[1];
    }
  };
  jsts.algorithm.ConvexHull.prototype.geomFactory = null;
  jsts.algorithm.ConvexHull.prototype.inputPts = null;

  /**
   * @private
   */
  jsts.algorithm.ConvexHull.extractCoordinates = function(geom) {
    var filter = new UniqueCoordinateArrayFilter();
    geom.apply(filter);
    return filter.getCoordinates();
  };

  /**
   * Returns a {@link Geometry} that represents the convex hull of the input
   * geometry. The returned geometry contains the minimal number of points
   * needed to represent the convex hull. In particular, no more than two
   * consecutive points will be collinear.
   *
   * @return if the convex hull contains 3 or more points, a {@link Polygon} ; 2
   *         points, a {@link LineString}; 1 point, a {@link Point}; 0 points,
   *         an empty {@link GeometryCollection}.
   */
  jsts.algorithm.ConvexHull.prototype.getConvexHull = function() {

    if (this.inputPts.length == 0) {
      return this.geomFactory.createGeometryCollection(null);
    }
    if (this.inputPts.length == 1) {
      return this.geomFactory.createPoint(this.inputPts[0]);
    }
    if (this.inputPts.length == 2) {
      return this.geomFactory.createLineString(this.inputPts);
    }

    var reducedPts = this.inputPts;
    // use heuristic to reduce points, if large
    if (this.inputPts.length > 50) {
      reducedPts = this.reduce(this.inputPts);
    }
    // sort points for Graham scan.
    var sortedPts = this.preSort(reducedPts);

    // Use Graham scan to find convex hull.
    var cHS = this.grahamScan(sortedPts);

    // Convert stack to an array.
    var cH = cHS.toArray();

    // Convert array to appropriate output geometry.
    return this.lineOrPolygon(cH);
  };


  /**
   * Uses a heuristic to reduce the number of points scanned to compute the
   * hull. The heuristic is to find a polygon guaranteed to be in (or on) the
   * hull, and eliminate all points inside it. A quadrilateral defined by the
   * extremal points in the four orthogonal directions can be used, but even
   * more inclusive is to use an octilateral defined by the points in the 8
   * cardinal directions.
   * <p>
   * Note that even if the method used to determine the polygon vertices is not
   * 100% robust, this does not affect the robustness of the convex hull.
   * <p>
   * To satisfy the requirements of the Graham Scan algorithm, the returned
   * array has at least 3 entries.
   *
   * @param pts
   *          the points to reduce.
   * @return the reduced list of points (at least 3).
   * @private
   */
  jsts.algorithm.ConvexHull.prototype.reduce = function(inputPts) {
    var polyPts = this.computeOctRing(inputPts);

    // unable to compute interior polygon for some reason
    if (polyPts == null)
      return this.inputPts;

    // add points defining polygon
    var reducedSet = new javascript.util.TreeSet();
    for (var i = 0; i < polyPts.length; i++) {
      reducedSet.add(polyPts[i]);
    }
    /**
     * Add all unique points not in the interior poly.
     * CGAlgorithms.isPointInRing is not defined for points actually on the
     * ring, but this doesn't matter since the points of the interior polygon
     * are forced to be in the reduced set.
     */
    for (var i = 0; i < inputPts.length; i++) {
      if (!CGAlgorithms.isPointInRing(inputPts[i], polyPts)) {
        reducedSet.add(inputPts[i]);
      }
    }
    var reducedPts = reducedSet.toArray();

    // ensure that computed array has at least 3 points (not necessarily unique)
    if (reducedPts.length < 3)
      return this.padArray3(reducedPts);
    return reducedPts;
  };

  /**
   * @private
   */
  jsts.algorithm.ConvexHull.prototype.padArray3 = function(pts) {
    var pad = [];
    for (var i = 0; i < pad.length; i++) {
      if (i < pts.length) {
        pad[i] = pts[i];
      } else
        pad[i] = pts[0];
    }
    return pad;
  };

  /**
   * @private
   */
  jsts.algorithm.ConvexHull.prototype.preSort = function(pts) {
    var t;

    // find the lowest point in the set. If two or more points have
    // the same minimum y coordinate choose the one with the minimu x.
    // This focal point is put in array location pts[0].
    for (var i = 1; i < pts.length; i++) {
      if ((pts[i].y < pts[0].y) ||
          ((pts[i].y == pts[0].y) && (pts[i].x < pts[0].x))) {
        t = pts[0];
        pts[0] = pts[i];
        pts[i] = t;
      }
    }

    // sort the points radially around the focal point.
    Arrays.sort(pts, 1, pts.length, new RadialComparator(pts[0]));

    return pts;
  };

  /**
   * Uses the Graham Scan algorithm to compute the convex hull vertices.
   *
   * @param c
   *          a list of points, with at least 3 entries.
   * @return a Stack containing the ordered points of the convex hull ring.
   */
  /**
   * @private
   */
  jsts.algorithm.ConvexHull.prototype.grahamScan = function(c) {
    var p;
    var ps = new Stack();
    p = ps.push(c[0]);
    p = ps.push(c[1]);
    p = ps.push(c[2]);
    for (var i = 3; i < c.length; i++) {
      p = ps.pop();
      // check for empty stack to guard against robustness problems
      while (!ps.empty() &&
          CGAlgorithms.computeOrientation(ps.peek(), p, c[i]) > 0) {
        p = ps.pop();
      }
      p = ps.push(p);
      p = ps.push(c[i]);
    }
    p = ps.push(c[0]);
    return ps;
  };

  /**
   * @return whether the three coordinates are collinear and c2 lies between c1
   *         and c3 inclusive.
   *
   * @private
   */
  jsts.algorithm.ConvexHull.prototype.isBetween = function(c1, c2, c3) {
    if (CGAlgorithms.computeOrientation(c1, c2, c3) !== 0) {
      return false;
    }
    if (c1.x != c3.x) {
      if (c1.x <= c2.x && c2.x <= c3.x) {
        return true;
      }
      if (c3.x <= c2.x && c2.x <= c1.x) {
        return true;
      }
    }
    if (c1.y != c3.y) {
      if (c1.y <= c2.y && c2.y <= c3.y) {
        return true;
      }
      if (c3.y <= c2.y && c2.y <= c1.y) {
        return true;
      }
    }
    return false;
  };

  /**
   * @private
   */
  jsts.algorithm.ConvexHull.prototype.computeOctRing = function(inputPts) {
    var octPts = this.computeOctPts(inputPts);
    var coordList = new jsts.geom.CoordinateList();
    coordList.add(octPts, false);

    // points must all lie in a line
    if (coordList.size() < 3) {
      return null;
    }
    coordList.closeRing();
    return coordList.toCoordinateArray();
  };

  /**
   * @private
   */
  jsts.algorithm.ConvexHull.prototype.computeOctPts = function(inputPts) {
    var pts = [];
    for (var j = 0; j < 8; j++) {
      pts[j] = inputPts[0];
    }
    for (var i = 1; i < inputPts.length; i++) {
      if (inputPts[i].x < pts[0].x) {
        pts[0] = inputPts[i];
      }
      if (inputPts[i].x - inputPts[i].y < pts[1].x - pts[1].y) {
        pts[1] = inputPts[i];
      }
      if (inputPts[i].y > pts[2].y) {
        pts[2] = inputPts[i];
      }
      if (inputPts[i].x + inputPts[i].y > pts[3].x + pts[3].y) {
        pts[3] = inputPts[i];
      }
      if (inputPts[i].x > pts[4].x) {
        pts[4] = inputPts[i];
      }
      if (inputPts[i].x - inputPts[i].y > pts[5].x - pts[5].y) {
        pts[5] = inputPts[i];
      }
      if (inputPts[i].y < pts[6].y) {
        pts[6] = inputPts[i];
      }
      if (inputPts[i].x + inputPts[i].y < pts[7].x + pts[7].y) {
        pts[7] = inputPts[i];
      }
    }
    return pts;

  };


  /**
   * @param vertices
   *          the vertices of a linear ring, which may or may not be flattened
   *          (i.e. vertices collinear).
   * @return a 2-vertex <code>LineString</code> if the vertices are collinear;
   *         otherwise, a <code>Polygon</code> with unnecessary (collinear)
   *         vertices removed.
   * @private
   */
  jsts.algorithm.ConvexHull.prototype.lineOrPolygon = function(coordinates) {
    coordinates = this.cleanRing(coordinates);
    if (coordinates.length == 3) {
      return this.geomFactory
          .createLineString([coordinates[0], coordinates[1]]);
    }
    var linearRing = this.geomFactory.createLinearRing(coordinates);
    return this.geomFactory.createPolygon(linearRing, null);
  };

  /**
   * @param vertices
   *          the vertices of a linear ring, which may or may not be flattened
   *          (i.e. vertices collinear).
   * @return the coordinates with unnecessary (collinear) vertices removed.
   * @private
   */
  jsts.algorithm.ConvexHull.prototype.cleanRing = function(original) {
    Assert.equals(original[0], original[original.length - 1]);
    var cleanedRing = new ArrayList();
    var previousDistinctCoordinate = null;
    for (var i = 0; i <= original.length - 2; i++) {
      var currentCoordinate = original[i];
      var nextCoordinate = original[i + 1];
      if (currentCoordinate.equals(nextCoordinate)) {
        continue;
      }
      if (previousDistinctCoordinate != null &&
          this.isBetween(previousDistinctCoordinate, currentCoordinate,
              nextCoordinate)) {
        continue;
      }
      cleanedRing.add(currentCoordinate);
      previousDistinctCoordinate = currentCoordinate;
    }
    cleanedRing.add(original[original.length - 1]);
    var cleanedRingCoordinates = [];
    return cleanedRing.toArray(cleanedRingCoordinates);
  };

})();
/* ======================================================================
    jsts/algorithm/MinimumDiameter.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @requires jsts/geom/Geometry.js
 * @requires jsts/geom/Coordinate.js
 * @requires jsts/geom/LineSegment.js
 * @requires jsts/geom/Polygon.js
 * @requires jsts/algorithm/ConvexHull.js
 */

/**
 * Computes the minimum diameter of a {@link Geometry}.
 * The minimum diameter is defined to be the
 * width of the smallest band that
 * contains the geometry,
 * where a band is a strip of the plane defined
 * by two parallel lines.
 * This can be thought of as the smallest hole that the geometry can be
 * moved through, with a single rotation.
 * <p>
 * The first step in the algorithm is computing the convex hull of the Geometry.
 * If the input Geometry is known to be convex, a hint can be supplied to
 * avoid this computation.
 * <p>
 * This class can also be used to compute a line segment representing 
 * the minimum diameter, the supporting line segment of the minimum diameter,
 * and a minimum rectangle enclosing the input geometry.
 * This rectangle will
 * have width equal to the minimum diameter, and have one side
 * parallel to the supporting segment.
 *
 * @see ConvexHull
 *
 * @version 1.7
 *
 * @constructor
 */
jsts.algorithm.MinimumDiameter = function (inputGeom, isConvex) {

    /**
     * @type {jsts.geom.Coordinate[]}
     * @private
     */
    this.convexHullPts = null;

    /**
     * @type {jsts.geom.LineSegment}
     * @private
     */
    this.minBaseSeg = new jsts.geom.LineSegment();

    /**
     * @type {jsts.geom.Coordinate}
     * @private
     */
    this.minWidthPt = null;

    /**
     * @type {number}
     * @private
     */
    this.minPtIndex = 0;

    /**
     * @type {number}
     * @private
     */
    this.minWidth = 0;


    jsts.algorithm.MinimumDiameter.inputGeom = inputGeom;
    jsts.algorithm.MinimumDiameter.isConvex = isConvex || false;
};

/**
 * A Geometry which is convex
 * @type {jsts.geom.Geometry}
 * @private
 */
jsts.algorithm.MinimumDiameter.inputGeom = null;

/**
 * <code>true</code> if the input geometry is convex
 * @type {boolean}
 * @private
 */
jsts.algorithm.MinimumDiameter.isConvex = false;

/**
 * @param {jsts.geom.Coordinate[]} pts
 * @param {number} index
 * @return {number}
 * @private
 */
jsts.algorithm.MinimumDiameter.nextIndex = function (pts, index) {
    index++;
    if (index >= pts.length) {
        index = 0;
    }
    return index;
};

/**
 * @param {number} a
 * @param {number} b
 * @param {jsts.geom.Coordinate} p
 * @return {number}
 * @private
 */
jsts.algorithm.MinimumDiameter.computeC = function (a, b, p) {
    return a * p.y - b * p.x;
};

/**
 * @param {number} a
 * @param {number} b
 * @param {number} c
 * @return {jsts.geom.LineSegment}
 * @private
 */
jsts.algorithm.MinimumDiameter.computeSegmentForLine = function (a, b, c) {
    var p0;
    var p1;
    /*
     * Line eqn is ax + by = c
     * Slope is a/b.
     * If slope is steep, use y values as the inputs
     */
    if (Math.abs(b) > Math.abs(a)) {
        p0 = new jsts.geom.Coordinate(0, c / b);
        p1 = new jsts.geom.Coordinate(1, c / b - a / b);
    }
    else {
        p0 = new jsts.geom.Coordinate(c / a, 0);
        p1 = new jsts.geom.Coordinate(c / a - b / a, 1);
    }
    return new jsts.geom.LineSegment(p0, p1);
};

/**
 * Gets the length of the minimum diameter of the input Geometry
 * @return {number} the length of the minimum diameter
 */
jsts.algorithm.MinimumDiameter.prototype.getLength = function () {
    this.computeMinimumDiameter();
    return this.minWidth;
};

/**
 * Gets the {@link Coordinate} forming one end of the minimum diameter
 * @return {jsts.geom.Coordinate} a coordinate forming one end of the minimum diameter
 */
jsts.algorithm.MinimumDiameter.prototype.getWidthCoordinate = function () {
    this.computeMinimumDiameter();
    return this.minWidthPt;
};

/**
 * Gets the segment forming the base of the minimum diameter
 * @return {jsts.geom.LineString} the segment forming the base of the minimum diameter
 */
jsts.algorithm.MinimumDiameter.prototype.getSupportingSegment = function () {
    this.computeMinimumDiameter();
    var coord = [this.minBaseSeg.p0, this.minBaseSeg.p1];
    return jsts.algorithm.MinimumDiameter.inputGeom.getFactory().createLineString(coord);
};

/**
 * Gets a {@link LineString} which is a minimum diameter
 * @return {jsts.geom.LineString} a {@link LineString} which is a minimum diameter
 */
jsts.algorithm.MinimumDiameter.prototype.getDiameter = function () {
    this.computeMinimumDiameter();

    // return empty linestring if no minimum width calculated
    if (this.minWidthPt === null) {
        return jsts.algorithm.MinimumDiameter.inputGeom.getFactory().createLineString(null);
    }

    var basePt = this.minBaseSeg.project(this.minWidthPt);
    return jsts.algorithm.MinimumDiameter.inputGeom.getFactory().createLineString([basePt, this.minWidthPt]);
};

/**
 * @private
 */
jsts.algorithm.MinimumDiameter.prototype.computeMinimumDiameter = function () {
    // check if computation is cached
    if (this.minWidthPt !== null) {
        return;
    }

    if (jsts.algorithm.MinimumDiameter.isConvex)
        this.computeWidthConvex(jsts.algorithm.MinimumDiameter.inputGeom);
    else {
        var convexGeom = new jsts.algorithm.ConvexHull(jsts.algorithm.MinimumDiameter.inputGeom).getConvexHull();
        this.computeWidthConvex(convexGeom);
    }
};

/**
 * @param {jsts.geom.Geometry} convexGeom
 * @private
 */
jsts.algorithm.MinimumDiameter.prototype.computeWidthConvex = function (convexGeom) {
    if (convexGeom instanceof jsts.geom.Polygon) {
        this.convexHullPts = convexGeom.getExteriorRing().getCoordinates();
    } else {
        this.convexHullPts = convexGeom.getCoordinates();
    }

    // special cases for lines or points or degenerate rings
    if (this.convexHullPts.length === 0) {
        this.minWidth = 0;
        this.minWidthPt = null;
        this.minBaseSeg = null;
    } else if (this.convexHullPts.length === 1) {
        this.minWidth = 0;
        this.minWidthPt = this.convexHullPts[0];
        this.minBaseSeg.p0 = this.convexHullPts[0];
        this.minBaseSeg.p1 = this.convexHullPts[0];
    } else if (this.convexHullPts.length === 2 || this.convexHullPts.length === 3) {
        this.minWidth = 0;
        this.minWidthPt = this.convexHullPts[0];
        this.minBaseSeg.p0 = this.convexHullPts[0];
        this.minBaseSeg.p1 = this.convexHullPts[1];
    } else {
        this.computeConvexRingMinDiameter(this.convexHullPts);
    }
};

/**
 * Compute the width information for a ring of {@link Coordinate}s.
 * Leaves the width information in the instance variables.
 * @param {jsts.geom.Coordinate[]} pts
 * @private
 */
jsts.algorithm.MinimumDiameter.prototype.computeConvexRingMinDiameter = function (pts) {
    // for each segment in the ring
    this.minWidth = Number.MAX_VALUE;
    var currMaxIndex = 1;

    var seg = new jsts.geom.LineSegment();
    // compute the max distance for all segments in the ring, and pick the minimum
    for (var i = 0; i < pts.length - 1; i++) {
        seg.p0 = pts[i];
        seg.p1 = pts[i + 1];
        currMaxIndex = this.findMaxPerpDistance(pts, seg, currMaxIndex);
    }
};

/**
 * @param {jsts.geom.Coordinate[]} pts
 * @param {jsts.geom.LineSegment} seg
 * @param {number} startIndex
 * @return {number}
 * @private
 */
jsts.algorithm.MinimumDiameter.prototype.findMaxPerpDistance = function (pts, seg, startIndex) {
    var maxPerpDistance = seg.distancePerpendicular(pts[startIndex]);
    var nextPerpDistance = maxPerpDistance;
    var maxIndex = startIndex;
    var nextIndex = maxIndex;
    while (nextPerpDistance >= maxPerpDistance) {
        maxPerpDistance = nextPerpDistance;
        maxIndex = nextIndex;

        nextIndex = jsts.algorithm.MinimumDiameter.nextIndex(pts, maxIndex);
        nextPerpDistance = seg.distancePerpendicular(pts[nextIndex]);
    }
    // found maximum width for this segment - update global min dist if appropriate
    if (maxPerpDistance < this.minWidth) {
        this.minPtIndex = maxIndex;
        this.minWidth = maxPerpDistance;
        this.minWidthPt = pts[this.minPtIndex];
        this.minBaseSeg = new jsts.geom.LineSegment(seg);
    }
    return maxIndex;
};

/**
 * Gets the minimum rectangular {@link Polygon} which encloses the input geometry.
 * The rectangle has width equal to the minimum diameter, 
 * and a longer length.
 * If the convex hull of the input is degenerate (a line or point)
 * a {@link LineString} or {@link Point} is returned.
 * <p>
 * The minimum rectangle can be used as an extremely generalized representation
 * for the given geometry.
 * 
 * @return {jsts.geom.Geometry} the minimum rectangle enclosing the input (or a line or point if degenerate)
 */
jsts.algorithm.MinimumDiameter.prototype.getMinimumRectangle = function () {
    this.computeMinimumDiameter();

    // check if minimum rectangle is degenerate (a point or line segment)
    if (this.minWidth === 0) {
        if (this.minBaseSeg.p0.equals2D(this.minBaseSeg.p1)) {
            return jsts.algorithm.MinimumDiameter.inputGeom.getFactory().createPoint(this.minBaseSeg.p0);
        }
        return this.minBaseSeg.toGeometry(jsts.algorithm.MinimumDiameter.inputGeom.getFactory());
    }

    // deltas for the base segment of the minimum diameter
    var dx = this.minBaseSeg.p1.x - this.minBaseSeg.p0.x;
    var dy = this.minBaseSeg.p1.y - this.minBaseSeg.p0.y;

    var minPara = Number.MAX_VALUE;
    var maxPara = -Number.MAX_VALUE;
    var minPerp = Number.MAX_VALUE;
    var maxPerp = -Number.MAX_VALUE;

    // compute maxima and minima of lines parallel and perpendicular to base segment
    for (var i = 0; i < this.convexHullPts.length; i++) {

        var paraC = jsts.algorithm.MinimumDiameter.computeC(dx, dy, this.convexHullPts[i]);
        if (paraC > maxPara) maxPara = paraC;
        if (paraC < minPara) minPara = paraC;

        var perpC = jsts.algorithm.MinimumDiameter.computeC(-dy, dx, this.convexHullPts[i]);
        if (perpC > maxPerp) maxPerp = perpC;
        if (perpC < minPerp) minPerp = perpC;
    }

    // compute lines along edges of minimum rectangle
    var maxPerpLine = jsts.algorithm.MinimumDiameter.computeSegmentForLine(-dx, -dy, maxPerp);
    var minPerpLine = jsts.algorithm.MinimumDiameter.computeSegmentForLine(-dx, -dy, minPerp);
    var maxParaLine = jsts.algorithm.MinimumDiameter.computeSegmentForLine(-dy, dx, maxPara);
    var minParaLine = jsts.algorithm.MinimumDiameter.computeSegmentForLine(-dy, dx, minPara);

    // compute vertices of rectangle (where the para/perp max & min lines intersect)
    var p0 = maxParaLine.lineIntersection(maxPerpLine);
    var p1 = minParaLine.lineIntersection(maxPerpLine);
    var p2 = minParaLine.lineIntersection(minPerpLine);
    var p3 = maxParaLine.lineIntersection(minPerpLine);

    var shell = jsts.algorithm.MinimumDiameter.inputGeom.getFactory().createLinearRing(
        [p0, p1, p2, p3, p0]);
    return jsts.algorithm.MinimumDiameter.inputGeom.getFactory().createPolygon(shell, null);
};
/* ======================================================================
    jsts/io/GeoJSONParser.js
   ====================================================================== */

/* Copyright (c) 2011, 2012 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Class for reading and writing Well-Known Text.
 *
 * NOTE: Adapted from OpenLayers 2.11 implementation.
 */

(function() {
    /**
     * Create a new parser for GeoJSON
     *
     * @param {GeometryFactory}
     *          geometryFactory
     * @return An instance of GeoJsonParser.
     */
    jsts.io.GeoJSONParser = function(geometryFactory) {
        this.geometryFactory = geometryFactory || new jsts.geom.GeometryFactory();
        this.geometryTypes = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon'];
    };

    /**
     * Deserialize a GeoJSON object and return the Geometry or Feature(Collection) with JSTS Geometries
     *
     * @param {}
     *          A GeoJSON object.
     * @return {} A Geometry instance or object representing a Feature(Collection) with Geometry instances.
     */
    jsts.io.GeoJSONParser.prototype.read = function(json) {
        var obj;
        if (typeof json === 'string') {
            obj = JSON.parse(json);
        } else {
            obj = json;
        }

        var type = obj.type;

        if (!this.parse[type]) {
            throw new Error('Unknown GeoJSON type: ' + obj.type);
        }

        if (this.geometryTypes.indexOf(type) != -1) {
            return this.parse[type].apply(this, [obj.coordinates]);
        } else if (type === 'GeometryCollection') {
            return this.parse[type].apply(this, [obj.geometries]);
        }

        // feature or feature collection
        return this.parse[type].apply(this, [obj]);
    };

    jsts.io.GeoJSONParser.prototype.parse = {
        /**
         * Parse a GeoJSON Feature object
         *
         * @param {Object}
         *          obj Object to parse.
         *
         * @return {Object} Feature with geometry/bbox converted to JSTS Geometries.
         */
        'Feature': function(obj) {
            var feature = {};

            // copy features
            for (var key in obj) {
                feature[key] = obj[key];
            }

            // parse geometry
            if (obj.geometry) {
                var type = obj.geometry.type;
                if (!this.parse[type]) {
                    throw new Error('Unknown GeoJSON type: ' + obj.type);
                }
                feature.geometry = this.read(obj.geometry);
            }

            // bbox
            if (obj.bbox) {
                feature.bbox = this.parse.bbox.apply(this, [obj.bbox]);
            }

            return feature;
        },

        /**
         * Parse a GeoJSON FeatureCollection object
         *
         * @param {Object}
         *          obj Object to parse.
         *
         * @return {Object} FeatureCollection with geometry/bbox converted to JSTS Geometries.
         */
        'FeatureCollection': function(obj) {
            var featureCollection = {};

            if (obj.features) {
                featureCollection.features = [];

                for (var i = 0; i < obj.features.length; ++i) {
                    featureCollection.features.push(this.read(obj.features[i]));
                }
            }

            if (obj.bbox) {
                featureCollection.bbox = this.parse.bbox.apply(this, [obj.bbox]);
            }

            return featureCollection;
        },


        /**
         * Convert the ordinates in an array to an array of jsts.geom.Coordinates
         *
         * @param {Array}
         *          array Array with {Number}s.
         *
         * @return {Array} Array with jsts.geom.Coordinates.
         */
        'coordinates': function(array) {
            var coordinates = [];

            for (var i = 0; i < array.length; ++i) {
                var sub = array[i];
                coordinates.push(new jsts.geom.Coordinate(sub[0], sub[1]));
            }

            return coordinates;
        },

        /**
         * Convert the bbox to a jsts.geom.LinearRing
         *
         * @param {Array}
         *          array Array with [xMin, yMin, xMax, yMax].
         *
         * @return {Array} Array with jsts.geom.Coordinates.
         */
        'bbox': function(array) {
            return this.geometryFactory.createLinearRing([
                new jsts.geom.Coordinate(array[0], array[1]),
                new jsts.geom.Coordinate(array[2], array[1]),
                new jsts.geom.Coordinate(array[2], array[3]),
                new jsts.geom.Coordinate(array[0], array[3]),
                new jsts.geom.Coordinate(array[0], array[1])
            ]);
        },


        /**
         * Convert an Array with ordinates to a jsts.geom.Point
         *
         * @param {Array}
         *          array Array with ordinates.
         *
         * @return {jsts.geom.Point} Point.
         */
        'Point': function(array) {
            var coordinate = new jsts.geom.Coordinate(array[0], array[1]);
            return this.geometryFactory.createPoint(coordinate);
        },

        /**
         * Convert an Array with coordinates to a jsts.geom.MultiPoint
         *
         * @param {Array}
         *          array Array with coordinates.
         *
         * @return {jsts.geom.MultiPoint} MultiPoint.
         */
        'MultiPoint': function(array) {
            var points = [];

            for (var i = 0; i < array.length; ++i) {
                points.push(this.parse.Point.apply(this, [array[i]]));
            }

            return this.geometryFactory.createMultiPoint(points);
        },

        /**
         * Convert an Array with coordinates to a jsts.geom.LineString
         *
         * @param {Array}
         *          array Array with coordinates.
         *
         * @return {jsts.geom.LineString} LineString.
         */
        'LineString': function(array) {
            var coordinates = this.parse.coordinates.apply(this, [array]);
            return this.geometryFactory.createLineString(coordinates);
        },

        /**
         * Convert an Array with coordinates to a jsts.geom.MultiLineString
         *
         * @param {Array}
         *          array Array with coordinates.
         *
         * @return {jsts.geom.MultiLineString} MultiLineString.
         */
        'MultiLineString': function(array) {
            var lineStrings = [];

            for (var i = 0; i < array.length; ++i) {
                lineStrings.push(this.parse.LineString.apply(this, [array[i]]));
            }

            return this.geometryFactory.createMultiLineString(lineStrings);
        },

        /**
         * Convert an Array to a jsts.geom.Polygon
         *
         * @param {Array}
         *          array Array with shell and holes.
         *
         * @return {jsts.geom.Polygon} Polygon.
         */
        'Polygon': function(array) {
            // shell
            var shellCoordinates = this.parse.coordinates.apply(this, [array[0]]);
            var shell = this.geometryFactory.createLinearRing(shellCoordinates);

            // holes
            var holes = [];
            for (var i = 1; i < array.length; ++i) {
                var hole = array[i];
                var coordinates = this.parse.coordinates.apply(this, [hole]);
                var linearRing = this.geometryFactory.createLinearRing(coordinates);
                holes.push(linearRing);
            }

            return this.geometryFactory.createPolygon(shell, holes);
        },

        /**
         * Convert an Array to a jsts.geom.MultiPolygon
         *
         * @param {Array}
         *          array Array of arrays with shell and rings.
         *
         * @return {jsts.geom.MultiPolygon} MultiPolygon.
         */
        'MultiPolygon': function(array) {
            var polygons = [];

            for (var i = 0; i < array.length; ++i) {
                var polygon = array[i];
                polygons.push(this.parse.Polygon.apply(this, [polygon]));
            }

            return this.geometryFactory.createMultiPolygon(polygons);
        },

        /**
         * Convert an Array to a jsts.geom.GeometryCollection
         *
         * @param {Array}
         *          array Array of GeoJSON geometries.
         *
         * @return {jsts.geom.GeometryCollection} GeometryCollection.
         */
        'GeometryCollection': function(array) {
            var geometries = [];

            for (var i = 0; i < array.length; ++i) {
                var geometry = array[i];
                geometries.push(this.read(geometry));
            }

            return this.geometryFactory.createGeometryCollection(geometries);
        }
    };

    /**
     * Serialize a Geometry object into GeoJSON
     *
     * @param {jsts.geom.geometry}
     *          geometry A Geometry or array of Geometries.
     * @return {Object} A GeoJSON object represting the input Geometry/Geometries.
     */
    jsts.io.GeoJSONParser.prototype.write = function(geometry) {
        var type = geometry.CLASS_NAME.slice(10);

        if (!this.extract[type]) {
            throw new Error('Geometry is not supported');
        }

        return this.extract[type].apply(this, [geometry]);
    };

    jsts.io.GeoJSONParser.prototype.extract = {
        /**
         * Convert a jsts.geom.Coordinate to an Array
         *
         * @param {jsts.geom.Coordinate}
         *          coordinate Coordinate to convert.
         *
         * @return {Array} Array of ordinates.
         */
        'coordinate': function(coordinate) {
            return [coordinate.x, coordinate.y];
        },

        /**
         * Convert a jsts.geom.Point to a GeoJSON object
         *
         * @param {jsts.geom.Point}
         *          point Point to convert.
         *
         * @return {Array} Array of 2 ordinates (paired to a coordinate).
         */
        'Point': function(point) {
            var array = this.extract.coordinate.apply(this, [point.coordinate]);

            return {
                type: 'Point',
                coordinates: array
            };
        },

        /**
         * Convert a jsts.geom.MultiPoint to a GeoJSON object
         *
         * @param {jsts.geom.MultiPoint}
         *          multipoint MultiPoint to convert.
         *
         * @return {Array} Array of coordinates.
         */
        'MultiPoint': function(multipoint) {
            var array = [];

            for (var i = 0; i < multipoint.geometries.length; ++i) {
                var point = multipoint.geometries[i];
                var geoJson = this.extract.Point.apply(this, [point]);
                array.push(geoJson.coordinates);
            }

            return {
                type: 'MultiPoint',
                coordinates: array
            };
        },

        /**
         * Convert a jsts.geom.LineString to a GeoJSON object
         *
         * @param {jsts.geom.LineString}
         *          linestring LineString to convert.
         *
         * @return {Array} Array of coordinates.
         */
        'LineString': function(linestring) {
            var array = [];

            for (var i = 0; i < linestring.points.length; ++i) {
                var coordinate = linestring.points[i];
                array.push(this.extract.coordinate.apply(this, [coordinate]));
            }

            return {
                type: 'LineString',
                coordinates: array
            };
        },

        /**
         * Convert a jsts.geom.MultiLineString to a GeoJSON object
         *
         * @param {jsts.geom.MultiLineString}
         *          multilinestring MultiLineString to convert.
         *
         * @return {Array} Array of Array of coordinates.
         */
        'MultiLineString': function(multilinestring) {
            var array = [];

            for (var i = 0; i < multilinestring.geometries.length; ++i) {
                var linestring = multilinestring.geometries[i];
                var geoJson = this.extract.LineString.apply(this, [linestring]);
                array.push(geoJson.coordinates);
            }

            return {
                type: 'MultiLineString',
                coordinates: array
            };
        },

        /**
         * Convert a jsts.geom.Polygon to a GeoJSON object
         *
         * @param {jsts.geom.Polygon}
         *          polygon Polygon to convert.
         *
         * @return {Array} Array with shell, holes.
         */
        'Polygon': function(polygon) {
            var array = [];

            // shell
            var shellGeoJson = this.extract.LineString.apply(this, [polygon.shell]);
            array.push(shellGeoJson.coordinates);

            // holes
            for (var i = 0; i < polygon.holes.length; ++i) {
                var hole = polygon.holes[i];
                var holeGeoJson = this.extract.LineString.apply(this, [hole]);
                array.push(holeGeoJson.coordinates);
            }

            return {
                type: 'Polygon',
                coordinates: array
            };
        },

        /**
         * Convert a jsts.geom.MultiPolygon to a GeoJSON object
         *
         * @param {jsts.geom.MultiPolygon}
         *          multipolygon MultiPolygon to convert.
         *
         * @return {Array} Array of polygons.
         */
        'MultiPolygon': function(multipolygon) {
            var array = [];

            for (var i = 0; i < multipolygon.geometries.length; ++i) {
                var polygon = multipolygon.geometries[i];
                var geoJson = this.extract.Polygon.apply(this, [polygon]);
                array.push(geoJson.coordinates);
            }

            return {
                type: 'MultiPolygon',
                coordinates: array
            };
        },

        /**
         * Convert a jsts.geom.GeometryCollection to a GeoJSON object
         *
         * @param {jsts.geom.GeometryCollection}
         *          collection GeometryCollection to convert.
         *
         * @return {Array} Array of geometries.
         */
        'GeometryCollection': function(collection) {
            var array = [];

            for (var i = 0; i < collection.geometries.length; ++i) {
                var geometry = collection.geometries[i];
                var type = geometry.CLASS_NAME.slice(10);
                array.push(this.extract[type].apply(this, [geometry]));
            }

            return {
                type: 'GeometryCollection',
                geometries: array
            };
        }
    };
})();
/* ======================================================================
    jsts/triangulate/quadedge/Vertex.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */


/**
 * Models a site (node) in a {@link QuadEdgeSubdivision}. The sites can be
 * points on a lineString representing a linear site. The vertex can be
 * considered as a vector with a norm, length, inner product, cross product,
 * etc. Additionally, point relations (e.g., is a point to the left of a line,
 * the circle defined by this point and two others, etc.) are also defined in
 * this class.
 *
 * Initializes a new Vertex. Will call the correct init* -function based on
 * arguments
 *
 * @constructor
 */

jsts.triangulate.quadedge.Vertex = function() {
  if (arguments.length === 1) {
    this.initFromCoordinate(arguments[0]);
  } else {
    this.initFromXY(arguments[0], arguments[1]);
  }
};


/**
 * LEFT The integer representing left
 */
jsts.triangulate.quadedge.Vertex.LEFT = 0;


/**
 * RIGHT The integer representing right
 */
jsts.triangulate.quadedge.Vertex.RIGHT = 1;


/**
 * BEYOND The integer representing beyond
 */
jsts.triangulate.quadedge.Vertex.BEYOND = 2;


/**
 * BEHIND The integer representing behind
 */
jsts.triangulate.quadedge.Vertex.BEHIND = 3;


/**
 * BETWEEN The integer representing between
 */
jsts.triangulate.quadedge.Vertex.BETWEEN = 4;


/**
 * ORIGIN The integer representing origin
 */
jsts.triangulate.quadedge.Vertex.ORIGIN = 5;


/**
 * DESTINATION The integer representing destination
 */
jsts.triangulate.quadedge.Vertex.DESTINATION = 6;


/**
 * Initializes a new Vertex
 *
 * @param {Number}
 *          x the X-coordinate.
 * @param {Number}
 *          y the Y-coordinate.
 */
jsts.triangulate.quadedge.Vertex.prototype.initFromXY = function(x, y) {
  this.p = new jsts.geom.Coordinate(x, y);
};


/**
 * Initializes a new Vertex
 *
 * @param {jsts.geom.Coordinate}
 *          _p the coordinate to initialize the vertex from.
 */
jsts.triangulate.quadedge.Vertex.prototype.initFromCoordinate = function(_p) {
  this.p = new jsts.geom.Coordinate(_p);
};


/**
 * Gets the X-coordinate
 *
 * @return {Number} The X-coordinate.
 */
jsts.triangulate.quadedge.Vertex.prototype.getX = function() {
  return this.p.x;
};


/**
 * Gets the Y-coordinate
 *
 * @return {Number} The Y-coordinate.
 */
jsts.triangulate.quadedge.Vertex.prototype.getY = function() {
  return this.p.y;
};


/**
 * Gets the Z-coordinate
 *
 * @return {Number} The Z-coordinate.
 */
jsts.triangulate.quadedge.Vertex.prototype.getZ = function() {
  return this.p.z;
};


/**
 * Sets the Z-coordinate
 *
 * @param {Number}
 *          z the new z-coordinate.
 */
jsts.triangulate.quadedge.Vertex.prototype.setZ = function(z) {
  this.p.z = z;
};


/**
 * Gets the coordinate of the vertex
 *
 * @return {jsts.geom.Coordinate} The coordinate.
 */
jsts.triangulate.quadedge.Vertex.prototype.getCoordinate = function() {
  return this.p;
};


/**
 * Gets the string representation of the vertex
 *
 * @return {String} The string representing the vertex.
 */
jsts.triangulate.quadedge.Vertex.prototype.toString = function() {
  return 'POINT (' + this.p.x + ' ' + this.p.y + ')';
};


/**
 * Checks if this vertex is identical to another vertex.
 *
 * Calls correct equals* function based on arguments
 *
 * @return {Boolean} true if the vertex equals eachother.
 */
jsts.triangulate.quadedge.Vertex.prototype.equals = function() {
  if (arguments.length === 1) {
    return this.equalsExact(arguments[0]);
  } else {
    return this.equalsWithTolerance(arguments[0], arguments[1]);
  }
};


/**
 * Checks if this vertex is identical to other
 *
 * @param {jsts.triangulate.quadedge.Vertex}
 *          other The vertex to compare this vertex to.
 * @return {Boolean} true if this vertex equals other.
 */
jsts.triangulate.quadedge.Vertex.prototype.equalsExact = function(other) {
  return (this.p.x === other.getX() && this.p.y === other.getY());
};


/**
 * Checks if this vertex is identical to other with respect to a tolerance
 *
 * @param {jsts.triangulate.quadedge.Vertex}
 *          other The vertex to compare this vertex to.
 * @param {Number}
 *          tolerance The tolerance to consider when comparing the two vertexes.
 * @return {Boolean} true if this vertex equals other.
 */
jsts.triangulate.quadedge.Vertex.prototype.equalsWithTolerance = function(other,
    tolerance) {
  return (this.p.distance(other.getCoordinate()) < tolerance);
};


/**
 * Clasifys a vertex with respect to another vertex
 *
 * @param {jsts.triangulate.quadedge.Vertex}
 *          p0 The first vertex.
 * @param {jsts.triangulate.quadedge.Vertex}
 *          p1 The second vertex.
 * @return {Number} The classification.
 */
jsts.triangulate.quadedge.Vertex.prototype.classify = function(p0, p1) {
  var p2, a, b, sa;

  p2 = this;
  a = p1.sub(p0);
  b = p2.sub(p0);
  sa = a.crossProduct(b);

  if (sa > 0.0) {
    return jsts.triangulate.quadedge.Vertex.LEFT;
  }
  if (sa < 0.0) {
    return jsts.triangulate.quadedge.Vertex.RIGHT;
  }
  if ((a.getX() * b.getX() < 0.0) || (a.getY() * b.getY() < 0.0)) {
    return jsts.triangulate.quadedge.Vertex.BEHIND;
  }
  if (a.magn() < b.magn()) {
    return jsts.triangulate.quadedge.Vertex.BEYOND;
  }
  if (p0.equals(p2)) {
    return jsts.triangulate.quadedge.Vertex.ORIGIN;
  }
  if (p1.equals(p2)) {
    return jsts.triangulate.quadedge.Vertex.DESTINATION;
  }
  return jsts.triangulate.quadedge.Vertex.BETWEEN;
};


/**
 * Computes the cross product k = u X v.
 *
 * @param {jsts.triangulate.quadedge.Vertex}
 *          v a vertex.
 * @return {Number} The magnitude of u X v.
 */
jsts.triangulate.quadedge.Vertex.prototype.crossProduct = function(v) {
  return ((this.p.x * v.getY()) - (this.p.y * v.getX()));
};


/**
 * Computes the inner or dot product
 *
 * @param {jsts.triangulate.quadedge.Vertex}
 *          v a vertex.
 * @return {Number} The dot product u.v.
 */
jsts.triangulate.quadedge.Vertex.prototype.dot = function(v) {
  return ((this.p.x * v.getX()) + (this.p.y * v.getY()));
};


/**
 * Computes the scalar product c(v).
 *
 * @param {Number}
 *          c The scalar.
 * @return {jsts.triangulate.quadedge.Vertex} The scaled vector.
 */
jsts.triangulate.quadedge.Vertex.prototype.times = function(c) {
  return new jsts.triangulate.quadedge.Vertex(c * this.p.x, c * this.p.y);
};


/**
 * Computes the sum of vectors.
 *
 * @param {jsts.triangulate.quadedge.Vertex}
 *          v Another vertex.
 * @return {jsts.triangulate.quadedge.Vertex} The sum of the this and v.
 */
jsts.triangulate.quadedge.Vertex.prototype.sum = function(v) {
  return new jsts.triangulate.quadedge.Vertex(this.p.x + v.getX(), this.p.y +
      v.getY());
};


/**
 * Computes the substraction of vectors.
 *
 * @param {jsts.triangulate.quadedge.Vertex}
 *          v Another vertex.
 * @return {jsts.triangulate.quadedge.Vertex} The substraction of v from this.
 */
jsts.triangulate.quadedge.Vertex.prototype.sub = function(v) {
  return new jsts.triangulate.quadedge.Vertex(this.p.x - v.getX(), this.p.y -
      v.getY());
};


/**
 * Computes the magnitude.
 *
 * @return {Number} The magnitude of this vertex.
 */
jsts.triangulate.quadedge.Vertex.prototype.magn = function() {
  return (Math.sqrt((this.p.x * this.p.x) + (this.p.y * this.p.y)));
};


/**
 * Returns k X v (cross product). This is a vector perpendicular to v.
 *
 * @return {jsts.triangulate.quadedge.Vertex} A perpendicular vertex to this
 *         vertex.
 */
jsts.triangulate.quadedge.Vertex.prototype.cross = function() {
  return new Vertex(this.p.y, -this.p.x);
};


/**
 * Checks if this vertex lies in the circle defined by a, b and c
 *
 * @param {jsts.triangulate.quadedge.Vertex}
 *          a A vertex.
 * @param {jsts.triangulate.quadedge.Vertex}
 *          b A vertex.
 * @param {jsts.triangulate.quadedge.Vertex}
 *          c A vertex.
 * @return {Boolean} true if this vertex lies in the circle.
 */
jsts.triangulate.quadedge.Vertex.prototype.isInCircle = function(a, b, c) {
  return jsts.triangulate.quadedge.TrianglePredicate.isInCircleRobust(a.p, b.p, c.p, this.p);
};


/**
 * Tests whether the triangle formed by this vertex and two other vertices is in
 * CCW orientation.
 *
 * @param {jsts.triangulate.quadedge.Vertex}
 *          b a vertex.
 * @param {jsts.triangulate.quadedge.Vertex}
 *          c a vertex.
 * @return {Boolean} true if the triangle is oriented CCW.
 */
jsts.triangulate.quadedge.Vertex.prototype.isCCW = function(b, c) {
  // is equal to the signed area of the triangle
  return ((b.p.x - this.p.x) * (c.p.y - this.p.y) - (b.p.y - this.p.y) *
      (c.p.x - this.p.x) > 0);
};


/**
 * Tests wheter this vertex lies to the right of an edge
 *
 * @param {jsts.triangulate.quadedge.QuadEdge}
 *          e A quadedge.
 * @return {Boolean} true if this vertex lies to the right of the edge.
 */
jsts.triangulate.quadedge.Vertex.prototype.rightOf = function(e) {
  return this.isCCW(e.dest(), e.orig());
};


/**
 * Tests wheter this vertex lies to the left of an edge
 *
 * @param {jsts.triangulate.quadedge.QuadEdge}
 *          e A quadedge.
 * @return {Boolean} true if this vertex lies to the left of the edge.
 */
jsts.triangulate.quadedge.Vertex.prototype.leftOf = function(e) {
  return this.isCCW(e.orig(), e.dest());
};


/**
 * Returns the perpendicular bisector of the line between the input vertices
 *
 * @param {jsts.triangulate.quadedge.Vertex}
 *          a A vertex.
 * @param {jsts.triangulate.quadedge.Vertex}
 *          b A vertex.
 * @return {jsts.algorithm.HCoordinate} The bisector.
 */
jsts.triangulate.quadedge.Vertex.prototype.bisector = function(a, b) {
  var dx, dy, l1, l2;

  dx = b.getX() - a.getX();
  dy = b.getY() - a.getY();

  l1 = new jsts.algorithm.HCoordinate(a.getX() + (dx / 2.0), a.getY() +
      (dy / 2.0), 1.0);
  l2 = new jsts.algorithm.HCoordinate(a.getX() - dy + (dx / 2.0), a.getY() +
      dx + (dy / 2.0), 1.0);
  return new jsts.algorithm.HCoordinate(l1, l2);
};


/**
 * Calculates the distance between two vertices
 *
 * @param {jsts.triangulate.quadedge.Vertex}
 *          v1 a vertex.
 * @param {jsts.triangulate.quadedge.Vertex}
 *          v2 a vertex.
 * @return {Number} The distance.
 */
jsts.triangulate.quadedge.Vertex.prototype.distance = function(v1, v2) {
  return v1.p.distance(v2.p);
};


/**
 * Computes the value of the ratio of the circumradius to shortest edge. If
 * smaller than some given tolerance B, the associated triangle is considered
 * skinny.
 *
 * For an equal lateral triangle this value is 0.57735. The ratio is related to
 * the minimum triangle angle theta by: circumRadius/shortestEdge =
 * 1/(2sin(theta)).
 *
 * @param {jsts.triangulate.quadedge}
 *          b second vertex of the triangle.
 * @param {jsts.triangulate.quadedge}
 *          c third vertex of the triangle.
 * @return {Number} ratio of circumradius to shortest edge.
 */
jsts.triangulate.quadedge.Vertex.prototype.circumRadiusRatio = function(b, c) {
  var x, radius, edgeLength, el;

  x = this.circleCenter(b, c);
  radius = this.distance(x, b);
  edgeLength = this.distance(this, b);
  el = this.distance(b, c);

  if (el < edgeLength) {
    edgeLength = el;
  }
  el = this.distance(c, this);
  if (el < edgeLength) {
    edgeLength = el;
  }
  return radius / edgeLength;
};


/**
 * returns a new vertex that is mid-way between this vertex and another end
 * point.
 *
 * @param {jsts.triangulate.quadedge.Vertex}
 *          a the other end point.
 * @return {jsts.triangulate.quadedge.Vertex} the point mid-way between this and
 *         that.
 */
jsts.triangulate.quadedge.Vertex.prototype.midPoint = function(a) {
  var xm, ym;
  xm = (this.p.x + a.getX()) / 2.0;
  ym = (this.p.y + a.getY()) / 2.0;

  return new jsts.triangulate.quadedge.Vertex(xm, ym);
};


/**
 * Computes the centre of the circumcircle of this vertex and two others.
 *
 * @param {jsts.triangulate.quadedge.Vertex}
 *          b a vertex.
 * @param {jsts.triangulate.quadedge.Vertex}
 *          c a vertex.
 * @return {jsts.triangulate.quadedge.Vertex} the Coordinate which is the
 *         circumcircle of the 3 points.
 */
jsts.triangulate.quadedge.Vertex.prototype.circleCenter = function(b, c) {
  var a, cab, cbc, hcc, cc;

  a = new jsts.triangulate.quadedge.Vertex(this.getX(), this.getY());
  // compute the perpendicular bisector of cord ab
  cab = this.bisector(a, b);
  // compute the perpendicular bisector of cord bc
  cbc = this.bisector(b, c);
  // compute the intersection of the bisectors (circle radii)
  hcc = new jsts.algorithm.HCoordinate(cab, cbc);
  cc = null;
  try {
    cc = new jsts.triangulate.quadedge.Vertex(hcc.getX(), hcc.getY());
  } catch (err) {
  }

  return cc;
};
/* ======================================================================
    jsts/operation/valid/IsValidOp.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Implements the algorithms required to compute the <code>isValid()</code>
 * method for {@link Geometry}s. See the documentation for the various geometry
 * types for a specification of validity.
 *
 * @version 1.7
 * @constructor
 */

jsts.operation.valid.IsValidOp = function(parentGeometry) {
  this.parentGeometry = parentGeometry;
  this.isSelfTouchingRingFormingHoleValid = false;
  this.validErr = null;
};

/**
 * Tests whether a {@link Geometry} is valid.
 *
 * @param geom
 *          the Geometry to test.
 * @return true if the geometry is valid.
 */
jsts.operation.valid.IsValidOp.isValid = function(arg) {
  if (arguments[0] instanceof jsts.geom.Coordinate) {
    if (isNaN(arg.x)) {
      return false;
    }
    if (!isFinite(arg.x) && !isNaN(arg.x)) {
      return false;
    }
    if (isNaN(arg.y)) {
      return false;
    }
    if (!isFinite(arg.y) && !isNaN(arg.y)) {
      return false;
    }
    return true;
  } else {
    var isValidOp = new jsts.operation.valid.IsValidOp(arg);
    return isValidOp.isValid();
  }
};

/**
 * Find a point from the list of testCoords that is NOT a node in the edge for
 * the list of searchCoords
 *
 * @return the point found, or <code>null</code> if none found.
 */
jsts.operation.valid.IsValidOp.findPtNotNode = function(testCoords, searchRing,
    graph) {
  // find edge corresponding to searchRing.
  var searchEdge = graph.findEdge(searchRing);
  // find a point in the testCoords which is not a node of the searchRing
  var eiList = searchEdge.getEdgeIntersectionList();
  // somewhat inefficient - is there a better way? (Use a node map, for
  // instance?)
  for (var i = 0; i < testCoords.length; i++) {
    var pt = testCoords[i];
    if (!eiList.isIntersection(pt)) {
      return pt;
    }
  }
  return null;
};

/**
 * Sets whether polygons using <b>Self-Touching Rings</b> to form holes are
 * reported as valid. If this flag is set, the following Self-Touching
 * conditions are treated as being valid:
 * <ul>
 * <li>the shell ring self-touches to create a hole touching the shell
 * <li>a hole ring self-touches to create two holes touching at a point
 * </ul>
 * <p>
 * The default (following the OGC SFS standard) is that this condition is <b>not</b>
 * valid (<code>false</code>).
 * <p>
 * This does not affect whether Self-Touching Rings disconnecting the polygon
 * interior are considered valid (these are considered to be <b>invalid</b>
 * under the SFS, and many other spatial models as well). This includes
 * "bow-tie" shells, which self-touch at a single point causing the interior to
 * be disconnected, and "C-shaped" holes which self-touch at a single point
 * causing an island to be formed.
 *
 * @param isValid
 *          states whether geometry with this condition is valid.
 */
jsts.operation.valid.IsValidOp.prototype.setSelfTouchingRingFormingHoleValid = function(
    isValid) {
  this.isSelfTouchingRingFormingHoleValid = isValid;
};

jsts.operation.valid.IsValidOp.prototype.isValid = function() {
  this.checkValid(this.parentGeometry);
  return this.validErr == null;
};

jsts.operation.valid.IsValidOp.prototype.getValidationError = function() {
  this.checkValid(this.parentGeometry);
  return this.validErr;
};

jsts.operation.valid.IsValidOp.prototype.checkValid = function(g) {
  this.validErr = null;

  // empty geometries are always valid!
  if (g.isEmpty()) {
    return;
  }

  if (g instanceof jsts.geom.Point) {
    this.checkValidPoint(g);
  } else if (g instanceof jsts.geom.MultiPoint) {
    this.checkValidMultiPoint(g);
    // LineString also handles LinearRings
  } else if (g instanceof jsts.geom.LinearRing) {
    this.checkValidLinearRing(g);
  } else if (g instanceof jsts.geom.LineString) {
    this.checkValidLineString(g);
  } else if (g instanceof jsts.geom.Polygon) {
    this.checkValidPolygon(g);
  } else if (g instanceof jsts.geom.MultiPolygon) {
    this.checkValidMultiPolygon(g);
  } else if (g instanceof jsts.geom.GeometryCollection) {
    this.checkValidGeometryCollection(g);
  } else {
    throw g.constructor;
  }
};

/**
 * Checks validity of a Point.
 */
jsts.operation.valid.IsValidOp.prototype.checkValidPoint = function(g) {
  this.checkInvalidCoordinates(g.getCoordinates());
};
/**
 * Checks validity of a MultiPoint.
 */
jsts.operation.valid.IsValidOp.prototype.checkValidMultiPoint = function(g) {
  this.checkInvalidCoordinates(g.getCoordinates());
};

/**
 * Checks validity of a LineString. Almost anything goes for linestrings!
 */
jsts.operation.valid.IsValidOp.prototype.checkValidLineString = function(g) {
  this.checkInvalidCoordinates(g.getCoordinates());
  if (this.validErr != null) {
    return;
  }
  var graph = new jsts.geomgraph.GeometryGraph(0, g);
  this.checkTooFewPoints(graph);
};
/**
 * Checks validity of a LinearRing.
 */
jsts.operation.valid.IsValidOp.prototype.checkValidLinearRing = function(g) {
  this.checkInvalidCoordinates(g.getCoordinates());
  if (this.validErr != null) {
    return;
  }
  this.checkClosedRing(g);
  if (this.validErr != null) {
    return;
  }
  var graph = new jsts.geomgraph.GeometryGraph(0, g);
  this.checkTooFewPoints(graph);
  if (this.validErr != null) {
    return;
  }
  var li = new jsts.algorithm.RobustLineIntersector();
  graph.computeSelfNodes(li, true);
  this.checkNoSelfIntersectingRings(graph);
};

/**
 * Checks the validity of a polygon. Sets the validErr flag.
 */
jsts.operation.valid.IsValidOp.prototype.checkValidPolygon = function(g) {
  this.checkInvalidCoordinates(g);
  if (this.validErr != null) {
    return;
  }
  this.checkClosedRings(g);
  if (this.validErr != null) {
    return;
  }

  var graph = new jsts.geomgraph.GeometryGraph(0, g);

  this.checkTooFewPoints(graph);
  if (this.validErr != null) {
    return;
  }
  this.checkConsistentArea(graph);
  if (this.validErr != null) {
    return;
  }

  if (!this.isSelfTouchingRingFormingHoleValid) {
    this.checkNoSelfIntersectingRings(graph);
    if (this.validErr != null) {
      return;
    }
  }
  this.checkHolesInShell(g, graph);
  if (this.validErr != null) {
    return;
  }
  // SLOWcheckHolesNotNested(g);
  this.checkHolesNotNested(g, graph);
  if (this.validErr != null) {
    return;
  }
  this.checkConnectedInteriors(graph);
};

jsts.operation.valid.IsValidOp.prototype.checkValidMultiPolygon = function(g) {
  var il = g.getNumGeometries();
  for (var i = 0; i < il; i++) {
    var p = g.getGeometryN(i);
    this.checkInvalidCoordinates(p);
    if (this.validErr != null) {
      return;
    }
    this.checkClosedRings(p);
    if (this.validErr != null) {
      return;
    }
  }
  // Add this
  var graph = new jsts.geomgraph.GeometryGraph(0, g);

  this.checkTooFewPoints(graph);
  if (this.validErr != null) {
    return;
  }
  this.checkConsistentArea(graph);
  if (this.validErr != null) {
    return;
  }
  if (!this.isSelfTouchingRingFormingHoleValid) {
    this.checkNoSelfIntersectingRings(graph);
    if (this.validErr != null) {
      return;
    }
  }
  for (var i = 0; i < g.getNumGeometries(); i++) {
    var p = g.getGeometryN(i);
    this.checkHolesInShell(p, graph);
    if (this.validErr != null) {
      return;
    }
  }
  for (var i = 0; i < g.getNumGeometries(); i++) {
    var p = g.getGeometryN(i);
    this.checkHolesNotNested(p, graph);
    if (this.validErr != null) {
      return;
    }
  }
  this.checkShellsNotNested(g, graph);
  if (this.validErr != null) {
    return;
  }
  this.checkConnectedInteriors(graph);
};

jsts.operation.valid.IsValidOp.prototype.checkValidGeometryCollection = function(
    gc) {
  for (var i = 0; i < gc.getNumGeometries(); i++) {
    var g = gc.getGeometryN(i);
    this.checkValid(g);
    if (this.validErr != null) {
      return;
    }
  }
};

jsts.operation.valid.IsValidOp.prototype.checkInvalidCoordinates = function(
    arg) {
  if (arg instanceof jsts.geom.Polygon) {
    var poly = arg;
    this.checkInvalidCoordinates(poly.getExteriorRing().getCoordinates());
    if (this.validErr != null) {
      return;
    }
    for (var i = 0; i < poly.getNumInteriorRing(); i++) {
      this.checkInvalidCoordinates(poly.getInteriorRingN(i).getCoordinates());
      if (this.validErr != null) {
        return;
      }
    }
  } else {
    var coords = arg;
    for (var i = 0; i < coords.length; i++) {
      if (!jsts.operation.valid.IsValidOp.isValid(coords[i])) {
        this.validErr = new jsts.operation.valid.TopologyValidationError(
            jsts.operation.valid.TopologyValidationError.INVALID_COORDINATE,
            coords[i]);
        return;
      }
    }
  }
};

jsts.operation.valid.IsValidOp.prototype.checkClosedRings = function(poly) {
  // checkClosedRing((LinearRing) poly.getExteriorRing());
  this.checkClosedRing(poly.getExteriorRing());
  if (this.validErr != null) {
    return;
  }
  for (var i = 0; i < poly.getNumInteriorRing(); i++) {
    // checkClosedRing((LinearRing) poly.getInteriorRingN(i));
    this.checkClosedRing(poly.getInteriorRingN(i));
    if (this.validErr != null) {
      return;
    }
  }
};

jsts.operation.valid.IsValidOp.prototype.checkClosedRing = function(ring) {
  if (!ring.isClosed()) {
    var pt = null;
    if (ring.getNumPoints() >= 1) {
      pt = ring.getCoordinateN(0);
    }
    this.validErr = new jsts.operation.valid.TopologyValidationError(
        jsts.operation.valid.TopologyValidationError.RING_NOT_CLOSED, pt);
  }
};

jsts.operation.valid.IsValidOp.prototype.checkTooFewPoints = function(graph) {
  if (graph.hasTooFewPoints) {
    this.validErr = new jsts.operation.valid.TopologyValidationError(
        jsts.operation.valid.TopologyValidationError.TOO_FEW_POINTS, graph
            .getInvalidPoint());
    return;
  }
};

/**
 * Checks that the arrangement of edges in a polygonal geometry graph forms a
 * consistent area.
 *
 * @param graph
 *
 * @see ConsistentAreaTester
 */
jsts.operation.valid.IsValidOp.prototype.checkConsistentArea = function(graph) {
  var cat = new jsts.operation.valid.ConsistentAreaTester(graph);
  var isValidArea = cat.isNodeConsistentArea();
  if (!isValidArea) {
    this.validErr = new jsts.operation.valid.TopologyValidationError(
        jsts.operation.valid.TopologyValidationError.SELF_INTERSECTION, cat
            .getInvalidPoint());
    return;
  }
  if (cat.hasDuplicateRings()) {
    this.validErr = new jsts.operation.valid.TopologyValidationError(
        jsts.operation.valid.TopologyValidationError.DUPLICATE_RINGS, cat
            .getInvalidPoint());
  }
};

/**
 * Check that there is no ring which self-intersects (except of course at its
 * endpoints). This is required by OGC topology rules (but not by other models
 * such as ESRI SDE, which allow inverted shells and exverted holes).
 *
 * @param graph
 *          the topology graph of the geometry.
 */
jsts.operation.valid.IsValidOp.prototype.checkNoSelfIntersectingRings = function(
    graph) {
  for (var i = graph.getEdgeIterator(); i.hasNext();) {
    var e = i.next();
    this.checkNoSelfIntersectingRing(e.getEdgeIntersectionList());
    if (this.validErr != null) {
      return;
    }
  }
};

/**
 * Check that a ring does not self-intersect, except at its endpoints. Algorithm
 * is to count the number of times each node along edge occurs. If any occur
 * more than once, that must be a self-intersection.
 */
jsts.operation.valid.IsValidOp.prototype.checkNoSelfIntersectingRing = function(
    eiList) {
  var nodeSet = [];
  var isFirst = true;
  for (var i = eiList.iterator(); i.hasNext();) {
    var ei = i.next();
    if (isFirst) {
      isFirst = false;
      continue;
    }
    if (nodeSet.indexOf(ei.coord) >= 0) {
      this.validErr = new jsts.operation.valid.TopologyValidationError(
          jsts.operation.valid.TopologyValidationError.RING_SELF_INTERSECTION,
          ei.coord);
      return;
    } else {
      nodeSet.push(ei.coord);
    }
  }
};

/**
 * Tests that each hole is inside the polygon shell. This routine assumes that
 * the holes have previously been tested to ensure that all vertices lie on the
 * shell oon the same side of it (i.e that the hole rings do not cross the shell
 * ring). In other words, this test is only correct if the ConsistentArea test
 * is passed first. Given this, a simple point-in-polygon test of a single point
 * in the hole can be used, provided the point is chosen such that it does not
 * lie on the shell.
 *
 * @param p
 *          the polygon to be tested for hole inclusion.
 * @param graph
 *          a GeometryGraph incorporating the polygon.
 */
jsts.operation.valid.IsValidOp.prototype.checkHolesInShell = function(p, graph) {
  var shell = p.getExteriorRing();

  // PointInRing pir = new SimplePointInRing(shell);
  // PointInRing pir = new SIRtreePointInRing(shell);

  var pir = new jsts.algorithm.MCPointInRing(shell);

  for (var i = 0; i < p.getNumInteriorRing(); i++) {

    var hole = p.getInteriorRingN(i); // Cast?
    var holePt = jsts.operation.valid.IsValidOp.findPtNotNode(hole.getCoordinates(), shell, graph);
    /**
     * If no non-node hole vertex can be found, the hole must split the polygon
     * into disconnected interiors. This will be caught by a subsequent check.
     */
    if (holePt == null) {
      return;
    }

    var outside = !pir.isInside(holePt);
    if (outside) {
      this.validErr = new jsts.operation.valid.TopologyValidationError(
          jsts.operation.valid.TopologyValidationError.HOLE_OUTSIDE_SHELL,
          holePt);
      return;
    }
  }
};

/**
 * Tests that no hole is nested inside another hole. This routine assumes that
 * the holes are disjoint. To ensure this, holes have previously been tested to
 * ensure that:
 * <ul>
 * <li>they do not partially overlap (checked by
 * <code>checkRelateConsistency</code>)
 * <li>they are not identical (checked by <code>checkRelateConsistency</code>)
 * </ul>
 */
jsts.operation.valid.IsValidOp.prototype.checkHolesNotNested = function(p,
    graph) {
  var nestedTester = new jsts.operation.valid.IndexedNestedRingTester(graph);
  // SimpleNestedRingTester nestedTester = new SimpleNestedRingTester(arg[0]);
  // SweeplineNestedRingTester nestedTester = new
  // SweeplineNestedRingTester(arg[0]);

  for (var i = 0; i < p.getNumInteriorRing(); i++) {
    var innerHole = p.getInteriorRingN(i);
    nestedTester.add(innerHole);
  }
  var isNonNested = nestedTester.isNonNested();
  if (!isNonNested) {
    this.validErr = new jsts.operation.valid.TopologyValidationError(
        jsts.operation.valid.TopologyValidationError.NESTED_HOLES, nestedTester
            .getNestedPoint());
  }
};

/**
 * Tests that no element polygon is wholly in the interior of another element
 * polygon.
 * <p>
 * Preconditions:
 * <ul>
 * <li>shells do not partially overlap
 * <li>shells do not touch along an edge
 * <li>no duplicate rings exist
 * </ul>
 * This routine relies on the fact that while polygon shells may touch at one or
 * more vertices, they cannot touch at ALL vertices.
 */
jsts.operation.valid.IsValidOp.prototype.checkShellsNotNested = function(mp,
    graph) {
  for (var i = 0; i < mp.getNumGeometries(); i++) {
    var p = mp.getGeometryN(i);
    var shell = p.getExteriorRing();
    for (var j = 0; j < mp.getNumGeometries(); j++) {
      if (i == j) {
        continue;
      }
      var p2 = mp.getGeometryN(j);
      this.checkShellNotNested(shell, p2, graph);
      if (this.validErr != null) {
        return;
      }
    }
  }
};

/**
 * Check if a shell is incorrectly nested within a polygon. This is the case if
 * the shell is inside the polygon shell, but not inside a polygon hole. (If the
 * shell is inside a polygon hole, the nesting is valid.)
 * <p>
 * The algorithm used relies on the fact that the rings must be properly
 * contained. E.g. they cannot partially overlap (this has been previously
 * checked by <code>checkRelateConsistency</code> )
 */
jsts.operation.valid.IsValidOp.prototype.checkShellNotNested = function(shell,
    p, graph) {
  var shellPts = shell.getCoordinates();
  // test if shell is inside polygon shell
  var polyShell = p.getExteriorRing();
  var polyPts = polyShell.getCoordinates();
  var shellPt = jsts.operation.valid.IsValidOp.findPtNotNode(shellPts, polyShell, graph);
  // if no point could be found, we can assume that the shell is outside the
  // polygon
  if (shellPt == null) {
    return;
  }
  var insidePolyShell = jsts.algorithm.CGAlgorithms.isPointInRing(shellPt, polyPts);
  if (!insidePolyShell) {
    return;
  }

  // if no holes, this is an error!
  if (p.getNumInteriorRing() <= 0) {
    this.validErr = new jsts.operation.valid.TopologyValidationError(
        jsts.operation.valid.TopologyValidationError.NESTED_SHELLS, shellPt);
    return;
  }

  /**
   * Check if the shell is inside one of the holes. This is the case if one of
   * the calls to checkShellInsideHole returns a null coordinate. Otherwise, the
   * shell is not properly contained in a hole, which is an error.
   */
  var badNestedPt = null;
  for (var i = 0; i < p.getNumInteriorRing(); i++) {
    var hole = p.getInteriorRingN(i);
    badNestedPt = this.checkShellInsideHole(shell, hole, graph);
    if (badNestedPt == null) {
      return;
    }
  }
  this.validErr = new jsts.operation.valid.TopologyValidationError(
      jsts.operation.valid.TopologyValidationError.NESTED_SHELLS, badNestedPt);
};

/**
 * This routine checks to see if a shell is properly contained in a hole. It
 * assumes that the edges of the shell and hole do not properly intersect.
 *
 * @return <code>null</code> if the shell is properly contained, or a
 *         Coordinate which is not inside the hole if it is not.
 *
 */
jsts.operation.valid.IsValidOp.prototype.checkShellInsideHole = function(shell,
    hole, graph) {
  var shellPts = shell.getCoordinates();
  var holePts = hole.getCoordinates();
  // TODO: improve performance of this - by sorting pointlists for instance?
  var shellPt = jsts.operation.valid.IsValidOp.findPtNotNode(shellPts, hole, graph);
  // if point is on shell but not hole, check that the shell is inside the
  // hole
  if (shellPt != null) {
    var insideHole = jsts.algorithm.CGAlgorithms.isPointInRing(shellPt, holePts);
    if (!insideHole) {
      return shellPt;
    }
  }
  var holePt = jsts.operation.valid.IsValidOp.findPtNotNode(holePts, shell, graph);
  // if point is on hole but not shell, check that the hole is outside the
  // shell
  if (holePt != null) {
    var insideShell = jsts.algorithm.CGAlgorithms.isPointInRing(holePt, shellPts);
    if (insideShell) {
      return holePt;
    }
    return null;
  }
  jsts.util.Assert
      .shouldNeverReachHere('points in shell and hole appear to be equal');
  return null;
};

jsts.operation.valid.IsValidOp.prototype.checkConnectedInteriors = function(
    graph) {
  var cit = new jsts.operation.valid.ConnectedInteriorTester(graph);
  if (!cit.isInteriorsConnected()) {
    this.validErr = new jsts.operation.valid.TopologyValidationError(
        jsts.operation.valid.TopologyValidationError.DISCONNECTED_INTERIOR, cit
            .getCoordinate());
  }

};
/* ======================================================================
    jsts/algorithm/RobustDeterminant.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Port source:
 * /jts/jts/java/src/com/vividsolutions/jts/algorithm/RobustDeterminant.java
 * Revision: 626
 */

/**
 * Implements an algorithm to compute the
 * sign of a 2x2 determinant for double precision values robustly.
 * It is a direct translation of code developed by Olivier Devillers.
 * <p>
 * The original code carries the following copyright notice:
 *
 * <pre>
 *************************************************************************
 * Author : Olivier Devillers
 * Olivier.Devillers@sophia.inria.fr
 * http:/www.inria.fr:/prisme/personnel/devillers/anglais/determinant.html
 * 
 * Olivier Devillers has allowed the code to be distributed under
 * the LGPL (2012-02-16) saying "It is ok for LGPL distribution."
 * 
 **************************************************************************
 *
 **************************************************************************
 *              Copyright (c) 1995  by  INRIA Prisme Project
 *                  BP 93 06902 Sophia Antipolis Cedex, France.
 *                           All rights reserved
 **************************************************************************
 * </pre>
 * @constructor
 */
jsts.algorithm.RobustDeterminant = function() {

};


/**
 * Computes the sign of the determinant of the 2x2 matrix
 * with the given entries, in a robust way.
 *
 * @param {Number}
 *        x1 X-1.
 * @param {Number}
 *        y1 Y-1.
 * @param {Number}
 *        x2 X-2.
 * @param {Number}
 *        y2 Y-1.
 *
 * @return {Number}
 *         -1 if the determinant is negative,.
 * @return {Number}
 *         1 if the determinant is positive,.
 * @return {Number}
 *         0 if the determinant is 0.
 */
jsts.algorithm.RobustDeterminant.signOfDet2x2 = function(x1, y1, x2, y2) {
  //returns -1 if the determinant is negative,
  // returns  1 if the determinant is positive,
  // returns  0 if the determinant is null.
  var sign, swap, k, count;
  count = 0;

  sign = 1;

  /*
   *  testing null entries
   */
  if ((x1 === 0.0) || (y2 === 0.0)) {
    if ((y1 === 0.0) || (x2 === 0.0)) {
      return 0;
    }
    else if (y1 > 0) {
      if (x2 > 0) {
        return -sign;
      }
      else {
        return sign;
      }
    }
    else {
      if (x2 > 0) {
        return sign;
      }
      else {
        return -sign;
      }
    }
  }
  if ((y1 === 0.0) || (x2 === 0.0)) {
    if (y2 > 0) {
      if (x1 > 0) {
        return sign;
      }
      else {
        return -sign;
      }
    }
    else {
      if (x1 > 0) {
        return -sign;
      }
      else {
        return sign;
      }
    }
  }

  /*
   *  making y coordinates positive and permuting the entries
   */
  /*
   *  so that y2 is the biggest one
   */
  if (0.0 < y1) {
    if (0.0 < y2) {
      if (y1 > y2) {
        sign = -sign;
        swap = x1;
        x1 = x2;
        x2 = swap;
        swap = y1;
        y1 = y2;
        y2 = swap;
      }
    }
    else {
      if (y1 <= -y2) {
        sign = -sign;
        x2 = -x2;
        y2 = -y2;
      }
      else {
        swap = x1;
        x1 = -x2;
        x2 = swap;
        swap = y1;
        y1 = -y2;
        y2 = swap;
      }
    }
  }
  else {
    if (0.0 < y2) {
      if (-y1 <= y2) {
        sign = -sign;
        x1 = -x1;
        y1 = -y1;
      }
      else {
        swap = -x1;
        x1 = x2;
        x2 = swap;
        swap = -y1;
        y1 = y2;
        y2 = swap;
      }
    }
    else {
      if (y1 >= y2) {
        x1 = -x1;
        y1 = -y1;
        x2 = -x2;
        y2 = -y2;
      }
      else {
        sign = -sign;
        swap = -x1;
        x1 = -x2;
        x2 = swap;
        swap = -y1;
        y1 = -y2;
        y2 = swap;
      }
    }
  }

  /*
   *  making x coordinates positive
   */
  /*
   *  if |x2| < |x1| one can conclude
   */
  if (0.0 < x1) {
    if (0.0 < x2) {
      if (x1 > x2) {
        return sign;
      }
    }
    else {
      return sign;
    }
  }
  else {
    if (0.0 < x2) {
      return -sign;
    }
    else {
      if (x1 >= x2) {
        sign = -sign;
        x1 = -x1;
        x2 = -x2;
      }
      else {
        return -sign;
      }
    }
  }

  /*
   *  all entries strictly positive   x1 <= x2 and y1 <= y2
   */
  while (true) {
    count = count + 1;
    k = Math.floor(x2 / x1);
    x2 = x2 - k * x1;
    y2 = y2 - k * y1;

    /*
     *  testing if R (new U2) is in U1 rectangle
     */
    if (y2 < 0.0) {
      return -sign;
    }
    if (y2 > y1) {
      return sign;
    }

    /*
     *  finding R'
     */
    if (x1 > x2 + x2) {
      if (y1 < y2 + y2) {
        return sign;
      }
    }
    else {
      if (y1 > y2 + y2) {
        return -sign;
      }
      else {
        x2 = x1 - x2;
        y2 = y1 - y2;
        sign = -sign;
      }
    }
    if (y2 === 0.0) {
      if (x2 === 0.0) {
        return 0;
      }
      else {
        return -sign;
      }
    }
    if (x2 === 0.0) {
      return sign;
    }

    /*
     *  exchange 1 and 2 role.
     */
    k = Math.floor(x1 / x2);
    x1 = x1 - k * x2;
    y1 = y1 - k * y2;

    /*
     *  testing if R (new U1) is in U2 rectangle
     */
    if (y1 < 0.0) {
      return sign;
    }
    if (y1 > y2) {
      return -sign;
    }

    /*
     *  finding R'
     */
    if (x2 > x1 + x1) {
      if (y2 < y1 + y1) {
        return -sign;
      }
    }
    else {
      if (y2 > y1 + y1) {
        return sign;
      }
      else {
        x1 = x2 - x1;
        y1 = y2 - y1;
        sign = -sign;
      }
    }
    if (y1 === 0.0) {
      if (x1 === 0.0) {
        return 0;
      }
      else {
        return sign;
      }
    }
    if (x1 === 0.0) {
      return -sign;
    }
  }
};


/**
 * Returns the index of the direction of the point <code>q</code> relative to
 * a vector specified by <code>p1-p2</code>.
 * 
 * @param p1 the origin point of the vector
 * @param p2 the final point of the vector
 * @param q the point to compute the direction to
 * 
 * @return 1 if q is counter-clockwise (left) from p1-p2
 * @return -1 if q is clockwise (right) from p1-p2
 * @return 0 if q is collinear with p1-p2
 */
jsts.algorithm.RobustDeterminant.orientationIndex = function(p1, p2, q) {
  /**
   * MD - 9 Aug 2010 It seems that the basic algorithm is slightly orientation
   * dependent, when computing the orientation of a point very close to a
   * line. This is possibly due to the arithmetic in the translation to the
   * origin.
   * 
   * For instance, the following situation produces identical results in spite
   * of the inverse orientation of the line segment:
   * 
   * Coordinate p0 = new Coordinate(219.3649559090992, 140.84159161824724);
   * Coordinate p1 = new Coordinate(168.9018919682399, -5.713787599646864);
   * 
   * Coordinate p = new Coordinate(186.80814046338352, 46.28973405831556); int
   * orient = orientationIndex(p0, p1, p); int orientInv =
   * orientationIndex(p1, p0, p);
   * 
   * 
   */
  
  var dx1 = p2.x - p1.x;
  var dy1 = p2.y - p1.y;
  var dx2 = q.x - p2.x;
  var dy2 = q.y - p2.y;
  return jsts.algorithm.RobustDeterminant.signOfDet2x2(dx1, dy1, dx2, dy2);
};
/* ======================================================================
    jsts/index/quadtree/NodeBase.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * The base class for nodes in a {@link Quadtree}.
 *
 * @constructor
 */
jsts.index.quadtree.NodeBase = function() {
  /**
   * subquads are numbered as follows:
   *
   * <pre>
   *  2 | 3
   *  --+--
   *  0 | 1
   * </pre>
   */
  this.subnode = new Array(4);
  this.subnode[0] = null;
  this.subnode[1] = null;
  this.subnode[2] = null;
  this.subnode[3] = null;

  this.items = [];
};


/**
 * Returns the index of the subquad that wholly contains the given envelope. If
 * none does, returns -1.
 *
 * @param {jsts.geom.Envelope}
 *          env The envelope to check.
 * @param {jsts.geom.Coordinate}
 *          centre The coordinate.
 * @return {Number} The sub-index or -1.
 */
jsts.index.quadtree.NodeBase.prototype.getSubnodeIndex = function(env, centre) {
  var subnodeIndex = -1;
  if (env.getMinX() >= centre.x) {
    if (env.getMinY() >= centre.y) {
      subnodeIndex = 3;
    }
    if (env.getMaxY() <= centre.y) {
      subnodeIndex = 1;
    }
  }
  if (env.getMaxX() <= centre.x) {
    if (env.getMinY() >= centre.y) {
      subnodeIndex = 2;
    }
    if (env.getMaxY() <= centre.y) {
      subnodeIndex = 0;
    }
  }
  return subnodeIndex;
};


/**
 * Returns the nodes items
 *
 * @return {Array} the items-array.
 */
jsts.index.quadtree.NodeBase.prototype.getItems = function() {
  return this.items;
};


/**
 * Checks if the node has any items
 *
 * @return {Boolean} true if the node has any items.
 */
jsts.index.quadtree.NodeBase.prototype.hasItems = function() {
  return (this.items.length > 0);
};


/**
 * Adds an item to the node
 *
 * @param {Object}
 *          item the item to add.
 */
jsts.index.quadtree.NodeBase.prototype.add = function(item) {
  this.items.push(item);
};


/**
 * Removes a single item from this subtree.
 *
 * @param {jsts.geom.Envelope}
 *          itemEnv the envelope containing the item.
 * @param {Object}
 *          item the item to remove.
 * @return {Boolean} <code>true</code> if the item was found and removed.
 */
jsts.index.quadtree.NodeBase.prototype.remove = function(itemEnv, item) {
  // use envelope to restrict nodes scanned
  if (!this.isSearchMatch(itemEnv)) {
    return false;
  }

  var found = false, i = 0;
  for (i; i < 4; i++) {
    if (this.subnode[i] !== null) {
      found = this.subnode[i].remove(itemEnv, item);
      if (found) {
        // trim subtree if empty
        if (this.subnode[i].isPrunable()) {
          this.subnode[i] = null;
        }
        break;
      }
    }
  }
  // if item was found lower down, don't need to search for it here
  if (found) {
    return found;
  }
  // otherwise, try and remove the item from the list of items in this node

  if (this.items.indexOf(item) !== -1) {
    for (var i = this.items.length - 1; i >= 0; i--) {
      if (this.items[i] === item) {
        this.items.splice(i, 1);
        // break;more than once??
      }
    }

    found = true;
  }
  return found;
};


/**
 * @return {Boolean} <code>true</code> if the node is prunable.
 */
jsts.index.quadtree.NodeBase.prototype.isPrunable = function() {
  return !(this.hasChildren() || this.hasItems());
};


/**
 * @return {Boolean} <code>true</code> if the node has any children.
 */
jsts.index.quadtree.NodeBase.prototype.hasChildren = function() {
  var i = 0;
  for (i; i < 4; i++) {
    if (this.subnode[i] !== null) {
      return true;
    }
  }
  return false;
};


/**
 * @return {Boolean} <code>true</code> if the node or any subnode does not
 *         have any items.
 */
jsts.index.quadtree.NodeBase.prototype.isEmpty = function() {
  var isEmpty = true;
  if (this.items.length > 0) {
    isEmpty = false;
  }
  var i = 0;
  for (i; i < 4; i++) {
    if (this.subnode[i] !== null) {
      if (!this.subnode[i].isEmpty()) {
        isEmpty = false;
      }
    }
  }
  return isEmpty;
};


/**
 * Adds all the items of the node and any subnodes
 *
 * @param {Array}
 *          resultItems the array to add items to.
 * @return {Array} a new array with original and added items.
 */
jsts.index.quadtree.NodeBase.prototype.addAllItems = function(resultItems) {
  // this node may have items as well as subnodes (since items may not
  // be wholely contained in any single subnode
  resultItems = resultItems.concat(this.items);
  var i = 0;
  for (i; i < 4; i++) {
    if (this.subnode[i] !== null) {
      resultItems = this.subnode[i].addAllItems(resultItems);
      // resultItems = resultItems.concat(this.subnode[i]);
    }
  }

  return resultItems;
};


/**
 *
 * @param {jsts.geom.Envelope}
 *          searchEnv the search-envelope.
 * @param {Array}
 *          resultItems the array containing original and added items.
 */
jsts.index.quadtree.NodeBase.prototype.addAllItemsFromOverlapping = function(
    searchEnv, resultItems) {
  if (!this.isSearchMatch(searchEnv)) {
    return;
  }

  // this node may have items as well as subnodes (since items may not
  // be wholely contained in any single subnode

  resultItems = resultItems.concat(this.items);

  var i = 0;
  for (i; i < 4; i++) {
    if (this.subnode[i] !== null) {
      resultItems = this.subnode[i].addAllItemsFromOverlapping(searchEnv,
          resultItems);
    }
  }
};


/**
 * Visits the node
 *
 * @param {jsts.geom.Envelope}
 *          searchEnv the search-envelope.
 * @param {Object}
 *          visitor the visitor.
 */
jsts.index.quadtree.NodeBase.prototype.visit = function(searchEnv, visitor) {
  if (!this.isSearchMatch(searchEnv)) {
    return;
  }

  // this node may have items as well as subnodes (since items may not
  // be wholely contained in any single subnode
  this.visitItems(searchEnv, visitor);

  var i = 0;
  for (i; i < 4; i++) {
    if (this.subnode[i] !== null) {
      this.subnode[i].visit(searchEnv, visitor);
    }
  }
};


/**
 * Visits the items
 *
 * @param {jsts.geom.Envelope}
 *          env the search envelope.
 * @param {Object}
 *          visitor the visitor.
 */
jsts.index.quadtree.NodeBase.prototype.visitItems = function(env, visitor) {
  var i = 0, il = this.items.length;

  for (i; i < il; i++) {
    visitor.visitItem(this.items[i]);
  }
};


/**
 * Calculates the depth
 *
 * @return {Number} the calculated depth.
 */
jsts.index.quadtree.NodeBase.prototype.depth = function() {
  var maxSubDepth = 0, i = 0, sqd;
  for (i; i < 4; i++) {
    if (this.subnode[i] !== null) {
      sqd = this.subnode[i].depth();
      if (sqd > maxSubDepth) {
        maxSubDepth = sqd;
      }
    }
  }
  return maxSubDepth + 1;
};


/**
 * Calculates the size
 *
 * @return {Number} the calculated size.
 */
jsts.index.quadtree.NodeBase.prototype.size = function() {
  var subSize = 0, i = 0;
  for (i; i < 4; i++) {
    if (this.subnode[i] !== null) {
      subSize += this.subnode[i].size();
    }
  }
  return subSize + this.items.length;
};


/**
 * Counts the nodes
 *
 * @return {Number} the size of this node.
 */
jsts.index.quadtree.NodeBase.prototype.getNodeCount = function() {
  var subSize = 0, i = 0;
  for (i; i < 4; i++) {
    if (this.subnode[i] !== null) {
      subSize += this.subnode[i].size();
    }
  }
  return subSize + 1;
};
/* ======================================================================
    jsts/index/quadtree/Node.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * Represents a node of a {@link Quadtree}. Nodes contain items which have a
 * spatial extent corresponding to the node's position in the quadtree.
 *
 * @param {jsts.geom.Envelope}
 *          env Envelope to initialize from.
 * @param {Number}
 *          level The level.
 *
 * @constructor
 * @requires jsts/index/quadtree/NodeBase.js
 */
jsts.index.quadtree.Node = function(env, level) {
  jsts.index.quadtree.NodeBase.prototype.constructor.apply(this, arguments);

  this.env = env;
  this.level = level;
  this.centre = new jsts.geom.Coordinate();
  this.centre.x = (env.getMinX() + env.getMaxX()) / 2;
  this.centre.y = (env.getMinY() + env.getMaxY()) / 2;
};

jsts.index.quadtree.Node.prototype = new jsts.index.quadtree.NodeBase();


/**
 * Creates a node from specified envelope
 *
 * @param {jsts.geom.Envelope}
 *          env the envelope.
 * @return {jsts.index.quadtree.Node} the created node.
 */
jsts.index.quadtree.Node.createNode = function(env) {
  var key, node;
  key = new jsts.index.quadtree.Key(env);
  node = new jsts.index.quadtree.Node(key.getEnvelope(), key.getLevel());

  return node;
};


/**
 * Creates an expanded node.
 *
 * @param {jsts.index.quadtree.Node}
 *          node the node to create a new node from.
 * @param {jsts.geom.Envelope}
 *          addEnv the envelope.
 * @return {jsts.index.quadtree.Node} the created node.
 */
jsts.index.quadtree.Node.createExpanded = function(node, addEnv) {
  var expandEnv = new jsts.geom.Envelope(addEnv), largerNode;

  if (node !== null) {
    expandEnv.expandToInclude(node.env);
  }

  largerNode = jsts.index.quadtree.Node.createNode(expandEnv);
  if (node !== null) {
    largerNode.insertNode(node);
  }

  return largerNode;
};


/**
 * Gets the envelope for this node
 *
 * @return {jsts.geom.Envelope} the envelope.
 */
jsts.index.quadtree.Node.prototype.getEnvelope = function() {
  return this.env;
};


/**
 * Checks wheter the provided envelope intersects this nodes envelope.
 *
 * @param {jsts.geom.Envelope}
 *          searchEnv the envelope to search.
 * @return {Boolean} True if searchEnv intersects this nodes envelope.
 */
jsts.index.quadtree.Node.prototype.isSearchMatch = function(searchEnv) {
  return this.env.intersects(searchEnv);
};


/**
 * Returns the subquad containing the envelope. Creates the subquad if it does
 * not already exist.
 *
 * @param {jsts.geom.Envelope}
 *          searchEnv the input envelope.
 * @return {jsts.index.quadtree.Node} the node containing the searchEnv.
 */
jsts.index.quadtree.Node.prototype.getNode = function(searchEnv) {
  var subnodeIndex = this.getSubnodeIndex(searchEnv, this.centre), node;

  // if subquadIndex is -1 searchEnv is not contained in a subquad
  if (subnodeIndex !== -1) {
    // create the quad if it does not exist
    node = this.getSubnode(subnodeIndex);
    // recursively search the found/created quad
    return node.getNode(searchEnv);
  } else {
    return this;
  }
};


/**
 * Returns the smallest <i>existing</i> node containing the envelope.
 *
 * @param {jsts.geom.Envelope}
 *          searchEnv input Envelope.
 * @return {jsts.index.quadtree.Node} the smallest node containing searchEnv.
 */
jsts.index.quadtree.Node.prototype.find = function(searchEnv) {
  var subnodeIndex = this.getSubnodeIndex(searchEnv, this.centre), node;
  if (subnodeIndex === -1) {
    return this;
  }

  if (this.subnode[subnodeIndex] !== null) {
    // query lies in subquad, so search it
    node = this.subnode[subnodeIndex];
    return node.find(searchEnv);
  }

  // no existing subquad, so return this one anyway
  return this;
};


/**
 * Inserts a child-node
 *
 * @param {jsts.index.quadtree.Node}
 *          node to insert.
 */
jsts.index.quadtree.Node.prototype.insertNode = function(node) {
  var index = this.getSubnodeIndex(node.env, this.centre), childNode;
  if (node.level === this.level - 1) {
    this.subnode[index] = node;
  } else {
    // the quad is not a direct child, so make a new child quad to contain it
    // and recursively insert the quad
    childNode = this.createSubnode(index);
    childNode.insertNode(node);
    this.subnode[index] = childNode;
  }
};


/**
 * get the subquad for the index. If it doesn't exist, create it
 *
 * @param {Number}
 *          index the index of the subnode to get.
 * @return {jsts.index.quadtree.Node} the specified subnode.
 */
jsts.index.quadtree.Node.prototype.getSubnode = function(index) {
  if (this.subnode[index] === null) {
    this.subnode[index] = this.createSubnode(index);
  }
  return this.subnode[index];
};


/**
 * Creates a subnode
 *
 * @param {Number}
 *          index The index (0-4) on where to create a subnode.
 * @return {jsts.index.quadtree.Node} the created node.
 */
jsts.index.quadtree.Node.prototype.createSubnode = function(index) {
  var minx = 0.0, maxx = 0.0, miny = 0.0, maxy = 0.0, sqEnv, node;
  // create a new subquad in the appropriate quadrant
  switch (index) {
    case 0:
      minx = this.env.getMinX();
      maxx = this.centre.x;
      miny = this.env.getMinY();
      maxy = this.centre.y;
      break;
    case 1:
      minx = this.centre.x;
      maxx = this.env.getMaxX();
      miny = this.env.getMinY();
      maxy = this.centre.y;
      break;
    case 2:
      minx = this.env.getMinX();
      maxx = this.centre.x;
      miny = this.centre.y;
      maxy = this.env.getMaxY();
      break;
    case 3:
      minx = this.centre.x;
      maxx = this.env.getMaxX();
      miny = this.centre.y;
      maxy = this.env.getMaxY();
      break;
  }

  sqEnv = new jsts.geom.Envelope(minx, maxx, miny, maxy);
  node = new jsts.index.quadtree.Node(sqEnv, this.level - 1);

  return node;
};
/* ======================================================================
    jsts/triangulate/quadedge/QuadEdge.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */


(function() {
  /**
   * A class that represents the edge data structure which implements the quadedge algebra.
   * The quadedge algebra was described in a well-known paper by Guibas and Stolfi,
   * "Primitives for the manipulation of general subdivisions and the computation of Voronoi diagrams",
   * <i>ACM Transactions on Graphics</i>, 4(2), 1985, 75-123.
   * <p>
   * Each edge object is part of a quartet of 4 edges,
   * linked via their <tt>rot</tt> references.
   * Any edge in the group may be accessed using a series of {@link #rot} operations.
   * Quadedges in a subdivision are linked together via their <tt>next</tt> references.
   * The linkage between the quadedge quartets determines the topology
   * of the subdivision.
   * <p>
   * The edge class does not contain separate information for vertice or faces; a vertex is implicitly
   * defined as a ring of edges (created using the <tt>next</tt> field).
   *
   * @author David Skea
   * @author Martin Davis
   */

  /**
   * Quadedges must be made using {@link makeEdge},
   * to ensure proper construction.
   *
   * @constructor
   */
  jsts.triangulate.quadedge.QuadEdge = function() {
    // the dual of this edge, directed from right to left
    this.rot = null;
    this.vertex = null;            // The vertex that this edge represents
    this.next = null;              // A reference to a connected edge
    this.data = null;
  };

  var QuadEdge = jsts.triangulate.quadedge.QuadEdge;

  /**
   * Creates a new QuadEdge quartet from {@link Vertex} o to {@link Vertex} d.
   *
   * @param {jsts.triangulate.quadedge.Vertex}
   *        o the origin Vertex.
   * @param {jsts.triangulate.quadedge.Vertex}
   *        d the destination Vertex.
   * @return the new QuadEdge quartet.
   */
  jsts.triangulate.quadedge.QuadEdge.makeEdge = function(o, d) {
    var q0, q1, q2, q3, base;

    q0 = new QuadEdge();
    q1 = new QuadEdge();
    q2 = new QuadEdge();
    q3 = new QuadEdge();

    q0.rot = q1;
    q1.rot = q2;
    q2.rot = q3;
    q3.rot = q0;

    q0.setNext(q0);
    q1.setNext(q3);
    q2.setNext(q2);
    q3.setNext(q1);

    base = q0;
    base.setOrig(o);
    base.setDest(d);
    return base;
  };

  /**
   * Creates a new QuadEdge connecting the destination of a to the origin of
   * b, in such a way that all three have the same left face after the
   * connection is complete. Additionally, the data pointers of the new edge
   * are set.
   *
   * @param  {jsts.triangulate.quadedge.QuadEdge}
   *          a the first edge to connect.
   * @param  {jsts.triangulate.quadedge.QuadEdge}
   *          b the second edge to connect.
   * @return {jsts.triangulate.quadedge.QuadEdge}
   *          the connected edge.
   */
  jsts.triangulate.quadedge.QuadEdge.connect = function(a, b) {
      var e = QuadEdge.makeEdge(a.dest(), b.orig());
      QuadEdge.splice(e, a.lNext());
      QuadEdge.splice(e.sym(), b);
      return e;
  };

  /**
   * Splices two edges together or apart.
   * Splice affects the two edge rings around the origins of a and b, and, independently, the two
   * edge rings around the left faces of <tt>a</tt> and <tt>b</tt>.
   * In each case, (i) if the two rings are distinct,
   * Splice will combine them into one, or (ii) if the two are the same ring, Splice will break it
   * into two separate pieces. Thus, Splice can be used both to attach the two edges together, and
   * to break them apart.
   *
   * @param {jsts.triangulate.quadedge.QuadEdge}
   *          a an edge to splice.
   * @param {jsts.triangulate.quadedge.QuadEdge}
   *          b an edge to splice.
   */
  jsts.triangulate.quadedge.QuadEdge.splice = function(a, b) {
      var alpha, beta, t1, t2, t3, t4;
      alpha = a.oNext().rot;
      beta = b.oNext().rot;

      t1 = b.oNext();
      t2 = a.oNext();
      t3 = beta.oNext();
      t4 = alpha.oNext();

      a.setNext(t1);
      b.setNext(t2);
      alpha.setNext(t3);
      beta.setNext(t4);
  };

  /**
   * Turns an edge counterclockwise inside its enclosing quadrilateral.
   *
   * @param {jsts.triangulate.quadedge.QuadEdge}
   *          e the quadedge to turn.
   */
  jsts.triangulate.quadedge.QuadEdge.swap = function(e) {
    var a, b;
    a = e.oPrev();
    b = e.sym().oPrev();
    QuadEdge.splice(e, a);
    QuadEdge.splice(e.sym(), b);
    QuadEdge.splice(e, a.lNext());
    QuadEdge.splice(e.sym(), b.lNext());
    e.setOrig(a.dest());
    e.setDest(b.dest());
  };

  /**
   * Gets the primary edge of this quadedge and its <tt>sym</tt>.
   * The primary edge is the one for which the origin
   * and destination coordinates are ordered
   * according to the standard {@link Coordinate} ordering
   *
   * @return the primary quadedge.
   */
  jsts.triangulate.quadedge.QuadEdge.prototype.getPrimary = function() {
    if (this.orig().getCoordinate().compareTo(this.dest().getCoordinate()) <= 0) {
      return this;
    }
    else {
      return this.sym();
    }
  };

  /**
   * Sets the external data value for this edge.
   *
   * @param {Object}
   *          data an object containing external data.
   */
  jsts.triangulate.quadedge.QuadEdge.prototype.setData = function(data) {
      this.data = data;
  };

  /**
   * Gets the external data value for this edge.
   *
   * @return {Object}
   *          the data object.
   */
  jsts.triangulate.quadedge.QuadEdge.prototype.getData = function() {
      return this.data;
  };

  /**
   * Marks this quadedge as being deleted.
   * This does not free the memory used by
   * this quadedge quartet, but indicates
   * that this edge no longer participates
   * in a subdivision.
   *
   */
  jsts.triangulate.quadedge.QuadEdge.prototype.delete_jsts = function() {
    this.rot = null;
  };

  /**
   * Tests whether this edge has been deleted.
   *
   * @return {boolean}
   *          true if this edge has not been deleted.
   */
  jsts.triangulate.quadedge.QuadEdge.prototype.isLive = function() {
    return this.rot !== null;
  };


  /**
   * Sets the connected edge
   *
   * @param {jsts.triangulate.quadedge.QuadEdge}
   *          next next-edge.
   */
  jsts.triangulate.quadedge.QuadEdge.prototype.setNext = function(next) {
      this.next = next;
  };

  /***************************************************************************
   * QuadEdge Algebra
   ***************************************************************************
   */

  /**
   * Gets the dual of this edge, directed from its left to its right.
   *
   * @return {jsts.triangulate.quadedge.QuadEdge}
   *          the inverse rotated edge.
   */
  jsts.triangulate.quadedge.QuadEdge.prototype.invRot = function() {
    return this.rot.sym();
  };

  /**
   * Gets the edge from the destination to the origin of this edge.
   *
   * @return {jsts.triangulate.quadedge.QuadEdge}
   *          the sym of the edge.
   */
  jsts.triangulate.quadedge.QuadEdge.prototype.sym = function() {
    return this.rot.rot;
  };

  /**
   * Gets the next CCW edge around the origin of this edge.
   *
   * @return {jsts.triangulate.quadedge.QuadEdge}
   *          the next linked edge.
   */
  jsts.triangulate.quadedge.QuadEdge.prototype.oNext = function() {
      return this.next;
  };

  /**
   * Gets the next CW edge around (from) the origin of this edge.
   *
   * @return {jsts.triangulate.quadedge.QuadEdge}
   *          the previous edge.
   */
  jsts.triangulate.quadedge.QuadEdge.prototype.oPrev = function() {
      return this.rot.next.rot;
  };

  /**
   * Gets the next CCW edge around (into) the destination of this edge.
   *
   * @return {jsts.triangulate.quadedge.QuadEdge}
   *          the next destination edge.
   */
  jsts.triangulate.quadedge.QuadEdge.prototype.dNext = function() {
      return this.sym().oNext().sym();
  };

  /**
   * Gets the next CW edge around (into) the destination of this edge.
   *
   * @return {jsts.triangulate.quadedge.QuadEdge}
   *          the previous destination edge.
   */
  jsts.triangulate.quadedge.QuadEdge.prototype.dPrev = function() {
      return this.invRot().oNext().invRot();
  };

  /**
   * Gets the CCW edge around the left face following this edge.
   *
   * @return {jsts.triangulate.quadedge.QuadEdge}
   *          the next left face edge.
   */
  jsts.triangulate.quadedge.QuadEdge.prototype.lNext = function() {
      return this.invRot().oNext().rot;
  };

  /**
   * Gets the CCW edge around the left face before this edge.
   *
   * @return {jsts.triangulate.quadedge.QuadEdge}
   *          the previous left face edge.
   */
  jsts.triangulate.quadedge.QuadEdge.prototype.lPrev = function() {
      return this.next.sym();
  };

  /**
   * Gets the edge around the right face ccw following this edge.
   *
   * @return {jsts.triangulate.quadedge.QuadEdge}
   *          the next right face edge.
   */
  jsts.triangulate.quadedge.QuadEdge.prototype.rNext = function() {
      return this.rot.next.invRot();
  };

  /**
   * Gets the edge around the right face ccw before this edge.
   *
   * @return {jsts.triangulate.quadedge.QuadEdge}
   *          the previous right face edge.
   */
  jsts.triangulate.quadedge.QuadEdge.prototype.rPrev = function() {
      return this.sym().oNext();
  };

  /***********************************************************************************************
   * Data Access
   **********************************************************************************************/
  /**
   * Sets the vertex for this edge's origin
   *
   * @param {jsts.triangulate.quadedge.Vertex}
   *          o the origin vertex.
   */
  jsts.triangulate.quadedge.QuadEdge.prototype.setOrig = function(o) {
      this.vertex = o;
  };

  /**
   * Sets the vertex for this edge's destination
   *
   * @param {jsts.triangulate.quadedge.Vertex}
   *          d the destination vertex.
   */
  jsts.triangulate.quadedge.QuadEdge.prototype.setDest = function(d) {
      this.sym().setOrig(d);
  };

  /**
   * Gets the vertex for the edge's origin
   *
   * @return {jsts.triangulate.quadedge.Vertex}
   *          the origin vertex.
   */
  jsts.triangulate.quadedge.QuadEdge.prototype.orig = function() {
      return this.vertex;
  };

  /**
   * Gets the vertex for the edge's destination
   *
   * @return {jsts.triangulate.quadedge.Vertex}
   *          the destination vertex.
   */
  jsts.triangulate.quadedge.QuadEdge.prototype.dest = function() {
      return this.sym().orig();
  };

  /**
   * Gets the length of the geometry of this quadedge.
   *
   * @return {number}
   *          the length of the quadedge.
   */
  jsts.triangulate.quadedge.QuadEdge.prototype.getLength = function() {
      return this.orig().getCoordinate().distance(dest().getCoordinate());
  };

  /**
   * Tests if this quadedge and another have the same line segment geometry,
   * regardless of orientation.
   *
   * @param {jsts.triangulate.quadedge.QuadEdge}
   *          qe a quadege.
   * @return {boolean}
   *          true if the quadedges are based on the same line segment regardless of orientation.
   */
  jsts.triangulate.quadedge.QuadEdge.prototype.equalsNonOriented = function(qe) {
      if (this.equalsOriented(qe)) {
          return true;
      }

      if (this.equalsOriented(qe.sym())) {
          return true;
      }

      return false;
  };

  /**
   * Tests if this quadedge and another have the same line segment geometry
   * with the same orientation.
   *
   * @param {jsts.triangulate.quadedge.QuadEdge}
   *          qe a quadege.
   * @return {boolean}
   *          true if the quadedges are based on the same line segment.
   */
  jsts.triangulate.quadedge.QuadEdge.prototype.equalsOriented = function(qe) {
      if (this.orig().getCoordinate().equals2D(qe.orig().getCoordinate())
              && this.dest().getCoordinate().equals2D(qe.dest().getCoordinate())) {
          return true;
      }
      return false;
  };

  /**
   * Creates a {@link LineSegment} representing the
   * geometry of this edge.
   *
   * @return {jsts.geom.LineSegment}
   *          a LineSegment.
   */
  jsts.triangulate.quadedge.QuadEdge.prototype.toLineSegment = function()
  {
    return new jsts.geom.LineSegment(this.vertex.getCoordinate(), this.dest().getCoordinate());
  };

  /**
   * Converts this edge to a WKT two-point <tt>LINESTRING</tt> indicating
   * the geometry of this edge.
   *
   * @return {String}
   *          a String representing this edge's geometry.
   */
  jsts.triangulate.quadedge.QuadEdge.prototype.toString = function() {
    var p0, p1;
    p0 = this.vertex.getCoordinate();
    p1 = this.dest().getCoordinate();
    return jsts.io.WKTWriter.toLineString(p0, p1);
  };
})();
/* ======================================================================
    jsts/geomgraph/EdgeEnd.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * @requires jsts/util/Assert.js
   */

  var Assert = jsts.util.Assert;

  /**
   * Models the end of an edge incident on a node. EdgeEnds have a direction
   * determined by the direction of the ray from the initial point to the next
   * point. EdgeEnds are comparable under the ordering "a has a greater angle
   * with the x-axis than b". This ordering is used to sort EdgeEnds around a
   * node.
   *
   * @param {Edge}
   *          edge
   * @param {Coordinate}
   *          p0
   * @param {Coordinate}
   *          p1
   * @param {Label}
   *          label
   * @constructor
   */
  jsts.geomgraph.EdgeEnd = function(edge, p0, p1, label) {
    this.edge = edge;
    if (p0 && p1) {
      this.init(p0, p1);
    }
    if (label) {
      this.label = label || null;
    }
  };

  /**
   * the parent edge of this edge end
   *
   * @type {Edge}
   * @protected
   */
  jsts.geomgraph.EdgeEnd.prototype.edge = null;


  /**
   * @type {Label}
   * @protected
   */
  jsts.geomgraph.EdgeEnd.prototype.label = null;


  /**
   * the node this edge end originates at
   *
   * @type {Node}
   * @private
   */
  jsts.geomgraph.EdgeEnd.prototype.node = null;


  /**
   * points of initial line segment
   *
   * @type {Coordinate}
   * @private
   */
  jsts.geomgraph.EdgeEnd.prototype.p0 = null;
  jsts.geomgraph.EdgeEnd.prototype.p1 = null;


  /**
   * the direction vector for this edge from its starting point
   *
   * @type {double}
   * @private
   */
  jsts.geomgraph.EdgeEnd.prototype.dx = null;
  jsts.geomgraph.EdgeEnd.prototype.dy = null;


  /**
   * @type {int}
   * @private
   */
  jsts.geomgraph.EdgeEnd.prototype.quadrant = null;


  /**
   * @param {Coordinate}
   *          p0
   * @param {Coordinate}
   *          p1
   * @protected
   */
  jsts.geomgraph.EdgeEnd.prototype.init = function(p0, p1) {
    this.p0 = p0;
    this.p1 = p1;
    this.dx = p1.x - p0.x;
    this.dy = p1.y - p0.y;
    this.quadrant = jsts.geomgraph.Quadrant.quadrant(this.dx, this.dy);
    Assert.isTrue(!(this.dx === 0 && this.dy === 0),
        'EdgeEnd with identical endpoints found');
  };

  jsts.geomgraph.EdgeEnd.prototype.getEdge = function() {
    return this.edge;
  };

  jsts.geomgraph.EdgeEnd.prototype.getLabel = function() {
    return this.label;
  };

  jsts.geomgraph.EdgeEnd.prototype.getCoordinate = function() {
    return this.p0;
  };

  jsts.geomgraph.EdgeEnd.prototype.getDirectedCoordinate = function() {
    return this.p1;
  };

  jsts.geomgraph.EdgeEnd.prototype.getQuadrant = function() {
    return this.quadrant;
  };

  jsts.geomgraph.EdgeEnd.prototype.getDx = function() {
    return this.dx;
  };

  jsts.geomgraph.EdgeEnd.prototype.getDy = function() {
    return this.dy;
  };


  jsts.geomgraph.EdgeEnd.prototype.setNode = function(node) {
    this.node = node;
  };

  jsts.geomgraph.EdgeEnd.prototype.getNode = function() {
    return this.node;
  };

  jsts.geomgraph.EdgeEnd.prototype.compareTo = function(e) {
    return this.compareDirection(e);
  };


  /**
   * Implements the total order relation:
   * <p>
   * a has a greater angle with the positive x-axis than b
   * <p>
   * Using the obvious algorithm of simply computing the angle is not robust,
   * since the angle calculation is obviously susceptible to roundoff. A robust
   * algorithm is: - first compare the quadrant. If the quadrants are different,
   * it it trivial to determine which vector is "greater". - if the vectors lie
   * in the same quadrant, the computeOrientation function can be used to decide
   * the relative orientation of the vectors.
   *
   * @param {EdgeEnd}
   *          e
   * @return {number}
   */
  jsts.geomgraph.EdgeEnd.prototype.compareDirection = function(e) {
    if (this.dx === e.dx && this.dy === e.dy)
      return 0;
    // if the rays are in different quadrants, determining the ordering is
    // trivial
    if (this.quadrant > e.quadrant)
      return 1;
    if (this.quadrant < e.quadrant)
      return -1;
    // vectors are in the same quadrant - check relative orientation of
    // direction vectors
    // this is > e if it is CCW of e
    return jsts.algorithm.CGAlgorithms.computeOrientation(e.p0, e.p1, this.p1);
  };

  jsts.geomgraph.EdgeEnd.prototype.computeLabel = function(boundaryNodeRule) {
  // subclasses should override this if they are using labels
  };

})();
/* ======================================================================
    jsts/noding/NodingValidator.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */
/* ======================================================================
    jsts/operation/buffer/RightmostEdgeFinder.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * A RightmostEdgeFinder find the DirectedEdge in a list which has the highest
 * coordinate, and which is oriented L to R at that point. (I.e. the right side
 * is on the RHS of the edge.)
 *
 * @constructor
 */
jsts.operation.buffer.RightmostEdgeFinder = function() {};
// private Coordinate extremeCoord;
jsts.operation.buffer.RightmostEdgeFinder.prototype.minIndex = -1;
jsts.operation.buffer.RightmostEdgeFinder.prototype.minCoord = null;
jsts.operation.buffer.RightmostEdgeFinder.prototype.minDe = null;
jsts.operation.buffer.RightmostEdgeFinder.prototype.orientedDe = null;


jsts.operation.buffer.RightmostEdgeFinder.prototype.getEdge = function() {
  return this.orientedDe;
};
jsts.operation.buffer.RightmostEdgeFinder.prototype.getCoordinate = function() {
  return this.minCoord;
};

jsts.operation.buffer.RightmostEdgeFinder.prototype.findEdge = function(
    dirEdgeList) {
  /**
   * Check all forward DirectedEdges only. This is still general, because each
   * edge has a forward DirectedEdge.
   */
  for (var i = dirEdgeList.iterator(); i.hasNext();) {
    var de = i.next();
    if (!de.isForward())
      continue;
    this.checkForRightmostCoordinate(de);
  }

  /**
   * If the rightmost point is a node, we need to identify which of the incident
   * edges is rightmost.
   */
  jsts.util.Assert.isTrue(this.minIndex !== 0 ||
      this.minCoord.equals(this.minDe.getCoordinate()),
      'inconsistency in rightmost processing');
  if (this.minIndex === 0) {
    this.findRightmostEdgeAtNode();
  } else {
    this.findRightmostEdgeAtVertex();
  }
  /**
   * now check that the extreme side is the R side. If not, use the sym instead.
   */
  this.orientedDe = this.minDe;
  var rightmostSide = this.getRightmostSide(this.minDe, this.minIndex);
  if (rightmostSide == jsts.geomgraph.Position.LEFT) {
    this.orientedDe = this.minDe.getSym();
  }
};
/**
 * @private
 */
jsts.operation.buffer.RightmostEdgeFinder.prototype.findRightmostEdgeAtNode = function() {
  var node = this.minDe.getNode();
  var star = node.getEdges();
  this.minDe = star.getRightmostEdge();
  // the DirectedEdge returned by the previous call is not
  // necessarily in the forward direction. Use the sym edge if it isn't.
  if (!this.minDe.isForward()) {
    this.minDe = this.minDe.getSym();
    this.minIndex = this.minDe.getEdge().getCoordinates().length - 1;
  }
};
/**
 * @private
 */
jsts.operation.buffer.RightmostEdgeFinder.prototype.findRightmostEdgeAtVertex = function() {
  /**
   * The rightmost point is an interior vertex, so it has a segment on either
   * side of it. If these segments are both above or below the rightmost point,
   * we need to determine their relative orientation to decide which is
   * rightmost.
   */
  var pts = this.minDe.getEdge().getCoordinates();
  jsts.util.Assert.isTrue(this.minIndex > 0 && this.minIndex < pts.length,
      'rightmost point expected to be interior vertex of edge');
  var pPrev = pts[this.minIndex - 1];
  var pNext = pts[this.minIndex + 1];
  var orientation = jsts.algorithm.CGAlgorithms.computeOrientation(
      this.minCoord, pNext, pPrev);
  var usePrev = false;
  // both segments are below min point
  if (pPrev.y < this.minCoord.y && pNext.y < this.minCoord.y &&
      orientation === jsts.algorithm.CGAlgorithms.COUNTERCLOCKWISE) {
    usePrev = true;
  } else if (pPrev.y > this.minCoord.y && pNext.y > this.minCoord.y &&
      orientation === jsts.algorithm.CGAlgorithms.CLOCKWISE) {
    usePrev = true;
  }
  // if both segments are on the same side, do nothing - either is safe
  // to select as a rightmost segment
  if (usePrev) {
    this.minIndex = this.minIndex - 1;
  }
};
/**
 * @private
 */
jsts.operation.buffer.RightmostEdgeFinder.prototype.checkForRightmostCoordinate = function(
    de) {
  var coord = de.getEdge().getCoordinates();
  for (var i = 0; i < coord.length - 1; i++) {
    // only check vertices which are the start or end point of a non-horizontal
    // segment
    // <FIX> MD 19 Sep 03 - NO! we can test all vertices, since the rightmost
    // must have a non-horiz segment adjacent to it
    if (this.minCoord === null || coord[i].x > this.minCoord.x) {
      this.minDe = de;
      this.minIndex = i;
      this.minCoord = coord[i];
    }
    // }
  }
};
/**
 * @private
 */
jsts.operation.buffer.RightmostEdgeFinder.prototype.getRightmostSide = function(
    de, index) {
  var side = this.getRightmostSideOfSegment(de, index);
  if (side < 0)
    side = this.getRightmostSideOfSegment(de, index - 1);
  if (side < 0) {
    // reaching here can indicate that segment is horizontal
    // Assert.shouldNeverReachHere("problem with finding rightmost side of
    // segment at " + de.getCoordinate());
    // testing only
    this.minCoord = null;
    this.checkForRightmostCoordinate(de);
  }
  return side;
};

/**
 * @private
 */
jsts.operation.buffer.RightmostEdgeFinder.prototype.getRightmostSideOfSegment = function(
    de, i) {
  var e = de.getEdge();
  var coord = e.getCoordinates();

  if (i < 0 || i + 1 >= coord.length)
    return -1;
  if (coord[i].y == coord[i + 1].y)
    return -1; // indicates edge is parallel to x-axis

  var pos = jsts.geomgraph.Position.LEFT;
  if (coord[i].y < coord[i + 1].y)
    pos = jsts.geomgraph.Position.RIGHT;
  return pos;
};
/* ======================================================================
    jsts/triangulate/IncrementalDelaunayTriangulator.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
*/



/**
 * Computes a Delauanay Triangulation of a set of {@link Vertex}es, using an
 * incrementatal insertion algorithm.
 *
 * @author Martin Davis
 * @version 1.0
 */

(function() {
  /**
     * Creates a new triangulator using the given {@link QuadEdgeSubdivision}.
     * The triangulator uses the tolerance of the supplied subdivision.
     *
     * @param subdiv
     *          a subdivision in which to build the TIN.
     */
  jsts.triangulate.IncrementalDelaunayTriangulator = function(subdiv) {
      this.subdiv = subdiv;
      this.isUsingTolerance = subdiv.getTolerance() > 0.0;
  };

  /**
   * Inserts all sites in a collection. The inserted vertices <b>MUST</b> be
   * unique up to the provided tolerance value. (i.e. no two vertices should be
   * closer than the provided tolerance value). They do not have to be rounded
   * to the tolerance grid, however.
   *
   * @param {jsts.triangulate.quadedge.Vertex[]}
   *          vertices an array of Vertices.
   *
   * @throws LocateFailureException if the location algorithm fails to converge in a reasonable number of iterations
   */
  jsts.triangulate.IncrementalDelaunayTriangulator.prototype.insertSites = function(vertices) {
    var i = 0, il = vertices.length, v;

    for (i; i < il; i++) {
      v = vertices[i];
      this.insertSite(v);
    }
  };

  /**
   * Inserts a new point into a subdivision representing a Delaunay
   * triangulation, and fixes the affected edges so that the result is still a
   * Delaunay triangulation.
   * <p>
   *
   * @param {jsts.triangulate.quadedge.Vertex}
   *          v the vertex to insert.
   *
   * @return {jsts.triangulate.quadedge.QuadEdge}
   *          a quadedge containing the inserted vertex.
   */
  jsts.triangulate.IncrementalDelaunayTriangulator.prototype.insertSite = function(v) {
    /**
     * This code is based on Guibas and Stolfi (1985), with minor modifications
     * and a bug fix from Dani Lischinski (Graphic Gems 1993). (The modification
     * I believe is the test for the inserted site falling exactly on an
     * existing edge. Without this test zero-width triangles have been observed
     * to be created)
     */

    var e, base, startEdge, t;

    e = this.subdiv.locate(v);
    if (this.subdiv.isVertexOfEdge(e, v)) {
      // point is already in subdivision.
      return e;
    }
    else if (this.subdiv.isOnEdge(e, v.getCoordinate())) {
      // the point lies exactly on an edge, so delete the edge
      // (it will be replaced by a pair of edges which have the point as a vertex)
      e = e.oPrev();
      this.subdiv.delete_jsts(e.oNext());
    }

    /**
     * Connect the new point to the vertices of the containing triangle
     * (or quadrilateral, if the new point fell on an existing edge.)
     */
    base = this.subdiv.makeEdge(e.orig(), v);
    jsts.triangulate.quadedge.QuadEdge.splice(base, e);
    startEdge = base;
    do {
      base = this.subdiv.connect(e, base.sym());
      e = base.oPrev();
    } while (e.lNext() != startEdge);

    // Examine suspect edges to ensure that the Delaunay condition
    // is satisfied.
    do {
      t = e.oPrev();
      if (t.dest().rightOf(e) && v.isInCircle(e.orig(), t.dest(), e.dest())) {
        jsts.triangulate.quadedge.QuadEdge.swap(e);
        e = e.oPrev();
      } else if (e.oNext() == startEdge) {
        return base; // no more suspect edges.
      } else {
        e = e.oNext().lPrev();
      }
    } while (true);
  };
}());
/* ======================================================================
    jsts/algorithm/CentroidArea.js
   ====================================================================== */

/**
 * Computes the centroid of an area geometry.
 * <h2>Algorithm</h2>
 * Based on the usual algorithm for calculating the centroid as a weighted sum
 * of the centroids of a decomposition of the area into (possibly overlapping)
 * triangles. The algorithm has been extended to handle holes and
 * multi-polygons. See
 * <code>http://www.faqs.org/faqs/graphics/algorithms-faq/</code> for further
 * details of the basic approach. The code has also be extended to handle
 * degenerate (zero-area) polygons. In this case, the centroid of the line
 * segments in the polygon will be returned.
 *
 * @version 1.7
 */
jsts.algorithm.CentroidArea = function() {
  this.basePt = null;
  this.triangleCent3 = new jsts.geom.Coordinate();
  this.centSum = new jsts.geom.Coordinate();
  this.cg3 = new jsts.geom.Coordinate();
};


/**
 * the point all triangles are based at
 *
 * @type {jsts.geom.Coordinate}
 * @private
 */
jsts.algorithm.CentroidArea.prototype.basePt = null;


/**
 * temporary variable to hold centroid of triangle
 *
 * @type {jsts.geom.Coordinate}
 * @private
 */
jsts.algorithm.CentroidArea.prototype.triangleCent3 = null;


/**
 * Partial area sum
 *
 * @type {double}
 * @private
 */
jsts.algorithm.CentroidArea.prototype.areasum2 = 0;


/**
 * partial centroid sum
 *
 * @type {jsts.geom.Coordinate}
 * @private
 */
jsts.algorithm.CentroidArea.prototype.cg3 = null;


/**
 * // data for linear centroid computation, if needed
 *
 * @type {jsts.geom.Coordinate}
 * @private
 */
jsts.algorithm.CentroidArea.prototype.centSum = null;


/**
 * @type {double}
 * @private
 */
jsts.algorithm.CentroidArea.prototype.totalLength = 0.0;


/**
 * Adds the area defined by a Geometry to the centroid total. If the geometry
 * has no area it does not contribute to the centroid.
 *
 * @param geom
 *          the geometry to add.
 */
jsts.algorithm.CentroidArea.prototype.add = function(geom) {
  if (geom instanceof jsts.geom.Polygon) {
    var poly = geom;
    this.setBasePoint(poly.getExteriorRing().getCoordinateN(0));
    this.add3(poly);
  } else if (geom instanceof jsts.geom.GeometryCollection || geom instanceof jsts.geom.MultiPolygon) {
    var gc = geom;
    for (var i = 0; i < gc.getNumGeometries(); i++) {
      this.add(gc.getGeometryN(i));
    }
  } else if (geom instanceof Array) {
    this.add2(geom);
  }
};


/**
 * Adds the area defined by an array of coordinates. The array must be a ring;
 * i.e. end with the same coordinate as it starts with.
 *
 * @param ring
 *          an array of {@link Coordinate} s.
 */
jsts.algorithm.CentroidArea.prototype.add2 = function(ring) {
  this.setBasePoint(ring[0]);
  this.addShell(ring);
};

jsts.algorithm.CentroidArea.prototype.getCentroid = function() {
  var cent = new jsts.geom.Coordinate();
  if (Math.abs(this.areasum2) > 0.0) {
    cent.x = this.cg3.x / 3 / this.areasum2;
    cent.y = this.cg3.y / 3 / this.areasum2;
  } else {
    // if polygon was degenerate, compute linear centroid instead
    cent.x = this.centSum.x / this.totalLength;
    cent.y = this.centSum.y / this.totalLength;
  }
  return cent;
};


/**
 * @private
 */
jsts.algorithm.CentroidArea.prototype.setBasePoint = function(basePt) {
  if (this.basePt == null)
    this.basePt = basePt;
};


/**
 * @private
 */
jsts.algorithm.CentroidArea.prototype.add3 = function(poly) {
  this.addShell(poly.getExteriorRing().getCoordinates());
  for (var i = 0; i < poly.getNumInteriorRing(); i++) {
    this.addHole(poly.getInteriorRingN(i).getCoordinates());
  }
};


/**
 * @private
 */
jsts.algorithm.CentroidArea.prototype.addShell = function(pts) {
  var isPositiveArea = !jsts.algorithm.CGAlgorithms.isCCW(pts);
  for (var i = 0; i < pts.length - 1; i++) {
    this.addTriangle(this.basePt, pts[i], pts[i + 1], isPositiveArea);
  }
  this.addLinearSegments(pts);
};


/**
 * @private
 */
jsts.algorithm.CentroidArea.prototype.addHole = function(pts) {
  var isPositiveArea = jsts.algorithm.CGAlgorithms.isCCW(pts);
  for (var i = 0; i < pts.length - 1; i++) {
    this.addTriangle(this.basePt, pts[i], pts[i + 1], isPositiveArea);
  }
  this.addLinearSegments(pts);
};


/**
 * @private
 */
jsts.algorithm.CentroidArea.prototype.addTriangle = function(p0, p1, p2,
    isPositiveArea) {
  var sign = (isPositiveArea) ? 1.0 : -1.0;
  jsts.algorithm.CentroidArea.centroid3(p0, p1, p2, this.triangleCent3);
  var area2 = jsts.algorithm.CentroidArea.area2(p0, p1, p2);
  this.cg3.x += sign * area2 * this.triangleCent3.x;
  this.cg3.y += sign * area2 * this.triangleCent3.y;
  this.areasum2 += sign * area2;
};


/**
 * Returns three times the centroid of the triangle p1-p2-p3. The factor of 3 is
 * left in to permit division to be avoided until later.
 *
 * @private
 */
jsts.algorithm.CentroidArea.centroid3 = function(p1, p2, p3, c) {
  c.x = p1.x + p2.x + p3.x;
  c.y = p1.y + p2.y + p3.y;
  return;
};


/**
 * Returns twice the signed area of the triangle p1-p2-p3, positive if a,b,c are
 * oriented ccw, and negative if cw.
 *
 * @private
 */
jsts.algorithm.CentroidArea.area2 = function(p1, p2, p3) {
  return (p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y);
};


/**
 * Adds the linear segments defined by an array of coordinates to the linear
 * centroid accumulators. This is done in case the polygon(s) have zero-area, in
 * which case the linear centroid is computed instead.
 *
 * @param pts
 *          an array of {@link Coordinate} s.
 * @private
 */
jsts.algorithm.CentroidArea.prototype.addLinearSegments = function(pts) {
  for (var i = 0; i < pts.length - 1; i++) {
    var segmentLen = pts[i].distance(pts[i + 1]);
    this.totalLength += segmentLen;

    var midx = (pts[i].x + pts[i + 1].x) / 2;
    this.centSum.x += segmentLen * midx;
    var midy = (pts[i].y + pts[i + 1].y) / 2;
    this.centSum.y += segmentLen * midy;
  }
};
/* ======================================================================
    jsts/geomgraph/index/SweepLineSegment.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @param {Edge}
 *          edge
 * @param {int}
 *          ptIndex
 * @constructor 
 */
jsts.geomgraph.index.SweepLineSegment = function(
    edge, ptIndex) {
  this.edge = edge;
  this.ptIndex = ptIndex;
  this.pts = edge.getCoordinates();
};

/**
 * @type {Edge} 
 */
jsts.geomgraph.index.SweepLineSegment.prototype.edge = null;

/**
 * @type {Coordinate[]} 
 */
jsts.geomgraph.index.SweepLineSegment.prototype.pts = null;

/**
 * @type {int} 
 */
jsts.geomgraph.index.SweepLineSegment.prototype.ptIndex = null;

/**
 * @return {double} 
 */
jsts.geomgraph.index.SweepLineSegment.prototype.getMinX = function() {
  var x1 = this.pts[this.ptIndex].x;
  var x2 = this.pts[this.ptIndex + 1].x;
  if (x1 < x2) {
    return x1;
  }
  return x2;
};

/**
 * @return {double} 
 */
jsts.geomgraph.index.SweepLineSegment.prototype.getMaxX = function() {
  var x1 = this.pts[this.ptIndex].x;
  var x2 = this.pts[this.ptIndex + 1].x;
  if (x1 > x2) {
    return x1;
  }
  return x2;
};

/**
 * @param {SweepLineSegment}
 *          ss
 * @param {SegmentIntersector}
 *          si 
 */
jsts.geomgraph.index.SweepLineSegment.prototype.computeIntersections = function(
    ss, si) {
  si.addIntersections(this.edge, this.ptIndex, ss.edge, ss.ptIndex);
};
/* ======================================================================
    jsts/index/quadtree/Root.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
*/



/**
 * QuadRoot is the root of a single Quadtree. It is centred at the origin, and
 * does not have a defined extent.
 *
 * @constructor
 */
jsts.index.quadtree.Root = function() {
  jsts.index.quadtree.NodeBase.prototype.constructor.apply(this, arguments);

  // the root quad is centred at the origin.
  this.origin = new jsts.geom.Coordinate(0.0, 0.0);
};

jsts.index.quadtree.Root.prototype = new jsts.index.quadtree.NodeBase();


/**
 * Insert an item into the quadtree this is the root of.
 *
 * @param {jsts.geom.Envelope}
 *          itemEnv the item envelope.
 * @param {Object}
 *          item the item to insert.
 */
jsts.index.quadtree.Root.prototype.insert = function(itemEnv, item) {
  var index = this.getSubnodeIndex(itemEnv, this.origin);

  // if index is -1, itemEnv must cross the X or Y axis.
  if (index === -1) {
    this.add(item);
    return;
  }
  /**
   * the item must be contained in one quadrant, so insert it into the tree for
   * that quadrant (which may not yet exist)
   */
  var node = this.subnode[index];
  /**
   * If the subquad doesn't exist or this item is not contained in it, have to
   * expand the tree upward to contain the item.
   */

  if (node === null || !node.getEnvelope().contains(itemEnv)) {
    var largerNode = jsts.index.quadtree.Node.createExpanded(node, itemEnv);
    this.subnode[index] = largerNode;
  }
  /**
   * At this point we have a subquad which exists and must contain contains the
   * env for the item. Insert the item into the tree.
   */
  this.insertContained(this.subnode[index], itemEnv, item);
};


/**
 * insert an item which is known to be contained in the tree rooted at the given
 * QuadNode root. Lower levels of the tree will be created if necessary to hold
 * the item.
 *
 * @param {jsts.index.quadtree.Node}
 *          tree the root-node of the tree.
 * @param {jsts.geom.Envelope}
 *          itemEnv the envelope.
 * @param {Object}
 *          item the item to insert.
 */
jsts.index.quadtree.Root.prototype.insertContained = function(tree, itemEnv,
    item) {
  /**
   * Do NOT create a new quad for zero-area envelopes - this would lead to
   * infinite recursion. Instead, use a heuristic of simply returning the
   * smallest existing quad containing the query
   */
  var isZeroX, isZeroY, node;
  isZeroX = jsts.index.IntervalSize.isZeroWidth(itemEnv.getMinX(),
      itemEnv.getMaxX());
  isZeroY = jsts.index.IntervalSize.isZeroWidth(itemEnv.getMinY(),
      itemEnv.getMaxY());

  if (isZeroX || isZeroY) {
    node = tree.find(itemEnv);
  } else {
    node = tree.getNode(itemEnv);
  }
  node.add(item);
};


/**
 * Checks if the root is a search match.
 *
 * @param {jsts.geom.Envelope} searchEnv the envelope.
 * @return {Boolean} Always returns true for a root node.
 */
jsts.index.quadtree.Root.prototype.isSearchMatch = function(searchEnv) {
  return true;
};
/* ======================================================================
    jsts/geomgraph/index/MonotoneChainIndexer.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * MonotoneChains are a way of partitioning the segments of an edge to
 * allow for fast searching of intersections.
 * Specifically, a sequence of contiguous line segments
 * is a monotone chain iff all the vectors defined by the oriented segments
 * lies in the same quadrant.
 * <p>
 * Monotone Chains have the following useful properties:
 * <ol>
 * <li>the segments within a monotone chain will never intersect each other
 * <li>the envelope of any contiguous subset of the segments in a monotone chain
 * is simply the envelope of the endpoints of the subset.
 * </ol>
 * Property 1 means that there is no need to test pairs of segments from within
 * the same monotone chain for intersection.
 * Property 2 allows
 * binary search to be used to find the intersection points of two monotone chains.
 * For many types of real-world data, these properties eliminate a large number of
 * segment comparisons, producing substantial speed gains.
 * 
 * @constructor 
 */
jsts.geomgraph.index.MonotoneChainIndexer = function() {

};

/**
 * @param {javascript.util.List}
 *          list
 * @return {int[]} 
 */
jsts.geomgraph.index.MonotoneChainIndexer.toIntArray = function(
    list) {
  var array = [];
  for (var i = list.iterator(); i.hasNext(); ) {
    var element = i.next();
    array.push(element);
  }
  return array;
};

/**
 * @param {Coordinate[]}
 *          pts
 * @return {int[]} 
 */
jsts.geomgraph.index.MonotoneChainIndexer.prototype.getChainStartIndices = function(
    pts) {
  // find the startpoint (and endpoints) of all monotone chains in this edge
  var start = 0;
  var startIndexList = new javascript.util.ArrayList();
  startIndexList.add(start);
  do {
    var last = this.findChainEnd(pts, start);
    startIndexList.add(last);
    start = last;
  } while (start < pts.length - 1);

  // copy list to an array of ints, for efficiency
  var startIndex = jsts.geomgraph.index.MonotoneChainIndexer.toIntArray(startIndexList);
  return startIndex;
};

/**
 * return the index of the last point in the monotone chain
 * 
 * @param {Coordinate[]}
 *          pts
 * @param {int}
 *          start
 * @return {int} 
 */
jsts.geomgraph.index.MonotoneChainIndexer.prototype.findChainEnd = function(
    pts, start) {
  // determine quadrant for chain
  var chainQuad = jsts.geomgraph.Quadrant.quadrant(pts[start], pts[start + 1]);
  var last = start + 1;
  while (last < pts.length) {
    // compute quadrant for next possible segment in chain
    var quad = jsts.geomgraph.Quadrant.quadrant(pts[last - 1], pts[last]);
    if (quad != chainQuad) {
      break;
    }
    last++;
  }
  return last - 1;
};
/* ======================================================================
    jsts/noding/IntersectionAdder.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 *@requires jsts/noding/SegmentIntersector.js
 */

/**
 * Computes the intersections between two line segments in {@link SegmentString}s
 * and adds them to each string. The {@link SegmentIntersector} is passed to a
 * {@link Noder}. The {@link addIntersections} method is called whenever the
 * {@link Noder} detects that two SegmentStrings <i>might</i> intersect. This
 * class is an example of the <i>Strategy</i> pattern.
 *
 * @constructor
 */
jsts.noding.IntersectionAdder = function(li) {
  this.li = li;
};

jsts.noding.IntersectionAdder.prototype = new jsts.noding.SegmentIntersector();
jsts.noding.IntersectionAdder.constructor = jsts.noding.IntersectionAdder;


jsts.noding.IntersectionAdder.isAdjacentSegments = function(i1, i2) {
  return Math.abs(i1 - i2) === 1;
};

/**
 * These variables keep track of what types of intersections were found during
 * ALL edges that have been intersected.
 */
/**
 * @type {boolean}
 * @private
 */
jsts.noding.IntersectionAdder.prototype._hasIntersection = false;
/**
 * @type {boolean}
 * @private
 */
jsts.noding.IntersectionAdder.prototype.hasProper = false;
/**
 * @type {boolean}
 * @private
 */
jsts.noding.IntersectionAdder.prototype.hasProperInterior = false;
/**
 * @type {boolean}
 * @private
 */
jsts.noding.IntersectionAdder.prototype.hasInterior = false;

// the proper intersection point found

/**
 * @type {Coordinate}
 * @private
 */
jsts.noding.IntersectionAdder.prototype.properIntersectionPoint = null;

/**
 * @type {LineIntersector}
 * @private
 */
jsts.noding.IntersectionAdder.prototype.li = null;
/**
 * @type {boolean}
 * @private
 */
jsts.noding.IntersectionAdder.prototype.isSelfIntersection = null;

jsts.noding.IntersectionAdder.prototype.numIntersections = 0;
jsts.noding.IntersectionAdder.prototype.numInteriorIntersections = 0;
jsts.noding.IntersectionAdder.prototype.numProperIntersections = 0;

// testing only
jsts.noding.IntersectionAdder.prototype.numTests = 0;


jsts.noding.IntersectionAdder.prototype.getLineIntersector = function() {
  return this.li;
};

/**
 * @return the proper intersection point, or <code>null</code> if none was
 *         found.
 */
jsts.noding.IntersectionAdder.prototype.getProperIntersectionPoint = function() {
  return this.properIntersectionPoint;
};

jsts.noding.IntersectionAdder.prototype.hasIntersection = function() {
  return this._hasIntersection;
};
/**
 * A proper intersection is an intersection which is interior to at least two
 * line segments. Note that a proper intersection is not necessarily in the
 * interior of the entire Geometry, since another edge may have an endpoint
 * equal to the intersection, which according to SFS semantics can result in the
 * point being on the Boundary of the Geometry.
 */
jsts.noding.IntersectionAdder.prototype.hasProperIntersection = function() {
  return this.hasProper;
};
/**
 * A proper interior intersection is a proper intersection which is <b>not</b>
 * contained in the set of boundary nodes set for this SegmentIntersector.
 */
jsts.noding.IntersectionAdder.prototype.hasProperInteriorIntersection = function() {
  return this.hasProperInterior;
};
/**
 * An interior intersection is an intersection which is in the interior of some
 * segment.
 */
jsts.noding.IntersectionAdder.prototype.hasInteriorIntersection = function() {
  return this.hasInterior;
};

/**
 * A trivial intersection is an apparent self-intersection which in fact is
 * simply the point shared by adjacent line segments. Note that closed edges
 * require a special check for the point shared by the beginning and end
 * segments.
 *
 * @private
 */
jsts.noding.IntersectionAdder.prototype.isTrivialIntersection = function(e0,
    segIndex0, e1, segIndex1) {
  if (e0 == e1) {
    if (this.li.getIntersectionNum() == 1) {
      if (jsts.noding.IntersectionAdder
          .isAdjacentSegments(segIndex0, segIndex1))
        return true;
      if (e0.isClosed()) {
        var maxSegIndex = e0.size() - 1;
        if ((segIndex0 === 0 && segIndex1 === maxSegIndex) ||
            (segIndex1 === 0 && segIndex0 === maxSegIndex)) {
          return true;
        }
      }
    }
  }
  return false;
};

/**
 * This method is called by clients of the {@link SegmentIntersector} class to
 * process intersections for two segments of the {@link SegmentString}s being
 * intersected. Note that some clients (such as {@link MonotoneChain}s) may
 * optimize away this call for segment pairs which they have determined do not
 * intersect (e.g. by an disjoint envelope test).
 */
jsts.noding.IntersectionAdder.prototype.processIntersections = function(e0,
    segIndex0, e1, segIndex1) {
  if (e0 === e1 && segIndex0 === segIndex1)
    return;
  this.numTests++;
  var p00 = e0.getCoordinates()[segIndex0];
  var p01 = e0.getCoordinates()[segIndex0 + 1];
  var p10 = e1.getCoordinates()[segIndex1];
  var p11 = e1.getCoordinates()[segIndex1 + 1];

  this.li.computeIntersection(p00, p01, p10, p11);
  if (this.li.hasIntersection()) {
    this.numIntersections++;
    if (this.li.isInteriorIntersection()) {
      this.numInteriorIntersections++;
      this.hasInterior = true;
    }
    // if the segments are adjacent they have at least one trivial intersection,
    // the shared endpoint. Don't bother adding it if it is the
    // only intersection.
    if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {
      this._hasIntersection = true;
      e0.addIntersections(this.li, segIndex0, 0);
      e1.addIntersections(this.li, segIndex1, 1);
      if (this.li.isProper()) {
        this.numProperIntersections++;
        this.hasProper = true;
        this.hasProperInterior = true;
      }
    }
  }
};

/**
 * Always process all intersections
 *
 * @return false always.
 */
jsts.noding.IntersectionAdder.prototype.isDone = function() {
  return false;
};
/* ======================================================================
    jsts/operation/union/CascadedPolygonUnion.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */
/**
 * Provides an efficient method of unioning a collection of
 * {@link Polygonal} geometrys.
 * This algorithm is faster and likely more robust than
 * the simple iterated approach of
 * repeatedly unioning each polygon to a result geometry.
 * <p>
 * The <tt>buffer(0)</tt> trick is sometimes faster, but can be less robust and
 * can sometimes take an exceptionally long time to complete.
 * This is particularly the case where there is a high degree of overlap
 * between the polygons.  In this case, <tt>buffer(0)</tt> is forced to compute
 * with <i>all</i> line segments from the outset,
 * whereas cascading can eliminate many segments
 * at each stage of processing.
 * The best case for buffer(0) is the trivial case
 * where there is <i>no</i> overlap between the input geometries.
 * However, this case is likely rare in practice.
 *
 */



/**
 * Creates a new instance to union
 * the given collection of {@link Geometry}s.
 *
 * @param {Array.<jsts.geom.Geometry>} geoms a collection of {@link Polygonal} {@link Geometry}s.
 * @constructor
 */
jsts.operation.union.CascadedPolygonUnion = function(polys) {
  this.inputPolys = polys;
};


/**
 * Computes the union of
 * a collection of {@link Polygonal} {@link Geometry}s.
 *
 * @param {Array.<jsts.geom.Geometry>} polys a collection of {@link Polygonal} {@link Geometry}s.
 * @return {jsts.geom.Geometry}
 * @public
 */
jsts.operation.union.CascadedPolygonUnion.union = function(polys) {
  var op = new jsts.operation.union.CascadedPolygonUnion(polys);
  return op.union();
};


/**
 * @type {Array.<jsts.geom.Geometry>}
 */
jsts.operation.union.CascadedPolygonUnion.prototype.inputPolys;


/**
 * @type {jsts.geom.GeometryFactory}
 */
jsts.operation.union.CascadedPolygonUnion.prototype.geomFactory = null;


/**
 * The effectiveness of the index is somewhat sensitive
 * to the node capacity.
 * Testing indicates that a smaller capacity is better.
 * For an STRtree, 4 is probably a good number (since
 * this produces 2x2 "squares").
 *
 * @type {number}
 * @const
 */
jsts.operation.union.CascadedPolygonUnion.prototype.STRTREE_NODE_CAPACITY = 4;


/**
 * Computes the union of the input geometries.
 *
 * @return {?jsts.geom.Geometry} the union of the input geometries, null if no input geometries were provided.
 * @public
 */
jsts.operation.union.CascadedPolygonUnion.prototype.union = function() {
  if (this.inputPolys.length === 0) {
    return null;
  }
  this.geomFactory = this.inputPolys[0].getFactory();

  /**
   * A spatial index to organize the collection
   * into groups of close geometries.
   * This makes unioning more efficient, since vertices are more likely
   * to be eliminated on each round.
   */

  var index = new jsts.index.strtree.STRtree(this.STRTREE_NODE_CAPACITY);
  for (var i = 0, l = this.inputPolys.length; i < l; i++) {
    var item = this.inputPolys[i];
    index.insert(item.getEnvelopeInternal(), item);
  }
  var itemTree = index.itemsTree();
  var unionAll = this.unionTree(itemTree);
  return unionAll;
};


/**
 *
 * @param {Array.<jsts.geom.Geometry>} geomTree
 * @return {jsts.geom.Geometry}
 * @private
 */
jsts.operation.union.CascadedPolygonUnion.prototype.unionTree = function(geomTree) {
  /**
   * Recursively unions all subtrees in the list into single geometries.
   * The result is a list of Geometrys only
   */
  var geoms = this.reduceToGeometries(geomTree);
  var union = this.binaryUnion(geoms);
  return union;
};


//TODO: Implement experimental methods?


/**
 * Unions a list of geometries
 * by treating the list as a flattened binary tree,
 * and performing a cascaded union on the tree.
 *
 * Unions a section of a list using a recursive binary union on each half
 * of the section.
 *
 * @param {Array.<jsts.geom.Geometry>} geoms
 * @param {number=} [start].
 * @param {number=} [end].
 * @return {jsts.geom.Geometry} the union of the list section.
 * @private
 */
jsts.operation.union.CascadedPolygonUnion.prototype.binaryUnion = function(geoms, start, end) {
  start = start || 0;
  end = end || geoms.length;

  if (end - start <= 1) {
    var g0 = this.getGeometry(geoms, start);
    return this.unionSafe(g0, null);
  }
  else if (end - start === 2) {
    return this.unionSafe(this.getGeometry(geoms, start), this.getGeometry(geoms, start + 1));
  }
  else {
    // recurse on both halves of the list
    var mid = parseInt((end + start) / 2);
    var g0 = this.binaryUnion(geoms, start, mid);
    var g1 = this.binaryUnion(geoms, mid, end);
    return this.unionSafe(g0, g1);
  }
};


/**
 *
 * @param {Array.<jsts.geom.Geometry>} list
 * @param {number} index
 * @return {jsts.geom.Geometry}
 * @private
 */
jsts.operation.union.CascadedPolygonUnion.prototype.getGeometry = function(list, index) {
  if (index >= list.length) {
    return null;
  }
  return list[index];
};


/**
 * Reduces a tree of geometries to a list of geometries
 * by recursively unioning the subtrees in the list.
 *
 * @param {Array} geomTree a tree-structured list of geometries.
 * @return {Array.<jsts.geom.Geometry>} a list of Geometrys.
 * @private
 */
jsts.operation.union.CascadedPolygonUnion.prototype.reduceToGeometries = function(geomTree) {
  var geoms = [];
  for (var i = 0, l = geomTree.length; i < l; i++) {
    var o = geomTree[i],
        geom = null;
    if (o instanceof Array) {
      geom = this.unionTree(o);
    }
    else if (o instanceof jsts.geom.Geometry) {
      geom = o;
    }
    geoms.push(geom);
  }
  return geoms;
};


/**
 * Computes the union of two geometries,
 * either of both of which may be null.
 *
 * @param {jsts.geom.Geometry} g0 a Geometry.
 * @param {jsts.geom.Geometry} g1 a Geometry.
 * @return {?jsts.geom.Geometry} the union of the input(s),
 *                               null if both inputs are null.
 * @private
 */
jsts.operation.union.CascadedPolygonUnion.prototype.unionSafe = function(g0, g1) {
  if (g0 === null && g1 === null) {
    return null;
  }
  if (g0 === null) {
    return g1.clone();
  }
  if (g1 === null) {
    return g0.clone();
  }

  //what if both are null?  Maybe return empty GC?

  return this.unionOptimized(g0, g1);
};


/**
 * @param {jsts.geom.Geometry} g0 a Geometry.
 * @param {jsts.geom.Geometry} g1 a Geometry.
 * @return {jsts.geom.Geometry} the union of the input(s).
 * @private
 */
jsts.operation.union.CascadedPolygonUnion.prototype.unionOptimized = function(g0, g1) {
  var g0Env = g0.getEnvelopeInternal(),
      g1Env = g1.getEnvelopeInternal();

  if (!g0Env.intersects(g1Env)) {
    var combo = jsts.geom.util.GeometryCombiner.combine(g0, g1);
    return combo;
  }

  if (g0.getNumGeometries <= 1 && g1.getNumGeometries <= 1) {
    return this.unionActual(g0, g1);
  }

  var commonEnv = g0Env.intersection(g1Env);
  return this.unionUsingEnvelopeIntersection(g0, g1, commonEnv);
};


/**
 * Unions two polygonal geometries.
 * The case of MultiPolygons is optimized to union only
 * the polygons which lie in the intersection of the two geometry's envelopes.
 * Polygons outside this region can simply be combined with the union result,
 * which is potentially much faster.
 * This case is likely to occur often during cascaded union, and may also
 * occur in real world data (such as unioning data for parcels on different street blocks).
 *
 * @param {jsts.geom.Geometry} g0 a polygonal geometry.
 * @param {jsts.geom.Geometry} g1 a polygonal geometry.
 * @param {jsts.geom.Envelope} common the intersection of the envelopes of the inputs.
 * @return {jsts.geom.Geometry} the union of the inputs.
 * @private
 */
jsts.operation.union.CascadedPolygonUnion.prototype.unionUsingEnvelopeIntersection = function(g0, g1, common) {
  var disjointPolys = new javascript.util.ArrayList();
  var g0Int = this.extractByEnvelope(common, g0, disjointPolys);
  var g1Int = this.extractByEnvelope(common, g1, disjointPolys);

  var union = this.unionActual(g0Int, g1Int);

  disjointPolys.add(union);
  var overallUnion = jsts.geom.util.GeometryCombiner.combine(disjointPolys);

  return overallUnion;
};


/**
 *
 * @param {jsts.geom.Envelope} env
 * @param {jsts.geom.Geometry} geom
 * @param {Array.<jsts.geom.Geometry>} disjointGeoms
 * @return {jsts.geom.Geometry}
 * @private
 */
jsts.operation.union.CascadedPolygonUnion.prototype.extractByEnvelope = function(env, geom, disjointGeoms) {
  var intersectingGeoms = new javascript.util.ArrayList();

  for (var i = 0; i < geom.getNumGeometries(); i++) {
    var elem = geom.getGeometryN(i);
    if (elem.getEnvelopeInternal().intersects(env)) {
      intersectingGeoms.add(elem);
    }
    else {
      disjointGeoms.add(elem);
    }
  }

  return this.geomFactory.buildGeometry(intersectingGeoms);
};


/**
 * Encapsulates the actual unioning of two polygonal geometries.
 *
 * @param {jsts.geom.Geometry} g0
 * @param {jsts.geom.Geometry} g1
 * @return {jsts.geom.Geometry}
 * @private
 */
jsts.operation.union.CascadedPolygonUnion.prototype.unionActual = function(g0, g1) {
  return g0.union(g1);
};
/* ======================================================================
    jsts/geom/MultiPoint.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @requires jsts/geom/GeometryCollection.js
 */

(function() {

  /**
   * @requires jsts/geom/GeometryCollection.js
   */

  /**
   * @constructor
   * @extends jsts.geom.GeometryCollection
   */
  jsts.geom.MultiPoint = function(points, factory) {
    this.geometries = points || [];
    this.factory = factory;
  };

  jsts.geom.MultiPoint.prototype = new jsts.geom.GeometryCollection();
  jsts.geom.MultiPoint.constructor = jsts.geom.MultiPoint;



  /**
   * Gets the boundary of this geometry. Zero-dimensional geometries have no
   * boundary by definition, so an empty GeometryCollection is returned.
   *
   * @return {Geometry} an empty GeometryCollection.
   * @see Geometry#getBoundary
   */
  jsts.geom.MultiPoint.prototype.getBoundary = function() {
    return this.getFactory().createGeometryCollection(null);
  };

  jsts.geom.MultiPoint.prototype.getGeometryN = function(n) {
    return this.geometries[n];
  };


  /**
   * @param {Geometry}
   *          other
   * @param {double}
   *          tolerance
   * @return {boolean}
   */
  jsts.geom.MultiPoint.prototype.equalsExact = function(other, tolerance) {
    if (!this.isEquivalentClass(other)) {
      return false;
    }
    return jsts.geom.GeometryCollection.prototype.equalsExact.call(this, other,
        tolerance);
  };

  jsts.geom.MultiPoint.prototype.CLASS_NAME = 'jsts.geom.MultiPoint';

})();
/* ======================================================================
    jsts/operation/buffer/OffsetCurveBuilder.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * Computes the raw offset curve for a single {@link Geometry} component (ring,
 * line or point). A raw offset curve line is not noded - it may contain
 * self-intersections (and usually will). The final buffer polygon is computed
 * by forming a topological graph of all the noded raw curves and tracing
 * outside contours. The points in the raw curve are rounded to a given
 * {@link PrecisionModel}.
 *
 * @constructor
 */
jsts.operation.buffer.OffsetCurveBuilder = function(precisionModel, bufParams) {
  this.precisionModel = precisionModel;
  this.bufParams = bufParams;
};


/**
 * @type {double}
 * @private
 */
jsts.operation.buffer.OffsetCurveBuilder.prototype.distance = 0.0;


/**
 * @type {PrecisionModel}
 * @private
 */
jsts.operation.buffer.OffsetCurveBuilder.prototype.precisionModel = null;


/**
 * @type {BufferParameters}
 * @private
 */
jsts.operation.buffer.OffsetCurveBuilder.prototype.bufParams = null;


/**
 * Gets the buffer parameters being used to generate the curve.
 *
 * @return the buffer parameters being used.
 */
jsts.operation.buffer.OffsetCurveBuilder.prototype.getBufferParameters = function() {
  return this.bufParams;
};


/**
 * This method handles single points as well as LineStrings. LineStrings are
 * assumed <b>not</b> to be closed (the function will not fail for closed
 * lines, but will generate superfluous line caps).
 *
 * @param inputPts
 *          the vertices of the line to offset.
 * @param distance
 *          the offset distance.
 *
 * @return a Coordinate array representing the curve.
 * @return null if the curve is empty.
 */
jsts.operation.buffer.OffsetCurveBuilder.prototype.getLineCurve = function(
    inputPts, distance) {
  this.distance = distance;

  // a zero or negative width buffer of a line/point is empty
  if (this.distance < 0.0 && !this.bufParams.isSingleSided())
    return null;
  if (this.distance == 0.0)
    return null;

  var posDistance = Math.abs(this.distance);
  var segGen = this.getSegGen(posDistance);
  if (inputPts.length <= 1) {
    this.computePointCurve(inputPts[0], segGen);
  } else {
    if (this.bufParams.isSingleSided()) {
      var isRightSide = distance < 0.0;
      this.computeSingleSidedBufferCurve(inputPts, isRightSide, segGen);
    } else
      this.computeLineBufferCurve(inputPts, segGen);
  }

  var lineCoord = segGen.getCoordinates();
  return lineCoord;
};


/**
 * This method handles the degenerate cases of single points and lines, as well
 * as rings.
 *
 * @return a Coordinate array representing the curve.
 * @return null if the curve is empty.
 */
jsts.operation.buffer.OffsetCurveBuilder.prototype.getRingCurve = function(
    inputPts, side, distance) {
  this.distance = distance;
  if (inputPts.length <= 2)
    return this.getLineCurve(inputPts, distance);

  // optimize creating ring for for zero distance
  if (this.distance == 0.0) {
    return jsts.operation.buffer.OffsetCurveBuilder.copyCoordinates(inputPts);
  }
  var segGen = this.getSegGen(this.distance);
  this.computeRingBufferCurve(inputPts, side, segGen);
  return segGen.getCoordinates();
};

jsts.operation.buffer.OffsetCurveBuilder.prototype.getOffsetCurve = function(
    inputPts, distance) {
  this.distance = distance;

  // a zero width offset curve is empty
  if (this.distance === 0.0)
    return null;

  var isRightSide = this.distance < 0.0;
  var posDistance = Math.abs(this.distance);
  var segGen = this.getSegGen(posDistance);
  if (inputPts.length <= 1) {
    this.computePointCurve(inputPts[0], segGen);
  } else {
    this.computeOffsetCurve(inputPts, isRightSide, segGen);
  }
  var curvePts = segGen.getCoordinates();
  // for right side line is traversed in reverse direction, so have to reverse
  // generated line
  if (isRightSide)
    curvePts.reverse();
  return curvePts;
};


/**
 * @private
 */
jsts.operation.buffer.OffsetCurveBuilder.copyCoordinates = function(pts) {
  var copy = [];
  for (var i = 0; i < pts.length; i++) {
    copy.push(pts[i].clone());
  }
  return copy;
};


/**
 * @private
 */
jsts.operation.buffer.OffsetCurveBuilder.prototype.getSegGen = function(
    distance) {
  return new jsts.operation.buffer.OffsetSegmentGenerator(this.precisionModel,
      this.bufParams, distance);
};


/**
 * Use a value which results in a potential distance error which is
 * significantly less than the error due to the quadrant segment discretization.
 * For QS = 8 a value of 100 is reasonable. This should produce a maximum of 1%
 * distance error.
 *
 * @private
 */
jsts.operation.buffer.OffsetCurveBuilder.SIMPLIFY_FACTOR = 100.0;


/**
 * Computes the distance tolerance to use during input line simplification.
 *
 * @param distance
 *          the buffer distance.
 * @return the simplification tolerance.
 * @private
 */
jsts.operation.buffer.OffsetCurveBuilder.simplifyTolerance = function(
    bufDistance) {
  return bufDistance / jsts.operation.buffer.OffsetCurveBuilder.SIMPLIFY_FACTOR;
};


/**
 * @private
 */
jsts.operation.buffer.OffsetCurveBuilder.prototype.computePointCurve = function(
    pt, segGen) {
  switch (this.bufParams.getEndCapStyle()) {
  case jsts.operation.buffer.BufferParameters.CAP_ROUND:
    segGen.createCircle(pt);
    break;
  case jsts.operation.buffer.BufferParameters.CAP_SQUARE:
    segGen.createSquare(pt);
    break;
  // otherwise curve is empty (e.g. for a butt cap);
  }
};


/**
 * @private
 */
jsts.operation.buffer.OffsetCurveBuilder.prototype.computeLineBufferCurve = function(
    inputPts, segGen) {
  var distTol = jsts.operation.buffer.OffsetCurveBuilder
      .simplifyTolerance(this.distance);

  // --------- compute points for left side of line
  // Simplify the appropriate side of the line before generating
  var simp1 = jsts.operation.buffer.BufferInputLineSimplifier.simplify(
      inputPts, distTol);
  // MD - used for testing only (to eliminate simplification)
  // Coordinate[] simp1 = inputPts;

  var n1 = simp1.length - 1;
  segGen.initSideSegments(simp1[0], simp1[1], jsts.geomgraph.Position.LEFT);
  for (var i = 2; i <= n1; i++) {
    segGen.addNextSegment(simp1[i], true);
  }
  segGen.addLastSegment();
  // add line cap for end of line
  segGen.addLineEndCap(simp1[n1 - 1], simp1[n1]);

  // ---------- compute points for right side of line
  // Simplify the appropriate side of the line before generating
  var simp2 = jsts.operation.buffer.BufferInputLineSimplifier.simplify(
      inputPts, -distTol);
  // MD - used for testing only (to eliminate simplification)
  // Coordinate[] simp2 = inputPts;
  var n2 = simp2.length - 1;

  // since we are traversing line in opposite order, offset position is still
  // LEFT
  segGen.initSideSegments(simp2[n2], simp2[n2 - 1], jsts.geomgraph.Position.LEFT);
  for (var i = n2 - 2; i >= 0; i--) {
    segGen.addNextSegment(simp2[i], true);
  }
  segGen.addLastSegment();
  // add line cap for start of line
  segGen.addLineEndCap(simp2[1], simp2[0]);

  segGen.closeRing();
};


/**
 * @private
 */
jsts.operation.buffer.OffsetCurveBuilder.prototype.computeSingleSidedBufferCurve = function(
    inputPts, isRightSide, segGen) {
  var distTol = jsts.operation.buffer.OffsetCurveBuilder
      .simplifyTolerance(this.distance);

  if (isRightSide) {
    // add original line
    segGen.addSegments(inputPts, true);

    // ---------- compute points for right side of line
    // Simplify the appropriate side of the line before generating
    var simp2 = jsts.operation.buffer.BufferInputLineSimplifier.simplify(
        inputPts, -distTol);
    // MD - used for testing only (to eliminate simplification)
    // Coordinate[] simp2 = inputPts;
    var n2 = simp2.length - 1;

    // since we are traversing line in opposite order, offset position is still
    // LEFT
    segGen.initSideSegments(simp2[n2], simp2[n2 - 1],
        jsts.geomgraph.Position.LEFT);
    segGen.addFirstSegment();
    for (var i = n2 - 2; i >= 0; i--) {
      segGen.addNextSegment(simp2[i], true);
    }
  } else {
    // add original line
    segGen.addSegments(inputPts, false);

    // --------- compute points for left side of line
    // Simplify the appropriate side of the line before generating
    var simp1 = jsts.operation.buffer.BufferInputLineSimplifier.simplify(
        inputPts, distTol);
    // MD - used for testing only (to eliminate simplification)
    // Coordinate[] simp1 = inputPts;

    var n1 = simp1.length - 1;
    segGen.initSideSegments(simp1[0], simp1[1], jsts.geomgraph.Position.LEFT);
    segGen.addFirstSegment();
    for (var i = 2; i <= n1; i++) {
      segGen.addNextSegment(simp1[i], true);
    }
  }
  segGen.addLastSegment();
  segGen.closeRing();
};


/**
 * @private
 */
jsts.operation.buffer.OffsetCurveBuilder.prototype.computeOffsetCurve = function(
    inputPts, isRightSide, segGen) {
  var distTol = jsts.operation.buffer.OffsetCurveBuilder
      .simplifyTolerance(this.distance);

  if (isRightSide) {
    // ---------- compute points for right side of line
    // Simplify the appropriate side of the line before generating
    var simp2 = jsts.operation.buffer.BufferInputLineSimplifier.simplify(
        inputPts, -distTol);
    // MD - used for testing only (to eliminate simplification)
    // Coordinate[] simp2 = inputPts;
    var n2 = simp2.length - 1;

    // since we are traversing line in opposite order, offset position is still
    // LEFT
    segGen.initSideSegments(simp2[n2], simp2[n2 - 1],
        jsts.geomgraph.Position.LEFT);
    segGen.addFirstSegment();
    for (var i = n2 - 2; i >= 0; i--) {
      segGen.addNextSegment(simp2[i], true);
    }
  } else {
    // --------- compute points for left side of line
    // Simplify the appropriate side of the line before generating
    var simp1 = jsts.operation.buffer.BufferInputLineSimplifier.simplify(
        inputPts, distTol);
    // MD - used for testing only (to eliminate simplification)
    // Coordinate[] simp1 = inputPts;

    var n1 = simp1.length - 1;
    segGen.initSideSegments(simp1[0], simp1[1], jsts.geomgraph.Position.LEFT);
    segGen.addFirstSegment();
    for (var i = 2; i <= n1; i++) {
      segGen.addNextSegment(simp1[i], true);
    }
  }
  segGen.addLastSegment();
};


/**
 * @private
 */
jsts.operation.buffer.OffsetCurveBuilder.prototype.computeRingBufferCurve = function(
    inputPts, side, segGen) {
  // simplify input line to improve performance
  var distTol = jsts.operation.buffer.OffsetCurveBuilder
      .simplifyTolerance(this.distance);
  // ensure that correct side is simplified
  if (side === jsts.geomgraph.Position.RIGHT)
    distTol = -distTol;
  var simp = jsts.operation.buffer.BufferInputLineSimplifier.simplify(inputPts,
      distTol);

  var n = simp.length - 1;
  segGen.initSideSegments(simp[n - 1], simp[0], side);
  for (var i = 1; i <= n; i++) {
    var addStartPoint = i !== 1;
    segGen.addNextSegment(simp[i], addStartPoint);
  }
  segGen.closeRing();
};
/* ======================================================================
    jsts/noding/snapround/MCIndexPointSnapper.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Port source:
 * /jts/jts/java/src/com/vividsolutions/jts/noding/snapround/MCIndexPointSnapper.java
 * Revision: 486
 */

/**
 * @requires jsts/index/chain/MonotoneChainSelectAction.js
 */

(function() {

  var HotPixelSnapAction = function(hotPixel, parentEdge, vertexIndex) {
    this.hotPixel = hotPixel;
    this.parentEdge = parentEdge;
    this.vertexIndex = vertexIndex;
  };

  HotPixelSnapAction.prototype = new jsts.index.chain.MonotoneChainSelectAction();
  HotPixelSnapAction.constructor = HotPixelSnapAction;

  HotPixelSnapAction.prototype.hotPixel = null;
  HotPixelSnapAction.prototype.parentEdge = null;
  HotPixelSnapAction.prototype.vertexIndex = null;
  HotPixelSnapAction.prototype._isNodeAdded = false;

  HotPixelSnapAction.prototype.isNodeAdded = function() {
    return this._isNodeAdded;
  };

  HotPixelSnapAction.prototype.select = function(mc, startIndex) {
    var ss = mc.getContext();
    // don't snap a vertex to itself
    if (this.parentEdge !== null) {
      if (ss === this.parentEdge && startIndex === this.vertexIndex)
        return;
    }
    // isNodeAdded = SimpleSnapRounder.addSnappedNode(hotPixel, ss, startIndex);
    this._isNodeAdded = this.hotPixel.addSnappedNode(ss, startIndex);
  };


  /**
   * "Snaps" all {@link SegmentString}s in a {@link SpatialIndex} containing
   * {@link MonotoneChain}s to a given {@link HotPixel}.
   */
  jsts.noding.snapround.MCIndexPointSnapper = function(index) {
    this.index = index;
  };

  jsts.noding.snapround.MCIndexPointSnapper.prototype.index = null;

  /**
   * Snaps (nodes) all interacting segments to this hot pixel. The hot pixel may
   * represent a vertex of an edge, in which case this routine uses the
   * optimization of not noding the vertex itself
   *
   * @param hotPixel
   *          the hot pixel to snap to.
   * @param parentEdge
   *          the edge containing the vertex, if applicable, or
   *          <code>null.</code>
   * @param vertexIndex
   *          the index of the vertex, if applicable, or -1.
   * @return <code>true</code> if a node was added for this pixel.
   */
  jsts.noding.snapround.MCIndexPointSnapper.prototype.snap = function(hotPixel,
      parentEdge, vertexIndex) {
    if (arguments.length === 1) {
      this.snap2.apply(this, arguments);
      return;
    }

    var pixelEnv = hotPixel.getSafeEnvelope();
    var hotPixelSnapAction = new HotPixelSnapAction(hotPixel, parentEdge,
        vertexIndex);

    this.index.query(pixelEnv, {
      visitItem: function(testChain) {
        testChain.select(pixelEnv, hotPixelSnapAction);
      }
    });
    return hotPixelSnapAction.isNodeAdded();
  };

  jsts.noding.snapround.MCIndexPointSnapper.prototype.snap2 = function(hotPixel) {
    return this.snap(hotPixel, null, -1);
  };

})();
/* ======================================================================
    jsts/index/bintree/NodeBase.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * The base class for nodes in a {@link Bintree}.
 */
(function() {

  /**
   * Constructs a new NodeBase
   *
   * @constructor
   */
  var NodeBase = function() {
    this.items = new javascript.util.ArrayList();

    /**
     * subnodes are numbered as follows:
     *
     * 0 | 1
     */
    this.subnode = [null, null];
  };

  /**
   * Returns the index of the subnode that wholely contains the given interval.
   * If none does, returns -1.
   *
   * @param {jsts.index.bintree.Interval}
   *          interval the interval.
   * @param {Number}
   *          centre
   */
  NodeBase.getSubnodeIndex = function(interval, centre) {
    var subnodeIndex = -1;
    if (interval.min >= centre) {
      subnodeIndex = 1;
    }
    if (interval.max <= centre) {
      subnodeIndex = 0;
    }
    return subnodeIndex;
  };

  /**
   * Gets the items
   *
   * @return {javascript.util.ArrayList}
   */
  NodeBase.prototype.getItems = function() {
    return this.items;
  };

  /**
   * Adds an item
   *
   * @param {Object}
   *          item the item to add.
   */
  NodeBase.prototype.add = function(item) {
    this.items.add(item);
  };

  /**
   * Adds all items from this tree to the provided items
   *
   * @param {javascript.util.ArrayList}
   *          items the list to add to.
   * @return {javscript.util.ArrayList} the input list filled with items.
   */
  NodeBase.prototype.addAllItems = function(items) {
    // TODO: Check if addAll really takes an ordinary javascript array
    items.addAll(this.items);
    var i = 0, il = 2;
    for (i; i < il; i++) {
      if (this.subnode[i] !== null) {
        this.subnode[i].addAllItems(items);
      }
    }
    return items;
  };

  /**
   * Adds items in the tree which potentially overlap the query interval to the
   * given collection. If the query interval is <tt>null</tt>, add all items
   * in the tree.
   *
   * @param {jsts.index.bintree.Interval}
   *          interval a query nterval, or null.
   * @param {javascript.util.Collection}
   *          resultItems the candidate items found.
   */
  NodeBase.prototype.addAllItemsFromOverlapping = function(interval,
      resultItems) {
    if (interval !== null && !this.isSearchMatch(interval)) {
      return;
    }

    // some of these may not actually overlap - this is allowed by the bintree
    // contract
    resultItems.addAll(this.items);

    if (this.subnode[0] !== null) {
      this.subnode[0].addAllItemsFromOverlapping(interval, resultItems);
    }

    if (this.subnode[1] !== null) {
      this.subnode[1].addAllItemsFromOverlapping(interval, resultItems);
    }
  };

  /**
   * Removes a single item from this subtree.
   *
   * @param {jsts.index.bintree.Interval}
   *          itemInterval the envelope containing the item.
   * @param {Object}
   *          item the item to remove.
   * @return <code>true</code> if the item was found and removed.
   */
  NodeBase.prototype.remove = function(itemInterval, item) {
    if (!this.isSearchMatch(itemInterval)) {
      return false;
    }

    var found = false, i = 0, il = 2;
    for (i; i < il; i++) {
      if (this.subnode[i] !== null) {
        found = this.subnode[i].remove(itemInterval, item);
        if (found) {
          // trim subtree if empty
          if (this.subnode[i].isPrunable()) {
            this.subnode[i] = null;
          }
          break;
        }
      }
    }

    // if item was found lower down, don't need to search for it here
    if (found) {
      return found;
    }

    // otherwise, try and remove the item from the list of items in this node
    found = this.items.remove(item);
    return found;
  };

  /**
   * Checks if this tree has any children or items
   *
   * @return {Boolean} true if it has children or items (or both).
   */
  NodeBase.prototype.isPrunable = function() {
    return !(this.hasChildren() || this.hasItems());
  };

  /**
   * Checks if this tree has any children
   *
   * @return {Boolean} true if it has children.
   */
  NodeBase.prototype.hasChildren = function() {
    var i = 0, il = 2;
    for (i; i < il; i++) {
      if (this.subnode[i] !== null) {
        return true;
      }
    }
    return false;
  };

  /**
   * Checks i this node has any items
   *
   * @return {Boolean} true if it has items.
   */
  NodeBase.prototype.hasItems = function() {
    return !this.items.isEmpty();
  };

  NodeBase.prototype.depth = function() {
    var maxSubDepth = 0, i = 0, il = 2, sqd;
    for (i; i < il; i++) {
      if (this.subnode[i] !== null) {
        sqd = this.subnode[i].depth();
        if (sqd > maxSubDepth) {
          maxSubDepth = sqd;
        }
      }
    }
    return maxSubDepth + 1;
  };

  NodeBase.prototype.size = function() {
    var subSize = 0, i = 0, il = 2;
    for (i; i < il; i++) {
      if (this.subnode[i] !== null) {
        subSize += this.subnode[i].size();
      }
    }
    return subSize + this.items.size();
  };

  NodeBase.prototype.nodeSize = function() {
    var subSize = 0, i = 0, il = 2;
    for (i; i < il; i++) {
      if (this.subnode[i] !== null) {
        subSize += this.subnode[i].nodeSize();
      }
    }
    return subSize + 1;
  };

  jsts.index.bintree.NodeBase = NodeBase;
})();
/* ======================================================================
    jsts/index/bintree/Node.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * A node of a {@link Bintree}.
 */
(function() {

  /**
   * @requires jsts/index/bintree/NodeBase.js
   * @requires jsts/index/bintree/Interval.js
   * @requires jsts/index/bintree/Key.js
   */

  var NodeBase = jsts.index.bintree.NodeBase;
  var Key = jsts.index.bintree.Key;
  var Interval = jsts.index.bintree.Interval;

  /**
   * Constructs a new Node
   *
   * @constructor
   */
  var Node = function(interval, level) {
    /**
     * subnodes are numbered as follows:
     *
     * 0 | 1
     */
    this.items = new javascript.util.ArrayList();
    this.subnode = [null, null];
    this.interval = interval;
    this.level = level;
    this.centre = (interval.getMin() + interval.getMax()) / 2;
  };
  Node.prototype = new NodeBase();
  Node.constructor = Node;

  /**
   * Creates a node from a specified interval
   *
   * @param {jsts.index.bintree.Interval}
   *          itemInterval the interval.
   * @return {jsts.index.bintree.Node} the created node.
   */
  Node.createNode = function(itemInterval) {
    var key, node;

    key = new Key(itemInterval);
    node = new Node(key.getInterval(), key.getLevel());
    return node;
  };

  /**
   * Creates an expanded node
   *
   * @param {jsts.index.bintree.Node}
   *          node the node.
   * @param {jsts.index.bintree.Interval}
   *          addInterval the interval to add.
   * @return {jsts.index.bintree.Node} the expanded node.
   */
  Node.createExpanded = function(node, addInterval) {
    var expandInt, largerNode;
    expandInt = new Interval(addInterval);
    if (node !== null) {
      expandInt.expandToInclude(node.interval);
    }

    largerNode = Node.createNode(expandInt);

    if (node !== null) {
      largerNode.insert(node);
    }

    return largerNode;
  };

  Node.prototype.getInterval = function() {
    return this.interval;
  };

  /**
   * Checks if the input interval matches any items in this node
   *
   * @return {Boolean} true if there is a search match.
   */
  Node.prototype.isSearchMatch = function(itemInterval) {
    return itemInterval.overlaps(this.interval);
  };

  /**
   * Returns the subnode containing the envelope. Creates the node if it does
   * not already exist.
   *
   * @param {jsts.index.bintree.Interval}
   *          serachInterval the interval.
   * @return {jsts.index.bintree.Node} the node.
   */
  Node.prototype.getNode = function(searchInterval) {
    var subnodeIndex = NodeBase.getSubnodeIndex(searchInterval, this.centre), node;
    // if index is -1 searchEnv is not contained in a subnode
    if (subnodeIndex != -1) {
      // create the node if it does not exist
      node = this.getSubnode(subnodeIndex);
      // recursively search the found/created node
      return node.getNode(searchInterval);
    } else {
      return this;
    }
  };

  /**
   * Returns the smallest <i>existing</i> node containing the envelope.
   *
   * @param {jsts.index.bintree.Interval}
   *          searchInterval the interval.
   * @return {jsts.index.bintree.Node} the smallest node contained.
   */
  Node.prototype.find = function(searchInterval) {
    var subnodeIndex = NodeBase.getSubnodeIndex(searchInterval, this.centre), node;
    if (subnodeIndex === -1) {
      return this;
    }

    if (this.subnode[subnodeIndex] !== null) {
      // query lies in subnode, so search it
      node = this.subnode[subnodeIndex];
      return node.find(searchInterval);
    }
    // no existing subnode, so return this one anyway
    return this;
  };

  /**
   * Inserts a node as a child node (at some level) in this node
   *
   * @param {jsts.index.bintree.Node}
   *          node the node to insert.
   */
  Node.prototype.insert = function(node) {
    //Assert.isTrue(interval == null || interval.contains(node.interval));

    var index = NodeBase.getSubnodeIndex(node.interval, this.centre), childNode;
    if (node.level === this.level - 1) {
      this.subnode[index] = node;
    } else {
      // the node is not a direct child, so make a new child node to contain it
      // and recursively insert the node
      childNode = this.createSubnode(index);
      childNode.insert(node);
      this.subnode[index] = childNode;
    }
  };

  /**
   * get the subnode for the index. If it doesn't exist, create it
   *
   * @param {Number}
   *          index
   * @return {jsts.index.bintree.Node} the found or created node.
   */
  Node.prototype.getSubnode = function(index) {
    if (this.subnode[index] === null) {
      this.subnode[index] = this.createSubnode(index);
    }
    return this.subnode[index];
  };

  /**
   * Creates a subnode
   *
   * @param {Number}
   *          index the index to create the subnode at.
   * @return {jsts.index.bintree.Node} the created node.
   */
  Node.prototype.createSubnode = function(index) {
    // create a new subnode in the appropriate interval

    var min, max, subInt, node;

    min = 0.0;
    max = 0.0;

    switch (index) {
    case 0:
      min = this.interval.getMin();
      max = this.centre;
      break;
    case 1:
      min = this.centre;
      max = this.interval.getMax();
      break;
    }
    subInt = new Interval(min, max);
    node = new Node(subInt, this.level - 1);
    return node;
  };

  jsts.index.bintree.Node = Node;
})();
/* ======================================================================
    jsts/index/bintree/Root.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * The root node of a single {@link Bintree}. It is centred at the origin, and
 * does not have a defined extent.
 */
(function() {

  /**
   * @requires jsts/index/bintree/NodeBase.js
   * @requires jsts/index/bintree/Node.js
   */

  var Node = jsts.index.bintree.Node;
  var NodeBase = jsts.index.bintree.NodeBase;

  /**
   * Constructs a new Root
   *
   * @constructor
   */
  var Root = function() {
    /**
     * subnodes are numbered as follows:
     *
     * 0 | 1
     */
    this.subnode = [null, null];
    this.items = new javascript.util.ArrayList();
  };
  Root.prototype = new jsts.index.bintree.NodeBase();
  Root.constructor = Root;

  // the singleton root node is centred at the origin.
  Root.origin = 0.0;

  /**
   * Insert an item into the tree this is the root of.
   *
   * @param {jsts.index.bintree.Interval}
   *          itemInterval the interval of the item.
   * @param {Object}
   *          item the item to insert.
   */
  Root.prototype.insert = function(itemInterval, item) {
    var index = NodeBase.getSubnodeIndex(itemInterval, Root.origin), node, largerNode;
    // if index is -1, itemEnv must contain the origin.
    if (index === -1) {
      this.add(item);
      return;
    }

    /**
     * the item must be contained in one interval, so insert it into the tree
     * for that interval (which may not yet exist)
     */
    node = this.subnode[index];

    /**
     * If the subnode doesn't exist or this item is not contained in it, have to
     * expand the tree upward to contain the item.
     */

    if (node === null || !node.getInterval().contains(itemInterval)) {
      largerNode = Node.createExpanded(node, itemInterval);
      this.subnode[index] = largerNode;
    }

    /**
     * At this point we have a subnode which exists and must contain contains
     * the env for the item. Insert the item into the tree.
     */
    this.insertContained(this.subnode[index], itemInterval, item);
  };

  /**
   * insert an item which is known to be contained in the tree rooted at the
   * given Node. Lower levels of the tree will be created if necessary to hold
   * the item.
   *
   * @param {jsts.index.bintree.Node}
   *          tree the subtree.
   * @param {jsts.index.bintree.Interval}
   *          itemInterval the interval.
   * @param {Object}
   *          item the item to insert.
   */
  Root.prototype.insertContained = function(tree, itemInterval, item) {
    var isZeroArea, node;
    /**
     * Do NOT create a new node for zero-area intervals - this would lead to
     * infinite recursion. Instead, use a heuristic of simply returning the
     * smallest existing node containing the query
     */
    isZeroArea = jsts.index.IntervalSize.isZeroWidth(itemInterval
        .getMin(), itemInterval.getMax());
    node = isZeroArea ? tree.find(itemInterval) : tree.getNode(itemInterval);
    node.add(item);
  };

  /**
   * The root node matches all searches
   */
  Root.prototype.isSearchMatch = function(interval) {
    return true;
  };

  jsts.index.bintree.Root = Root;
})();
/* ======================================================================
    jsts/geomgraph/Quadrant.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * Utility functions for working with quadrants, which are numbered as follows:
 *
 * <pre>
 * 1 | 0
 * --+--
 * 2 | 3
 * &lt;pre&gt;
 * @constructor
 *
 */
jsts.geomgraph.Quadrant = function() {

};

jsts.geomgraph.Quadrant.NE = 0;
jsts.geomgraph.Quadrant.NW = 1;
jsts.geomgraph.Quadrant.SW = 2;
jsts.geomgraph.Quadrant.SE = 3;


/**
 * Returns the quadrant of a directed line segment (specified as x and y
 * displacements, which cannot both be 0).
 *
 * @throws IllegalArgumentException
 *           if the displacements are both 0
 */
jsts.geomgraph.Quadrant.quadrant = function(dx, dy) {
  if (dx instanceof jsts.geom.Coordinate) {
    return jsts.geomgraph.Quadrant.quadrant2.apply(this, arguments);
  }

  if (dx === 0.0 && dy === 0.0)
    throw new jsts.error.IllegalArgumentError(
        'Cannot compute the quadrant for point ( ' + dx + ', ' + dy + ' )');
  if (dx >= 0.0) {
    if (dy >= 0.0)
      return jsts.geomgraph.Quadrant.NE;
    else
      return jsts.geomgraph.Quadrant.SE;
  } else {
    if (dy >= 0.0)
      return jsts.geomgraph.Quadrant.NW;
    else
      return jsts.geomgraph.Quadrant.SW;
  }
};


/**
 * Returns the quadrant of a directed line segment from p0 to p1.
 *
 * @throws IllegalArgumentException
 *           if the points are equal
 */
jsts.geomgraph.Quadrant.quadrant2 = function(p0, p1) {
  if (p1.x === p0.x && p1.y === p0.y)
    throw new jsts.error.IllegalArgumentError(
        'Cannot compute the quadrant for two identical points ' + p0);

  if (p1.x >= p0.x) {
    if (p1.y >= p0.y)
      return jsts.geomgraph.Quadrant.NE;
    else
      return jsts.geomgraph.Quadrant.SE;
  } else {
    if (p1.y >= p0.y)
      return jsts.geomgraph.Quadrant.NW;
    else
      return jsts.geomgraph.Quadrant.SW;
  }
};


/**
 * Returns true if the quadrants are 1 and 3, or 2 and 4
 */
jsts.geomgraph.Quadrant.isOpposite = function(quad1, quad2) {
  if (quad1 === quad2)
    return false;
  var diff = (quad1 - quad2 + 4) % 4;
  // if quadrants are not adjacent, they are opposite
  if (diff === 2)
    return true;
  return false;
};


/**
 * Returns the right-hand quadrant of the halfplane defined by the two
 * quadrants, or -1 if the quadrants are opposite, or the quadrant if they are
 * identical.
 */
jsts.geomgraph.Quadrant.commonHalfPlane = function(quad1, quad2) {
  // if quadrants are the same they do not determine a unique common halfplane.
  // Simply return one of the two possibilities
  if (quad1 === quad2)
    return quad1;
  var diff = (quad1 - quad2 + 4) % 4;
  // if quadrants are not adjacent, they do not share a common halfplane
  if (diff === 2)
    return -1;
  //
  var min = (quad1 < quad2) ? quad1 : quad2;
  var max = (quad1 > quad2) ? quad1 : quad2;
  // for this one case, the righthand plane is NOT the minimum index;
  if (min === 0 && max === 3)
    return 3;
  // in general, the halfplane index is the minimum of the two adjacent
  // quadrants
  return min;
};


/**
 * Returns whether the given quadrant lies within the given halfplane (specified
 * by its right-hand quadrant).
 */
jsts.geomgraph.Quadrant.isInHalfPlane = function(quad, halfPlane) {
  if (halfPlane === jsts.geomgraph.Quadrant.SE) {
    return quad === jsts.geomgraph.Quadrant.SE ||
        quad === jsts.geomgraph.Quadrant.SW;
  }
  return quad === halfPlane || quad === halfPlane + 1;
};


/**
 * Returns true if the given quadrant is 0 or 1.
 */
jsts.geomgraph.Quadrant.isNorthern = function(quad) {
  return quad === jsts.geomgraph.Quadrant.NE ||
      quad === jsts.geomgraph.Quadrant.NW;
};
/* ======================================================================
    jsts/operation/valid/ConsistentAreaTester.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Checks that a {@link GeometryGraph} representing an area
 * (a {@link Polygon} or {@link MultiPolygon} )
 * has consistent semantics for area geometries.
 * This check is required for any reasonable polygonal model
 * (including the OGC-SFS model, as well as models which allow ring self-intersection at single points)
 * <p>
 * Checks include:
 * <ul>
 * <li>test for rings which properly intersect
 * (but not for ring self-intersection, or intersections at vertices)
 * <li>test for consistent labelling at all node points
 * (this detects vertex intersections with invalid topology,
 * i.e. where the exterior side of an edge lies in the interior of the area)
 * <li>test for duplicate rings
 * </ul>
 * If an inconsistency is found the location of the problem
 * is recorded and is available to the caller.
 *
 * @version 1.7
 */


/**
 *
 * Creates a new tester for consistent areas.
 *
 *
 *
 * @param geomGraph
 *          the topology graph of the area geometry.
 *
 */
jsts.operation.valid.ConsistentAreaTester = function(geomGraph) {
  this.geomGraph = geomGraph;
  this.li = new jsts.algorithm.RobustLineIntersector();
  this.nodeGraph = new jsts.operation.relate.RelateNodeGraph();
  this.invalidPoint = null;
};

/**
 *
 * @return the intersection point, or <code>null</code> if none was found.
 *
 */
jsts.operation.valid.ConsistentAreaTester.prototype.getInvalidPoint = function() {
  return this.invalidPoint;
};

/**
 *
 * Check all nodes to see if their labels are consistent with area topology.
 *
 * @return <code>true</code> if this area has a consistent node labelling.
 *
 */
jsts.operation.valid.ConsistentAreaTester.prototype.isNodeConsistentArea = function() {
  /**
   *
   * To fully check validity, it is necessary to compute ALL intersections,
   * including self-intersections within a single edge.
   *
   */
  var intersector = this.geomGraph.computeSelfNodes(this.li, true);
  if (intersector.hasProperIntersection()) {
    this.invalidPoint = intersector.getProperIntersectionPoint();
    return false;
  }

  this.nodeGraph.build(this.geomGraph);
  return this.isNodeEdgeAreaLabelsConsistent();
};

/**
 *
 * Check all nodes to see if their labels are consistent. If any are not, return
 * false
 *
 * @return <code>true</code> if the edge area labels are consistent at this
 *         node.
 *
 */
jsts.operation.valid.ConsistentAreaTester.prototype.isNodeEdgeAreaLabelsConsistent = function() {
  for (var nodeIt = this.nodeGraph.getNodeIterator(); nodeIt.hasNext();) {
    var node = nodeIt.next();
    if (!node.getEdges().isAreaLabelsConsistent(this.geomGraph)) {
      this.invalidPoint = node.getCoordinate().clone();
      return false;
    }
  }
  return true;
};

/**
 *
 * Checks for two duplicate rings in an area. Duplicate rings are rings that are
 * topologically equal (that is, which have the same sequence of points up to
 * point order). If the area is topologically consistent (determined by calling
 * the <code>isNodeConsistentArea</code>, duplicate rings can be found by
 * checking for EdgeBundles which contain more than one EdgeEnd. (This is
 * because topologically consistent areas cannot have two rings sharing the same
 * line segment, unless the rings are equal). The start point of one of the
 * equal rings will be placed in invalidPoint.
 *
 * @return true if this area Geometry is topologically consistent but has two
 *         duplicate rings.
 *
 */
jsts.operation.valid.ConsistentAreaTester.prototype.hasDuplicateRings = function() {
  for (var nodeIt = this.nodeGraph.getNodeIterator(); nodeIt.hasNext();) {
    var node = nodeIt.next();
    for (var i = node.getEdges().iterator(); i.hasNext();) {
      var eeb = i.next();
      if (eeb.getEdgeEnds().length > 1) {
        invalidPoint = eeb.getEdge().getCoordinate(0);
        return true;
      }
    }
  }
  return false;
};
/* ======================================================================
    jsts/operation/relate/RelateNode.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @requires jsts/geomgraph/Node.js
 */



/**
 * A RelateNode is a Node that maintains a list of EdgeStubs for the edges that
 * are incident on it.
 *
 * Represents a node in the topological graph used to compute spatial
 * relationships.
 *
 * @augments {Node}
 * @constructor
 */
jsts.operation.relate.RelateNode = function(coord, edges) {
  jsts.geomgraph.Node.apply(this, arguments);
};

jsts.operation.relate.RelateNode.prototype = new jsts.geomgraph.Node();


/**
 * Update the IM with the contribution for this component. A component only
 * contributes if it has a labelling for both parent geometries
 *
 * @protected
 */
jsts.operation.relate.RelateNode.prototype.computeIM = function(im) {
  im.setAtLeastIfValid(this.label.getLocation(0), this.label.getLocation(1), 0);
};


/**
 * Update the IM with the contribution for the EdgeEnds incident on this node.
 */
jsts.operation.relate.RelateNode.prototype.updateIMFromEdges = function(im) {
  this.edges.updateIM(im);
};
/* ======================================================================
    jsts/geomgraph/DirectedEdge.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * @requires jsts/geom/Location.js
   * @requires jsts/geomgraph/Position.js
   * @requires jsts/geomgraph/EdgeEnd.js
   */

  var Location = jsts.geom.Location;
  var Position = jsts.geomgraph.Position;
  var EdgeEnd = jsts.geomgraph.EdgeEnd;


  /**
   * @constructor
   * @extends jsts.geomgraph.EdgeEnd
   */
  jsts.geomgraph.DirectedEdge = function(edge, isForward) {
    EdgeEnd.call(this, edge);

    this.depth = [0, -999, -999];

    this._isForward = isForward;
    if (isForward) {
      this.init(edge.getCoordinate(0), edge.getCoordinate(1));
    } else {
      var n = edge.getNumPoints() - 1;
      this.init(edge.getCoordinate(n), edge.getCoordinate(n - 1));
    }
    this.computeDirectedLabel();

  };
  jsts.geomgraph.DirectedEdge.prototype = new EdgeEnd();
  jsts.geomgraph.DirectedEdge.constructor = jsts.geomgraph.DirectedEdge;


  /**
   * Computes the factor for the change in depth when moving from one location
   * to another. E.g. if crossing from the INTERIOR to the EXTERIOR the depth
   * decreases, so the factor is -1
   */
  jsts.geomgraph.DirectedEdge.depthFactor = function(currLocation, nextLocation) {
    if (currLocation === Location.EXTERIOR &&
        nextLocation === Location.INTERIOR)
      return 1;
    else if (currLocation === Location.INTERIOR &&
        nextLocation === Location.EXTERIOR)
      return -1;
    return 0;
  };

  /**
   * @type {boolean}
   * @protected
   */
  jsts.geomgraph.DirectedEdge.prototype._isForward = null;
  /**
   * @type {boolean}
   * @private
   */
  jsts.geomgraph.DirectedEdge.prototype._isInResult = false;
  /**
   * @type {boolean}
   * @private
   */
  jsts.geomgraph.DirectedEdge.prototype._isVisited = false;

  /**
   * the symmetric edge
   *
   * @type {DirectedEdge}
   * @private
   */
  jsts.geomgraph.DirectedEdge.prototype.sym = null;
  /**
   * the next edge in the edge ring for the polygon containing this edge
   *
   * @type {DirectedEdge}
   * @private
   */
  jsts.geomgraph.DirectedEdge.prototype.next = null;
  /**
   * the next edge in the MinimalEdgeRing that contains this edge
   *
   * @type {DirectedEdge}
   * @private
   */
  jsts.geomgraph.DirectedEdge.prototype.nextMin = null;
  /**
   * the EdgeRing that this edge is part of
   *
   * @type {EdgeRing}
   * @private
   */
  jsts.geomgraph.DirectedEdge.prototype.edgeRing = null;
  /**
   * the MinimalEdgeRing that this edge is part of
   *
   * @type {EdgeRing}
   * @private
   */
  jsts.geomgraph.DirectedEdge.prototype.minEdgeRing = null;
  /**
   * The depth of each side (position) of this edge. The 0 element of the array
   * is never used.
   *
   * @type {Array.<number>}
   */
  jsts.geomgraph.DirectedEdge.prototype.depth = null;

  jsts.geomgraph.DirectedEdge.prototype.getEdge = function() {
    return this.edge;
  };
  jsts.geomgraph.DirectedEdge.prototype.setInResult = function(isInResult) {
    this._isInResult = isInResult;
  };
  jsts.geomgraph.DirectedEdge.prototype.isInResult = function() {
    return this._isInResult;
  };
  jsts.geomgraph.DirectedEdge.prototype.isVisited = function() {
    return this._isVisited;
  };
  jsts.geomgraph.DirectedEdge.prototype.setVisited = function(isVisited) {
    this._isVisited = isVisited;
  };
  jsts.geomgraph.DirectedEdge.prototype.setEdgeRing = function(edgeRing) {
    this.edgeRing = edgeRing;
  };
  jsts.geomgraph.DirectedEdge.prototype.getEdgeRing = function() {
    return this.edgeRing;
  };
  jsts.geomgraph.DirectedEdge.prototype.setMinEdgeRing = function(minEdgeRing) {
    this.minEdgeRing = minEdgeRing;
  };
  jsts.geomgraph.DirectedEdge.prototype.getMinEdgeRing = function() { return this.minEdgeRing; };
  jsts.geomgraph.DirectedEdge.prototype.getDepth = function(position) {
    return this.depth[position];
  };

  jsts.geomgraph.DirectedEdge.prototype.setDepth = function(position, depthVal) {
    if (this.depth[position] !== -999) {
      if (this.depth[position] !== depthVal)
        throw new jsts.error.TopologyError('assigned depths do not match', this
            .getCoordinate());
    }
    this.depth[position] = depthVal;
  };

  jsts.geomgraph.DirectedEdge.prototype.getDepthDelta = function() {
    var depthDelta = this.edge.getDepthDelta();
    if (!this._isForward)
      depthDelta = -depthDelta;
    return depthDelta;
  };

  /**
   * setVisitedEdge marks both DirectedEdges attached to a given Edge. This is
   * used for edges corresponding to lines, which will only appear oriented in a
   * single direction in the result.
   */
  jsts.geomgraph.DirectedEdge.prototype.setVisitedEdge = function(isVisited) {
    this.setVisited(isVisited);
    this.sym.setVisited(isVisited);
  };
  /**
   * Each Edge gives rise to a pair of symmetric DirectedEdges, in opposite
   * directions.
   *
   * @return the DirectedEdge for the same Edge but in the opposite direction.
   */
  jsts.geomgraph.DirectedEdge.prototype.getSym = function() {
    return this.sym;
  };
  jsts.geomgraph.DirectedEdge.prototype.isForward = function() {
    return this._isForward;
  };
  jsts.geomgraph.DirectedEdge.prototype.setSym = function(de) {
    this.sym = de;
  };
  jsts.geomgraph.DirectedEdge.prototype.getNext = function() {
    return this.next;
  };
  jsts.geomgraph.DirectedEdge.prototype.setNext = function(next) {
    this.next = next;
  };
  jsts.geomgraph.DirectedEdge.prototype.getNextMin = function() {
    return this.nextMin;
  };
  jsts.geomgraph.DirectedEdge.prototype.setNextMin = function(nextMin) {
    this.nextMin = nextMin;
  };

  /**
   * This edge is a line edge if
   * <ul>
   * <li> at least one of the labels is a line label
   * <li> any labels which are not line labels have all Locations = EXTERIOR
   * </ul>
   */
  jsts.geomgraph.DirectedEdge.prototype.isLineEdge = function() {
    var isLine = this.label.isLine(0) || this.label.isLine(1);
    var isExteriorIfArea0 = !this.label.isArea(0) ||
        this.label.allPositionsEqual(0, Location.EXTERIOR);
    var isExteriorIfArea1 = !this.label.isArea(1) ||
        this.label.allPositionsEqual(1, Location.EXTERIOR);

    return isLine && isExteriorIfArea0 && isExteriorIfArea1;
  };
  /**
   * This is an interior Area edge if
   * <ul>
   * <li> its label is an Area label for both Geometries
   * <li> and for each Geometry both sides are in the interior.
   * </ul>
   *
   * @return true if this is an interior Area edge.
   */
  jsts.geomgraph.DirectedEdge.prototype.isInteriorAreaEdge = function() {
    var isInteriorAreaEdge = true;
    for (var i = 0; i < 2; i++) {
      if (!(this.label.isArea(i) &&
          this.label.getLocation(i, Position.LEFT) === Location.INTERIOR && this.label
          .getLocation(i, Position.RIGHT) === Location.INTERIOR)) {
        isInteriorAreaEdge = false;
      }
    }
    return isInteriorAreaEdge;
  };

  /**
   * Compute the label in the appropriate orientation for this DirEdge
   *
   * @private
   */
  jsts.geomgraph.DirectedEdge.prototype.computeDirectedLabel = function() {
    this.label = new jsts.geomgraph.Label(this.edge.getLabel());
    if (!this._isForward)
      this.label.flip();
  };

  /**
   * Set both edge depths. One depth for a given side is provided. The other is
   * computed depending on the Location transition and the depthDelta of the
   * edge.
   */
  jsts.geomgraph.DirectedEdge.prototype.setEdgeDepths = function(position, depth) {
    // get the depth transition delta from R to L for this directed Edge
    var depthDelta = this.getEdge().getDepthDelta();
    if (!this._isForward)
      depthDelta = -depthDelta;

    // if moving from L to R instead of R to L must change sign of delta
    var directionFactor = 1;
    if (position === Position.LEFT)
      directionFactor = -1;

    var oppositePos = Position.opposite(position);
    var delta = depthDelta * directionFactor;
    var oppositeDepth = depth + delta;
    this.setDepth(position, depth);
    this.setDepth(oppositePos, oppositeDepth);
  };

})();
/* ======================================================================
    jsts/operation/distance/DistanceOp.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */
/**
 * Find two points on two {@link Geometry}s which lie
 * within a given distance, or else are the nearest points
 * on the geometries (in which case this also
 * provides the distance between the geometries).
 * <p>
 * The distance computation also finds a pair of points in the input geometries
 * which have the minimum distance between them.
 * If a point lies in the interior of a line segment,
 * the coordinate computed is a close
 * approximation to the exact point.
 * <p>
 * The algorithms used are straightforward O(n^2)
 * comparisons.  This worst-case performance could be improved on
 * by using Voronoi techniques or spatial indexes.
 *
 */



/**
 * Constructs a DistanceOp that computes the distance and nearest points
 * between the two specified geometries.
 *
 * @param {Geometry}
 *          g0 a Geometry.
 * @param {Geometry}
 *          g1 a Geometry.
 * @param {double}
 *          terminateDistance the distance on which to terminate the search.
 * @constructor
 */
jsts.operation.distance.DistanceOp = function(g0, g1, terminateDistance) {
  this.ptLocator = new jsts.algorithm.PointLocator();

  this.geom = [];
  this.geom[0] = g0;
  this.geom[1] = g1;
  this.terminateDistance = terminateDistance;
};


/**
 * @type {Geometry[]}
 */
jsts.operation.distance.DistanceOp.prototype.geom = null;


/**
 * @type {double}
 */
jsts.operation.distance.DistanceOp.prototype.terminateDistance = 0.0;


/**
 * @type {PointLocator}
 */
jsts.operation.distance.DistanceOp.prototype.ptLocator = null;


/**
 * @type {GeometryLocation[]}
 */
jsts.operation.distance.DistanceOp.prototype.minDistanceLocation = null;


/**
 * @type {double}
 */
jsts.operation.distance.DistanceOp.prototype.minDistance = Number.MAX_VALUE;


/**
 * Compute the distance between the nearest points of two geometries.
 *
 * @param {Geometry}
 *          g0 a {@link Geometry}.
 * @param {Geometry}
 *          g1 another {@link Geometry}.
 * @return {double} the distance between the geometries.
 */
jsts.operation.distance.DistanceOp.distance = function(g0, g1) {
  var distOp = new jsts.operation.distance.DistanceOp(g0, g1, 0.0);
  return distOp.distance();
};


/**
 * Test whether two geometries lie within a given distance of each other.
 *
 * @param {Geometry}
 *          g0 a {@link Geometry}.
 * @param {Geometry}
 *          g1 another {@link Geometry}.
 * @param {double}
 *          distance the distance to test.
 * @return {boolean} true if g0.distance(g1) <= distance.
 */
jsts.operation.distance.DistanceOp.isWithinDistance = function(g0, g1,
    distance) {
  var distOp = new jsts.operation.distance.DistanceOp(g0, g1, distance);
  return distOp.distance() <= distance;
};


/**
 * Compute the the nearest points of two geometries. The points are presented
 * in the same order as the input Geometries.
 *
 * @param {Geometry}
 *          g0 a {@link Geometry}.
 * @param {Geometry}
 *          g1 another {@link Geometry}.
 * @return {Coordinate[]} the nearest points in the geometries.
 */
jsts.operation.distance.DistanceOp.nearestPoints = function(g0, g1) {
  var distOp = new jsts.operation.distance.DistanceOp(g0, g1, 0.0);
  return distOp.nearestPoints();
};


/**
 * Report the distance between the nearest points on the input geometries.
 *
 * @return {double} the distance between the geometries.
 * @return {double} 0 if either input geometry is empty.
 * @throws IllegalArgumentException
 *           if either input geometry is null
 */
jsts.operation.distance.DistanceOp.prototype.distance = function() {
  if (this.geom[0] === null || this.geom[1] === null)
    throw new jsts.error.IllegalArgumentError('null geometries are not supported');
  if (this.geom[0].isEmpty() || this.geom[1].isEmpty())
    return 0.0;

  this.computeMinDistance();
  return this.minDistance;
};


/**
 * Report the coordinates of the nearest points in the input geometries. The
 * points are presented in the same order as the input Geometries.
 *
 * @return {Coordinate[] } a pair of {@link Coordinate} s of the nearest
 *         points.
 */
jsts.operation.distance.DistanceOp.prototype.nearestPoints = function() {
  this.computeMinDistance();
  var nearestPts = [this.minDistanceLocation[0].getCoordinate(),
                    this.minDistanceLocation[1].getCoordinate()];
  return nearestPts;
};


/**
 * Report the locations of the nearest points in the input geometries. The
 * locations are presented in the same order as the input Geometries.
 *
 * @return {GeometryLocation[] } a pair of {@link GeometryLocation} s for the
 *         nearest points.
 */
jsts.operation.distance.DistanceOp.prototype.nearestLocations = function() {
  this.computeMinDistance();
  return this.minDistanceLocation;
};


/**
 * @param {GeometryLocation[]}
 *          locGeom locations.
 * @param {boolean}
 *          flip if locations should be flipped.
 * @private
 */
jsts.operation.distance.DistanceOp.prototype.updateMinDistance = function(
    locGeom, flip) {
  // if not set then don't update
  if (locGeom[0] === null)
    return;

  if (flip) {
    this.minDistanceLocation[0] = locGeom[1];
    this.minDistanceLocation[1] = locGeom[0];
  } else {
    this.minDistanceLocation[0] = locGeom[0];
    this.minDistanceLocation[1] = locGeom[1];
  }
};


/**
 * @private
 */
jsts.operation.distance.DistanceOp.prototype.computeMinDistance = function() {
  // overloaded variant
  if (arguments.length > 0) {
    this.computeMinDistance2.apply(this, arguments);
    return;
  }

  // only compute once!
  if (this.minDistanceLocation !== null)
    return;

  this.minDistanceLocation = [];
  this.computeContainmentDistance();
  if (this.minDistance <= this.terminateDistance)
    return;
  this.computeFacetDistance();
};


/**
 * @private
 */
jsts.operation.distance.DistanceOp.prototype.computeContainmentDistance = function() {
  if (arguments.length === 2) {
    this.computeContainmentDistance2.apply(this, arguments);
    return;
  } else if (arguments.length === 3 && (!arguments[0] instanceof jsts.operation.distance.GeometryLocation)) {
    this.computeContainmentDistance3.apply(this, arguments);
    return;
  } else if (arguments.length === 3) {
    this.computeContainmentDistance4.apply(this, arguments);
    return;
  }

  var locPtPoly = [];
  // test if either geometry has a vertex inside the other
  this.computeContainmentDistance2(0, locPtPoly);
  if (this.minDistance <= this.terminateDistance)
    return;
  this.computeContainmentDistance2(1, locPtPoly);
};


/**
 * @param {int}
 *          polyGeomIndex
 * @param {GeometryLocation[]}
 *          locPtPoly
 * @private
 */
jsts.operation.distance.DistanceOp.prototype.computeContainmentDistance2 = function(
    polyGeomIndex, locPtPoly) {

  var locationsIndex = 1 - polyGeomIndex;
  var polys = jsts.geom.util.PolygonExtracter.getPolygons(this.geom[polyGeomIndex]);
  if (polys.length > 0) {
    var insideLocs = jsts.operation.distance.ConnectedElementLocationFilter
        .getLocations(this.geom[locationsIndex]);
    this.computeContainmentDistance3(insideLocs, polys, locPtPoly);
    if (this.minDistance <= this.terminateDistance) {
      // this assigment is determined by the order of the args in the
      // computeInside call above
      this.minDistanceLocation[locationsIndex] = locPtPoly[0];
      this.minDistanceLocation[polyGeomIndex] = locPtPoly[1];
      return;
    }
  }
};


/**
 * @param {[]}
 *          locs
 * @param {[]}
 *          polys
 * @param {GeometryLocation[] }
 *          locPtPoly
 * @private
 */
jsts.operation.distance.DistanceOp.prototype.computeContainmentDistance3 = function(
    locs, polys, locPtPoly) {

  for (var i = 0; i < locs.length; i++) {
    var loc = locs[i];
    for (var j = 0; j < polys.length; j++) {
      this.computeContainmentDistance4(loc, polys[j], locPtPoly);
      if (this.minDistance <= this.terminateDistance)
        return;
    }
  }
};


/**
 * @param {GeometryLocation}
 *          ptLoc
 * @param {Polygon}
 *          poly
 * @param {GeometryLocation[]} locPtPoly
 * @private
 */
jsts.operation.distance.DistanceOp.prototype.computeContainmentDistance4 = function(
    ptLoc, poly, locPtPoly) {
  var pt = ptLoc.getCoordinate();
  // if pt is not in exterior, distance to geom is 0
  if (jsts.geom.Location.EXTERIOR !== this.ptLocator.locate(pt, poly)) {
    this.minDistance = 0.0;
    locPtPoly[0] = ptLoc;
    locPtPoly[1] = new jsts.operation.distance.GeometryLocation(poly, pt);
    return;
  }
};


/**
 * Computes distance between facets (lines and points) of input geometries.
 * @private
 */
jsts.operation.distance.DistanceOp.prototype.computeFacetDistance = function() {
  var locGeom = [];

  /**
   * Geometries are not wholely inside, so compute distance from lines and
   * points of one to lines and points of the other
   */
  var lines0 = jsts.geom.util.LinearComponentExtracter.getLines(this.geom[0]);
  var lines1 = jsts.geom.util.LinearComponentExtracter.getLines(this.geom[1]);

  var pts0 = jsts.geom.util.PointExtracter.getPoints(this.geom[0]);
  var pts1 = jsts.geom.util.PointExtracter.getPoints(this.geom[1]);

  // exit whenever minDistance goes LE than terminateDistance
  this.computeMinDistanceLines(lines0, lines1, locGeom);
  this.updateMinDistance(locGeom, false);
  if (this.minDistance <= this.terminateDistance)
    return;

  locGeom[0] = null;
  locGeom[1] = null;
  this.computeMinDistanceLinesPoints(lines0, pts1, locGeom);
  this.updateMinDistance(locGeom, false);
  if (this.minDistance <= this.terminateDistance)
    return;

  locGeom[0] = null;
  locGeom[1] = null;
  this.computeMinDistanceLinesPoints(lines1, pts0, locGeom);
  this.updateMinDistance(locGeom, true);
  if (this.minDistance <= this.terminateDistance)
    return;

  locGeom[0] = null;
  locGeom[1] = null;
  this.computeMinDistancePoints(pts0, pts1, locGeom);
  this.updateMinDistance(locGeom, false);
};


/**
 * @param {[]}
 *          lines0.
 * @param {[]}
 *          lines1
 * @param {GeometryLocation[]}
 *          locGeom
 * @private
 */
jsts.operation.distance.DistanceOp.prototype.computeMinDistanceLines = function(
    lines0, lines1, locGeom) {
  for (var i = 0; i < lines0.length; i++) {
    var line0 = lines0[i];
    for (var j = 0; j < lines1.length; j++) {
      var line1 = lines1[j];
      this.computeMinDistance(line0, line1, locGeom);
      if (this.minDistance <= this.terminateDistance)
        return;
    }
  }
};


/**
 * @param {[]}
 *          points0
 * @param {[]}
 *          points1
 * @param {GeometryLocation[]}
 *          locGeom
 * @private
 */
jsts.operation.distance.DistanceOp.prototype.computeMinDistancePoints = function(
    points0, points1, locGeom) {
  for (var i = 0; i < points0.length; i++) {
    var pt0 = points0[i];
    for (var j = 0; j < points1.length; j++) {
      var pt1 = points1[j];
      var dist = pt0.getCoordinate().distance(pt1.getCoordinate());
      if (dist < this.minDistance) {
        this.minDistance = dist;
        locGeom[0] = new jsts.operation.distance.GeometryLocation(pt0, 0, pt0.getCoordinate());
        locGeom[1] = new jsts.operation.distance.GeometryLocation(pt1, 0, pt1.getCoordinate());
      }
      if (this.minDistance <= this.terminateDistance)
        return;
    }
  }
};


/**
 * @param {[]}
 *          lines
 * @param {[]}
 *          points
 * @param {GeometryLocation[]}
 *          locGeom
 * @private
 */
jsts.operation.distance.DistanceOp.prototype.computeMinDistanceLinesPoints = function(
    lines, points, locGeom) {
  for (var i = 0; i < lines.length; i++) {
    var line = lines[i];
    for (var j = 0; j < points.length; j++) {
      var pt = points[j];
      this.computeMinDistance(line, pt, locGeom);
      if (this.minDistance <= this.terminateDistance)
        return;
    }
  }
};


/**
 * @param {LineString}
 *          line0
 * @param {Point}
 *          line1
 * @param {GeometryLocation[]}
 *          locGeom
 * @private
 */
jsts.operation.distance.DistanceOp.prototype.computeMinDistance2 = function(
    line0, line1, locGeom) {

  // overloaded variant
  if (line1 instanceof jsts.geom.Point) {
    this.computeMinDistance3(line0, line1, locGeom);
    return;
  }

  if (line0.getEnvelopeInternal().distance(line1.getEnvelopeInternal()) > this.minDistance) {
    return;
  }
  var coord0 = line0.getCoordinates();
  var coord1 = line1.getCoordinates();
  // brute force approach!
  for (var i = 0; i < coord0.length - 1; i++) {
    for (var j = 0; j < coord1.length - 1; j++) {
      var dist = jsts.algorithm.CGAlgorithms.distanceLineLine(coord0[i], coord0[i + 1],
          coord1[j], coord1[j + 1]);
      if (dist < this.minDistance) {
        this.minDistance = dist;
        var seg0 = new jsts.geom.LineSegment(coord0[i], coord0[i + 1]);
        var seg1 = new jsts.geom.LineSegment(coord1[j], coord1[j + 1]);
        var closestPt = seg0.closestPoints(seg1);
        locGeom[0] = new jsts.operation.distance.GeometryLocation(line0, i, closestPt[0]);
        locGeom[1] = new jsts.operation.distance.GeometryLocation(line1, j, closestPt[1]);
      }
      if (this.minDistance <= this.terminateDistance) {
        return;
      }
    }
  }
};


/**
 * @param {LineString}
 *          line
 * @param {Point}
 *          pt
 * @param {GeometryLocation[]}
 *          locGeom
 * @private
 */
jsts.operation.distance.DistanceOp.prototype.computeMinDistance3 = function(
    line, pt, locGeom) {
  if (line.getEnvelopeInternal().distance(pt.getEnvelopeInternal()) > this.minDistance) {
    return;
  }
  var coord0 = line.getCoordinates();
  var coord = pt.getCoordinate();
  // brute force approach!
  for (var i = 0; i < coord0.length - 1; i++) {
    var dist = jsts.algorithm.CGAlgorithms.distancePointLine(coord, coord0[i], coord0[i + 1]);
    if (dist < this.minDistance) {
      this.minDistance = dist;
      var seg = new jsts.geom.LineSegment(coord0[i], coord0[i + 1]);
      var segClosestPoint = seg.closestPoint(coord);
      locGeom[0] = new jsts.operation.distance.GeometryLocation(line, i, segClosestPoint);
      locGeom[1] = new jsts.operation.distance.GeometryLocation(pt, 0, coord);
    }
    if (this.minDistance <= this.terminateDistance) {
      return;
    }
  }
};
/* ======================================================================
    jsts/index/strtree/SIRtree.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * One-dimensional version of an STR-packed R-tree. SIR stands for
 * "Sort-Interval-Recursive". STR-packed R-trees are described in:
 * P. Rigaux, Michel Scholl and Agnes Voisard. Spatial Databases With
 * Application To GIS. Morgan Kaufmann, San Francisco, 2002.
 * @see STRtree
 *
 * @requires jsts/index/strtree/AbstractNode.js
 * @requires jsts/index/strtree/AbstractSTRtree.js
 */



/**
 * @param {number} [nodeCapacity].
 * @augments jsts.index.strtree.AbstractSTRtree
 * @constructor
 */
jsts.index.strtree.SIRtree = function(nodeCapacity) {
  nodeCapacity = nodeCapacity || 10;
  jsts.index.strtree.AbstractSTRtree.call(this, nodeCapacity);
};

jsts.index.strtree.SIRtree.prototype = new jsts.index.strtree.AbstractSTRtree();
jsts.index.strtree.SIRtree.constructor = jsts.index.strtree.SIRtree;

//TODO: Verify that this comparison really works
jsts.index.strtree.SIRtree.prototype.comperator = {
  compare: function(o1, o2) {
    return o1.getBounds().getCentre() - o2.getBounds().getCentre();
  }
};


/**
 * @type {Object}
 * @extends {jsts.index.strtree.AbstractSTRtree.IntersectsOp}
 * @private
 */
jsts.index.strtree.SIRtree.prototype.intersectionOp = {
  intersects: function(aBounds, bBounds) {
    return aBounds.intersects(bBounds);
  }
};


/**
 *
 * @param {number} level
 * @return {AbstractNode}
 * @protected
 */
jsts.index.strtree.SIRtree.prototype.createNode = function(level) {

  //TODO: Does it really have to be so complex?
  var AbstractNode = function(level) {
    jsts.index.strtree.AbstractNode.apply(this, arguments);
  };

  AbstractNode.prototype = new jsts.index.strtree.AbstractNode();
  AbstractNode.constructor = AbstractNode;

  AbstractNode.prototype.computeBounds = function() {
    var bounds = null,
        childBoundables = this.getChildBoundables(),
        childBoundable;

    for (var i = 0, l = childBoundables.length; i < l; i++) {
      childBoundable = childBoundables[i];
      if (bounds === null) {
        bounds = new jsts.index.strtree.Interval(childBoundable.getBounds());
      }
      else {
        bounds.expandToInclude(childBoundable.getBounds());
      }
    }
    return bounds;
  };

  return AbstractNode;
};


/**
 * Inserts an item having the given bounds into the tree.
 *
 * @param {number} x1
 * @param {number} x2
 * @param {Object} item
 */
jsts.index.strtree.SIRtree.prototype.insert = function(x1, x2, item) {
  jsts.index.strtree.AbstractSTRtree.prototype.insert(
      new jsts.index.strtree.Interval(Math.min(x1, x2), Math.max(x1, x2)),
      item);
};


/**
 * Returns items whose bounds intersect the given bounds.
 *
 * @param {number} x1 possibly equal to x2.
 * @param {number} [x2].
 * @return {Array}
 */
jsts.index.strtree.SIRtree.prototype.query = function(x1, x2) {
  x2 = x2 || x1;
  jsts.index.strtree.AbstractSTRtree.prototype.query(new jsts.index.strtree.Interval(Math.min(x1, x2), Math.max(x1, x2)));
};

jsts.index.strtree.SIRtree.prototype.getIntersectsOp = function() {
  return this.intersectionOp;
};

jsts.index.strtree.SIRtree.prototype.getComparator = function() {
  return this.comperator;
};
/* ======================================================================
    jsts/simplify/DouglasPeuckerSimplifier.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Simplifies a {@link Geometry} using the Douglas-Peucker algorithm.
 * Ensures that any polygonal geometries returned are valid.
 * Simple lines are not guaranteed to remain simple after simplification.
 * All geometry types are handled.
 * Empty and point geometries are returned unchanged.
 * Empty geometry components are deleted.
 * <p>
 * Note that in general D-P does not preserve topology -
 * e.g. polygons can be split, collapse to lines or disappear
 * holes can be created or disappear,
 * and lines can cross.
 * To simplify geometry while preserving topology use {@link TopologyPreservingSimplifier}.
 * (However, using D-P is significantly faster).
 * 
 * Creates a simplifier for a given geometry.
 * 
 * @constructor
 * @param {jsts.geom.Geometry}
 */
jsts.simplify.DouglasPeuckerSimplifier = function(
	inputGeom) {
  this.inputGeom = inputGeom;
  this.isEnsureValidTopology = true;
};

/**
 * @type {jsts.geom.Geometry} 
 */
jsts.simplify.DouglasPeuckerSimplifier.prototype.inputGeom = null;

/**
 * @type {double} 
 */
jsts.simplify.DouglasPeuckerSimplifier.prototype.distanceTolerance = null;

/**
 * @type {boolean} 
 */
jsts.simplify.DouglasPeuckerSimplifier.prototype.isEnsureValidTopology = null;

/**
 * Simplifies a geometry using a given tolerance.
 * @param {jsts.geom.Geometry}
 *          geom
 * @param {double}
 *          distanceTolerance
 * @return {jsts.geom.Geometry} 
 */
jsts.simplify.DouglasPeuckerSimplifier.simplify = function(
    geom, distanceTolerance) {
  var tss = new jsts.simplify.DouglasPeuckerSimplifier(geom);
  tss.setDistanceTolerance(distanceTolerance);
  return tss.getResultGeometry();
};

/**
 * Sets the distance tolerance for the simplification.
 * All vertices in the simplified geometry will be within this
 * distance of the original geometry.
 * The tolerance value must be non-negative.
 * @param {double}
 *          distanceTolerance 
 */
jsts.simplify.DouglasPeuckerSimplifier.prototype.setDistanceTolerance = function(
	distanceTolerance) {
  if (distanceTolerance < 0.0) {
  	throw "Tolerance must be non-negative";
  }
  this.distanceTolerance = distanceTolerance;
};

/**
 * Controls whether simplified polygons will be "fixed"
 * to have valid topology.
 * The caller may choose to disable this because:
 * <ul>
 * <li>valid topology is not required
 * <li>fixing topology is a relative expensive operation
 * <li>in some pathological cases the topology fixing operation may either fail or run for too long
 * </ul>
 * 
 * The default is to fix polygon topology.
 * 
 * @param {boolean}
 *          isEnsureValidTopology 
 */
jsts.simplify.DouglasPeuckerSimplifier.prototype.setEnsureValid = function(
	isEnsureValidTopology) {
  this.isEnsureValidTopology = isEnsureValidTopology;
};

/**
 * Gets the simplified geometry.
 * 
 * @return {jsts.geom.Geometry} 
 */
jsts.simplify.DouglasPeuckerSimplifier.prototype.getResultGeometry = function() {
  // empty input produces an empty result
  if (this.inputGeom.isEmpty()) {
    return this.inputGeom.clone();
  }
  return (new jsts.simplify.DPTransformer(this.distanceTolerance, this.isEnsureValidTopology)).transform(this.inputGeom);
};
/* ======================================================================
    jsts/operation/predicate/RectangleContains.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */
 
/**
 * Port source:
 * /jts/jts/java/src/com/vividsolutions/jts/operation/predicate/RectangleContains.java
 * Revision: 707
 */

(function() {

/**
 * Optimized implementation of the <tt>contains</tt> spatial predicate 
 * for cases where the first {@link Geometry} is a rectangle.
 * This class works for all input geometries, including
 * {@link GeometryCollection}s.
 * <p>
 * As a further optimization,
 * this class can be used to test 
 * many geometries against a single
 * rectangle in a slightly more efficient way.
 *
 * @version 1.7
 *
 * Create a new contains computer for two geometries.
 *
 * @param rectangle a rectangular geometry
 */
jsts.operation.predicate.RectangleContains = function(rectangle) {
    this.rectEnv = rectangle.getEnvelopeInternal();
}


  /**
   * Tests whether a rectangle contains a given geometry.
   * 
   * @param rectangle a rectangular Polygon
   * @param b a Geometry of any type
   * @return true if the geometries intersect
   */
jsts.operation.predicate.RectangleContains.contains = function(rectangle, b) {
    var rc = new jsts.operation.predicate.RectangleContains(rectangle);
    return rc.contains(b);
}

jsts.operation.predicate.RectangleContains.prototype.rectEnv = null;

jsts.operation.predicate.RectangleContains.prototype.contains = function(geom) {
    // the test geometry must be wholly contained in the rectangle envelope
    if (! this.rectEnv.contains(geom.getEnvelopeInternal()))
      return false;
    
    /**
     * Check that geom is not contained entirely in the rectangle boundary.
     * According to the somewhat odd spec of the SFS, if this
     * is the case the geometry is NOT contained.
     */
    if (this.isContainedInBoundary(geom))
      return false;
    return true;
}

jsts.operation.predicate.RectangleContains.prototype.isContainedInBoundary = function(geom) {
    // polygons can never be wholely contained in the boundary
    if (geom instanceof jsts.geom.Polygon) return false;
    if (geom instanceof jsts.geom.Point) return this.isPointContainedInBoundary(geom.getCoordinate());
    if (geom instanceof jsts.geom.LineString) return this.isLineStringContainedInBoundary(geom);

    for (var i = 0; i < geom.getNumGeometries(); i++) {
      var comp = geom.getGeometryN(i);
      if (! this.isContainedInBoundary(comp))
        return false;
    }
    return true;
}

  /**
   * Tests if a point is contained in the boundary of the target rectangle.
   * 
   * @param pt the point to test
   * @return true if the point is contained in the boundary
   */
jsts.operation.predicate.RectangleContains.prototype.isPointContainedInBoundary = function(pt) {
    /**
     * contains = false iff the point is properly contained in the rectangle.
     * 
     * This code assumes that the point lies in the rectangle envelope
     */ 
    return pt.x == this.rectEnv.getMinX() 
    		|| pt.x == this.rectEnv.getMaxX()
    		|| pt.y == this.rectEnv.getMinY()
    		|| pt.y == this.rectEnv.getMaxY();
}

  /**
   * Tests if a linestring is completely contained in the boundary of the target rectangle.
   * @param line the linestring to test
   * @return true if the linestring is contained in the boundary
   */
jsts.operation.predicate.RectangleContains.prototype.isLineStringContainedInBoundary = function(line) {
    var seq = line.getCoordinateSequence();  
    // TODO: reworked as CoordinateSequence does not use original API
    for (var i = 0; i < seq.length - 1; i++) {
      var p0 = seq[i];
      var p1 = seq[i + 1];

      if (! this.isLineSegmentContainedInBoundary(p0, p1))
        return false;
    }
    return true;
}

  /**
   * Tests if a line segment is contained in the boundary of the target rectangle.
   * @param p0 an endpoint of the segment
   * @param p1 an endpoint of the segment
   * @return true if the line segment is contained in the boundary
   */
jsts.operation.predicate.RectangleContains.prototype.isLineSegmentContainedInBoundary = function(p0, p1) {
    if (p0.equals(p1))
      return this.isPointContainedInBoundary(p0);

    // we already know that the segment is contained in the rectangle envelope
    if (p0.x == p1.x) {
      if (p0.x == this.rectEnv.getMinX() ||
          p0.x == this.rectEnv.getMaxX() )
        return true;
    }
    else if (p0.y == p1.y) {
      if (p0.y == this.rectEnv.getMinY() ||
          p0.y == this.rectEnv.getMaxY() )
        return true;
    }
    /**
     * Either
     *   both x and y values are different
     * or
     *   one of x and y are the same, but the other ordinate is not the same as a boundary ordinate
     *
     * In either case, the segment is not wholely in the boundary
     */
    return false;
}

})();


/* ======================================================================
    jsts/geomgraph/Depth.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * @requires jsts/geom/Location.js
   * @requires jsts/geomgraph/Position.js
   */

  var Location = jsts.geom.Location;
  var Position = jsts.geomgraph.Position;

  /**
   * A Depth object records the topological depth of the sides of an Edge for up
   * to two Geometries.
   *
   * @constructor
   */
  jsts.geomgraph.Depth = function() {
    // initialize depth array to a sentinel value
    this.depth = [[], []];
    for (var i = 0; i < 2; i++) {
      for (var j = 0; j < 3; j++) {
        this.depth[i][j] = jsts.geomgraph.Depth.NULL_VALUE;
      }
    }
  };

  jsts.geomgraph.Depth.NULL_VALUE = -1;

  jsts.geomgraph.Depth.depthAtLocation = function(location) {
    if (location === Location.EXTERIOR)
      return 0;
    if (location === Location.INTERIOR)
      return 1;
    return jsts.geomgraph.Depth.NULL_VALUE;
  };

  jsts.geomgraph.Depth.prototype.depth = null;


  jsts.geomgraph.Depth.prototype.getDepth = function(geomIndex, posIndex) {
    return this.depth[geomIndex][posIndex];
  };

  jsts.geomgraph.Depth.prototype.setDepth = function(geomIndex, posIndex,
      depthValue) {
    this.depth[geomIndex][posIndex] = depthValue;
  };

  jsts.geomgraph.Depth.prototype.getLocation = function(geomIndex, posIndex) {
    if (this.depth[geomIndex][posIndex] <= 0)
      return Location.EXTERIOR;
    return Location.INTERIOR;
  };

  jsts.geomgraph.Depth.prototype.add = function(geomIndex, posIndex, location) {
    if (location === Location.INTERIOR)
      this.depth[geomIndex][posIndex]++;
  };

  /**
   * A Depth object is null (has never been initialized) if all depths are null.
   */
  jsts.geomgraph.Depth.prototype.isNull = function() {
    if (arguments.length > 0) {
      return this.isNull2.apply(this, arguments);
    }

    for (var i = 0; i < 2; i++) {
      for (var j = 0; j < 3; j++) {
        if (this.depth[i][j] !== jsts.geomgraph.Depth.NULL_VALUE)
          return false;
      }
    }
    return true;
  };

  jsts.geomgraph.Depth.prototype.isNull2 = function(geomIndex) {
    if (arguments.length > 1) {
      return this.isNull3.apply(this, arguments);
    }

    return this.depth[geomIndex][1] == jsts.geomgraph.Depth.NULL_VALUE;
  };

  jsts.geomgraph.Depth.prototype.isNull3 = function(geomIndex, posIndex) {
    return this.depth[geomIndex][posIndex] == jsts.geomgraph.Depth.NULL_VALUE;
  };

  jsts.geomgraph.Depth.prototype.add = function(lbl) {
    for (var i = 0; i < 2; i++) {
      for (var j = 1; j < 3; j++) {
        var loc = lbl.getLocation(i, j);
        if (loc === Location.EXTERIOR || loc === Location.INTERIOR) {
          // initialize depth if it is null, otherwise add this location value
          if (this.isNull(i, j)) {
            this.depth[i][j] = jsts.geomgraph.Depth.depthAtLocation(loc);
          } else
            this.depth[i][j] += jsts.geomgraph.Depth.depthAtLocation(loc);
        }
      }
    }
  };

  jsts.geomgraph.Depth.prototype.getDelta = function(geomIndex) {
    return this.depth[geomIndex][Position.RIGHT] -
        this.depth[geomIndex][Position.LEFT];
  };

  /**
   * Normalize the depths for each geometry, if they are non-null. A normalized
   * depth has depth values in the set { 0, 1 }. Normalizing the depths involves
   * reducing the depths by the same amount so that at least one of them is 0.
   * If the remaining value is > 0, it is set to 1.
   */
  jsts.geomgraph.Depth.prototype.normalize = function() {
    for (var i = 0; i < 2; i++) {
      if (!this.isNull(i)) {
        var minDepth = this.depth[i][1];
        if (this.depth[i][2] < minDepth)
          minDepth = this.depth[i][2];

        if (minDepth < 0)
          minDepth = 0;
        for (var j = 1; j < 3; j++) {
          var newValue = 0;
          if (this.depth[i][j] > minDepth)
            newValue = 1;
          this.depth[i][j] = newValue;
        }
      }
    }
  };

  jsts.geomgraph.Depth.prototype.toString = function() {
    return 'A: ' + this.depth[0][1] + ',' + this.depth[0][2] + ' B: ' +
        this.depth[1][1] + ',' + this.depth[1][2];
  };

})();
/* ======================================================================
    jsts/algorithm/BoundaryNodeRule.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * An interface for rules which determine whether node points which are in
 * boundaries of {@link Lineal} geometry components are in the boundary of the
 * parent geometry collection. The SFS specifies a single kind of boundary node
 * rule, the {@link Mod2BoundaryNodeRule} rule. However, other kinds of Boundary
 * Node Rules are appropriate in specific situations (for instance, linear
 * network topology usually follows the {@link EndPointBoundaryNodeRule}.) Some
 * JTS operations allow the BoundaryNodeRule to be specified, and respect this
 * rule when computing the results of the operation.
 *
 * @see RelateOp
 * @see IsSimpleOp
 * @see PointLocator
 * @constructor
 */
jsts.algorithm.BoundaryNodeRule = function() {

};


/**
 * Tests whether a point that lies in <tt>boundaryCount</tt> geometry
 * component boundaries is considered to form part of the boundary of the parent
 * geometry.
 *
 * @param {int}
 *          boundaryCount the number of component boundaries that this point
 *          occurs in.
 * @return {boolean} true if points in this number of boundaries lie in the
 *         parent boundary.
 */
jsts.algorithm.BoundaryNodeRule.prototype.isInBoundary = function(boundaryCount) {
  throw new jsts.error.AbstractMethodInvocationError();
};


/**
 * A {@link BoundaryNodeRule} specifies that points are in the boundary of a
 * lineal geometry iff the point lies on the boundary of an odd number of
 * components. Under this rule {@link LinearRing}s and closed
 * {@link LineString}s have an empty boundary.
 * <p>
 * This is the rule specified by the <i>OGC SFS</i>, and is the default rule
 * used in JTS.
 */
jsts.algorithm.Mod2BoundaryNodeRule = function() {

};

jsts.algorithm.Mod2BoundaryNodeRule.prototype = new jsts.algorithm.BoundaryNodeRule();

jsts.algorithm.Mod2BoundaryNodeRule.prototype.isInBoundary = function(
    boundaryCount) {
  // the "Mod-2 Rule"
  return boundaryCount % 2 === 1;
};

jsts.algorithm.BoundaryNodeRule.MOD2_BOUNDARY_RULE = new jsts.algorithm.Mod2BoundaryNodeRule();
jsts.algorithm.BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE = jsts.algorithm.BoundaryNodeRule.MOD2_BOUNDARY_RULE;
/* ======================================================================
    jsts/operation/distance/GeometryLocation.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Represents the location of a point on a Geometry.
 * Maintains both the actual point location
 * (which may not be exact, if the point is not a vertex)
 * as well as information about the component
 * and segment index where the point occurs.
 * Locations inside area Geometrys will not have an associated segment index,
 * so in this case the segment index will have the sentinel value of
 * {@link #INSIDE_AREA}.
 */



/**
 * Constructs a GeometryLocation specifying a point on a geometry, as well as
 * the segment that the point is on (or {@link INSIDE_AREA} if the point is not
 * on a segment).
 *
 * @param {Geometry}
 *          component the component of the geometry containing the point.
 * @param {int}
 *          segIndex the segment index of the location, or INSIDE_AREA.
 * @param {Coordinate}
 *          pt the coordinate of the location.
 * @constructor
 */
jsts.operation.distance.GeometryLocation = function(component, segIndex, pt) {
  this.component = component;
  this.segIndex = segIndex;
  this.pt = pt;
};


/**
 * A special value of segmentIndex used for locations inside area geometries.
 * These locations are not located on a segment, and thus do not have an
 * associated segment index.
 *
 * @type {int}
 */
jsts.operation.distance.GeometryLocation.INSIDE_AREA = -1;


/**
 * @type {Geometry}
 */
jsts.operation.distance.GeometryLocation.prototype.component = null;


/**
 * @type {int}
 */
jsts.operation.distance.GeometryLocation.prototype.segIndex = null;


/**
 * @type {Coordinate}
 */
jsts.operation.distance.GeometryLocation.prototype.pt = null;


/**
 * @return {Geometry} the geometry component on (or in) which this location
 *         occurs.
 */
jsts.operation.distance.GeometryLocation.prototype.getGeometryComponent = function() {
  return this.component;
};


/**
 * Returns the segment index for this location. If the location is inside an
 * area, the index will have the value {@link INSIDE_AREA};
 *
 * @return {int} the segment index for the location, or INSIDE_AREA.
 */
jsts.operation.distance.GeometryLocation.prototype.getSegmentIndex = function() {
  return this.segIndex;
};


/**
 * @return {Coordinate} the {@link Coordinate} of this location.
 */
jsts.operation.distance.GeometryLocation.prototype.getCoordinate = function() {
  return this.pt;
};


/**
 * @return {boolean} whether this location represents a point inside an area
 *         geometry.
 */
jsts.operation.distance.GeometryLocation.prototype.isInsideArea = function() {
  return this.segIndex === jsts.operation.distance.GeometryLocation.INSIDE_AREA;
};
/* ======================================================================
    jsts/geom/util/PointExtracter.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @requires jsts/geom/GeometryFilter.js
 */



/**
 * Extracts all the 0-dimensional ({@link Point}) components from a
 * {@link Geometry}.
 *
 * Constructs a PointExtracterFilter with a list in which to store Points found.
 *
 * @extends {jsts.geom.GeometryFilter}
 * @see GeometryExtracter
 * @constructor
 */
jsts.geom.util.PointExtracter = function(pts) {
  this.pts = pts;
};

jsts.geom.util.PointExtracter.prototype = new jsts.geom.GeometryFilter();


/**
 * @private
 */
jsts.geom.util.PointExtracter.prototype.pts = null;


/**
 * Extracts the {@link Point} elements from a single {@link Geometry} and adds
 * them to the provided {@link List}.
 *
 * @param {Geometry}
 *          geom the geometry from which to extract.
 * @param {[]}
 *          list the list to add the extracted elements to.
 * @return {[]}
 */
jsts.geom.util.PointExtracter.getPoints = function(geom, list) {
  if (list === undefined) {
    list = [];
  }

  if (geom instanceof jsts.geom.Point) {
    list.push(geom);
  } else if (geom instanceof jsts.geom.GeometryCollection ||
      geom instanceof jsts.geom.MultiPoint ||
      geom instanceof jsts.geom.MultiLineString ||
      geom instanceof jsts.geom.MultiPolygon) {
    geom.apply(new jsts.geom.util.PointExtracter(list));
  }
  // skip non-Polygonal elemental geometries

  return list;
};

jsts.geom.util.PointExtracter.prototype.filter = function(geom) {
  if (geom instanceof jsts.geom.Point)
    this.pts.push(geom);
};
/* ======================================================================
    jsts/operation/relate/RelateNodeGraph.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * @requires jsts/geom/Location.js
   * @requires jsts/util/Assert.js
   */

  var Location = jsts.geom.Location;

  /**
   * Implements the simple graph of Nodes and EdgeEnd which is all that is
   * required to determine topological relationships between Geometries. Also
   * supports building a topological graph of a single Geometry, to allow
   * verification of valid topology.
   * <p>
   * It is <b>not</b> necessary to create a fully linked PlanarGraph to
   * determine relationships, since it is sufficient to know how the Geometries
   * interact locally around the nodes. In fact, this is not even feasible,
   * since it is not possible to compute exact intersection points, and hence
   * the topology around those nodes cannot be computed robustly. The only Nodes
   * that are created are for improper intersections; that is, nodes which occur
   * at existing vertices of the Geometries. Proper intersections (e.g. ones
   * which occur between the interior of line segments) have their topology
   * determined implicitly, without creating a Node object to represent them.
   *
   * @constructor
   */
  jsts.operation.relate.RelateNodeGraph = function() {
    this.nodes = new jsts.geomgraph.NodeMap(
        new jsts.operation.relate.RelateNodeFactory());
  };


  /**
   * @private
   */
  jsts.operation.relate.RelateNodeGraph.prototype.nodes = null;


  jsts.operation.relate.RelateNodeGraph.prototype.build = function(geomGraph) {
    // compute nodes for intersections between previously noded edges
    this.computeIntersectionNodes(geomGraph, 0);
    /**
     * Copy the labelling for the nodes in the parent Geometry. These override
     * any labels determined by intersections.
     */
    this.copyNodesAndLabels(geomGraph, 0);

    /**
     * Build EdgeEnds for all intersections.
     */
    var eeBuilder = new jsts.operation.relate.EdgeEndBuilder();
    var eeList = eeBuilder.computeEdgeEnds(geomGraph.getEdgeIterator());
    this.insertEdgeEnds(eeList);
  };


  /**
   * Insert nodes for all intersections on the edges of a Geometry. Label the
   * created nodes the same as the edge label if they do not already have a
   * label. This allows nodes created by either self-intersections or mutual
   * intersections to be labelled. Endpoint nodes will already be labelled from
   * when they were inserted.
   * <p>
   * Precondition: edge intersections have been computed.
   */
  jsts.operation.relate.RelateNodeGraph.prototype.computeIntersectionNodes = function(geomGraph,
      argIndex) {
    for (var edgeIt = geomGraph.getEdgeIterator(); edgeIt.hasNext();) {
      var e = edgeIt.next();
      var eLoc = e.getLabel().getLocation(argIndex);
      for (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext();) {
        var ei = eiIt.next();
        var n = this.nodes.addNode(ei.coord);
        if (eLoc === Location.BOUNDARY)
          n.setLabelBoundary(argIndex);
        else {
          if (n.getLabel().isNull(argIndex))
            n.setLabel(argIndex, Location.INTERIOR);
        }
      }
    }
  };


  /**
   * Copy all nodes from an arg geometry into this graph. The node label in the
   * arg geometry overrides any previously computed label for that argIndex.
   * (E.g. a node may be an intersection node with a computed label of BOUNDARY,
   * but in the original arg Geometry it is actually in the interior due to the
   * Boundary Determination Rule)
   */
  jsts.operation.relate.RelateNodeGraph.prototype.copyNodesAndLabels = function(geomGraph, argIndex) {
    for (var nodeIt = geomGraph.getNodeIterator(); nodeIt.hasNext();) {
      var graphNode = nodeIt.next();
      var newNode = this.nodes.addNode(graphNode.getCoordinate());
      newNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));
    }
  };

  jsts.operation.relate.RelateNodeGraph.prototype.insertEdgeEnds = function(ee) {
    for (var i = ee.iterator(); i.hasNext();) {
      var e = i.next();
      this.nodes.add(e);
    }
  };

  jsts.operation.relate.RelateNodeGraph.prototype.getNodeIterator = function() {
    return this.nodes.iterator();
  };

})();
/* ======================================================================
    jsts/geomgraph/index/SimpleSweepLineIntersector.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @constructor 
 */
jsts.geomgraph.index.SimpleSweepLineIntersector = function() {

};

jsts.geomgraph.index.SimpleSweepLineIntersector.prototype = new jsts.geomgraph.index.EdgeSetIntersector();

/**
 * @type {array} 
 */
jsts.geomgraph.index.SimpleSweepLineIntersector.prototype.events = [];

/**
 * @type {int} 
 */
jsts.geomgraph.index.SimpleSweepLineIntersector.prototype.nOverlaps = null;

/**
 * @param {javascript.util.List}
 *          edges
 * @param {SegmentIntersector}
 *          si
 * @param {boolean}
 *          testAllSegments 
 */
jsts.geomgraph.index.SimpleSweepLineIntersector.prototype.computeIntersections = function(
    edges, si, testAllSegments) {

  if (si instanceof javascript.util.List) {
    this.computeIntersections2.apply(this, arguments);
    return;
  }

  if (testAllSegments) {
    this.add(edges, null);
  } else {
    this.add(edges);
  }
  this.computeIntersections3(si);
};

/**
 * @param {javascript.util.List}
 *          edges0
 * @param {javascript.util.List}
 *          edges1
 * @param {SegmentIntersector}
 *          si 
 */
jsts.geomgraph.index.SimpleSweepLineIntersector.prototype.computeIntersections2 = function(
    edges0, edges1, si) {
  this.add(edges0, edges0);
  this.add(edges1, edges1);
  this.computeIntersections3(si);
};

/**
 * @param {Edge}
 *          edge
 * @param {Object}
 *          edgeSet 
 */
jsts.geomgraph.index.SimpleSweepLineIntersector.prototype.add = function(
    edge, edgeSet) {

  if (edge instanceof javascript.util.List) {
    this.add2.apply(this, arguments);
    return;
  }

  var pts = edge.getCoordinates();
  for (var i = 0; i < pts.length - 1; i++) {
    var ss = new jsts.geomgraph.index.SweepLineSegment(edge, i);
    var insertEvent = new jsts.geomgraph.index.SweepLineEvent(ss.getMinX(), ss, edgeSet);
    this.events.push(insertEvent);
    this.events.push(new jsts.geomgraph.index.SweepLineEvent(ss.getMaxX(), insertEvent));
  }
};

/**
 * @param {javascript.util.List}
 *          edges
 * @param {Object}
 *          edgeSet
 */
jsts.geomgraph.index.SimpleSweepLineIntersector.prototype.add2 = function(
    edges, edgeSet) {
  for (var i = edges.iterator(); i.hasNext(); ) {
    var edge = i.next();
    if (edgeSet) {
      this.add(edge, edgeSet);
    } else {
      // edge is its own group
      this.add(edge, edge);
    }
  }
};

/**
 * Because DELETE Events have a link to their corresponding INSERT event,
 * it is possible to compute exactly the range of events which must be
 * compared to a given INSERT event object.
 */
jsts.geomgraph.index.SimpleSweepLineIntersector.prototype.prepareEvents = function() {
  this.events.sort(function(a,b) {
    return a.compareTo(b);
  });

  // set DELETE event indexes
  for (var i = 0; i < this.events.length; i++) {
    var ev = this.events[i];
    if (ev.isDelete()) {
      ev.getInsertEvent().setDeleteEventIndex(i);
    }
  }
};

/**
 * @param {SegmentIntersector}
 *          si 
 */
jsts.geomgraph.index.SimpleSweepLineIntersector.prototype.computeIntersections3 = function(
    si) {
  this.nOverlaps = 0;
  this.prepareEvents();

  for (var i = 0; i < this.events.length; i++) {
    var ev = this.events[i];
    if (ev.isInsert()) {
      this.processOverlaps(i, ev.getDeleteEventIndex(), ev, si);
    }
  }
};

/**
 * @param {int}
 *          start
 * @param {int}
 *          end
 * @param {SweepLineEvent}
 *          ev0
 * @param {SegmentIntersector}
 *          si
 */
jsts.geomgraph.index.SimpleSweepLineIntersector.prototype.processOverlaps = function(
  start, end, ev0, si) {
  var ss0 = ev0.getObject();

  /**
   * Since we might need to test for self-intersections,
   * include current INSERT event object in list of event objects to test.
   * Last index can be skipped, because it must be a Delete event.
   */
  for (var i = start; i < end; i++) {
    var ev1 = this.events[i];
    if (ev1.isInsert()) {
      var ss1 = ev1.getObject();
      // don't compare edges in same group, if labels are present
      if (!ev0.isSameLabel(ev1)) {
        ss0.computeIntersections(ss1, si);
        this.nOverlaps++;
      }
    }
  }
}
/* ======================================================================
    jsts/triangulate/VoronoiDiagramBuilder.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
*/

/**
 * A utility class which creates Voronoi Diagrams
 * from collections of points.
 * The diagram is returned as a {@link GeometryCollection} of {@link Polygon}s,
 * clipped to the larger of a supplied envelope or to an envelope determined
 * by the input sites.
 *
 * @author Martin Davis
 *
 * @constructor
 */
jsts.triangulate.VoronoiDiagramBuilder = function() {
  this.siteCoords = null;
  this.tolerance = 0.0;
  this.subdiv = null;
  this.clipEnv = null;
  this.diagramEnv = null;
};

/**
 * Sets the sites of the builder. Will call correct setSites* based on arguments
 */
jsts.triangulate.VoronoiDiagramBuilder.prototype.setSites = function() {
  var arg = arguments[0];

  if (arg instanceof jsts.geom.Geometry ||
      arg instanceof jsts.geom.Coordinate || arg instanceof jsts.geom.Point ||
      arg instanceof jsts.geom.MultiPoint ||
      arg instanceof jsts.geom.LineString ||
      arg instanceof jsts.geom.MultiLineString ||
      arg instanceof jsts.geom.LinearRing || arg instanceof jsts.geom.Polygon ||
      arg instanceof jsts.geom.MultiPolygon) {
    this.setSitesByGeometry(arg);
  } else {
    this.setSitesByArray(arg);
  }
};

/**
 * Sets the sites (point or vertices) which will be diagrammed.
 * All vertices of the given geometry will be used as sites.
 *
 * @param {jsts.geom.Geometry}
 *          geom the geometry from which the sites will be extracted.
 */
jsts.triangulate.VoronoiDiagramBuilder.prototype.setSitesByGeometry = function(geom) {
  //remove any duplicate points (they will cause the triangulation to fail)
  this.siteCoords = jsts.triangulate.DelaunayTriangulationBuilder.extractUniqueCoordinates(geom);
};

/**
 * Sets the sites (point or vertices) which will be diagrammed
 * from a collection of {@link Coordinate}s.
 *
 * @param {jsts.geom.Coordinate[]}
 *          coords an array of Coordinates.
 */
jsts.triangulate.VoronoiDiagramBuilder.prototype.setSitesByArray = function(coords) {
  this.siteCoords = jsts.triangulate.DelaunayTriangulationBuilder.unique(coords);
};

/**
 * Sets the envelope to clip the diagram to.
 * The diagram will be clipped to the larger
 * of this envelope or an envelope surrounding the sites.
 *
 * @param {jsts.geom.Envelope}
 *          clipEnv the clip envelope.
 */
jsts.triangulate.VoronoiDiagramBuilder.prototype.setClipEnvelope = function(clipEnv) {
  this.clipEnv = clipEnv;
};

/**
 * Sets the snapping tolerance which will be used
 * to improved the robustness of the triangulation computation.
 * A tolerance of 0.0 specifies that no snapping will take place.
 *
 * @param {number}
 *          tolerance the tolerance distance to use.
 */
jsts.triangulate.VoronoiDiagramBuilder.prototype.setTolerance = function(tolerance)
{
  this.tolerance = tolerance;
};

jsts.triangulate.VoronoiDiagramBuilder.prototype.create = function() {
  if (this.subdiv !== null) {
    return;
  }

  var siteEnv, expandBy, vertices, triangulator;

  siteEnv = jsts.triangulate.DelaunayTriangulationBuilder.envelope(this.siteCoords);
  this.diagramEnv = siteEnv;

  // add a buffer around the final envelope
  expandBy = Math.max(this.diagramEnv.getWidth(), this.diagramEnv.getHeight());
  this.diagramEnv.expandBy(expandBy);

  if (this.clipEnv !== null) {
    this.diagramEnv.expandToInclude(this.clipEnv);
  }

  vertices = jsts.triangulate.DelaunayTriangulationBuilder.toVertices(this.siteCoords);
  this.subdiv = new jsts.triangulate.quadedge.QuadEdgeSubdivision(siteEnv, this.tolerance);
  triangulator = new jsts.triangulate.IncrementalDelaunayTriangulator(this.subdiv);
  triangulator.insertSites(vertices);
};

/**
 * Gets the {@link QuadEdgeSubdivision} which models the computed diagram.
 *
 * @return {jsts.triangulate.quadedge.QuadEdgeSubdivision}
 *          the subdivision containing the triangulation.
 */
jsts.triangulate.VoronoiDiagramBuilder.prototype.getSubdivision = function() {
  this.create();
  return this.subdiv;
};

/**
 * Gets the faces of the computed diagram as a {@link GeometryCollection}
 * of {@link Polygon}s, clipped as specified.
 *
 * @param {jsts.geom.GeometryFactory}
 *          geomFact the geometry factory to use to create the output.
 * @return {jsts.geom.GeometryCollection}
 *          the faces of the diagram.
 */
jsts.triangulate.VoronoiDiagramBuilder.prototype.getDiagram = function(geomFact) {
  this.create();
  var polys = this.subdiv.getVoronoiDiagram(geomFact);

  // clip polys to diagramEnv
  return this.clipGeometryCollection(polys, this.diagramEnv);
};

jsts.triangulate.VoronoiDiagramBuilder.prototype.clipGeometryCollection = function(geom, clipEnv) {
  var clipPoly, clipped, i, il, g, result;

  clipPoly = geom.getFactory().toGeometry(clipEnv);

  clipped = [];
  i = 0, il = geom.getNumGeometries();

  for (i; i < il; i++) {
    g = geom.getGeometryN(i);
    result = null;
    // don't clip unless necessary
    if (clipEnv.contains(g.getEnvelopeInternal())) {
        result = g;
    }
    else if (clipEnv.intersects(g.getEnvelopeInternal())) {
      result = clipPoly.intersection(g);
      // keep vertex key info
      //result.setUserData(g.getUserData());
    }

    if (result !== null && !result.isEmpty()) {
      clipped.push(result);
    }
  }

  return geom.getFactory().createGeometryCollection(clipped);
};
/* ======================================================================
    jsts/operation/valid/IndexedNestedRingTester.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 *
 * Tests whether any of a set of {@link LinearRing}s are nested inside another
 * ring in the set, using a spatial index to speed up the comparisons.
 *
 * @version 1.7
 */

jsts.operation.valid.IndexedNestedRingTester = function(graph) {
  this.graph = graph;
  this.rings = new javascript.util.ArrayList();
  this.totalEnv = new jsts.geom.Envelope();
  this.index = null;
  this.nestedPt = null;
};

jsts.operation.valid.IndexedNestedRingTester.prototype.getNestedPoint = function() {
  return this.nestedPt;
};

jsts.operation.valid.IndexedNestedRingTester.prototype.add = function(ring) {
  this.rings.add(ring);
  this.totalEnv.expandToInclude(ring.getEnvelopeInternal());
};

jsts.operation.valid.IndexedNestedRingTester.prototype.isNonNested = function() {
  this.buildIndex();
  for (var i = 0; i < this.rings.size(); i++) {
    var innerRing = this.rings.get(i);
    var innerRingPts = innerRing.getCoordinates();
    var results = this.index.query(innerRing.getEnvelopeInternal());

    for (var j = 0; j < results.length; j++) {
      var searchRing = results[j];
      var searchRingPts = searchRing.getCoordinates();

      if (innerRing == searchRing) {
        continue;
      }

      if (!innerRing.getEnvelopeInternal().intersects(
          searchRing.getEnvelopeInternal())) {
        continue;
      }

      var innerRingPt = jsts.operation.valid.IsValidOp.findPtNotNode(
          innerRingPts, searchRing, this.graph);

      /**
       *
       * If no non-node pts can be found, this means that the searchRing touches
       * ALL of the innerRing vertices. This indicates an invalid polygon, since
       * either the two holes create a disconnected interior, or they touch in
       * an infinite number of points (i.e. along a line segment). Both of these
       * cases are caught by other tests, so it is safe to simply skip this
       * situation here.
       */

      if (innerRingPt == null) {
        continue;
      }

      var isInside = jsts.algorithm.CGAlgorithms.isPointInRing(innerRingPt,
          searchRingPts);

      if (isInside) {
        this.nestedPt = innerRingPt;
        return false;
      }
    }
  }
  return true;
};

jsts.operation.valid.IndexedNestedRingTester.prototype.buildIndex = function() {
  this.index = new jsts.index.strtree.STRtree();

  for (var i = 0; i < this.rings.size(); i++) {
    var ring = this.rings.get(i);
    var env = ring.getEnvelopeInternal();
    this.index.insert(env, ring);
  }
};
/* ======================================================================
    jsts/geomgraph/index/MonotoneChain.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @param {MonotoneChainEdge}
 *          mce
 * @param {int}
 *          chainIndex 
 */
jsts.geomgraph.index.MonotoneChain = function(mce, chainIndex) {
  this.mce = mce;
  this.chainIndex = chainIndex;
};

/**
 * @type {MonotoneChainEdge} 
 */
jsts.geomgraph.index.MonotoneChain.prototype.mce = null;

/**
 * @type {int} 
 */
jsts.geomgraph.index.MonotoneChain.prototype.chainIndex = null;

jsts.geomgraph.index.MonotoneChain.prototype.computeIntersections = function(
    mc, si) {
  this.mce.computeIntersectsForChain(this.chainIndex, mc.mce, mc.chainIndex, si);
};
/* ======================================================================
    jsts/noding/SegmentNode.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Port source: /jts/jts/java/src/com/vividsolutions/jts/noding/SegmentNode.java
 * Revision: 478
 */

/**
 * Represents an intersection point between two {@link SegmentString}s.
 *
 * @constructor
 */
jsts.noding.SegmentNode = function(segString,  coord,  segmentIndex,  segmentOctant) {
  this.segString = segString;
  this.coord = new jsts.geom.Coordinate(coord);
  this.segmentIndex = segmentIndex;
  this.segmentOctant = segmentOctant;
  this._isInterior = ! coord.equals2D(segString.getCoordinate(segmentIndex));
};


/**
 * @type {NodedSegmentString}
 * @private
 */
jsts.noding.SegmentNode.prototype.segString = null;
jsts.noding.SegmentNode.prototype.coord = null;   // the point of intersection
jsts.noding.SegmentNode.prototype.segmentIndex = null;   // the index of the containing line segment in the parent edge
jsts.noding.SegmentNode.prototype.segmentOctant = null;
jsts.noding.SegmentNode.prototype._isInterior = null;

/**
 * Gets the {@link Coordinate} giving the location of this node.
 *
 * @return the coordinate of the node.
 */
jsts.noding.SegmentNode.prototype.getCoordinate = function() {
  return this.coord;
};


jsts.noding.SegmentNode.prototype.isInterior = function() { return this._isInterior; };

jsts.noding.SegmentNode.prototype.isEndPoint = function(maxSegmentIndex)  {
  if (this.segmentIndex === 0 && ! this._isInterior) return true;
  if (this.segmentIndex === this.maxSegmentIndex) return true;
  return false;
};


/**
   * @return -1 this SegmentNode is located before the argument location.
   * @return 0 this SegmentNode is at the argument location.
   * @return 1 this SegmentNode is located after the argument location.
   */
jsts.noding.SegmentNode.prototype.compareTo = function(obj)  {
  var other = obj;

  if (this.segmentIndex < other.segmentIndex) return -1;
  if (this.segmentIndex > other.segmentIndex) return 1;

  if (this.coord.equals2D(other.coord)) return 0;

  return jsts.noding.SegmentPointComparator.compare(this.segmentOctant, this.coord, other.coord);
};

/* ======================================================================
    jsts/io/GeoJSONWriter.js
   ====================================================================== */

/* Copyright (c) 2011, 2012 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {
    /**
     * Writes the GeoJSON representation of a {@link Geometry}. The
     * The GeoJSON format is defined <A
     * HREF="http://geojson.org/geojson-spec.html">here</A>.
     * <p>
     * The <code>GeoJSONWriter</code> outputs coordinates rounded to the precision
     * model. Only the maximum number of decimal places necessary to represent the
     * ordinates to the required precision will be output.
     * <p>
     *
     * @see WKTReader
     * @constructor
     */
    jsts.io.GeoJSONWriter = function() {
      this.parser = new jsts.io.GeoJSONParser(this.geometryFactory);
    };

    /**
     * Converts a <code>Geometry</code> to its GeoJSON representation.
     *
     * @param {jsts.geom.Geometry}
     *          geometry a <code>Geometry</code> to process.
     * @return {Object} The GeoJSON representation of the Geometry.
     */

    jsts.io.GeoJSONWriter.prototype.write = function(geometry) {
      var geoJson = this.parser.write(geometry);

      return geoJson;
    };
})();
/* ======================================================================
    jsts/io/OpenLayersParser.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

jsts.io.OpenLayersParser = function(geometryFactory) {
  this.geometryFactory = geometryFactory || new jsts.geom.GeometryFactory();
};

/**
 * @param geometry
 *          {OpenLayers.Geometry}
 * @return {jsts.geom.Geometry}
 */
jsts.io.OpenLayersParser.prototype.read = function(geometry) {
  if (geometry.CLASS_NAME === 'OpenLayers.Geometry.Point') {
    return this.convertFromPoint(geometry);
  } else if (geometry.CLASS_NAME === 'OpenLayers.Geometry.LineString') {
    return this.convertFromLineString(geometry);
  } else if (geometry.CLASS_NAME === 'OpenLayers.Geometry.LinearRing') {
    return this.convertFromLinearRing(geometry);
  } else if (geometry.CLASS_NAME === 'OpenLayers.Geometry.Polygon') {
    return this.convertFromPolygon(geometry);
  } else if (geometry.CLASS_NAME === 'OpenLayers.Geometry.MultiPoint') {
    return this.convertFromMultiPoint(geometry);
  } else if (geometry.CLASS_NAME === 'OpenLayers.Geometry.MultiLineString') {
    return this.convertFromMultiLineString(geometry);
  } else if (geometry.CLASS_NAME === 'OpenLayers.Geometry.MultiPolygon') {
    return this.convertFromMultiPolygon(geometry);
  } else if (geometry.CLASS_NAME === 'OpenLayers.Geometry.Collection') {
    return this.convertFromCollection(geometry);
  }
};

jsts.io.OpenLayersParser.prototype.convertFromPoint = function(point) {
  return this.geometryFactory.createPoint(new jsts.geom.Coordinate(point.x,
      point.y));
};

jsts.io.OpenLayersParser.prototype.convertFromLineString = function(lineString) {
  var i;
  var coordinates = [];

  for (i = 0; i < lineString.components.length; i++) {
    coordinates.push(new jsts.geom.Coordinate(lineString.components[i].x,
        lineString.components[i].y));
  }

  return this.geometryFactory.createLineString(coordinates);
};

jsts.io.OpenLayersParser.prototype.convertFromLinearRing = function(linearRing) {
  var i;
  var coordinates = [];

  for (i = 0; i < linearRing.components.length; i++) {
    coordinates.push(new jsts.geom.Coordinate(linearRing.components[i].x,
        linearRing.components[i].y));
  }

  return this.geometryFactory.createLinearRing(coordinates);
};

jsts.io.OpenLayersParser.prototype.convertFromPolygon = function(polygon) {
  var i;
  var shell = null;
  var holes = [];

  for (i = 0; i < polygon.components.length; i++) {
    var linearRing = this.convertFromLinearRing(polygon.components[i]);

    if (i === 0) {
      shell = linearRing;
    } else {
      holes.push(linearRing);
    }
  }

  return this.geometryFactory.createPolygon(shell, holes);
};

jsts.io.OpenLayersParser.prototype.convertFromMultiPoint = function(multiPoint) {
  var i;
  var points = [];

  for (i = 0; i < multiPoint.components.length; i++) {
    points.push(this.convertFromPoint(multiPoint.components[i]));
  }

  return this.geometryFactory.createMultiPoint(points);
};

jsts.io.OpenLayersParser.prototype.convertFromMultiLineString = function(
    multiLineString) {
  var i;
  var lineStrings = [];

  for (i = 0; i < multiLineString.components.length; i++) {
    lineStrings.push(this.convertFromLineString(multiLineString.components[i]));
  }

  return this.geometryFactory.createMultiLineString(lineStrings);
};

jsts.io.OpenLayersParser.prototype.convertFromMultiPolygon = function(
    multiPolygon) {
  var i;
  var polygons = [];

  for (i = 0; i < multiPolygon.components.length; i++) {
    polygons.push(this.convertFromPolygon(multiPolygon.components[i]));
  }

  return this.geometryFactory.createMultiPolygon(polygons);
};

jsts.io.OpenLayersParser.prototype.convertFromCollection = function(collection) {
  var i;
  var geometries = [];

  for (i = 0; i < collection.components.length; i++) {
    geometries.push(this.read(collection.components[i]));
  }

  return this.geometryFactory.createGeometryCollection(geometries);
};

/**
 * @param geometry
 *          {jsts.geom.Geometry}
 * @return {OpenLayers.Geometry}
 */
jsts.io.OpenLayersParser.prototype.write = function(geometry) {
  if (geometry.CLASS_NAME === 'jsts.geom.Point') {
    return this.convertToPoint(geometry.coordinate);
  } else if (geometry.CLASS_NAME === 'jsts.geom.LineString') {
    return this.convertToLineString(geometry);
  } else if (geometry.CLASS_NAME === 'jsts.geom.LinearRing') {
    return this.convertToLinearRing(geometry);
  } else if (geometry.CLASS_NAME === 'jsts.geom.Polygon') {
    return this.convertToPolygon(geometry);
  } else if (geometry.CLASS_NAME === 'jsts.geom.MultiPoint') {
    return this.convertToMultiPoint(geometry);
  } else if (geometry.CLASS_NAME === 'jsts.geom.MultiLineString') {
    return this.convertToMultiLineString(geometry);
  } else if (geometry.CLASS_NAME === 'jsts.geom.MultiPolygon') {
    return this.convertToMultiPolygon(geometry);
  } else if (geometry.CLASS_NAME === 'jsts.geom.GeometryCollection') {
    return this.convertToCollection(geometry);
  }
};

jsts.io.OpenLayersParser.prototype.convertToPoint = function(coordinate) {
  return new OpenLayers.Geometry.Point(coordinate.x, coordinate.y);
};

jsts.io.OpenLayersParser.prototype.convertToLineString = function(lineString) {
  var i;
  var points = [];

  for (i = 0; i < lineString.points.length; i++) {
    var coordinate = lineString.points[i];
    points.push(this.convertToPoint(coordinate));
  }

  return new OpenLayers.Geometry.LineString(points);
};

jsts.io.OpenLayersParser.prototype.convertToLinearRing = function(linearRing) {
  var i;
  var points = [];

  for (i = 0; i < linearRing.points.length; i++) {
    var coordinate = linearRing.points[i];
    points.push(this.convertToPoint(coordinate));
  }

  return new OpenLayers.Geometry.LinearRing(points);
};

jsts.io.OpenLayersParser.prototype.convertToPolygon = function(polygon) {
  var i;
  var rings = [];

  rings.push(this.convertToLinearRing(polygon.shell));

  for (i = 0; i < polygon.holes.length; i++) {
    var ring = polygon.holes[i];
    rings.push(this.convertToLinearRing(ring));
  }

  return new OpenLayers.Geometry.Polygon(rings);
};

jsts.io.OpenLayersParser.prototype.convertToMultiPoint = function(multiPoint) {
  var i;
  var points = [];

  for (i = 0; i < multiPoint.geometries.length; i++) {
    var coordinate = multiPoint.geometries[i].coordinate;
    points.push(new OpenLayers.Geometry.Point(coordinate.x, coordinate.y));
  }

  return new OpenLayers.Geometry.MultiPoint(points);
};

jsts.io.OpenLayersParser.prototype.convertToMultiLineString = function(
    multiLineString) {
  var i;
  var lineStrings = [];

  for (i = 0; i < multiLineString.geometries.length; i++) {
    lineStrings.push(this.convertToLineString(multiLineString.geometries[i]));
  }

  return new OpenLayers.Geometry.MultiLineString(lineStrings);
};

jsts.io.OpenLayersParser.prototype.convertToMultiPolygon = function(
    multiPolygon) {
  var i;
  var polygons = [];

  for (i = 0; i < multiPolygon.geometries.length; i++) {
    polygons.push(this.convertToPolygon(multiPolygon.geometries[i]));
  }

  return new OpenLayers.Geometry.MultiPolygon(polygons);
};

jsts.io.OpenLayersParser.prototype.convertToCollection = function(
    geometryCollection) {
  var i;
  var geometries = [];

  for (i = 0; i < geometryCollection.geometries.length; i++) {
    var geometry = geometryCollection.geometries[i];
    var geometryOpenLayers = this.write(geometry);

    geometries.push(geometryOpenLayers);
  }

  return new OpenLayers.Geometry.Collection(geometries);
};
/* ======================================================================
    jsts/index/quadtree/Quadtree.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
*/



/**
 * A Quadtree is a spatial index structure for efficient querying of 2D
 * rectangles. If other kinds of spatial objects need to be indexed they can be
 * represented by their envelopes
 * <p>
 * The quadtree structure is used to provide a primary filter for range
 * rectangle queries. The query() method returns a list of all objects which
 * <i>may</i> intersect the query rectangle. Note that it may return objects
 * which do not in fact intersect. A secondary filter is required to test for
 * exact intersection. Of course, this secondary filter may consist of other
 * tests besides intersection, such as testing other kinds of spatial
 * relationships.
 *
 * <p>
 * This implementation does not require specifying the extent of the inserted
 * items beforehand. It will automatically expand to accomodate any extent of
 * dataset.
 * <p>
 * This data structure is also known as an <i>MX-CIF quadtree</i> following the
 * usage of Samet and others.
 *
 * @constructor
 */
jsts.index.quadtree.Quadtree = function() {
  this.root = new jsts.index.quadtree.Root();

  /**
   * minExtent is the minimum envelope extent of all items inserted into the
   * tree so far. It is used as a heuristic value to construct non-zero
   * envelopes for features with zero X and/or Y extent. Start with a non-zero
   * extent, in case the first feature inserted has a zero extent in both
   * directions. This value may be non-optimal, but only one feature will be
   * inserted with this value.
   */
  this.minExtent = 1.0;
};

/**
 * Ensure that the envelope for the inserted item has non-zero extents. Use the
 * current minExtent to pad the envelope, if necessary
 */


/**
 * Ensures an extent is not zero.
 *
 * @param {jsts.geom.Envelope}
 *          itemEnv The envelope to check.
 * @param {Number}
 *          minExtent the minimum width/height to expand the extent with if it
 *          is zero.
 * @return {jsts.geom.Envelope} A valid extent.
 */
jsts.index.quadtree.Quadtree.ensureExtent = function(itemEnv, minExtent) {
  var minx, maxx, miny, maxy;

  minx = itemEnv.getMinX();
  maxx = itemEnv.getMaxX();
  miny = itemEnv.getMinY();
  maxy = itemEnv.getMaxY();

  // has a non-zero extent
  if (minx !== maxx && miny !== maxy) {
    return itemEnv;
  }

  // pad one or both extents
  if (minx === maxx) {
    minx = minx - (minExtent / 2.0);
    maxx = minx + (minExtent / 2.0);
  }

  if (miny === maxy) {
    miny = miny - (minExtent / 2.0);
    maxy = miny + (minExtent / 2.0);
  }

  return new jsts.geom.Envelope(minx, maxx, miny, maxy);
};


/**
 * Returns the depth of the tree.
 *
 * @return {Number} the depth.
 */
jsts.index.quadtree.Quadtree.prototype.depth = function() {
  return this.root.depth();
};


/**
 * Returns the number of items in the tree.
 *
 * @return {Number} the number of items in the tree.
 */
jsts.index.quadtree.Quadtree.prototype.size = function() {
  return this.root.size();
};


/**
 * Inserts an item to the tree
 *
 * @param {jsts.geom.Envelope}
 *          itemEnv The envelope.
 * @param {Object}
 *          item The item.
 */
jsts.index.quadtree.Quadtree.prototype.insert = function(itemEnv, item) {
  this.collectStats(itemEnv);
  var insertEnv = jsts.index.quadtree.Quadtree.ensureExtent(itemEnv,
      this.minExtent);
  this.root.insert(insertEnv, item);
};


/**
 * Removes a single item from the tree
 *
 * @param {jsts.geom.Envelope}
 *          itemEnv the envelope of the item to be removed.
 * @param {Object}
 *          item the item to remove.
 * @return {Boolean} <code>true</true> if the item was found (and removed).
 */
jsts.index.quadtree.Quadtree.prototype.remove = function(itemEnv, item) {
  var posEnv = jsts.index.quadtree.Quadtree.ensureExtent(itemEnv,
      this.minExtent);
  return this.root.remove(posEnv, item);
};


/**
 * Querys the quadtree.
 *
 * Calls appropriate function depending on arguments
 */
jsts.index.quadtree.Quadtree.prototype.query = function() {
  if (arguments.length === 1) {
    return jsts.index.quadtree.Quadtree.prototype.queryByEnvelope.apply(this,
        arguments);
  } else {
    jsts.index.quadtree.Quadtree.prototype.queryWithVisitor.apply(this,
        arguments);
  }
};


/**
 * Queries the tree and returns items which may lie in the given search
 * envelope. Precisely, the items that are returned are all items in the tree
 * whose envelope <b>may</b> intersect the search Envelope. Note that some
 * items with non-intersecting envelopes may be returned as well; the client is
 * responsible for filtering these out. In most situations there will be many
 * items in the tree which do not intersect the search envelope and which are
 * not returned - thus providing improved performance over a simple linear scan.
 *
 * @param {jsts.geom.Envelope}
 *          searchEnv the envelope of the desired query area.
 * @return {Array} an array of items which may intersect the search envelope.
 */
jsts.index.quadtree.Quadtree.prototype.queryByEnvelope = function(searchEnv) {
  var visitor = new jsts.index.ArrayListVisitor();
  this.query(searchEnv, visitor);

  return visitor.getItems();
};


/**
 * Queries the tree and visits items which may lie in the given search envelope.
 * Precisely, the items that are visited are all items in the tree whose
 * envelope <b>may</b> intersect the search Envelope. Note that some items with
 * non-intersecting envelopes may be visited as well; the client is responsible
 * for filtering these out. In most situations there will be many items in the
 * tree which do not intersect the search envelope and which are not visited -
 * thus providing improved performance over a simple linear scan.
 *
 * @param {jsts.geom.Envelope}
 *          searchEnv the envelope of the desired query area.
 * @param {jsts.index.Visitor}
 *          visitor a visitor object which is passed the visited items.
 */
jsts.index.quadtree.Quadtree.prototype.queryWithVisitor = function(searchEnv,
    visitor) {
  this.root.visit(searchEnv, visitor);
};


/**
 * Returns an array of all items in the quadtree.
 *
 * @return {Array} An array of all items in the quadtree.
 */
jsts.index.quadtree.Quadtree.prototype.queryAll = function() {
  var foundItems = [];
  foundItems = this.root.addAllItems(foundItems);
  return foundItems;
};


/**
 * Checks wheter a width and height of an envelope is above zero and sets
 * minExtent if the widht or height is less than the current min extent
 *
 * @param {jsts.geom.Envelope}
 *          itemEnv The envelope.
 */
jsts.index.quadtree.Quadtree.prototype.collectStats = function(itemEnv) {
  var delX = itemEnv.getWidth();
  if (delX < this.minExtent && delX > 0.0) {
    this.minExtent = delX;
  }

  var delY = itemEnv.getHeight();
  if (delY < this.minExtent && delY > 0.0) {
    this.minExtent = delY;
  }
};
/* ======================================================================
    jsts/operation/relate/RelateNodeFactory.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * Used by the {@link NodeMap} in a {@link RelateNodeGraph} to create
 * {@link RelateNode}s.
 *
 * @augments {jsts.geomgraph.NodeFactory}
 * @constructor
 */
jsts.operation.relate.RelateNodeFactory = function() {

};

jsts.operation.relate.RelateNodeFactory.prototype = new jsts.geomgraph.NodeFactory();

jsts.operation.relate.RelateNodeFactory.prototype.createNode = function(coord) {
  return new jsts.operation.relate.RelateNode(coord,
      new jsts.operation.relate.EdgeEndBundleStar());
};
/* ======================================================================
    jsts/index/quadtree/Key.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * A Key is a unique identifier for a node in a quadtree. It contains a
 * lower-left point and a level number. The level number is the power of two for
 * the size of the node envelope.
 *
 * @param {jsts.geom.Envelope}
 *          itemEnv the envelope of the key.
 *
 * @constructor
 */
jsts.index.quadtree.Key = function(itemEnv) {
  // the fields which make up the key
  this.pt = new jsts.geom.Coordinate();
  this.level = 0;
  // auxiliary data which is derived from the key for use in computation
  this.env = null;

  this.computeKey(itemEnv);
};


/**
 * Computes the quad-level for specified envelope
 *
 * @param {jsts.geom.Envelope}
 *          env the envelope to calculate level for.
 * @return {Number} The calculated level.
 */
jsts.index.quadtree.Key.computeQuadLevel = function(env) {
  var dx, dy, dMax, level;

  dx = env.getWidth();
  dy = env.getHeight();
  dMax = dx > dy ? dx : dy;
  level = jsts.index.DoubleBits.exponent(dMax) + 1;
  return level;
};


/**
 * Gets the point of this key.
 *
 * @return {jsts.geom.Coordinate} The point.
 */
jsts.index.quadtree.Key.prototype.getPoint = function() {
  return this.pt;
};


/**
 * Gets the level of this key
 *
 * @return {Number} The level.
 */
jsts.index.quadtree.Key.prototype.getLevel = function() {
  return this.level;
};


/**
 * Gets the envelope of this key
 *
 * @return {jsts.geom.Envelope} The envelope.
 */
jsts.index.quadtree.Key.prototype.getEnvelope = function() {
  return this.env;
};


/**
 * Gets the centre of this key
 *
 * @return {jsts.geom.Coordinate} the center-point.
 */
jsts.index.quadtree.Key.prototype.getCentre = function() {
  var x, y;
  x = (this.env.getMinX() + this.env.getMaxX()) / 2;
  y = (this.env.getMinY() + this.env.getMaxY()) / 2;
  return new jsts.geom.Coordinate(x, y);
};


/**
 * Will call appropriate computeKey* method depending on arguments.
 */
jsts.index.quadtree.Key.prototype.computeKey = function() {
  if (arguments[0] instanceof jsts.geom.Envelope) {
    this.computeKeyFromEnvelope(arguments[0]);
  } else {
    this.computeKeyFromLevel(arguments[0], arguments[1]);
  }
};


/**
 * Computes the key from specified envlope.
 *
 * @param {jsts.geom.Envelope}
 *          env the envelope.
 */
jsts.index.quadtree.Key.prototype.computeKeyFromEnvelope = function(env) {
  this.level = jsts.index.quadtree.Key.computeQuadLevel(env);
  this.env = new jsts.geom.Envelope();
  this.computeKey(this.level, env);
  while (!this.env.contains(env)) {
    this.level += 1;
    this.computeKey(this.level, env);
  }
};


/**
 * Computes a key from a level and an envelope
 *
 * @param {Number}
 *          level the level.
 * @param {jsts.geom.Envelope}
 *          env the envelope.
 */
jsts.index.quadtree.Key.prototype.computeKeyFromLevel = function(level, env) {
  var quadSize = jsts.index.DoubleBits.powerOf2(level);
  this.pt.x = Math.floor(env.getMinX() / quadSize) * quadSize;
  this.pt.y = Math.floor(env.getMinY() / quadSize) * quadSize;
  this.env.init(this.pt.x, this.pt.x + quadSize, this.pt.y, this.pt.y +
      quadSize);
};
/* ======================================================================
    jsts/geom/CoordinateArrays.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * @constructor
 */
jsts.geom.CoordinateArrays = function() {
  throw new jsts.error.AbstractMethodInvocationError();
};

jsts.geom.CoordinateArrays.copyDeep = function () {
    if (arguments.length === 1) {
        return jsts.geom.CoordinateArrays.copyDeep1(arguments[0]);
    } else if (arguments.length === 5) {
        jsts.geom.CoordinateArrays.copyDeep2(
            arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);
    }
};

/**
 * Creates a deep copy of the argument {@link Coordinate} array.
 *
 * @param {jsts.geom.Coordinate[]} coordinates an array of Coordinates
 * @return {jsts.geom.Coordinate[]} a deep copy of the input
 */
jsts.geom.CoordinateArrays.copyDeep1 = function (coordinates) {
    var copy = [];
    for (var i = 0; i < coordinates.length; i++) {
        copy[i] = new jsts.geom.Coordinate(coordinates[i]);
    }
    return copy;
};

/**
 * Creates a deep copy of a given section of a source {@link Coordinate} array
 * into a destination Coordinate array.
 * The destination array must be an appropriate size to receive
 * the copied coordinates.
 *
 * @param {jsts.geom.Coordinate[]} src an array of Coordinates
 * @param {number} srcStart the index to start copying from
 * @param {jsts.geom.Coordinate[]} dest the
 * @param {number} destStart the destination index to start copying to
 * @param {number} length the number of items to copy
 */
jsts.geom.CoordinateArrays.copyDeep2 = function (src, srcStart, dest, destStart, length) {
    for (var i = 0; i < length; i++) {
        dest[destStart + i] = new jsts.geom.Coordinate(src[srcStart + i]);
    }
};

/**
 * If the coordinate array argument has repeated points, constructs a new array
 * containing no repeated points. Otherwise, returns the argument.
 *
 * @return {Coordinate[]}
 * @see #hasRepeatedPoints(Coordinate[])
 */
jsts.geom.CoordinateArrays.removeRepeatedPoints = function(coord) {
  var coordList;
  if (!this.hasRepeatedPoints(coord)) {
    return coord;
  }
  coordList = new jsts.geom.CoordinateList(coord, false);
  return coordList.toCoordinateArray();
};


/**
 * Returns whether #equals returns true for any two consecutive Coordinates in
 * the given array.
 *
 * @param {Coordinate[]}
 *          coord
 * @return {boolean}
 */
jsts.geom.CoordinateArrays.hasRepeatedPoints = function(coord) {
  var i;
  for (i = 1; i < coord.length; i++) {
    if (coord[i - 1].equals(coord[i])) {
      return true;
    }
  }
  return false;
};

/**
 * Finds a point in a list of points which is not contained in another list of points
 * @param testPts the {@link Coordinate} s to test.
 * @param pts an array of {@link Coordinate} s to test the input points against.
 * @return a {@link Coordinate} from <code>testPts</code> which is not in <code>pts</code>, '
 * or <code>null.</code>
 */
jsts.geom.CoordinateArrays.ptNotInList = function(testPts, pts) {
  for (var i = 0; i < testPts.length; i++) {
    var testPt = testPts[i];
    if (jsts.geom.CoordinateArrays.indexOf(testPt, pts) < 0)
        return testPt;
  }
  return null;
};

/**
 * Determines which orientation of the {@link Coordinate} array is (overall)
 * increasing. In other words, determines which end of the array is "smaller"
 * (using the standard ordering on {@link Coordinate}). Returns an integer
 * indicating the increasing direction. If the sequence is a palindrome, it is
 * defined to be oriented in a positive direction.
 *
 * @param pts
 *          the array of Coordinates to test.
 * @return <code>1</code> if the array is smaller at the start or is a
 *         palindrome, <code>-1</code> if smaller at the end.
 */
jsts.geom.CoordinateArrays.increasingDirection = function(pts) {
  for (var i = 0; i < parseInt(pts.length / 2); i++) {
    var j = pts.length - 1 - i;
    // skip equal points on both ends
    var comp = pts[i].compareTo(pts[j]);
    if (comp != 0)
      return comp;
  }
  // array must be a palindrome - defined to be in positive direction
  return 1;
};

/**
 * Returns the minimum coordinate, using the usual lexicographic comparison.
 *
 * @param coordinates
 *          the array to search.
 * @return the minimum coordinate in the array, found using
 *         <code>compareTo.</code>
 * @see Coordinate#compareTo(Object)
 */
jsts.geom.CoordinateArrays.minCoordinate = function(coordinates) {
  var minCoord = null;
  for (var i = 0; i < coordinates.length; i++) {
    if (minCoord === null || minCoord.compareTo(coordinates[i]) > 0) {
      minCoord = coordinates[i];
    }
  }
  return minCoord;
};

/**
 * Shifts the positions of the coordinates until <code>firstCoordinate</code>
 * is first.
 *
 * @param coordinates
 *          the array to rearrange.
 * @param firstCoordinate
 *          the coordinate to make first.
 */
jsts.geom.CoordinateArrays.scroll = function(coordinates, firstCoordinate) {
  var i = jsts.geom.CoordinateArrays.indexOf(firstCoordinate, coordinates);
  if (i < 0)
    return;

  var newCoordinates = coordinates.slice(i).concat(coordinates.slice(0, i));
  for (i = 0; i < newCoordinates.length; i++) {
    coordinates[i] = newCoordinates[i];
  }
};

/**
 * Returns the index of <code>coordinate</code> in <code>coordinates</code>.
 * The first position is 0; the second, 1; etc.
 *
 * @param coordinate
 *          the <code>Coordinate</code> to search for.
 * @param coordinates
 *          the array to search.
 * @return the position of <code>coordinate</code>, or -1 if it is not found.
 */
jsts.geom.CoordinateArrays.indexOf = function(coordinate, coordinates) {
  for (var i = 0; i < coordinates.length; i++) {
    if (coordinate.equals(coordinates[i])) {
      return i;
    }
  }
  return -1;
};
/* ======================================================================
    jsts/operation/overlay/MinimalEdgeRing.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @requires jsts/geomgraph/EdgeRing.js
 */

/**
 * A ring of {@link Edge}s with the property that no node has degree greater
 * than 2. These are the form of rings required to represent polygons under the
 * OGC SFS spatial data model.
 *
 * Port source: com.vividsolutions.jts.operation.overlay.MinimalEdgeRing r6
 *
 * @extends jsts.geomgraph.EdgeRing
 * @constructor
 */
jsts.operation.overlay.MinimalEdgeRing = function(start, geometryFactory) {
  jsts.geomgraph.EdgeRing.call(this, start, geometryFactory);

};
jsts.operation.overlay.MinimalEdgeRing.prototype = new jsts.geomgraph.EdgeRing();
jsts.operation.overlay.MinimalEdgeRing.constructor = jsts.operation.overlay.MinimalEdgeRing;

jsts.operation.overlay.MinimalEdgeRing.prototype.getNext = function(de) {
  return de.getNextMin();
};
jsts.operation.overlay.MinimalEdgeRing.prototype.setEdgeRing = function(de, er) {
  de.setMinEdgeRing(er);
};
/* ======================================================================
    jsts/triangulate/DelaunayTriangulationBuilder.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
*/



/**
 * A utility class which creates Delaunay Trianglulations from collections of
 * points and extract the resulting triangulation edges or triangles as
 * geometries.
 *
 * Initializes a new DelaunayTriangulationBuilder
 *
 * @constructor
 */
jsts.triangulate.DelaunayTriangulationBuilder = function() {

  this.siteCoords = null;
  this.tolerance = 0.0;
  this.subdiv = null;
};


/**
 * Extracts the unique {@link Coordinate}s from the given {@link Geometry}.
 *
 * @param {jsts.geom.Geometry}
 *          geom the geometry to extract from.
 * @return {Array{jsts.geom.Coordinate}} An array of the unique Coordinates
 */
jsts.triangulate.DelaunayTriangulationBuilder.extractUniqueCoordinates = function(
    geom) {
  if (geom === undefined || geom === null) {
    return new jsts.geom.CoordinateList([], false).toArray();
  }

  var coords = geom.getCoordinates();
  return jsts.triangulate.DelaunayTriangulationBuilder.unique(coords);
};


/**
 * Removes any duplicates in the passed array.
 *
 * @param {Array{jsts.geom.Coordinate}}
 *          coords The input coordinates
 * @return {Array{jsts.geom.Coordinate}} An array stripped out of any duplicates
 */
jsts.triangulate.DelaunayTriangulationBuilder.unique = function(coords) {
  // Sort the coordinates by their compareTo-function
  coords.sort(function(a, b) {
    return a.compareTo(b);
  });

  var coordList = new jsts.geom.CoordinateList(coords, false);
  return coordList.toArray();
};


/**
 * Converts an array of coordinates to an array of vertexes
 *
 * @param {Array{jsts.geom.Coordinate}}
 *          coords the input coordinates
 * @return {Array{jsts.triangulate.quadedge.Vertex}} The created vertexes
 */
jsts.triangulate.DelaunayTriangulationBuilder.toVertices = function(coords) {
  var verts = new Array(coords.length), i = 0, il = coords.length, coord;

  for (i; i < il; i++) {
    coord = coords[i];
    verts[i] = new jsts.triangulate.quadedge.Vertex(coord);
  }

  return verts;
};


/**
 * Computes the {jsts.geom.Envelope} of an array of {jsts.geom.Coordinate}s
 *
 * @param {Array{jsts.geom.Coordinate}}
 *          coords the input coordinates
 * @return {jsts.geom.Envelope} The created envelope.
 *
 */
jsts.triangulate.DelaunayTriangulationBuilder.envelope = function(coords) {
  var env = new jsts.geom.Envelope(), i = 0, il = coords.length;

  for (i; i < il; i++) {
    env.expandToInclude(coords[i]);
  }

  return env;
};


/**
 * Sets the sites which will be triangulated. Calls the correct setSites*
 * function after argument-checking
 */
jsts.triangulate.DelaunayTriangulationBuilder.prototype.setSites = function() {
  var arg = arguments[0];

  if (arg instanceof jsts.geom.Geometry ||
      arg instanceof jsts.geom.Coordinate || arg instanceof jsts.geom.Point ||
      arg instanceof jsts.geom.MultiPoint ||
      arg instanceof jsts.geom.LineString ||
      arg instanceof jsts.geom.MultiLineString ||
      arg instanceof jsts.geom.LinearRing || arg instanceof jsts.geom.Polygon ||
      arg instanceof jsts.geom.MultiPolygon) {
    this.setSitesFromGeometry(arg);
  } else {
    this.setSitesFromCollection(arg);
  }
};


/**
 * Sets the sites (point or vertices) which will be triangulated. All vertices
 * of the given geometry will be used as sites.
 *
 * @param {jsts.geom.Geometry}
 *          geom the geometry from which the sites will be extracted.
 */
jsts.triangulate.DelaunayTriangulationBuilder.prototype.setSitesFromGeometry = function(
    geom) {
  // remove any duplicate points (they will cause the triangulation to fail)
  this.siteCoords = jsts.triangulate.DelaunayTriangulationBuilder
      .extractUniqueCoordinates(geom);
};


/**
 * Sets the sites (point or vertices) which will be triangulated from a
 * collection of {@link Coordinate}s.
 *
 * @param {Array{Coordinates}}
 *          coords a collection of Coordinates.
 */
jsts.triangulate.DelaunayTriangulationBuilder.prototype.setSitesFromCollection = function(
    coords) {
  // remove any duplicate points (they will cause the triangulation to fail)
  this.siteCoords = jsts.triangulate.DelaunayTriangulationBuilder.unique(coords);
};


/**
 * Sets the snapping tolerance which will be used to improved the robustness of
 * the triangulation computation. A tolerance of 0.0 specifies that no snapping
 * will take place.
 *
 * @param {Number}
 *          tolerance the tolerance distance to use.
 */
jsts.triangulate.DelaunayTriangulationBuilder.prototype.setTolerance = function(
    tolerance) {
  this.tolerance = tolerance;
};


/**
 * Creates the Delaunay-triangulation.
 *
 */
jsts.triangulate.DelaunayTriangulationBuilder.prototype.create = function() {
  if (this.subdiv === null) {
    var siteEnv, vertices, triangulator;

    siteEnv = jsts.triangulate.DelaunayTriangulationBuilder
        .envelope(this.siteCoords);
    vertices = jsts.triangulate.DelaunayTriangulationBuilder
        .toVertices(this.siteCoords);
    this.subdiv = new jsts.triangulate.quadedge.QuadEdgeSubdivision(siteEnv,
        this.tolerance);
    triangulator = new jsts.triangulate.IncrementalDelaunayTriangulator(
        this.subdiv);
    triangulator.insertSites(vertices);
  }
};


/**
 * Gets the {jsts.triangulate.quadedge.QuadEdgeSubdivision} which models the
 * computed triangulation.
 *
 * @return {jsts.triangulate.quadedge.QuadEdgeSubdivision} containing the
 *         triangulation.
 */
jsts.triangulate.DelaunayTriangulationBuilder.prototype.getSubdivision = function() {
  this.create();
  return this.subdiv;
};


/**
 * Gets the edges of the computed triangulation as a {@link MultiLineString}.
 *
 * @param {jsts.geom.GeometryFactory}
 *          geomFact the geometry factory to use to create the output.
 * @return {jsts.geom.Geometry} the edges of the triangulation.
 */
jsts.triangulate.DelaunayTriangulationBuilder.prototype.getEdges = function(
    geomFact) {
  this.create();
  return this.subdiv.getEdges(geomFact);
};


/**
 * Gets the faces of the computed triangulation as a {@link GeometryCollection}
 * of {@link Polygon}.
 *
 * @param {jsts.geom.GeometryFactory}
 *          geomFact the geometry factory to use to create the output.
 * @return {jsts.geom.Geometry} the faces of the triangulation.
 */
jsts.triangulate.DelaunayTriangulationBuilder.prototype.getTriangles = function(
    geomFact) {
  this.create();
  return this.subdiv.getTriangles(geomFact);
};
/* ======================================================================
    jsts/algorithm/RayCrossingCounter.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * Counts the number of segments crossed by a horizontal ray extending to the
 * right from a given point, in an incremental fashion. This can be used to
 * determine whether a point lies in a {@link Polygonal} geometry. The class
 * determines the situation where the point lies exactly on a segment. When
 * being used for Point-In-Polygon determination, this case allows
 * short-circuiting the evaluation.
 * <p>
 * This class handles polygonal geometries with any number of shells and holes.
 * The orientation of the shell and hole rings is unimportant. In order to
 * compute a correct location for a given polygonal geometry, it is essential
 * that <b>all</b> segments are counted which
 * <ul>
 * <li>touch the ray
 * <li>lie in in any ring which may contain the point
 * </ul>
 * The only exception is when the point-on-segment situation is detected, in
 * which case no further processing is required. The implication of the above
 * rule is that segments which can be a priori determined to <i>not</i> touch
 * the ray (i.e. by a test of their bounding box or Y-extent) do not need to be
 * counted. This allows for optimization by indexing.
 *
 * @constructor
 */
jsts.algorithm.RayCrossingCounter = function(p) {
  this.p = p;
};


/**
 * Determines the {@link Location} of a point in a ring. This method is an
 * exemplar of how to use this class.
 *
 * @param {Coordinate}
 *          p the point to test.
 * @param {Coordinate[]}
 *          ring an array of Coordinates forming a ring.
 * @return {int} the location of the point in the ring.
 */
jsts.algorithm.RayCrossingCounter.locatePointInRing = function(p, ring) {
  var counter = new jsts.algorithm.RayCrossingCounter(p);

  for (var i = 1; i < ring.length; i++) {
    var p1 = ring[i];
    var p2 = ring[i - 1];
    counter.countSegment(p1, p2);
    if (counter.isOnSegment())
      return counter.getLocation();
  }
  return counter.getLocation();
};


/**
 * @type {Coordinate}
 * @private
 */
jsts.algorithm.RayCrossingCounter.prototype.p = null;


/**
 * @type {int}
 * @private
 */
jsts.algorithm.RayCrossingCounter.prototype.crossingCount = 0;


/**
 * true if the test point lies on an input segment
 *
 * @type {boolean}
 * @private
 */
jsts.algorithm.RayCrossingCounter.prototype.isPointOnSegment = false;


/**
 * Counts a segment
 *
 * @param {Coordinate}
 *          p1 an endpoint of the segment.
 * @param {Coordinate}
 *          p2 another endpoint of the segment.
 */
jsts.algorithm.RayCrossingCounter.prototype.countSegment = function(p1, p2) {
  /**
   * For each segment, check if it crosses a horizontal ray running from the
   * test point in the positive x direction.
   */

  // check if the segment is strictly to the left of the test point
  if (p1.x < this.p.x && p2.x < this.p.x)
    return;

  // check if the point is equal to the current ring vertex
  if (this.p.x == p2.x && this.p.y === p2.y) {
    this.isPointOnSegment = true;
    return;
  }
  /**
   * For horizontal segments, check if the point is on the segment. Otherwise,
   * horizontal segments are not counted.
   */
  if (p1.y === this.p.y && p2.y === this.p.y) {
    var minx = p1.x;
    var maxx = p2.x;
    if (minx > maxx) {
      minx = p2.x;
      maxx = p1.x;
    }
    if (this.p.x >= minx && this.p.x <= maxx) {
      this.isPointOnSegment = true;
    }
    return;
  }
  /**
   * Evaluate all non-horizontal segments which cross a horizontal ray to the
   * right of the test pt. To avoid double-counting shared vertices, we use the
   * convention that
   * <ul>
   * <li>an upward edge includes its starting endpoint, and excludes its final
   * endpoint
   * <li>a downward edge excludes its starting endpoint, and includes its final
   * endpoint
   * </ul>
   */
  if (((p1.y > this.p.y) && (p2.y <= this.p.y)) || ((p2.y > this.p.y) && (p1.y <= this.p.y))) {
    // translate the segment so that the test point lies on the origin
    var x1 = p1.x - this.p.x;
    var y1 = p1.y - this.p.y;
    var x2 = p2.x - this.p.x;
    var y2 = p2.y - this.p.y;

    /**
     * The translated segment straddles the x-axis. Compute the sign of the
     * ordinate of intersection with the x-axis. (y2 != y1, so denominator will
     * never be 0.0)
     */
    // double xIntSign = RobustDeterminant.signOfDet2x2(x1, y1, x2, y2) / (y2
    // - y1);
    // MD - faster & more robust computation?
    var xIntSign = jsts.algorithm.RobustDeterminant.signOfDet2x2(x1, y1, x2, y2);
    if (xIntSign === 0.0) {
      this.isPointOnSegment = true;
      return;
    }
    if (y2 < y1)
      xIntSign = -xIntSign;
    // xsave = xInt;

    // System.out.println("xIntSign(" + x1 + ", " + y1 + ", " + x2 + ", " + y2
    // + " = " + xIntSign);
    // The segment crosses the ray if the sign is strictly positive.
    if (xIntSign > 0.0) {
      this.crossingCount++;
    }
  }
};


/**
 * Reports whether the point lies exactly on one of the supplied segments. This
 * method may be called at any time as segments are processed. If the result of
 * this method is <tt>true</tt>, no further segments need be supplied, since
 * the result will never change again.
 *
 * @return {boolean} true if the point lies exactly on a segment.
 */
jsts.algorithm.RayCrossingCounter.prototype.isOnSegment = function() {
  return jsts.geom.isPointOnSegment;
};


/**
 * Gets the {@link Location} of the point relative to the ring, polygon or
 * multipolygon from which the processed segments were provided.
 * <p>
 * This method only determines the correct location if <b>all</b> relevant
 * segments must have been processed.
 *
 * @return {int} the Location of the point.
 */
jsts.algorithm.RayCrossingCounter.prototype.getLocation = function() {
  if (this.isPointOnSegment)
    return jsts.geom.Location.BOUNDARY;

  // The point is in the interior of the ring if the number of X-crossings is
  // odd.
  if ((this.crossingCount % 2) === 1) {
    return jsts.geom.Location.INTERIOR;
  }
  return jsts.geom.Location.EXTERIOR;
};


/**
 * Tests whether the point lies in or on the ring, polygon or multipolygon from
 * which the processed segments were provided.
 * <p>
 * This method only determines the correct location if <b>all</b> relevant
 * segments must have been processed.
 *
 * @return {boolean} true if the point lies in or on the supplied polygon.
 */
jsts.algorithm.RayCrossingCounter.prototype.isPointInPolygon = function() {
  return this.getLocation() !== jsts.geom.Location.EXTERIOR;
};
/* ======================================================================
    jsts/operation/BoundaryOp.js
   ====================================================================== */



/**
 * Computes the boundary of a {@link Geometry}.
 * Allows specifying the {@link BoundaryNodeRule} to be used.
 * This operation will always return a {@link Geometry} of the appropriate
 * dimension for the boundary (even if the input geometry is empty).
 * The boundary of zero-dimensional geometries (Points) is
 * always the empty {@link GeometryCollection}.
 *
 * @author Martin Davis
 * @version 1.7
 */

jsts.operation.BoundaryOp = function(geom, bnRule) {
  this.geom = geom;
  this.geomFact = geom.getFactory();
  this.bnRule = bnRule || jsts.algorithm.BoundaryNodeRule.MOD2_BOUNDARY_RULE;
};


/**
   * @type {Geometry}
   * @private
   */
jsts.operation.BoundaryOp.prototype.geom = null;


/**
   * @type {GeometryFactory}
   * @private
   */
jsts.operation.BoundaryOp.prototype.geomFact = null;


/**
   * @type {BoundaryNodeRule}
   * @private
   */
jsts.operation.BoundaryOp.prototype.bnRule = null;


/**
   * @return {Geometry}
   */
jsts.operation.BoundaryOp.prototype.getBoundary = function()  {
  if (this.geom instanceof jsts.geom.LineString) return this.boundaryLineString(this.geom);
  if (this.geom instanceof jsts.geom.MultiLineString) return this.boundaryMultiLineString(this.geom);
  return this.geom.getBoundary();
};


/**
   * @return {MultiPoint}
   * @private
   */
jsts.operation.BoundaryOp.prototype.getEmptyMultiPoint = function()  {
  return this.geomFact.createMultiPoint(null);
};


/**
   * @param {MultiLineString} mLine
   * @return {Geometry}
   * @private
   */
jsts.operation.BoundaryOp.prototype.boundaryMultiLineString = function(mLine)  {
  if (this.geom.isEmpty()) {
    return this.getEmptyMultiPoint();
  }

  var bdyPts = this.computeBoundaryCoordinates(mLine);

  // return Point or MultiPoint
  if (bdyPts.length == 1) {
    return this.geomFact.createPoint(bdyPts[0]);
  }
  // this handles 0 points case as well
  return this.geomFact.createMultiPoint(bdyPts);
};


/**
   * @type {Array}
   * @private
   */
jsts.operation.BoundaryOp.prototype.endpoints = null;


/**
   * @param {MultiLineString} mLine
   * @return {Array.<Coordinate>}
   * @private
   */
jsts.operation.BoundaryOp.prototype.computeBoundaryCoordinates = function(mLine)  {
  var i, line, endpoint, bdyPts = [];

  this.endpoints = [];
  for (i = 0; i < mLine.getNumGeometries(); i++) {
    line = mLine.getGeometryN(i);
    if (line.getNumPoints() == 0)
      continue;
    this.addEndpoint(line.getCoordinateN(0));
    this.addEndpoint(line.getCoordinateN(line.getNumPoints() - 1));
  }

  for (i = 0; i < this.endpoints.length; i++) {
    endpoint = this.endpoints[i];
    if (this.bnRule.isInBoundary(endpoint.count)) {
      bdyPts.push(endpoint.coordinate);
    }
  }

  return bdyPts;
};


/**
   * @param {Coordinate} pt
   * @private
   */
jsts.operation.BoundaryOp.prototype.addEndpoint = function(pt) {
  var i, endpoint, found = false;
  for (i = 0; i < this.endpoints.length; i++) {
    endpoint = this.endpoints[i];
    if (endpoint.coordinate.equals(pt)) {
      found = true;
      break;
    }
  }

  if (!found) {
    endpoint = {};
    endpoint.coordinate = pt;
    endpoint.count = 0;
    this.endpoints.push(endpoint);
  }

  endpoint.count++;
};


/**
   * @param {LineString} line
   * @return {Geometry}
   * @private
   */
jsts.operation.BoundaryOp.prototype.boundaryLineString = function(line)  {
  if (this.geom.isEmpty()) {
    return this.getEmptyMultiPoint();
  }

  if (line.isClosed()) {
    // check whether endpoints of valence 2 are on the boundary or not
    var closedEndpointOnBoundary = this.bnRule.isInBoundary(2);
    if (closedEndpointOnBoundary) {
      return line.getStartPoint();
    }
    else {
      return this.geomFact.createMultiPoint(null);
    }
  }
  return this.geomFact.createMultiPoint([line.getStartPoint(),
        line.getEndPoint()]
  );
};
/* ======================================================================
    jsts/operation/buffer/OffsetCurveSetBuilder.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */


/**
 * Creates all the raw offset curves for a buffer of a {@link Geometry}. Raw
 * curves need to be noded together and polygonized to form the final buffer
 * area.
 *
 * @constructor
 */
jsts.operation.buffer.OffsetCurveSetBuilder = function(inputGeom, distance,
    curveBuilder) {
  this.inputGeom = inputGeom;
  this.distance = distance;
  this.curveBuilder = curveBuilder;

  this.curveList = new javascript.util.ArrayList();
};


/**
 * @private
 */
jsts.operation.buffer.OffsetCurveSetBuilder.prototype.inputGeom = null;


/**
 * @private
 */
jsts.operation.buffer.OffsetCurveSetBuilder.prototype.distance = null;


/**
 * @private
 */
jsts.operation.buffer.OffsetCurveSetBuilder.prototype.curveBuilder = null;


/**
 * @private
 */
jsts.operation.buffer.OffsetCurveSetBuilder.prototype.curveList = null;


/**
 * Computes the set of raw offset curves for the buffer. Each offset curve has
 * an attached {@link Label} indicating its left and right location.
 *
 * @return a Collection of SegmentStrings representing the raw buffer curves.
 */
jsts.operation.buffer.OffsetCurveSetBuilder.prototype.getCurves = function() {
  this.add(this.inputGeom);
  return this.curveList;
};


/**
 * Creates a {@link SegmentString} for a coordinate list which is a raw offset
 * curve, and adds it to the list of buffer curves. The SegmentString is tagged
 * with a Label giving the topology of the curve. The curve may be oriented in
 * either direction. If the curve is oriented CW, the locations will be: <br>
 * Left: Location.EXTERIOR <br>
 * Right: Location.INTERIOR
 *
 * @private
 */
jsts.operation.buffer.OffsetCurveSetBuilder.prototype.addCurve = function(
    coord, leftLoc, rightLoc) {
  // don't add null or trivial curves
  if (coord == null || coord.length < 2)
    return;
  // add the edge for a coordinate list which is a raw offset curve
  var e = new jsts.noding.NodedSegmentString(coord, new jsts.geomgraph.Label(0,
      jsts.geom.Location.BOUNDARY, leftLoc, rightLoc));
  this.curveList.add(e);
};


/**
 * @private
 */
jsts.operation.buffer.OffsetCurveSetBuilder.prototype.add = function(g) {
  if (g.isEmpty())
    return;

  if (g instanceof jsts.geom.Polygon)
    this.addPolygon(g);
  // LineString also handles LinearRings
  else if (g instanceof jsts.geom.LineString)
    this.addLineString(g);
  else if (g instanceof jsts.geom.Point)
    this.addPoint(g);
  else if (g instanceof jsts.geom.MultiPoint)
    this.addCollection(g);
  else if (g instanceof jsts.geom.MultiLineString)
    this.addCollection(g);
  else if (g instanceof jsts.geom.MultiPolygon)
    this.addCollection(g);
  else if (g instanceof jsts.geom.GeometryCollection)
    this.addCollection(g);
  else
    throw new jsts.error.IllegalArgumentError();
};


/**
 * @private
 */
jsts.operation.buffer.OffsetCurveSetBuilder.prototype.addCollection = function(
    gc) {
  for (var i = 0; i < gc.getNumGeometries(); i++) {
    var g = gc.getGeometryN(i);
    this.add(g);
  }
};


/**
 * Add a Point to the graph.
 *
 * @private
 */
jsts.operation.buffer.OffsetCurveSetBuilder.prototype.addPoint = function(p) {
  // a zero or negative width buffer of a line/point is empty
  if (this.distance <= 0.0)
    return;
  var coord = p.getCoordinates();
  var curve = this.curveBuilder.getLineCurve(coord, this.distance);
  this
      .addCurve(curve, jsts.geom.Location.EXTERIOR, jsts.geom.Location.INTERIOR);
};


/**
 * @private
 */
jsts.operation.buffer.OffsetCurveSetBuilder.prototype.addLineString = function(
    line) {
  // a zero or negative width buffer of a line/point is empty
  if (this.distance <= 0.0 &&
      !this.curveBuilder.getBufferParameters().isSingleSided())
    return;
  var coord = jsts.geom.CoordinateArrays.removeRepeatedPoints(line
      .getCoordinates());
  var curve = this.curveBuilder.getLineCurve(coord, this.distance);
  this
      .addCurve(curve, jsts.geom.Location.EXTERIOR, jsts.geom.Location.INTERIOR);
};


/**
 * @private
 */
jsts.operation.buffer.OffsetCurveSetBuilder.prototype.addPolygon = function(p) {
  var offsetDistance = this.distance;
  var offsetSide = jsts.geomgraph.Position.LEFT;
  if (this.distance < 0.0) {
    offsetDistance = -this.distance;
    offsetSide = jsts.geomgraph.Position.RIGHT;
  }

  var shell = p.getExteriorRing();
  var shellCoord = jsts.geom.CoordinateArrays.removeRepeatedPoints(shell
      .getCoordinates());
  // optimization - don't bother computing buffer
  // if the polygon would be completely eroded
  if (this.distance < 0.0 && this.isErodedCompletely(shell, this.distance))
    return;
  // don't attemtp to buffer a polygon with too few distinct vertices
  if (this.distance <= 0.0 && shellCoord.length < 3)
    return;

  this.addPolygonRing(shellCoord, offsetDistance, offsetSide,
      jsts.geom.Location.EXTERIOR, jsts.geom.Location.INTERIOR);

  for (var i = 0; i < p.getNumInteriorRing(); i++) {

    var hole = p.getInteriorRingN(i);
    var holeCoord = jsts.geom.CoordinateArrays.removeRepeatedPoints(hole
        .getCoordinates());

    // optimization - don't bother computing buffer for this hole
    // if the hole would be completely covered
    if (this.distance > 0.0 && this.isErodedCompletely(hole, -this.distance))
      continue;

    // Holes are topologically labelled opposite to the shell, since
    // the interior of the polygon lies on their opposite side
    // (on the left, if the hole is oriented CCW)
    this.addPolygonRing(holeCoord, offsetDistance, jsts.geomgraph.Position
        .opposite(offsetSide), jsts.geom.Location.INTERIOR,
        jsts.geom.Location.EXTERIOR);
  }
};


/**
 * Adds an offset curve for a polygon ring. The side and left and right
 * topological location arguments assume that the ring is oriented CW. If the
 * ring is in the opposite orientation, the left and right locations must be
 * interchanged and the side flipped.
 *
 * @param coord
 *          the coordinates of the ring (must not contain repeated points).
 * @param offsetDistance
 *          the distance at which to create the buffer.
 * @param side
 *          the side of the ring on which to construct the buffer line.
 * @param cwLeftLoc
 *          the location on the L side of the ring (if it is CW).
 * @param cwRightLoc
 *          the location on the R side of the ring (if it is CW).
 */
/**
 * @private
 */
jsts.operation.buffer.OffsetCurveSetBuilder.prototype.addPolygonRing = function(
    coord, offsetDistance, side, cwLeftLoc, cwRightLoc) {
  // don't bother adding ring if it is "flat" and will disappear in the output
  if (offsetDistance == 0.0 &&
      coord.length < jsts.geom.LinearRing.MINIMUM_VALID_SIZE)
    return;

  var leftLoc = cwLeftLoc;
  var rightLoc = cwRightLoc;
  if (coord.length >= jsts.geom.LinearRing.MINIMUM_VALID_SIZE &&
      jsts.algorithm.CGAlgorithms.isCCW(coord)) {
    leftLoc = cwRightLoc;
    rightLoc = cwLeftLoc;
    side = jsts.geomgraph.Position.opposite(side);
  }
  var curve = this.curveBuilder.getRingCurve(coord, side, offsetDistance);
  this.addCurve(curve, leftLoc, rightLoc);
};


/**
 * The ringCoord is assumed to contain no repeated points. It may be degenerate
 * (i.e. contain only 1, 2, or 3 points). In this case it has no area, and hence
 * has a minimum diameter of 0.
 *
 * @param ringCoord
 * @param offsetDistance
 * @return
 */
/**
 * @private
 */
jsts.operation.buffer.OffsetCurveSetBuilder.prototype.isErodedCompletely = function(
    ring, bufferDistance) {
  var ringCoord = ring.getCoordinates();
  var minDiam = 0.0;
  // degenerate ring has no area
  if (ringCoord.length < 4)
    return bufferDistance < 0;

  // important test to eliminate inverted triangle bug
  // also optimizes erosion test for triangles
  if (ringCoord.length == 4)
    return this.isTriangleErodedCompletely(ringCoord, bufferDistance);

  // if envelope is narrower than twice the buffer distance, ring is eroded
  var env = ring.getEnvelopeInternal();
  var envMinDimension = Math.min(env.getHeight(), env.getWidth());
  if (bufferDistance < 0.0 && 2 * Math.abs(bufferDistance) > envMinDimension)
    return true;

  return false;
};


/**
 * Tests whether a triangular ring would be eroded completely by the given
 * buffer distance. This is a precise test. It uses the fact that the inner
 * buffer of a triangle converges on the inCentre of the triangle (the point
 * equidistant from all sides). If the buffer distance is greater than the
 * distance of the inCentre from a side, the triangle will be eroded completely.
 *
 * This test is important, since it removes a problematic case where the buffer
 * distance is slightly larger than the inCentre distance. In this case the
 * triangle buffer curve "inverts" with incorrect topology, producing an
 * incorrect hole in the buffer.
 *
 * @param triangleCoord
 * @param bufferDistance
 * @return
 *
 * @private
 */
jsts.operation.buffer.OffsetCurveSetBuilder.prototype.isTriangleErodedCompletely = function(
    triangleCoord, bufferDistance) {
  var tri = new jsts.geom.Triangle(triangleCoord[0], triangleCoord[1], triangleCoord[2]);
  var inCentre = tri.inCentre();
  var distToCentre = jsts.algorithm.CGAlgorithms.distancePointLine(inCentre,
      tri.p0, tri.p1);
  return distToCentre < Math.abs(bufferDistance);
};
/* ======================================================================
    jsts/operation/buffer/BufferSubgraph.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * A connected subset of the graph of {@link DirectedEdge}s and {@link Node}s.
 * Its edges will generate either
 * <ul>
 * <li> a single polygon in the complete buffer, with zero or more holes, or
 * <li> one or more connected holes
 * </ul>
 *
 *
 * @constructor
 */
jsts.operation.buffer.BufferSubgraph = function() {
  this.dirEdgeList = new javascript.util.ArrayList();
  this.nodes = new javascript.util.ArrayList();

  this.finder = new jsts.operation.buffer.RightmostEdgeFinder();
};

/**
 * @type {RightmostEdgeFinder}
 * @private
 */
jsts.operation.buffer.BufferSubgraph.prototype.finder = null;
/**
 * @type {Array}
 * @private
 */
jsts.operation.buffer.BufferSubgraph.prototype.dirEdgeList = null;
/**
 * @type {Array}
 * @private
 */
jsts.operation.buffer.BufferSubgraph.prototype.nodes = null;
/**
 * @type {Coordinate}
 * @private
 */
jsts.operation.buffer.BufferSubgraph.prototype.rightMostCoord = null;
/**
 * @type {Envelope}
 * @private
 */
jsts.operation.buffer.BufferSubgraph.prototype.env = null;


jsts.operation.buffer.BufferSubgraph.prototype.getDirectedEdges = function() {
  return this.dirEdgeList;
};
jsts.operation.buffer.BufferSubgraph.prototype.getNodes = function() {
  return this.nodes;
};

/**
 * Computes the envelope of the edges in the subgraph. The envelope is cached
 * after being computed.
 *
 * @return the envelope of the graph.
 */
jsts.operation.buffer.BufferSubgraph.prototype.getEnvelope = function() {
  if (this.env === null) {
    var edgeEnv = new jsts.geom.Envelope();
    for (var it = this.dirEdgeList.iterator(); it.hasNext(); ) {
      var dirEdge = it.next();
      var pts = dirEdge.getEdge().getCoordinates();
      for (var j = 0; j < pts.length - 1; j++) {
        edgeEnv.expandToInclude(pts[j]);
      }
    }
    this.env = edgeEnv;
  }
  return this.env;
};

/**
 * Gets the rightmost coordinate in the edges of the subgraph
 */
jsts.operation.buffer.BufferSubgraph.prototype.getRightmostCoordinate = function() {
  return this.rightMostCoord;
};

/**
 * Creates the subgraph consisting of all edges reachable from this node. Finds
 * the edges in the graph and the rightmost coordinate.
 *
 * @param node
 *          a node to start the graph traversal from.
 */
jsts.operation.buffer.BufferSubgraph.prototype.create = function(node) {
  this.addReachable(node);
  this.finder.findEdge(this.dirEdgeList);
  this.rightMostCoord = this.finder.getCoordinate();
};

/**
 * Adds all nodes and edges reachable from this node to the subgraph. Uses an
 * explicit stack to avoid a large depth of recursion.
 *
 * @param node
 *          a node known to be in the subgraph.
 * @private
 */
jsts.operation.buffer.BufferSubgraph.prototype.addReachable = function(
    startNode) {
  var nodeStack = [];
  nodeStack.push(startNode);
  while (nodeStack.length !== 0) {
    var node = nodeStack.pop();
    this.add(node, nodeStack);
  }
};

/**
 * Adds the argument node and all its out edges to the subgraph
 *
 * @param node
 *          the node to add.
 * @param nodeStack
 *          the current set of nodes being traversed.
 * @private
 */
jsts.operation.buffer.BufferSubgraph.prototype.add = function(node, nodeStack) {
  node.setVisited(true);
  this.nodes.add(node);
  for (var i = node.getEdges().iterator(); i.hasNext(); ) {
    var de = i.next();
    this.dirEdgeList.add(de);
    var sym = de.getSym();
    var symNode = sym.getNode();
    /**
     * NOTE: this is a depth-first traversal of the graph. This will cause a
     * large depth of recursion. It might be better to do a breadth-first
     * traversal.
     */
    if (!symNode.isVisited())
      nodeStack.push(symNode);
  }
};

jsts.operation.buffer.BufferSubgraph.prototype.clearVisitedEdges = function() {
  for (var it = this.dirEdgeList.iterator(); it.hasNext(); ) {
    var de = it.next();
    de.setVisited(false);
  }
};

jsts.operation.buffer.BufferSubgraph.prototype.computeDepth = function(
    outsideDepth) {
  this.clearVisitedEdges();
  // find an outside edge to assign depth to
  var de = this.finder.getEdge();
  var n = de.getNode();
  var label = de.getLabel();
  // right side of line returned by finder is on the outside
  de.setEdgeDepths(jsts.geomgraph.Position.RIGHT, outsideDepth);
  this.copySymDepths(de);

  this.computeDepths(de);
};

/**
 * Compute depths for all dirEdges via breadth-first traversal of nodes in graph
 *
 * @param startEdge
 *          edge to start processing with.
 * @private
 */
// <FIX> MD - use iteration & queue rather than recursion, for speed and
// robustness
jsts.operation.buffer.BufferSubgraph.prototype.computeDepths = function(
    startEdge) {
  var nodesVisited = [];
  var nodeQueue = [];

  var startNode = startEdge.getNode();
  nodeQueue.push(startNode);
  nodesVisited.push(startNode);
  startEdge.setVisited(true);

  while (nodeQueue.length !== 0) {
    var n = nodeQueue.shift();
    nodesVisited.push(n);
    // compute depths around node, starting at this edge since it has depths
    // assigned
    this.computeNodeDepth(n);

    // add all adjacent nodes to process queue,
    // unless the node has been visited already
    for (var i = n.getEdges().iterator(); i.hasNext(); ) {
      var de = i.next();
      var sym = de.getSym();
      if (sym.isVisited())
        continue;
      var adjNode = sym.getNode();
      if (nodesVisited.indexOf(adjNode) === -1) {
        nodeQueue.push(adjNode);
        nodesVisited.push(adjNode);
      }
    }
  }
};

/**
 * @private
 */
jsts.operation.buffer.BufferSubgraph.prototype.computeNodeDepth = function(n) {
  // find a visited dirEdge to start at
  var startEdge = null;
  for (var i = n.getEdges().iterator(); i.hasNext(); ) {
    var de = i.next();
    if (de.isVisited() || de.getSym().isVisited()) {
      startEdge = de;
      break;
    }
  }
  // MD - testing Result: breaks algorithm
  // if (startEdge == null) return;

  // only compute string append if assertion would fail
  if (startEdge == null)
    throw new jsts.error.TopologyError(
        'unable to find edge to compute depths at ' + n.getCoordinate());

  n.getEdges().computeDepths(startEdge);

  // copy depths to sym edges
  for (var i = n.getEdges().iterator(); i.hasNext(); ) {
    var de = i.next();
    de.setVisited(true);
    this.copySymDepths(de);
  }
};

/**
 * @private
 */
jsts.operation.buffer.BufferSubgraph.prototype.copySymDepths = function(de) {
  var sym = de.getSym();
  sym.setDepth(jsts.geomgraph.Position.LEFT, de
      .getDepth(jsts.geomgraph.Position.RIGHT));
  sym.setDepth(jsts.geomgraph.Position.RIGHT, de
      .getDepth(jsts.geomgraph.Position.LEFT));
};

/**
 * Find all edges whose depths indicates that they are in the result area(s).
 * Since we want polygon shells to be oriented CW, choose dirEdges with the
 * interior of the result on the RHS. Mark them as being in the result. Interior
 * Area edges are the result of dimensional collapses. They do not form part of
 * the result area boundary.
 */
jsts.operation.buffer.BufferSubgraph.prototype.findResultEdges = function() {
  for (var it = this.dirEdgeList.iterator(); it.hasNext(); ) {
    var de = it.next();
    /**
     * Select edges which have an interior depth on the RHS
     * and an exterior depth on the LHS.
     * Note that because of weird rounding effects there may be
     * edges which have negative depths!  Negative depths
     * count as "outside".
     */
    // <FIX> - handle negative depths
    if (de.getDepth(jsts.geomgraph.Position.RIGHT) >= 1 &&
        de.getDepth(jsts.geomgraph.Position.LEFT) <= 0 &&
        !de.isInteriorAreaEdge()) {
      de.setInResult(true);
    }
  }
};

/**
 * BufferSubgraphs are compared on the x-value of their rightmost Coordinate.
 * This defines a partial ordering on the graphs such that:
 * <p>
 * g1 >= g2 <==> Ring(g2) does not contain Ring(g1)
 * <p>
 * where Polygon(g) is the buffer polygon that is built from g.
 * <p>
 * This relationship is used to sort the BufferSubgraphs so that shells are
 * guaranteed to be built before holes.
 */
jsts.operation.buffer.BufferSubgraph.prototype.compareTo = function(o) {
  var graph = o;
  if (this.rightMostCoord.x < graph.rightMostCoord.x) {
    return -1;
  }
  if (this.rightMostCoord.x > graph.rightMostCoord.x) {
    return 1;
  }
  return 0;
};
/* ======================================================================
    jsts/simplify/DPTransformer.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @constructor
 * 
 * @param {double}
 * 			distanceTolerance
 * @param {boolean}
 *          isEnsureValidTopology
 */
jsts.simplify.DPTransformer = function(
    distanceTolerance, isEnsureValidTopology) {
  this.distanceTolerance = distanceTolerance;
  this.isEnsureValidTopology = isEnsureValidTopology;
};

jsts.simplify.DPTransformer.prototype = new jsts.geom.util.GeometryTransformer();

/**
 * @type {double} 
 */
jsts.simplify.DPTransformer.prototype.distanceTolerance = null;

/**
 * @type {boolean} 
 */
jsts.simplify.DPTransformer.prototype.isEnsureValidTopology = null;

/**
 * @param {jsts.geom.CoordinateSequence}
 *          coords
 * @param {jsts.geom.Geometry}
 *          parent
 * @return {jsts.geom.CoordinateSequence} 
 */
jsts.simplify.DPTransformer.prototype.transformCoordinates = function(
    coords, parent) {
  var inputPts = coords;
  var newPts = null;
  if (inputPts.length == 0) {
    newPts = [];
  } else {
    newPts = jsts.simplify.DouglasPeuckerLineSimplifier.simplify(inputPts, this.distanceTolerance);
  }
  return newPts;
};

/**
 * Simplifies a polygon, fixing it if required.
 * @param {jsts.geom.Polygon}
 *          geom
 * @param {jsts.geom.Geometry}
 *          parent
 * @return {jsts.geom.Geometry} 
 */
jsts.simplify.DPTransformer.prototype.transformPolygon = function(
    geom, parent) {
  // empty geometries are simply removed
  if (geom.isEmpty()) {
    return null;
  }
  var rawGeom = jsts.geom.util.GeometryTransformer.prototype.transformPolygon.apply(this, arguments);
  if (parent instanceof jsts.geom.MultiPolygon) {
    return rawGeom;
  }
  return this.createValidArea(rawGeom);
};

/**
 * Simplifies a LinearRing. If the simplification results
 * in a degenerate ring, remove the component.
 * @param {jsts.geom.LinearRing}
 *          geom
 * @param {jsts.geom.Geometry}
 *          parent
 * @return {jsts.geom.Geometry} 
 */
jsts.simplify.DPTransformer.prototype.transformLinearRing = function(
    geom, parent) {
  var removeDegenerateRings = parent instanceof jsts.geom.Polygon;
  var simpResult = jsts.geom.util.GeometryTransformer.prototype.transformLinearRing.apply(this, arguments);
  if (removeDegenerateRings && !(simpResult instanceof jsts.geom.LinearRing)) {
    return null;
  }
  return simpResult;
};

/**
 * Simplifies a MultiPolygon, fixing it if required.
 * @param {jsts.geom.MultiPolygon}
 *          geom
 * @param {jsts.geom.Geometry}
 *          parent
 * @return {jsts.geom.Geometry} 
 */
jsts.simplify.DPTransformer.prototype.transformMultiPolygon = function(
    geom, parent) {
  var rawGeom = jsts.geom.util.GeometryTransformer.prototype.transformMultiPolygon.apply(this, arguments);
  return this.createValidArea(rawGeom);
};

/**
 * Creates a valid area geometry from one that possibly has
 * bad topology (i.e. self-intersections).
 * Since buffer can handle invalid topology, but always returns
 * valid geometry, constructing a 0-width buffer "corrects" the
 * topology.
 * Note this only works for area geometries, since buffer always returns
 * areas. This also may return empty geometries, if the input
 * has no actual area.
 * @param {jsts.geom.Geometry}
 *          rawAreaGeom
 * @return {jsts.geom.Geometry} 
 */
jsts.simplify.DPTransformer.prototype.createValidArea = function(
    rawAreaGeom) {
  if (this.isEnsureValidTopology) {
    return rawAreaGeom.buffer(0.0);
  }
  return rawAreaGeom;
};
/* ======================================================================
    jsts/geom/util/GeometryExtracter.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @requires jsts/geom/GeometryFilter.js
 */



/**
 * Constructs a filter with a list in which to store the elements found.
 *
 * @param clz the class of the components to extract (null means all types).
 * @param {[]} comps the list to extract into.
 * @extends {jsts.geom.GeometryFilter}
 * @constructor
 */
jsts.geom.util.GeometryExtracter = function(clz, comps) {
  this.clz = clz;
  this.comps = comps;
};

jsts.geom.util.GeometryExtracter.prototype = new jsts.geom.GeometryFilter();


/**
 * @private
 */
jsts.geom.util.GeometryExtracter.prototype.clz = null;


/**
 * @private
 * @type {javascript.util.List}
 */
jsts.geom.util.GeometryExtracter.prototype.comps = null;


/**
 * Extracts the components of type <tt>clz</tt> from a {@link Geometry}
 * and adds them to the provided {@link List} if provided.
 *
 * @param {Geometry} geom the geometry from which to extract.
 * @param {Object} clz
 * @param {javascript.util.ArrayList} [list] the list to add the extracted elements to.
 *
 * @return {javascript.util.ArrayList}
 */
jsts.geom.util.GeometryExtracter.extract = function(geom, clz, list) {
  list = list || new javascript.util.ArrayList();
  if (geom instanceof clz) {
    list.add(geom);
  }
  else if (geom instanceof jsts.geom.GeometryCollection ||
      geom instanceof jsts.geom.MultiPoint ||
      geom instanceof jsts.geom.MultiLineString ||
      geom instanceof jsts.geom.MultiPolygon) {
    geom.apply(new jsts.geom.util.GeometryExtracter(clz, list));
  }
  //skip non-LineString elemental geometries

  return list;
};


/**
 * @param {Geometry} geom
 */
jsts.geom.util.GeometryExtracter.prototype.filter = function(geom) {
  if (this.clz === null || geom instanceof this.clz) {
    this.comps.add(geom);
  }
};
/* ======================================================================
    jsts/operation/overlay/snap/SnapIfNeededOverlayOp.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * @requires jsts/operation/overlay/OverlayOp.js
   * @requires jsts/operation/overlay/snap/SnapOverlayOp.js
   */

  var OverlayOp = jsts.operation.overlay.OverlayOp;
  var SnapOverlayOp = jsts.operation.overlay.snap.SnapOverlayOp;

  /**
   * Performs an overlay operation using snapping and enhanced precision to
   * improve the robustness of the result. This class only uses snapping if an
   * error is detected when running the standard JTS overlay code. Errors
   * detected include thrown exceptions (in particular,
   * {@link TopologyException}) and invalid overlay computations.
   */
  var SnapIfNeededOverlayOp = function(g1, g2) {
    this.geom = [];
    this.geom[0] = g1;
    this.geom[1] = g2;
  };

  SnapIfNeededOverlayOp.overlayOp = function(g0, g1, opCode) {
    var op = new SnapIfNeededOverlayOp(g0, g1);
    return op.getResultGeometry(opCode);
  };

  SnapIfNeededOverlayOp.intersection = function(g0, g1) {
    return overlayOp(g0, g1, OverlayOp.INTERSECTION);
  };

  SnapIfNeededOverlayOp.union = function(g0, g1) {
    return overlayOp(g0, g1, OverlayOp.UNION);
  };

  SnapIfNeededOverlayOp.difference = function(g0, g1) {
    return overlayOp(g0, g1, OverlayOp.DIFFERENCE);
  };

  SnapIfNeededOverlayOp.symDifference = function(g0, g1) {
    return overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE);
  };

  /**
   * @private
   * @type {Array.<jsts.geom.Geometry}
   */
  SnapIfNeededOverlayOp.prototype.geom = null;


  SnapIfNeededOverlayOp.prototype.getResultGeometry = function(opCode) {
    var result = null;
    var isSuccess = false;
    var savedException = null;
    try {
      result = OverlayOp.overlayOp(this.geom[0], this.geom[1], opCode);
      var isValid = true;
      if (isValid)
        isSuccess = true;

    } catch (ex) {
      savedException = ex;
    }
    if (!isSuccess) {
      // this may still throw an exception
      // if so, throw the original exception since it has the input coordinates
      try {
        result = SnapOverlayOp.overlayOp(this.geom[0], this.geom[1], opCode);
      } catch (ex) {
        throw savedException;
      }
    }
    return result;
  };

  jsts.operation.overlay.snap.SnapIfNeededOverlayOp = SnapIfNeededOverlayOp;

})();
/* ======================================================================
    jsts/operation/union/UnaryUnionOp.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

/**
 * @requires jsts/geom/util/GeometryExtracter.js
 * @requires jsts/operation/union/CascadedPolygonUnion.js
 * @requires jsts/operation/union/PointGeometryUnion.js
 * @requires jsts/operation/overlay/OverlayOp.js
 * @requires jsts/operation/overlay/snap/SnapIfNeededOverlayOp.js
 */

  var GeometryExtracter = jsts.geom.util.GeometryExtracter;
  var CascadedPolygonUnion = jsts.operation.union.CascadedPolygonUnion;
  var PointGeometryUnion = jsts.operation.union.PointGeometryUnion;
  var OverlayOp = jsts.operation.overlay.OverlayOp;
  var SnapIfNeededOverlayOp = jsts.operation.overlay.snap.SnapIfNeededOverlayOp;
  var ArrayList = javascript.util.ArrayList;

/**
 * Unions a collection of Geometry or a single Geometry (which may be a
 * collection) together. By using this special-purpose operation over a
 * collection of geometries it is possible to take advantage of various
 * optimizations to improve performance. Heterogeneous
 * {@link GeometryCollection}s are fully supported.
 * <p>
 * The result obeys the following contract:
 * <ul>
 * <li>Unioning a set of overlapping {@link Polygons}s has the effect of
 * merging the areas (i.e. the same effect as iteratively unioning all
 * individual polygons together).
 *
 * <li>Unioning a set of {@link LineString}s has the effect of <b>fully noding</b>
 * and <b>dissolving</b> the input linework. In this context "fully noded"
 * means that there will be a node or endpoint in the output for every endpoint
 * or line segment crossing in the input. "Dissolved" means that any duplicate
 * (e.g. coincident) line segments or portions of line segments will be reduced
 * to a single line segment in the output. This is consistent with the semantics
 * of the {@link Geometry#union(Geometry)} operation. If <b>merged</b> linework
 * is required, the {@link LineMerger} class can be used.
 *
 * <li>Unioning a set of {@link Points}s has the effect of merging al
 * identical points (producing a set with no duplicates).
 * </ul>
 *
 * <tt>UnaryUnion</tt> always operates on the individual components of
 * MultiGeometries. So it is possible to use it to "clean" invalid
 * self-intersecting MultiPolygons (although the polygon components must all
 * still be individually valid.)
 *
 */

  /**
   *
   * @param {jsts.geom.Geometry|Array.
   *          <jsts.geom.Geometry>} geoms a Geometry or Geometry collection.
   * @param {jsts.geom.GeometryFactory}
   *          [geomFact] a GeometryFactory.
   * @constructor
   */
  jsts.operation.union.UnaryUnionOp = function(geoms, geomFact) {
    this.polygons = new ArrayList();
    this.lines = new ArrayList();
    this.points = new ArrayList();

    if (geomFact) {
      this.geomFact = geomFact;
    }

    this.extract(geoms);
  };


  /**
   *
   * @param {jsts.geom.Geometry|Array.
   *          <jsts.geom.Geometry>} geoms a Geometry or Geometry collection.
   * @param {jsts.geom.GeometryFactory}
   *          [gemFact] a GeometryFactory.
   * @return {jsts.geom.Geometry}
   */
  jsts.operation.union.UnaryUnionOp.union = function(geoms, geomFact) {
    var op = new jsts.operation.union.UnaryUnionOp(geoms, geomFact);
    return op.union();
  };


  /**
   * @type {Array.<jsts.geom.Polygon>}
   * @private
   */
  jsts.operation.union.UnaryUnionOp.prototype.polygons = null;


  /**
   * @type {Array.<jsts.geom.Line>}
   * @private
   */
  jsts.operation.union.UnaryUnionOp.prototype.lines = null;


  /**
   * @type {Array.<jsts.geom.Point>}
   * @private
   */
  jsts.operation.union.UnaryUnionOp.prototype.points = null;


  /**
   * @type {jsts.geom.GeometryFactory}
   * @private
   */
  jsts.operation.union.UnaryUnionOp.prototype.geomFact = null;


  /**
   * @param {jsts.geom.Geometry|Array.
   *          <jsts.geom.Geometry>} geoms a Geometry or Geometry collection.
   * @private
   */
  jsts.operation.union.UnaryUnionOp.prototype.extract = function(geoms) {
    if (geoms instanceof ArrayList) {
      for (var i = geoms.iterator(); i.hasNext();) {
        var geom = i.next();
        this.extract(geom);
      }
    } else {
      if (this.geomFact === null) {
        this.geomFact = geoms.getFactory();
      }
      GeometryExtracter.extract(geoms, jsts.geom.Polygon,
          this.polygons);
      GeometryExtracter.extract(geoms, jsts.geom.LineString,
          this.lines);
      GeometryExtracter.extract(geoms, jsts.geom.Point,
          this.points);
    }
  };


  /**
   * Gets the union of the input geometries. If no input geometries were
   * provided, a POINT EMPTY is returned.
   *
   * @return {jsts.geom.Geometry|jsts.geom.GeometryCollection} a Geometry containing the union or an empty GEOMETRYCOLLECTION if no
   *         geometries were provided in the input.
   */
  jsts.operation.union.UnaryUnionOp.prototype.union = function() {
    if (this.geomFact === null) {
      return null;
    }

    /**
     * For points and lines, only a single union operation is required, since
     * the OGC model allowings self-intersecting MultiPoint and
     * MultiLineStrings. This is not the case for polygons, so Cascaded Union is
     * required.
     */

    var unionPoints = null;
    if (this.points.size() > 0) {
      var ptGeom = this.geomFact.buildGeometry(this.points);
      unionPoints = this.unionNoOpt(ptGeom);
    }

    var unionLines = null;
    if (this.lines.size() > 0) {
      var lineGeom = this.geomFact.buildGeometry(this.lines);
      unionLines = this.unionNoOpt(lineGeom);
    }

    var unionPolygons = null;
    if (this.polygons.size() > 0) {
      unionPolygons = CascadedPolygonUnion.union(this.polygons);
    }

    /**
     * Performing two unions is somewhat inefficient, but is mitigated by
     * unioning lines and points first
     */

    var unionLA = this.unionWithNull(unionLines, unionPolygons);
    var union = null;
    if (unionPoints === null) {
      union = unionLA;
    } else if (unionLA === null) {
      union = unionPoints;
    } else {
      union = PointGeometryUnion(unionPoints, unionLA);
    }

    if (union === null) {
      return this.geomFact.createGeometryCollection(null);
    }

    return union;
  };


  /**
   * Computes the union of two geometries, either of both of which may be null.
   *
   * @param {jsts.geom.Geometry}
   *          g0 a Geometry.
   * @param {jsts.geom.Geometry}
   *          g1 a Geometry.
   * @return {?jsts.geom.Geometry} the union of the input(s), returns null if
   *         both inputs are null.
   * @private
   */
  jsts.operation.union.UnaryUnionOp.prototype.unionWithNull = function(g0, g1) {
    if (g0 === null && g1 === null) {
      return null;
    }
    if (g1 === null) {
      return g0;
    }
    if (g0 === null) {
      return g1;
    }
    return g0.union(g1);
  };


  /**
   * Computes a unary union with no extra optimization, and no short-circuiting.
   * Due to the way the overlay operations are implemented, this is still
   * efficient in the case of linear and puntal geometries.
   *
   * @param {Geometry}
   *          g0
   * @return the union of the input geometry.
   * @private
   */
  jsts.operation.union.UnaryUnionOp.prototype.unionNoOpt = function(g0) {
    var empty = this.geomFact.createPoint(null);
    return SnapIfNeededOverlayOp.overlayOp(g0, empty, OverlayOp.UNION);
  };

}());
/* ======================================================================
    jsts/index/kdtree/KdNode.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license
 * notice.
 * See /license.txt for the full text of the license.
 */



/**
 * A node of a {@link KdTree}, which represents one or more points in the same
 * location.
 *
 * Creates a new KdNode. Will call appropriate *initialize-function depending on
 * arguments.
 *
 * @constructor
 */
jsts.index.kdtree.KdNode = function() {
  this.left = null;
  this.right = null;
  this.count = 1;

  if (arguments.length === 2) {
    this.initializeFromCoordinate.apply(this, arguments[0], arguments[1]);
  } else if (arguments.length === 3) {
    this.initializeFromXY.apply(this, arguments[0], arguments[1], arguments[2]);
  }
};


/**
 * Creates a new KdNode.
 *
 * @param {Number}
 *          x coordinate of point.
 * @param {Number}
 *          y coordinate of point.
 * @param {Object}
 *          data a data objects to associate with this node.
 */
jsts.index.kdtree.KdNode.prototype.initializeFromXY = function(x, y, data) {
  this.p = new jsts.geom.Coordinate(x, y);
  this.data = data;
};


/**
 * Creates a new KdNode.
 *
 * @param {jsts.geom.Coordinate}
 *          p point location of new node.
 * @param {Object}
 *          data a data objects to associate with this node.
 */
jsts.index.kdtree.KdNode.prototype.initializeFromCoordinate = function(p, data) {
  this.p = p;
  this.data = data;
};


/**
 * Returns the X coordinate of the node
 *
 * @return {Number} X coordinate of the node.
 */
jsts.index.kdtree.KdNode.prototype.getX = function() {
  return this.p.x;
};


/**
 * Returns the Y coordinate of the node
 *
 * @return {Number} Y coordinate of the node.
 */
jsts.index.kdtree.KdNode.prototype.getY = function() {
  return this.p.y;
};


/**
 * Returns the location of this node
 *
 * @return {jsts.geom.Coordinate} location of this node.
 */
jsts.index.kdtree.KdNode.prototype.getCoordinate = function() {
  return this.p;
};


/**
 * Gets the user data object associated with this node.
 *
 * @return {Object} The data of this node.
 */
jsts.index.kdtree.KdNode.prototype.getData = function() {
  return this.data;
};


/**
 * Returns the left node of the tree
 *
 * @return {jsts.index.kdtree.KdNode} The left node of the tree.
 */
jsts.index.kdtree.KdNode.prototype.getLeft = function() {
  return this.left;
};


/**
 * Returns the right node of the tree
 *
 * @return {jsts.index.kdtree.KdNode} The right node of the tree.
 */
jsts.index.kdtree.KdNode.prototype.getRight = function() {
  return this.right;
};


/**
 * Increments the count by 1
 */
jsts.index.kdtree.KdNode.prototype.increment = function() {
  this.count += 1;
};


/**
 * Returns the number of inserted points that are coincident at this location.
 *
 * @return {Number} Number of inserted points that this node represents.
 */
jsts.index.kdtree.KdNode.prototype.getCount = function() {
  return this.count;
};


/**
 * Tests whether more than one point with this value have been inserted (up to
 * the tolerance)
 *
 * @return {Boolean} true if more than one point have been inserted with this
 *         value.
 */
jsts.index.kdtree.KdNode.prototype.isRepeated = function() {
  return count > 1;
};


/**
 * Sets the left node value
 *
 * @param {jsts.index.kdtree.KdNode}
 *          left The node to be inserted as left.
 */
jsts.index.kdtree.KdNode.prototype.setLeft = function(left) {
  this.left = left;
};


/**
 * Sets the right node value
 *
 * @param {jsts.index.kdtree.KdNode}
 *          right The node to be inserted as right.
 */
jsts.index.kdtree.KdNode.prototype.setRight = function(right) {
  this.right = right;
};
/* ======================================================================
    jsts/algorithm/InteriorPointPoint.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * Computes a point in the interior of an point geometry.
 * <h2>Algorithm</h2>
 * Find a point which is closest to the centroid of the geometry.
 *
 * @version 1.7
 *
 * @constructor
 */
 jsts.algorithm.InteriorPointPoint = function(geometry) {
 
    this.minDistance = Number.MAX_VALUE;
    
    this.interiorPoint = null;
    
    this.centroid = geometry.getCentroid().getCoordinate();
    this.add(geometry);
};

/**
 * Tests the point(s) defined by a Geometry for the best inside point.
 * If a Geometry is not of dimension 0 it is not tested.
 * @param {jsts.geom.Geometry} geometry the geometry to add
 * @private
 */
jsts.algorithm.InteriorPointPoint.prototype.add = function(geometry) {
    if (geometry instanceof jsts.geom.Point) {
        this.addPoint(geometry.getCoordinate());
    } else if (geometry instanceof jsts.geom.GeometryCollection) {
        for (var i = 0; i < geometry.getNumGeometries(); i++) {
            this.add(geometry.getGeometryN(i));
        }
    }
};

/**
 * @private
 */
jsts.algorithm.InteriorPointPoint.prototype.addPoint = function(point) {
    var dist = point.distance(this.centroid);
    if (dist < this.minDistance) {
        this.interiorPoint = new jsts.geom.Coordinate(point);
        this.minDistance = dist;
    }
};

jsts.algorithm.InteriorPointPoint.prototype.getInteriorPoint = function() {
    return this.interiorPoint;
};
/* ======================================================================
    jsts/geom/MultiLineString.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * @requires jsts/geom/GeometryCollection.js
   */

  /**
   * @constructor
   * @extends jsts.geom.GeometryCollection
   */
  jsts.geom.MultiLineString = function(geometries, factory) {
    this.geometries = geometries || [];
    this.factory = factory;
  };

  jsts.geom.MultiLineString.prototype = new jsts.geom.GeometryCollection();
  jsts.geom.MultiLineString.constructor = jsts.geom.MultiLineString;

  jsts.geom.MultiLineString.prototype.getBoundary = function() {
    return (new jsts.operation.BoundaryOp(this)).getBoundary();
  };


  /**
   * @param {Geometry}
   *          other
   * @param {double}
   *          tolerance
   * @return {boolean}
   */
  jsts.geom.MultiLineString.prototype.equalsExact = function(other, tolerance) {
    if (!this.isEquivalentClass(other)) {
      return false;
    }
    return jsts.geom.GeometryCollection.prototype.equalsExact.call(this, other,
        tolerance);
  };

  jsts.geom.MultiLineString.prototype.CLASS_NAME = 'jsts.geom.MultiLineString';

})();
/* ======================================================================
    jsts/io/olParser.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

jsts.io.olParser = function(geometryFactory) {
  this.geometryFactory = geometryFactory || new jsts.geom.GeometryFactory();
};

/**
 * @param geometry
 *          {OpenLayers.Geometry}
 * @return {jsts.geom.Geometry}
 */
jsts.io.olParser.prototype.read = function(geometry) {
  if (geometry instanceof ol.geom.Point) {
    return this.convertFromPoint(geometry);
  } else if (geometry instanceof ol.geom.LineString) {
    return this.convertFromLineString(geometry);
  } else if (geometry instanceof ol.geom.LinearRing) {
    return this.convertFromLinearRing(geometry);
  } else if (geometry instanceof ol.geom.Polygon) {
    return this.convertFromPolygon(geometry);
  } else if (geometry instanceof ol.geom.MultiPoint) {
    return this.convertFromMultiPoint(geometry);
  } else if (geometry instanceof ol.geom.MultiLineString) {
    return this.convertFromMultiLineString(geometry);
  } else if (geometry instanceof ol.geom.MultiPolygon) {
    return this.convertFromMultiPolygon(geometry);
  } else if (geometry instanceof ol.geom.GeometryCollection) {
    return this.convertFromCollection(geometry);
  }
};

jsts.io.olParser.prototype.convertFromPoint = function(point) {
  var coordinates = point.getCoordinates();
  return this.geometryFactory.createPoint(new jsts.geom.Coordinate(coordinates[0],
      coordinates[1]));
};

jsts.io.olParser.prototype.convertFromLineString = function(lineString) {
  return this.geometryFactory.createLineString(lineString.getCoordinates().map(function(coordinates) {
    return new jsts.geom.Coordinate(coordinates[0], coordinates[1]);
  }));
};

jsts.io.olParser.prototype.convertFromLinearRing = function(linearRing) {
  return this.geometryFactory.createLinearRing(linearRing.getCoordinates().map(function(coordinates) {
    return new jsts.geom.Coordinate(coordinates[0], coordinates[1]);
  }));
};

jsts.io.olParser.prototype.convertFromPolygon = function(polygon) {
  var linearRings = polygon.getLinearRings();

  var i;
  var shell = null;
  var holes = [];

  for (i = 0; i < linearRings.length; i++) {
    var linearRing = this.convertFromLinearRing(linearRings[i]);

    if (i === 0) {
      shell = linearRing;
    } else {
      holes.push(linearRing);
    }
  }

  return this.geometryFactory.createPolygon(shell, holes);
};

jsts.io.olParser.prototype.convertFromMultiPoint = function(multiPoint) {
  var points =  multiPoint.getPoints().map(function(point) {
    return this.convertFromPoint(point);
  }, this);

  return this.geometryFactory.createMultiPoint(points);
};

jsts.io.olParser.prototype.convertFromMultiLineString = function(
    multiLineString) {
  var lineStrings = multiLineString.getLineStrings().map(function(lineString) {
    return this.convertFromLineString(lineString);
  }, this);

  return this.geometryFactory.createMultiLineString(lineStrings);
};

jsts.io.olParser.prototype.convertFromMultiPolygon = function(
    multiPolygon) {
  
  var polygons = multiPolygon.getPolygons().map(function(polygon) {
    return this.convertFromPolygon(polygon);
  }, this);
  
  return this.geometryFactory.createMultiPolygon(polygons);
};

jsts.io.olParser.prototype.convertFromCollection = function(collection) {
  var geometries = collection.getGeometries().map(function(geometry) {
    return this.read(geometry);
  }, this);

  return this.geometryFactory.createGeometryCollection(geometries);
};

/**
 * @param geometry
 *          {jsts.geom.Geometry}
 * @return {OpenLayers.Geometry}
 */
jsts.io.olParser.prototype.write = function(geometry) {
  if (geometry.CLASS_NAME === 'jsts.geom.Point') {
    return this.convertToPoint(geometry.coordinate);
  } else if (geometry.CLASS_NAME === 'jsts.geom.LineString') {
    return this.convertToLineString(geometry);
  } else if (geometry.CLASS_NAME === 'jsts.geom.LinearRing') {
    return this.convertToLinearRing(geometry);
  } else if (geometry.CLASS_NAME === 'jsts.geom.Polygon') {
    return this.convertToPolygon(geometry);
  } else if (geometry.CLASS_NAME === 'jsts.geom.MultiPoint') {
    return this.convertToMultiPoint(geometry);
  } else if (geometry.CLASS_NAME === 'jsts.geom.MultiLineString') {
    return this.convertToMultiLineString(geometry);
  } else if (geometry.CLASS_NAME === 'jsts.geom.MultiPolygon') {
    return this.convertToMultiPolygon(geometry);
  } else if (geometry.CLASS_NAME === 'jsts.geom.GeometryCollection') {
    return this.convertToCollection(geometry);
  }
};

jsts.io.olParser.prototype.convertToPoint = function(coordinate) {
  return new ol.geom.Point([coordinate.x, coordinate.y]);
};

jsts.io.olParser.prototype.convertToLineString = function(lineString) {
  var i;
  var points = [];

  for (i = 0; i < lineString.points.length; i++) {
    var coordinate = lineString.points[i];
    points.push(this.convertToPoint(coordinate));
  }

  return new new ol.geom.LineString(points);
};

jsts.io.olParser.prototype.convertToLinearRing = function(linearRing) {
  var i;
  var points = [];

  for (i = 0; i < linearRing.points.length; i++) {
    var coordinate = linearRing.points[i];
    points.push([coordinate.x, coordinate.y]);
  }

  return new ol.geom.LinearRing(points);
};

jsts.io.olParser.prototype.convertToPolygon = function(polygon) {
  var i;
  var rings = [];

  rings.push(this.convertToLinearRing(polygon.shell).getCoordinates());

  for (i = 0; i < polygon.holes.length; i++) {
    var ring = polygon.holes[i];
    rings.push(this.convertToLinearRing(ring).getCoordinates());
  }

  return new ol.geom.Polygon(rings);
};

jsts.io.olParser.prototype.convertToMultiPoint = function(multiPoint) {
  var i;
  var points = [];

  for (i = 0; i < multiPoint.geometries.length; i++) {
    var coordinate = multiPoint.geometries[i].coordinate;
    points.push(new ol.geom.Point([coordinate.x, coordinate.y]));
  }

  return new new ol.geom.MultiPoint(points);
};

jsts.io.olParser.prototype.convertToMultiLineString = function(
    multiLineString) {
  var i;
  var lineStrings = [];

  for (i = 0; i < multiLineString.geometries.length; i++) {
    lineStrings.push(this.convertToLineString(multiLineString.geometries[i]));
  }

  return new ol.geom.MultiLineString(lineStrings);
};

jsts.io.olParser.prototype.convertToMultiPolygon = function(
    multiPolygon) {
  var i;
  var polygons = [];

  for (i = 0; i < multiPolygon.geometries.length; i++) {
    polygons.push(this.convertToPolygon(multiPolygon.geometries[i]));
  }

  return new ol.geom.MultiPolygon(polygons);
};

jsts.io.olParser.prototype.convertToCollection = function(
    geometryCollection) {
  var i;
  var geometries = [];

  for (i = 0; i < geometryCollection.geometries.length; i++) {
    var geometry = geometryCollection.geometries[i];
    var geometryOpenLayers = this.write(geometry);

    geometries.push(geometryOpenLayers);
  }

  return new ol.geom.GeometryCollection(geometries);
};
/* ======================================================================
    jsts/index/bintree/Bintree.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */


/**
 * An <code>BinTree</code> (or "Binary Interval Tree") is a 1-dimensional
 * version of a quadtree. It indexes 1-dimensional intervals (which may be the
 * projection of 2-D objects on an axis). It supports range searching (where the
 * range may be a single point). This structure is dynamic - new items can be
 * added at any time, and it will support deletion of items (although this is
 * not currently implemented).
 * <p>
 * This implementation does not require specifying the extent of the inserted
 * items beforehand. It will automatically expand to accomodate any extent of
 * dataset.
 * <p>
 * The bintree structure is used to provide a primary filter for interval
 * queries. The query() method returns a list of all objects which <i>may</i>
 * intersect the query interval. Note that it may return objects which do not in
 * fact intersect. A secondary filter is required to test for exact
 * intersection. Of course, this secondary filter may consist of other tests
 * besides intersection, such as testing other kinds of spatial relationships.
 * <p>
 * This index is different to the Interval Tree of Edelsbrunner or the Segment
 * Tree of Bentley.
 */
(function() {

  /**
   * @requires jsts/index/bintree/Root.js
   * @requires jsts/index/bintree/Interval.js
   */

  var Interval = jsts.index.bintree.Interval;
  var Root = jsts.index.bintree.Root;

  /**
   * Constructs a new Bintree
   *
   * @constructor
   */
  var Bintree = function() {
    this.root = new Root();

    /**
     * Statistics
     *
     * minExtent is the minimum extent of all items inserted into the tree so
     * far. It is used as a heuristic value to construct non-zero extents for
     * features with zero extent. Start with a non-zero extent, in case the
     * first feature inserted has a zero extent in both directions. This value
     * may be non-optimal, but only one feature will be inserted with this
     * value.
     */
    this.minExtent = 1.0;
  };

  /**
   * Ensure that the Interval for the inserted item has non-zero extents. Use
   * the current minExtent to pad it, if necessary
   *
   * @param {jsts.index.bintree.Interval}
   *          itemInterval the interval.
   * @param {Number}
   *          minExtent used to pad the extent if necessary.
   */
  Bintree.ensureExtent = function(itemInterval, minExtent) {
    var min, max;

    min = itemInterval.getMin();
    max = itemInterval.getMax();

    // has a non-zero extent
    if (min !== max) {
      return itemInterval;
    }

    // pad extent
    if (min === max) {
      min = min - (minExtent / 2.0);
      max = min + (minExtent / 2.0);
    }

    return new Interval(min, max);
  };

  /**
   * Calculates the depth of the tree
   *
   * @return {Number} the depth.
   */
  Bintree.prototype.depth = function() {
    if (this.root !== null) {
      return this.root.depth();
    }
    return 0;
  };

  /**
   * Calculates the size of the tree
   *
   * @return {Number} the size.
   */
  Bintree.prototype.size = function() {
    if (this.root !== null) {
      return this.root.size();
    }
    return 0;
  };


  /**
   * Compute the total number of nodes in the tree
   *
   * @return {Number} the number of nodes in the tree.
   */
  Bintree.prototype.nodeSize = function() {
    if (this.root !== null) {
      return this.root.nodeSize();
    }
    return 0;
  };

  /**
   * Inserts an object in the tree
   *
   * @param {jsts.index.bintree.Interval}
   *          itemInterval the interval for the item.
   * @param {Object}
   *          item the item to insert.
   */
  Bintree.prototype.insert = function(itemInterval, item) {
    this.collectStats(itemInterval);
    var insertInterval = Bintree.ensureExtent(itemInterval, this.minExtent);
    this.root.insert(insertInterval, item);
  };

  /**
   * Removes a single item from the tree.
   *
   * @param {jsts.index.bintree.Interval}
   *          itemInterval the Interval of the item to be removed.
   * @param {Object}
   *          item the item to remove.
   * @return {Boolean} <code>true</code> if the item was found (and thus
   *         removed).
   */
  Bintree.prototype.remove = function(itemInterval, item) {
    var insertInterval = Bintree.ensureExtent(itemInterval, this.minExtent);
    return this.root.remove(insertInterval, item);
  };

  Bintree.prototype.iterator = function() {
    var foundItems = new javascript.util.ArrayList();
    this.root.addAllItems(foundItems);
    return foundItems.iterator();
  };

  /**
   * Queries the tree by Interval or number
   *
   * @param {Number}
   *          x OR {jsts.index.bintree.Interval} x.
   * @return {javascript.util.ArrayList} the found items.
   */
  Bintree.prototype.query = function() {
    if (arguments.length === 2) {
      this.queryAndAdd(arguments[0], arguments[1]);
    } else {
      var x = arguments[0];
      if (!x instanceof Interval) {
        x = new Interval(x, x);
      }

      return this.queryInterval(x);
    }
  };

  /**
   * Queries the tree to find all candidate items which may overlap the query
   * interval. If the query interval is <tt>null</tt>, all items in the tree
   * are found.
   *
   * min and max may be the same value
   *
   * @param {jsts.index.bintree.Interval}
   *          interval the interval to query by.
   */
  Bintree.prototype.queryInterval = function(interval) {
    /**
     * the items that are matched are all items in intervals which overlap the
     * query interval
     */
    var foundItems = new javascript.util.ArrayList();
    this.query(interval, foundItems);
    return foundItems;
  };

  /**
   * Adds items in the tree which potentially overlap the query interval to the
   * given collection. If the query interval is <tt>null</tt>, add all items
   * in the tree.
   *
   * @param {jsts.index.bintree.Interval}
   *          interval a query nterval, or null.
   * @param {javascript.util.ArrayList}
   *          resultItems the candidate items found.
   */
  Bintree.prototype.queryAndAdd = function(interval, foundItems) {
    this.root.addAllItemsFromOverlapping(interval, foundItems);
  };

  Bintree.prototype.collectStats = function(interval) {
    var del = interval.getWidth();
    if (del < this.minExtent && del > 0.0) {
      this.minExtent = del;
    }
  };

  jsts.index.bintree.Bintree = Bintree;
})();
/* ======================================================================
    jsts/algorithm/InteriorPointArea.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * Computes a point in the interior of an areal geometry.
 *
 * <h2>Algorithm</h2>
 * <ul>
 *   <li>Find a Y value which is close to the centre of
 *       the geometry's vertical extent but is different
 *       to any of it's Y ordinates.
 *   <li>Create a horizontal bisector line using the Y value
 *       and the geometry's horizontal extent
 *   <li>Find the intersection between the geometry
 *       and the horizontal bisector line.
 *       The intersection is a collection of lines and points.
 *   <li>Pick the midpoint of the largest intersection geometry
 * </ul>
 *
 * <h3>KNOWN BUGS</h3>
 * <ul>
 * <li>If a fixed precision model is used,
 * in some cases this method may return a point
 * which does not lie in the interior.
 * </ul>
 *
 * @version 1.7
 *
 * @constructor
 */
jsts.algorithm.InteriorPointArea = function(geometry) {
 
    this.factory;
    this.interiorPoint = null;
    this.maxWidth = 0;
    
    this.factory = geometry.getFactory();
    this.add(geometry);
};

jsts.algorithm.InteriorPointArea.avg = function(a, b) {
    return (a + b) / 2;
};

/**
 * Gets the computed interior point.
 *
 * @return {jsts.geom.Coordinate} the coordinate of an interior point
 */
jsts.algorithm.InteriorPointArea.prototype.getInteriorPoint = function() {
    return this.interiorPoint;
};

/**
 * Tests the interior vertices (if any)
 * defined by an areal Geometry for the best inside point.
 * If a component Geometry is not of dimension 2 it is not tested.
 * 
 * @param {jsts.geom.Geometry} geometry the geometry to add
 * @private
 */
jsts.algorithm.InteriorPointArea.prototype.add = function(geometry) {
    if (geometry instanceof jsts.geom.Polygon) {
        this.addPolygon(geometry);
    } else if (geometry instanceof jsts.geom.GeometryCollection) {
        for (var i = 0; i < geometry.getNumGeometries(); i++) {
            this.add(geometry.getGeometryN(i));
        }
    }
};

/**
 * Finds an interior point of a Polygon.
 * @param {jsts.geom.Geometry} geometry the geometry to analyze
 */
jsts.algorithm.InteriorPointArea.prototype.addPolygon = function(geometry) {
    if (geometry.isEmpty()) {
        return;
    }

    var intPt;
    var width = 0;

    var bisector = this.horizontalBisector(geometry);
    if (bisector.getLength() == 0.0) {
        width = 0;
        intPt = bisector.getCoordinate();
    } else {
        var intersections = bisector.intersection(geometry);
        var widestIntersection = this.widestGeometry(intersections);
        width = widestIntersection.getEnvelopeInternal().getWidth();
        intPt = this.centre(widestIntersection.getEnvelopeInternal());
    }
    if (this.interiorPoint == null || width > this.maxWidth) {
        this.interiorPoint = intPt;
        this.maxWidth = width;
    }
};

/**
 * Finds widest geometry
 * @return if geometry is a collection, the widest sub-geometry; otherwise, the geometry itself
 * @private
 */
jsts.algorithm.InteriorPointArea.prototype.widestGeometry = function(obj) {

    if (obj instanceof jsts.geom.GeometryCollection) {
        var gc = obj;
        if (gc.isEmpty()) {
            return gc;
        }

        var widestGeometry = gc.getGeometryN(0);
        // scan remaining geom components to see if any are wider
        for (var i = 1; i < gc.getNumGeometries(); i++) {
            if (gc.getGeometryN(i).getEnvelopeInternal().getWidth() >
                widestGeometry.getEnvelopeInternal().getWidth()) {
                
                widestGeometry = gc.getGeometryN(i);
            }
        }
        return widestGeometry;
    } else if (obj instanceof jsts.geom.Geometry) {
        return obj;
    }
};

/**
 * @protected
 */
jsts.algorithm.InteriorPointArea.prototype.horizontalBisector = function(geometry) {
    var envelope = geometry.getEnvelopeInternal();

    var bisectY = jsts.algorithm.SafeBisectorFinder.getBisectorY(geometry);
    return this.factory.createLineString([
        new jsts.geom.Coordinate(envelope.getMinX(), bisectY),
        new jsts.geom.Coordinate(envelope.getMaxX(), bisectY)
    ]);
};

/**
 * Returns the centre point of the envelope.
 * @param {jsts.geom.Envelope} envelope the envelope to analyze
 * @return {jsts.geom.Coordinate} the centre of the envelope
 */
jsts.algorithm.InteriorPointArea.prototype.centre = function(envelope) {
    return new jsts.geom.Coordinate(
        jsts.algorithm.InteriorPointArea.avg(envelope.getMinX(), envelope.getMaxX()),
        jsts.algorithm.InteriorPointArea.avg(envelope.getMinY(), envelope.getMaxY())
    );
};


/**
 * Finds a safe bisector Y ordinate
 * by projecting to the Y axis
 * and finding the Y-ordinate interval
 * which contains the centre of the Y extent.
 * The centre of this interval is returned as the bisector Y-ordinate.
 *
 * @author mdavis
 *
 * @constructor
 */
jsts.algorithm.SafeBisectorFinder = function(poly) {

    this.poly;

    this.centreY;
    this.hiY = Number.MAX_VALUE;
    this.loY = -Number.MAX_VALUE;


    this.poly = poly;

    // initialize using extremal values
    this.hiY = poly.getEnvelopeInternal().getMaxY();
    this.loY = poly.getEnvelopeInternal().getMinY();
    this.centreY = jsts.algorithm.InteriorPointArea.avg(this.loY, this.hiY);
};

jsts.algorithm.SafeBisectorFinder.getBisectorY = function(poly) {
    var finder = new jsts.algorithm.SafeBisectorFinder(poly);
    return finder.getBisectorY();
};

jsts.algorithm.SafeBisectorFinder.prototype.getBisectorY = function() {
    this.process(this.poly.getExteriorRing());
    for (var i = 0; i < this.poly.getNumInteriorRing(); i++) {
        this.process(this.poly.getInteriorRingN(i));
    }
    var bisectY = jsts.algorithm.InteriorPointArea.avg(this.hiY, this.loY);
    return bisectY;
};

jsts.algorithm.SafeBisectorFinder.prototype.process = function(line) {
    var seq = line.getCoordinateSequence();
    for (var i = 0; i < seq.length; i++) {
        var y = seq[i].y;
        this.updateInterval(y);
    }
};

jsts.algorithm.SafeBisectorFinder.prototype.updateInterval = function(y) {
    if (y <= this.centreY) {
        if (y > this.loY) {
            this.loY = y;
        }
    } else if (y > this.centreY) {
        if (y < this.hiY) {
            this.hiY = y;
        }
    }
};
/* ======================================================================
    jsts/operation/buffer/BufferParameters.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */


/**
 * Contains the parameters which describe how a buffer should be constructed.
 *
 * @constructor
 */
jsts.operation.buffer.BufferParameters = function(quadrantSegments,
    endCapStyle, joinStyle, mitreLimit) {
  if (quadrantSegments)
    this.setQuadrantSegments(quadrantSegments);
  if (endCapStyle)
    this.setEndCapStyle(endCapStyle);
  if (joinStyle)
    this.setJoinStyle(joinStyle);
  if (mitreLimit)
    this.setMitreLimit(mitreLimit);
};


/**
 * Specifies a round line buffer end cap style.
 *
 * @type {int}
 */
jsts.operation.buffer.BufferParameters.CAP_ROUND = 1;


/**
 * Specifies a flat line buffer end cap style.
 *
 * @type {int}
 */
jsts.operation.buffer.BufferParameters.CAP_FLAT = 2;


/**
 * Specifies a square line buffer end cap style.
 *
 * @type {int}
 */
jsts.operation.buffer.BufferParameters.CAP_SQUARE = 3;


/**
 * Specifies a round join style.
 *
 * @type {int}
 */
jsts.operation.buffer.BufferParameters.JOIN_ROUND = 1;


/**
 * Specifies a mitre join style.
 */
jsts.operation.buffer.BufferParameters.JOIN_MITRE = 2;


/**
 * Specifies a bevel join style.
 *
 * @type {int}
 */
jsts.operation.buffer.BufferParameters.JOIN_BEVEL = 3;


/**
 * The default number of facets into which to divide a fillet of 90 degrees. A
 * value of 8 gives less than 2% max error in the buffer distance. For a max
 * error of < 1%, use QS = 12. For a max error of < 0.1%, use QS = 18.
 *
 * @type {int}
 */
jsts.operation.buffer.BufferParameters.DEFAULT_QUADRANT_SEGMENTS = 8;


/**
 * The default mitre limit Allows fairly pointy mitres.
 *
 * @type {double}
 */
jsts.operation.buffer.BufferParameters.DEFAULT_MITRE_LIMIT = 5.0;


/**
 * @type {int}
 * @private
 */
jsts.operation.buffer.BufferParameters.prototype.quadrantSegments = jsts.operation.buffer.BufferParameters.DEFAULT_QUADRANT_SEGMENTS;


/**
 * @type {int}
 * @private
 */
jsts.operation.buffer.BufferParameters.prototype.endCapStyle = jsts.operation.buffer.BufferParameters.CAP_ROUND;


/**
 * @type {int}
 * @private
 */
jsts.operation.buffer.BufferParameters.prototype.joinStyle = jsts.operation.buffer.BufferParameters.JOIN_ROUND;


/**
 * @type {double}
 * @private
 */
jsts.operation.buffer.BufferParameters.prototype.mitreLimit = jsts.operation.buffer.BufferParameters.DEFAULT_MITRE_LIMIT;

/**
 * @type {boolean}
 * @private
 */
jsts.operation.buffer.BufferParameters.prototype._isSingleSided = false;

/**
 * Gets the number of quadrant segments which will be used
 *
 * @return the number of quadrant segments.
 */
jsts.operation.buffer.BufferParameters.prototype.getQuadrantSegments = function() {
  return this.quadrantSegments;
};


/**
 * Sets the number of segments used to approximate a angle fillet
 *
 * @param {int}
 *          quadrantSegments the number of segments in a fillet for a quadrant.
 */
jsts.operation.buffer.BufferParameters.prototype.setQuadrantSegments = function(
    quadrantSegments) {
  this.quadrantSegments = quadrantSegments;
};


/**
 * Sets the number of line segments used to approximate an angle fillet.
 * <ul>
 * <li>If <tt>quadSegs</tt> >= 1, joins are round, and <tt>quadSegs</tt>
 * indicates the number of segments to use to approximate a quarter-circle.
 * <li>If <tt>quadSegs</tt> = 0, joins are bevelled (flat)
 * <li>If <tt>quadSegs</tt> < 0, joins are mitred, and the value of qs
 * indicates the mitre ration limit as
 *
 * <pre>
 * mitreLimit= |
 * <tt>
 * quadSegs
 * </tt>
 * |
 * </pre>
 *
 * </ul>
 * For round joins, <tt>quadSegs</tt> determines the maximum error in the
 * approximation to the true buffer curve. The default value of 8 gives less
 * than 2% max error in the buffer distance. For a max error of < 1%, use QS =
 * 12. For a max error of < 0.1%, use QS = 18. The error is always less than the
 * buffer distance (in other words, the computed buffer curve is always inside
 * the true curve).
 *
 * @param quadrantSegments
 *          the number of segments in a fillet for a quadrant.
 */
jsts.operation.buffer.BufferParameters.prototype.setQuadrantSegments = function(
    quadSegs) {
  this.quadrantSegments = quadSegs;

  /**
   * Indicates how to construct fillets. If qs >= 1, fillet is round, and qs
   * indicates number of segments to use to approximate a quarter-circle. If qs =
   * 0, fillet is bevelled flat (i.e. no filleting is performed) If qs < 0,
   * fillet is mitred, and absolute value of qs indicates maximum length of
   * mitre according to
   *
   * mitreLimit = |qs|
   */
  if (this.quadrantSegments === 0)
    this.joinStyle = jsts.operation.buffer.BufferParameters.JOIN_BEVEL;
  if (this.quadrantSegments < 0) {
    this.joinStyle = jsts.operation.buffer.BufferParameters.JOIN_MITRE;
    this.mitreLimit = Math.abs(this.quadrantSegments);
  }

  if (quadSegs <= 0) {
    this.quadrantSegments = 1;
  }

  /**
   * If join style was set by the quadSegs value, use the default for the actual
   * quadrantSegments value.
   */
  if (this.joinStyle !== jsts.operation.buffer.BufferParameters.JOIN_ROUND) {
    this.quadrantSegments = jsts.operation.buffer.BufferParameters.DEFAULT_QUADRANT_SEGMENTS;
  }
};


/**
 * Computes the maximum distance error due to a given level of approximation to
 * a true arc.
 *
 * @param quadSegs
 *          the number of segments used to approximate a quarter-circle.
 * @return the error of approximation.
 */
jsts.operation.buffer.BufferParameters.bufferDistanceError = function(quadSegs) {
  var alpha = Math.PI / 2.0 / quadSegs;
  return 1 - Math.cos(alpha / 2.0);
};


/**
 * Gets the end cap style.
 *
 * @return the end cap style.
 */
jsts.operation.buffer.BufferParameters.prototype.getEndCapStyle = function() {
  return this.endCapStyle;
};


/**
 * Specifies the end cap style of the generated buffer. The styles supported are
 * {@link #CAP_ROUND}, {@link #CAP_BUTT}, and {@link #CAP_SQUARE}. The
 * default is CAP_ROUND.
 *
 * @param {int}
 *          endCapStyle the end cap style to specify.
 */
jsts.operation.buffer.BufferParameters.prototype.setEndCapStyle = function(
    endCapStyle) {
  this.endCapStyle = endCapStyle;
};


/**
 * Gets the join style
 *
 * @return the join style code.
 */
jsts.operation.buffer.BufferParameters.prototype.getJoinStyle = function() {
  return this.joinStyle;
};


/**
 * Sets the join style for outside (reflex) corners between line segments.
 * Allowable values are {@link JOIN_ROUND} (which is the default),
 * {@link JOIN_MITRE} and {link JOIN_BEVEL}.
 *
 * @param joinStyle
 *          the code for the join style.
 */
jsts.operation.buffer.BufferParameters.prototype.setJoinStyle = function(
    joinStyle) {
  this.joinStyle = joinStyle;
};


/**
 * Gets the mitre ratio limit.
 *
 * @return the limit value.
 */
jsts.operation.buffer.BufferParameters.prototype.getMitreLimit = function() {
  return this.mitreLimit;
};


/**
 * Sets the limit on the mitre ratio used for very sharp corners. The mitre
 * ratio is the ratio of the distance from the corner to the end of the mitred
 * offset corner. When two line segments meet at a sharp angle, a miter join
 * will extend far beyond the original geometry. (and in the extreme case will
 * be infinitely far.) To prevent unreasonable geometry, the mitre limit allows
 * controlling the maximum length of the join corner. Corners with a ratio which
 * exceed the limit will be beveled.
 *
 * @param mitreLimit
 *          the mitre ratio limit.
 */
jsts.operation.buffer.BufferParameters.prototype.setMitreLimit = function(
    mitreLimit) {
  this.mitreLimit = mitreLimit;
};


/**
 * Sets whether the computed buffer should be single-sided. A single-sided
 * buffer is constructed on only one side of each input line.
 * <p>
 * The side used is determined by the sign of the buffer distance:
 * <ul>
 * <li>a positive distance indicates the left-hand side
 * <li>a negative distance indicates the right-hand side
 * </ul>
 * The single-sided buffer of point geometries is the same as the regular
 * buffer.
 * <p>
 * The End Cap Style for single-sided buffers is always ignored, and forced to
 * the equivalent of <tt>CAP_FLAT</tt>.
 *
 * @param isSingleSided
 *          true if a single-sided buffer should be constructed.
 */
jsts.operation.buffer.BufferParameters.prototype.setSingleSided = function(
    isSingleSided) {
  this._isSingleSided = isSingleSided;
};


/**
 * Tests whether the buffer is to be generated on a single side only.
 *
 * @return true if the generated buffer is to be single-sided.
 */
jsts.operation.buffer.BufferParameters.prototype.isSingleSided = function() {
  return this._isSingleSided;
};
/* ======================================================================
    jsts/geom/util/ShortCircuitedGeometryVisitor.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */
 
/**
 * Port source:
 * /jts/jts/java/src/com/vividsolutions/jts/geom/util/ShortCircuitedGeometryVisitor.java
 * Revision: 707
 */

(function() {

/**
 * A visitor to {@link Geometry} componets, which 
 * allows short-circuiting when a defined condition holds.
 *
 * @version 1.7
 */
jsts.geom.util.ShortCircuitedGeometryVisitor = function() {

};

jsts.geom.util.ShortCircuitedGeometryVisitor.prototype.isDone = false;

jsts.geom.util.ShortCircuitedGeometryVisitor.prototype.applyTo = function(geom) {
    for (var i = 0; i < geom.getNumGeometries() && ! this.isDone; i++) {
      var element = geom.getGeometryN(i);
      if (! (element instanceof jsts.geom.GeometryCollection)) {
        this.visit(element);
        if (this.isDone()) {
          this.isDone = true;
          return;
        }
      }
      else
        this.applyTo(element);
    }
  }

jsts.geom.util.ShortCircuitedGeometryVisitor.prototype.visit = function(element) {};

jsts.geom.util.ShortCircuitedGeometryVisitor.prototype.isDone = function() {};

})();
/* ======================================================================
    jsts/operation/predicate/RectangleIntersects.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */
 
/**
 * Port source:
 * /jts/jts/java/src/com/vividsolutions/jts/operation/predicate/RectangleIntersects.java
 * Revision: 707
 */

(function() {

/**
 * @requires jsts/geom/util/ShortCircuitedGeometryVisitor.js
 */

/**
 * Tests whether it can be concluded that a rectangle intersects a geometry,
 * based on the relationship of the envelope(s) of the geometry.
 * 
 * @author Martin Davis
 * @version 1.7
 */
var EnvelopeIntersectsVisitor = function(rectEnv) {
    this.rectEnv = rectEnv;
};

EnvelopeIntersectsVisitor.prototype = new jsts.geom.util.ShortCircuitedGeometryVisitor();
EnvelopeIntersectsVisitor.constructor = EnvelopeIntersectsVisitor;

EnvelopeIntersectsVisitor.prototype.rectEnv = null;
EnvelopeIntersectsVisitor.prototype.intersects = false;

  /**
   * Reports whether it can be concluded that an intersection occurs, 
   * or whether further testing is required.
   * 
   * @return true if an intersection must occur 
   * or false if no conclusion about intersection can be made
   */
  EnvelopeIntersectsVisitor.prototype.intersects = function() {
    return this.intersects;
  }

  EnvelopeIntersectsVisitor.prototype.visit = function(element) {
    var elementEnv = element.getEnvelopeInternal();

    // disjoint => no intersection
    if (!this.rectEnv.intersects(elementEnv)) {
      return;
    }
    // rectangle contains target env => must intersect
    if (this.rectEnv.contains(elementEnv)) {
      this.intersects = true;
      return;
    }
    /**
     * Since the envelopes intersect and the test element is connected, if the
     * test envelope is completely bisected by an edge of the rectangle the
     * element and the rectangle must touch (This is basically an application of
     * the Jordan Curve Theorem). The alternative situation is that the test
     * envelope is "on a corner" of the rectangle envelope, i.e. is not
     * completely bisected. In this case it is not possible to make a conclusion
     * about the presence of an intersection.
     */
    if (elementEnv.getMinX() >= rectEnv.getMinX()
        && elementEnv.getMaxX() <= rectEnv.getMaxX()) {
      this.intersects = true;
      return;
    }
    if (elementEnv.getMinY() >= rectEnv.getMinY()
        && elementEnv.getMaxY() <= rectEnv.getMaxY()) {
      this.intersects = true;
      return;
    }
  }

  EnvelopeIntersectsVisitor.prototype.isDone = function() {
    return this.intersects == true;
  }
  
  
/**
 * A visitor which tests whether it can be 
 * concluded that a geometry contains a vertex of
 * a query geometry.
 * 
 * @author Martin Davis
 * @version 1.7
 */
var GeometryContainsPointVisitor = function(rectangle) {
    this.rectSeq = rectangle.getExteriorRing().getCoordinateSequence();
    this.rectEnv = rectangle.getEnvelopeInternal();
};
GeometryContainsPointVisitor.prototype = new jsts.geom.util.ShortCircuitedGeometryVisitor();
GeometryContainsPointVisitor.constructor = GeometryContainsPointVisitor;

GeometryContainsPointVisitor.prototype.rectSeq = null;
GeometryContainsPointVisitor.prototype.rectEnv = null;
GeometryContainsPointVisitor.prototype.containsPoint = false;

  /**
   * Reports whether it can be concluded that a corner point of the rectangle is
   * contained in the geometry, or whether further testing is required.
   * 
   * @return true if a corner point is contained 
   * or false if no conclusion about intersection can be made
   */
GeometryContainsPointVisitor.prototype.containsPoint = function() {
    return this.containsPoint;
  }

GeometryContainsPointVisitor.prototype.visit = function(geom) {
    // if test geometry is not polygonal this check is not needed
    if (!(geom instanceof jsts.geom.Polygon))
      return;

    // skip if envelopes do not intersect
    var elementEnv = geom.getEnvelopeInternal();
    if (!this.rectEnv.intersects(elementEnv))
      return;

    // test each corner of rectangle for inclusion
    var rectPt = new jsts.geom.Coordinate();
    for (var i = 0; i < 4; i++) {
      this.rectSeq.getCoordinate(i, rectPt);
      if (!elementEnv.contains(rectPt))
        continue;
      // check rect point in poly (rect is known not to touch polygon at this
      // point)
      if (SimplePointInAreaLocator.containsPointInPolygon(rectPt, geom)) {
        this.containsPoint = true;
        return;
      }
    }
  }

  GeometryContainsPointVisitor.prototype.isDone = function() {
    return this.containsPoint == true;
  }
  
/**
 * A visitor to test for intersection between the query
 * rectangle and the line segments of the geometry.
 * 
 * @author Martin Davis
 * 
 * Creates a visitor for checking rectangle intersection
 * with segments
 * 
 * @param rectangle the query rectangle 
 *
 */
var RectangleIntersectsSegmentVisitor = function(rectangle) {
    this.rectEnv = rectangle.getEnvelopeInternal();
    this.rectIntersector = new RectangleLineIntersector(rectEnv);
};
RectangleIntersectsSegmentVisitor.prototype = new jsts.geom.util.ShortCircuitedGeometryVisitor();
RectangleIntersectsSegmentVisitor.constructor = RectangleIntersectsSegmentVisitor;

RectangleIntersectsSegmentVisitor.prototype.rectEnv = null;
RectangleIntersectsSegmentVisitor.prototype.rectIntersector = null;
RectangleIntersectsSegmentVisitor.prototype.hasIntersection = false;
RectangleIntersectsSegmentVisitor.prototype.p0 = null;
RectangleIntersectsSegmentVisitor.prototype.p1 = null;

  /**
   * Reports whether any segment intersection exists.
   * 
   * @return true if a segment intersection exists
   * or false if no segment intersection exists
   */
  RectangleIntersectsSegmentVisitor.prototype.intersects = function() {
    return this.hasIntersection;
  }

  RectangleIntersectsSegmentVisitor.prototype.visit = function(geom) {
    /**
     * It may be the case that the rectangle and the 
     * envelope of the geometry component are disjoint,
     * so it is worth checking this simple condition.
     */
    var elementEnv = geom.getEnvelopeInternal();
    if (!this.rectEnv.intersects(elementEnv))
      return;
    
    // check segment intersections
    // get all lines from geometry component
    // (there may be more than one if it's a multi-ring polygon)
    var lines = LinearComponentExtracter.getLines(geom);
    this.checkIntersectionWithLineStrings(lines);
  }

  RectangleIntersectsSegmentVisitor.prototype.checkIntersectionWithLineStrings = function(lines) {
    for (var i = lines.iterator(); i.hasNext(); ) {
      var testLine = i.next();
      this.checkIntersectionWithSegments(testLine);
      if (this.hasIntersection)
        return;
    }
  }

  RectangleIntersectsSegmentVisitor.prototype.checkIntersectionWithSegments = function(testLine) {
    var seq1 = testLine.getCoordinateSequence();
    // TODO: reworked to use plain arrays instead of original API
    for (var j = 1; j < seq1.length; j++) {
      this.p0 = seq1[j - 1];
      this.p1 = seq1[j];

      if (rectIntersector.intersects(p0, p1)) {
        this.hasIntersection = true;
        return;
      }
    }
  }

  RectangleIntersectsSegmentVisitor.prototype.isDone = function() {
    return this.hasIntersection == true;
  }

/**
 * Implementation of the <tt>intersects</tt> spatial predicate
 * optimized for the case where one {@link Geometry} is a rectangle. 
 * This class works for all
 * input geometries, including {@link GeometryCollection}s.
 * <p>
 * As a further optimization, 
 * this class can be used in batch style
 * to test many geometries
 * against a single rectangle.
 * 
 * @version 1.7
 *
 * Create a new intersects computer for a rectangle.
 * 
 * @param rectangle
 *          a rectangular Polygon
 */
  jsts.operation.predicate.RectangleIntersects = function(rectangle) {
    this.rectangle = rectangle;
    this.rectEnv = rectangle.getEnvelopeInternal();
  }
  
  /**
   * Tests whether a rectangle intersects a given geometry.
   * 
   * @param rectangle
   *          a rectangular Polygon
   * @param b
   *          a Geometry of any type
   * @return true if the geometries intersect
   */
  jsts.operation.predicate.RectangleIntersects.intersects = function(rectangle, b) {
    var rp = new jsts.operation.predicate.RectangleIntersects(rectangle);
    return rp.intersects(b);
  }

  jsts.operation.predicate.RectangleIntersects.prototype.rectangle = null;

  jsts.operation.predicate.RectangleIntersects.prototype.rectEnv = null;

  /**
   * Tests whether the given Geometry intersects
   * the query rectangle.
   * 
   * @param geom the Geometry to test (may be of any type)
   * @return true if the geometry intersects the query rectangle
   */
  jsts.operation.predicate.RectangleIntersects.prototype.intersects = function(geom) {
    if (!this.rectEnv.intersects(geom.getEnvelopeInternal()))
      return false;

    /**
     * Test if rectangle envelope intersects any component envelope.
     * This handles Point components as well
     */
    var visitor = new EnvelopeIntersectsVisitor(this.rectEnv);
    visitor.applyTo(geom);
    if (visitor.intersects())
      return true;

    /**
     * Test if any rectangle vertex is contained in the target geometry
     */
    var ecpVisitor = new GeometryContainsPointVisitor(rectangle);
    ecpVisitor.applyTo(geom);
    if (ecpVisitor.containsPoint())
      return true;

    /**
     * Test if any target geometry line segment intersects the rectangle
     */
    var riVisitor = new RectangleIntersectsSegmentVisitor(rectangle);
    riVisitor.applyTo(geom);
    if (riVisitor.intersects())
      return true;

    return false;
  }
  
})();

/* ======================================================================
    jsts/operation/buffer/BufferBuilder.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * Builds the buffer geometry for a given input geometry and precision model.
 * Allows setting the level of approximation for circular arcs, and the
 * precision model in which to carry out the computation.
 * <p>
 * When computing buffers in floating point double-precision it can happen that
 * the process of iterated noding can fail to converge (terminate). In this case
 * a TopologyException will be thrown. Retrying the computation in a fixed
 * precision can produce more robust results.
 *
 * @param {jsts.operation.buffer.BufferBuilder.BufferParameters}
 *          bufParams
 * @constructor
 */
jsts.operation.buffer.BufferBuilder = function(bufParams) {
  this.bufParams = bufParams;

  this.edgeList = new jsts.geomgraph.EdgeList();
};


/**
 * Compute the change in depth as an edge is crossed from R to L
 *
 * @param {Label}
 *          label
 * @return {Number}
 */
jsts.operation.buffer.BufferBuilder.depthDelta = function(label) {
  var lLoc = label.getLocation(0, jsts.geomgraph.Position.LEFT);
  var rLoc = label.getLocation(0, jsts.geomgraph.Position.RIGHT);
  if (lLoc === jsts.geom.Location.INTERIOR &&
      rLoc === jsts.geom.Location.EXTERIOR)
    return 1;
  else if (lLoc === jsts.geom.Location.EXTERIOR &&
      rLoc === jsts.geom.Location.INTERIOR)
    return -1;
  return 0;
};


/**
 * @type {BufferParameters}
 * @private
 */
jsts.operation.buffer.BufferBuilder.prototype.bufParams = null;


/**
 * @type {PrecisionModel}
 * @private
 */
jsts.operation.buffer.BufferBuilder.prototype.workingPrecisionModel = null;


/**
 * @type {Noder}
 * @private
 */
jsts.operation.buffer.BufferBuilder.prototype.workingNoder = null;


/**
 * @type {GeometryFactory}
 * @private
 */
jsts.operation.buffer.BufferBuilder.prototype.geomFact = null;


/**
 * @type {PlanarGraph}
 * @private
 */
jsts.operation.buffer.BufferBuilder.prototype.graph = null;


/**
 * @type {EdgeList}
 * @private
 */
jsts.operation.buffer.BufferBuilder.prototype.edgeList = null;


/**
 * Sets the precision model to use during the curve computation and noding, if
 * it is different to the precision model of the Geometry. If the precision
 * model is less than the precision of the Geometry precision model, the
 * Geometry must have previously been rounded to that precision.
 *
 * @param pm
 *          the precision model to use.
 */
jsts.operation.buffer.BufferBuilder.prototype.setWorkingPrecisionModel = function(
    pm) {
  this.workingPrecisionModel = pm;
};


/**
 * Sets the {@link Noder} to use during noding. This allows choosing fast but
 * non-robust noding, or slower but robust noding.
 *
 * @param noder
 *          the noder to use.
 */
jsts.operation.buffer.BufferBuilder.prototype.setNoder = function(noder) {
  this.workingNoder = noder;
};

jsts.operation.buffer.BufferBuilder.prototype.buffer = function(g, distance) {
  var precisionModel = this.workingPrecisionModel;
  if (precisionModel === null)
    precisionModel = g.getPrecisionModel();

  // factory must be the same as the one used by the input
  this.geomFact = g.getFactory();

  var curveBuilder = new jsts.operation.buffer.OffsetCurveBuilder(
      precisionModel, this.bufParams);

  var curveSetBuilder = new jsts.operation.buffer.OffsetCurveSetBuilder(g,
      distance, curveBuilder);

  var bufferSegStrList = curveSetBuilder.getCurves();

  // short-circuit test
  if (bufferSegStrList.size() <= 0) {
    return this.createEmptyResultGeometry();
  }

  this.computeNodedEdges(bufferSegStrList, precisionModel);
  this.graph = new jsts.geomgraph.PlanarGraph(
      new jsts.operation.overlay.OverlayNodeFactory());
  this.graph.addEdges(this.edgeList.getEdges());

  var subgraphList = this.createSubgraphs(this.graph);
  var polyBuilder = new jsts.operation.overlay.PolygonBuilder(this.geomFact);
  this.buildSubgraphs(subgraphList, polyBuilder);
  var resultPolyList = polyBuilder.getPolygons();

  // just in case...
  if (resultPolyList.size() <= 0) {
    return this.createEmptyResultGeometry();
  }

  var resultGeom = this.geomFact.buildGeometry(resultPolyList);
  return resultGeom;
};


/**
 * @private
 */
jsts.operation.buffer.BufferBuilder.prototype.getNoder = function(
    precisionModel) {
  if (this.workingNoder !== null)
    return this.workingNoder;

  // otherwise use a fast (but non-robust) noder
  var noder = new jsts.noding.MCIndexNoder();
  var li = new jsts.algorithm.RobustLineIntersector();
  li.setPrecisionModel(precisionModel);
  noder.setSegmentIntersector(new jsts.noding.IntersectionAdder(li));
  return noder;
};


/**
 * @private
 */
jsts.operation.buffer.BufferBuilder.prototype.computeNodedEdges = function(
    bufferSegStrList, precisionModel) {
  var noder = this.getNoder(precisionModel);
  noder.computeNodes(bufferSegStrList);
  var nodedSegStrings = noder.getNodedSubstrings();

  for (var i = nodedSegStrings.iterator(); i.hasNext();) {
    var segStr = i.next();
    var oldLabel = segStr.getData();
    var edge = new jsts.geomgraph.Edge(segStr.getCoordinates(),
        new jsts.geomgraph.Label(oldLabel));
    this.insertUniqueEdge(edge);
  }
};


/**
 * Inserted edges are checked to see if an identical edge already exists. If so,
 * the edge is not inserted, but its label is merged with the existing edge.
 *
 * @protected
 */
jsts.operation.buffer.BufferBuilder.prototype.insertUniqueEdge = function(e) {
  var existingEdge = this.edgeList.findEqualEdge(e);

  // If an identical edge already exists, simply update its label
  if (existingEdge != null) {
    var existingLabel = existingEdge.getLabel();

    var labelToMerge = e.getLabel();
    // check if new edge is in reverse direction to existing edge
    // if so, must flip the label before merging it
    if (!existingEdge.isPointwiseEqual(e)) {
      labelToMerge = new jsts.geomgraph.Label(e.getLabel());
      labelToMerge.flip();
    }
    existingLabel.merge(labelToMerge);

    // compute new depth delta of sum of edges
    var mergeDelta = jsts.operation.buffer.BufferBuilder
        .depthDelta(labelToMerge);
    var existingDelta = existingEdge.getDepthDelta();
    var newDelta = existingDelta + mergeDelta;
    existingEdge.setDepthDelta(newDelta);
  } else {
    // no matching existing edge was found
    // add this new edge to the list of edges in this graph
    this.edgeList.add(e);
    e.setDepthDelta(jsts.operation.buffer.BufferBuilder
        .depthDelta(e.getLabel()));
  }
};


/**
 * @param {PlanarGraph}
 *          graph
 * @private
 */
jsts.operation.buffer.BufferBuilder.prototype.createSubgraphs = function(graph) {
  var subgraphList = [];
  for (var i = graph.getNodes().iterator(); i.hasNext();) {
    var node = i.next();
    if (!node.isVisited()) {
      var subgraph = new jsts.operation.buffer.BufferSubgraph();
      subgraph.create(node);
      subgraphList.push(subgraph);
    }
  }
  /**
   * Sort the subgraphs in descending order of their rightmost coordinate. This
   * ensures that when the Polygons for the subgraphs are built, subgraphs for
   * shells will have been built before the subgraphs for any holes they
   * contain.
   */

  var compare = function(a, b) {
    return a.compareTo(b);
  };
  subgraphList.sort(compare);
  subgraphList.reverse();
  return subgraphList;
};


/**
 * Completes the building of the input subgraphs by depth-labelling them, and
 * adds them to the PolygonBuilder. The subgraph list must be sorted in
 * rightmost-coordinate order.
 *
 * @param {Array}
 *          subgraphList the subgraphs to build.
 * @param {PolygonBuilder}
 *          polyBuilder the PolygonBuilder which will build the final polygons.
 * @private
 */
jsts.operation.buffer.BufferBuilder.prototype.buildSubgraphs = function(
    subgraphList, polyBuilder) {
  var processedGraphs = [];
  for (var i = 0; i < subgraphList.length; i++) {
    var subgraph = subgraphList[i];
    var p = subgraph.getRightmostCoordinate();
    var locater = new jsts.operation.buffer.SubgraphDepthLocater(
        processedGraphs);
    var outsideDepth = locater.getDepth(p);
    subgraph.computeDepth(outsideDepth);
    subgraph.findResultEdges();
    processedGraphs.push(subgraph);
    polyBuilder.add(subgraph.getDirectedEdges(), subgraph.getNodes());
  }
};


/**
 * @private
 */
jsts.operation.buffer.BufferBuilder.convertSegStrings = function(it) {
  var fact = new jsts.geom.GeometryFactory();
  var lines = new javascript.util.ArrayList();
  while (it.hasNext()) {
    var ss = it.next();
    var line = fact.createLineString(ss.getCoordinates());
    lines.add(line);
  }
  return fact.buildGeometry(lines);
};


/**
 * Gets the standard result for an empty buffer. Since buffer always returns a
 * polygonal result, this is chosen to be an empty polygon.
 *
 * @return the empty result geometry.
 * @private
 */
jsts.operation.buffer.BufferBuilder.prototype.createEmptyResultGeometry = function() {
  var emptyGeom = this.geomFact.createPolygon(null, null);
  return emptyGeom;
};
/* ======================================================================
    jsts/noding/SegmentPointComparator.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Implements a robust method of comparing the relative position of two points
 * along the same segment. The coordinates are assumed to lie "near" the
 * segment. This means that this algorithm will only return correct results if
 * the input coordinates have the same precision and correspond to rounded
 * values of exact coordinates lying on the segment.
 *
 */
jsts.noding.SegmentPointComparator = function() {
};

/**
 * Compares two {@link Coordinate}s for their relative position along a segment
 * lying in the specified {@link Octant}.
 *
 * @return -1 node0 occurs first.
 * @return 0 the two nodes are equal.
 * @return 1 node1 occurs first.
 */
jsts.noding.SegmentPointComparator.compare = function(octant, p0, p1) {
  // nodes can only be equal if their coordinates are equal
  if (p0.equals2D(p1))
    return 0;

  var xSign = jsts.noding.SegmentPointComparator.relativeSign(p0.x, p1.x);
  var ySign = jsts.noding.SegmentPointComparator.relativeSign(p0.y, p1.y);

  switch (octant) {
  case 0:
    return jsts.noding.SegmentPointComparator.compareValue(xSign, ySign);
  case 1:
    return jsts.noding.SegmentPointComparator.compareValue(ySign, xSign);
  case 2:
    return jsts.noding.SegmentPointComparator.compareValue(ySign, -xSign);
  case 3:
    return jsts.noding.SegmentPointComparator.compareValue(-xSign, ySign);
  case 4:
    return jsts.noding.SegmentPointComparator.compareValue(-xSign, -ySign);
  case 5:
    return jsts.noding.SegmentPointComparator.compareValue(-ySign, -xSign);
  case 6:
    return jsts.noding.SegmentPointComparator.compareValue(-ySign, xSign);
  case 7:
    return jsts.noding.SegmentPointComparator.compareValue(xSign, -ySign);
  }
  // TODO: Assert.shouldNeverReachHere("invalid octant value");
  return 0;
};
jsts.noding.SegmentPointComparator.relativeSign = function(x0, x1) {
  if (x0 < x1)
    return -1;
  if (x0 > x1)
    return 1;
  return 0;
};

/**
 * @private
 */
jsts.noding.SegmentPointComparator.compareValue = function(compareSign0,
    compareSign1) {
  if (compareSign0 < 0)
    return -1;
  if (compareSign0 > 0)
    return 1;
  if (compareSign1 < 0)
    return -1;
  if (compareSign1 > 0)
    return 1;
  return 0;

};
/* ======================================================================
    jsts/operation/relate/RelateOp.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * Implements the SFS <tt>relate()</tt> operation on two {@link Geometry}s.
 * This class supports specifying a custom {@link BoundaryNodeRule} to be used
 * during the relate computation.
 * <p>
 * <b>Note:</b> custom Boundary Node Rules do not (currently) affect the
 * results of other Geometry methods (such as {@link Geometry#getBoundary}. The
 * results of these methods may not be consistent with the relationship computed
 * by a custom Boundary Node Rule.
 *
 * Creates a new Relate operation with a specified Boundary Node Rule.
 *
 * @param g0
 *          a Geometry to relate.
 * @param g1
 *          another Geometry to relate.
 * @param boundaryNodeRule
 *          the Boundary Node Rule to use.
 *
 * @extends {jsts.operation.GeometryGraphOperation}
 * @constructor
 */
jsts.operation.relate.RelateOp = function() {
  jsts.operation.GeometryGraphOperation.apply(this, arguments);
  this._relate = new jsts.operation.relate.RelateComputer(this.arg);
};

jsts.operation.relate.RelateOp.prototype = new jsts.operation.GeometryGraphOperation();


/**
 * Computes the {@link IntersectionMatrix} for the spatial relationship between
 * two {@link Geometry}s using a specified Boundary Node Rule.
 *
 * @param a
 *          a Geometry to test.
 * @param b
 *          a Geometry to test.
 * @param boundaryNodeRule
 *          the Boundary Node Rule to use.
 * @return the IntersectonMatrix for the spatial relationship between the input
 *         geometries.
 */
jsts.operation.relate.RelateOp.relate = function(a, b, boundaryNodeRule) {
  var relOp = new jsts.operation.relate.RelateOp(a, b, boundaryNodeRule);
  var im = relOp.getIntersectionMatrix();
  return im;
};


/**
 * @type {RelateComputer}
 * @private
 */
jsts.operation.relate.RelateOp.prototype._relate = null;


/**
 * Gets the IntersectionMatrix for the spatial relationship between the input
 * geometries.
 *
 * @return the IntersectonMatrix for the spatial relationship between the input
 *         geometries.
 */
jsts.operation.relate.RelateOp.prototype.getIntersectionMatrix = function() {
  return this._relate.computeIM();
};
/* ======================================================================
    jsts/index/chain/MonotoneChain.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Monotone Chains are a way of partitioning the segments of a linestring to
 * allow for fast searching of intersections. They have the following
 * properties:
 * <ol>
 * <li>the segments within a monotone chain never intersect each other
 * <li>the envelope of any contiguous subset of the segments in a monotone
 * chain is equal to the envelope of the endpoints of the subset.
 * </ol>
 * Property 1 means that there is no need to test pairs of segments from within
 * the same monotone chain for intersection.
 * <p>
 * Property 2 allows an efficient binary search to be used to find the
 * intersection points of two monotone chains. For many types of real-world
 * data, these properties eliminate a large number of segment comparisons,
 * producing substantial speed gains.
 * <p>
 * One of the goals of this implementation of MonotoneChains is to be as space
 * and time efficient as possible. One design choice that aids this is that a
 * MonotoneChain is based on a subarray of a list of points. This means that new
 * arrays of points (potentially very large) do not have to be allocated.
 * <p>
 *
 * MonotoneChains support the following kinds of queries:
 * <ul>
 * <li>Envelope select: determine all the segments in the chain which intersect
 * a given envelope
 * <li>Overlap: determine all the pairs of segments in two chains whose
 * envelopes overlap
 * </ul>
 *
 * This implementation of MonotoneChains uses the concept of internal iterators
 * to return the resultsets for the above queries. This has time and space
 * advantages, since it is not necessary to build lists of instantiated objects
 * to represent the segments returned by the query. However, it does mean that
 * the queries are not thread-safe.
 *
 * @constructor
 */
jsts.index.chain.MonotoneChain = function(pts, start, end, context) {
  this.pts = pts;
  this.start = start;
  this.end = end;
  this.context = context;
};

/**
 * @type {Array.<jsts.geom.Coordinate>}
 * @private
 */
jsts.index.chain.MonotoneChain.prototype.pts = null;
/**
 * @type {number}
 * @private
 */
jsts.index.chain.MonotoneChain.prototype.start = null;
/**
 * @type {number}
 * @private
 */
jsts.index.chain.MonotoneChain.prototype.end = null;
/**
 * @type {Envelope}
 * @private
 */
jsts.index.chain.MonotoneChain.prototype.env = null;
/**
 * user-defined information
 *
 * @type {Object}
 * @private
 */
jsts.index.chain.MonotoneChain.prototype.context = null;
/**
 * useful for optimizing chain comparisons
 *
 * @type {number}
 * @private
 */
jsts.index.chain.MonotoneChain.prototype.id = null;

jsts.index.chain.MonotoneChain.prototype.setId = function(id) {
  this.id = id;
};
jsts.index.chain.MonotoneChain.prototype.getId = function() {
  return this.id;
};

jsts.index.chain.MonotoneChain.prototype.getContext = function() {
  return this.context;
};

jsts.index.chain.MonotoneChain.prototype.getEnvelope = function() {
  if (this.env == null) {
    var p0 = this.pts[this.start];
    var p1 = this.pts[this.end];
    this.env = new jsts.geom.Envelope(p0, p1);
  }
  return this.env;
};

jsts.index.chain.MonotoneChain.prototype.getStartIndex = function() {
  return this.start;
};
jsts.index.chain.MonotoneChain.prototype.getEndIndex = function() {
  return this.end;
};

jsts.index.chain.MonotoneChain.prototype.getLineSegment = function(index, ls) {
  ls.p0 = this.pts[index];
  ls.p1 = this.pts[index + 1];
};
/**
 * Return the subsequence of coordinates forming this chain. Allocates a new
 * array to hold the Coordinates
 */
jsts.index.chain.MonotoneChain.prototype.getCoordinates = function() {
  var coord = [];
  var index = 0;
  for (var i = this.start; i <= this.end; i++) {
    coord[index++] = this.pts[i];
  }
  return coord;
};

/**
 * Determine all the line segments in the chain whose envelopes overlap the
 * searchEnvelope, and process them.
 * <p>
 * The monotone chain search algorithm attempts to optimize performance by not
 * calling the select action on chain segments which it can determine are not in
 * the search envelope. However, it *may* call the select action on segments
 * which do not intersect the search envelope. This saves on the overhead of
 * checking envelope intersection each time, since clients may be able to do
 * this more efficiently.
 *
 * @param {Envelope}
 *          searchEnv the search envelope.
 * @param {MonotoneChainSelectAction}
 *          mcs the select action to execute on selected segments.
 */
jsts.index.chain.MonotoneChain.prototype.select = function(searchEnv, mcs) {
  this.computeSelect2(searchEnv, this.start, this.end, mcs);
};

/**
 * @private
 */
jsts.index.chain.MonotoneChain.prototype.computeSelect2 = function(searchEnv,
    start0, end0, mcs) {
  var p0 = this.pts[start0];
  var p1 = this.pts[end0];
  mcs.tempEnv1.init(p0, p1);

  // terminating condition for the recursion
  if (end0 - start0 === 1) {
    mcs.select(this, start0);
    return;
  }
  // nothing to do if the envelopes don't overlap
  if (!searchEnv.intersects(mcs.tempEnv1))
    return;

  // the chains overlap, so split each in half and iterate (binary search)
  var mid = parseInt((start0 + end0) / 2);

  // Assert: mid != start or end (since we checked above for end - start <= 1)
  // check terminating conditions before recursing
  if (start0 < mid) {
    this.computeSelect2(searchEnv, start0, mid, mcs);
  }
  if (mid < end0) {
    this.computeSelect2(searchEnv, mid, end0, mcs);
  }
};

/**
 * Determine all the line segments in two chains which may overlap, and process
 * them.
 * <p>
 * The monotone chain search algorithm attempts to optimize performance by not
 * calling the overlap action on chain segments which it can determine do not
 * overlap. However, it *may* call the overlap action on segments which do not
 * actually interact. This saves on the overhead of checking intersection each
 * time, since clients may be able to do this more efficiently.
 *
 * @param {MonotoneChain}
 *          searchEnv the search envelope.
 * @param {MonotoneChainOverlapAction}
 *          mco the overlap action to execute on selected segments.
 */
jsts.index.chain.MonotoneChain.prototype.computeOverlaps = function(mc, mco) {
  if (arguments.length === 6) {
    return this.computeOverlaps2.apply(this, arguments);
  }
  this.computeOverlaps2(this.start, this.end, mc, mc.start, mc.end, mco);
};

/**
 * @private
 */
jsts.index.chain.MonotoneChain.prototype.computeOverlaps2 = function(start0,
    end0, mc, start1, end1, mco) {
  var p00 = this.pts[start0];
  var p01 = this.pts[end0];
  var p10 = mc.pts[start1];
  var p11 = mc.pts[end1];
  // Debug.println("computeIntersectsForChain:" + p00 + p01 + p10 + p11);
  // terminating condition for the recursion
  if (end0 - start0 === 1 && end1 - start1 === 1) {
    mco.overlap(this, start0, mc, start1);
    return;
  }
  // nothing to do if the envelopes of these chains don't overlap
  mco.tempEnv1.init(p00, p01);
  mco.tempEnv2.init(p10, p11);
  if (!mco.tempEnv1.intersects(mco.tempEnv2))
    return;

  // the chains overlap, so split each in half and iterate (binary search)
  var mid0 = parseInt((start0 + end0) / 2);
  var mid1 = parseInt((start1 + end1) / 2);

  // Assert: mid != start or end (since we checked above for end - start <= 1)
  // check terminating conditions before recursing
  if (start0 < mid0) {
    if (start1 < mid1)
      this.computeOverlaps2(start0, mid0, mc, start1, mid1, mco);
    if (mid1 < end1)
      this.computeOverlaps2(start0, mid0, mc, mid1, end1, mco);
  }
  if (mid0 < end0) {
    if (start1 < mid1)
      this.computeOverlaps2(mid0, end0, mc, start1, mid1, mco);
    if (mid1 < end1)
      this.computeOverlaps2(mid0, end0, mc, mid1, end1, mco);
  }
};
/* ======================================================================
    jsts/geom/IntersectionMatrix.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * @requires jsts/geom/Location.js
   * @requires jsts/geom/Dimension.js
   */

  var Location = jsts.geom.Location;
  var Dimension = jsts.geom.Dimension;

  /**
   * Models a Dimensionally Extended Nine-Intersection Model (DE-9IM) matrix.
   * This class is used to represent intersection matrices (such as "212FF1FF2")
   * capturing the topological relationship between two {@link Geometry}s. It
   * can also be represent patterns (such as "T*T******")for matching existing
   * matrices.
   *
   * Methods are provided to:
   * <UL>
   * <LI> set and query the elements of the matrix in a convenient fashion
   * <LI> convert to and from the standard string representation (specified in
   * SFS Section 2.1.13.2).
   * <LI> test to see if a matrix matches a given pattern string.
   * </UL>
   * <P>
   *
   * For a description of the DE-9IM, see the <A
   * HREF="http://www.opengis.org/techno/specs.htm">OpenGIS Simple Features
   * Specification for SQL</A>.
   *
   * The entries of the matrix are defined by the constants in the
   * {@link Dimension} class. The indices of the matrix represent the
   * topological locations that occur in a geometry (Interior, Boundary,
   * Exterior). These are provided as constants in the {@link Location} class.
   *
   * @param {string/IntersectionMatrix}
   *          elements
   * @constructor
   */
  jsts.geom.IntersectionMatrix = function(elements) {
    var other = elements;

    if (elements === undefined || elements === null) {
      this.matrix = [[], [], []];
      this.setAll(Dimension.FALSE);
    } else if (typeof elements === 'string') {
      this.set(elements);
    } else if (other instanceof jsts.geom.IntersectionMatrix) {

      this.matrix[Location.INTERIOR][Location.INTERIOR] = other.matrix[Location.INTERIOR][Location.INTERIOR];
      this.matrix[Location.INTERIOR][Location.BOUNDARY] = other.matrix[Location.INTERIOR][Location.BOUNDARY];
      this.matrix[Location.INTERIOR][Location.EXTERIOR] = other.matrix[Location.INTERIOR][Location.EXTERIOR];
      this.matrix[Location.BOUNDARY][Location.INTERIOR] = other.matrix[Location.BOUNDARY][Location.INTERIOR];
      this.matrix[Location.BOUNDARY][Location.BOUNDARY] = other.matrix[Location.BOUNDARY][Location.BOUNDARY];
      this.matrix[Location.BOUNDARY][Location.EXTERIOR] = other.matrix[Location.BOUNDARY][Location.EXTERIOR];
      this.matrix[Location.EXTERIOR][Location.INTERIOR] = other.matrix[Location.EXTERIOR][Location.INTERIOR];
      this.matrix[Location.EXTERIOR][Location.BOUNDARY] = other.matrix[Location.EXTERIOR][Location.BOUNDARY];
      this.matrix[Location.EXTERIOR][Location.EXTERIOR] = other.matrix[Location.EXTERIOR][Location.EXTERIOR];
    }
  };


  /**
   * Internal representation of this <code>IntersectionMatrix</code>.
   *
   * @type {int[][]}
   * @private
   */
  jsts.geom.IntersectionMatrix.prototype.matrix = null;


  /**
   * Adds one matrix to another. Addition is defined by taking the maximum
   * dimension value of each position in the summand matrices.
   *
   * @param {IntersectionMatrix}
   *          im the matrix to add.
   */
  jsts.geom.IntersectionMatrix.prototype.add = function(im) {
    var i, j;
    for (i = 0; i < 3; i++) {
      for (j = 0; j < 3; j++) {
        this.setAtLeast(i, j, im.get(i, j));
      }
    }
  };


  /**
   * Returns true if the dimension value satisfies the dimension symbol.
   *
   * @param {int}
   *          actualDimensionValue a number that can be stored in the
   *          <code>IntersectionMatrix</code> . Possible values are
   *          <code>{TRUE, FALSE, DONTCARE, 0, 1, 2}</code>.
   * @param {string}
   *          requiredDimensionSymbol a character used in the string
   *          representation of an <code>IntersectionMatrix</code>. Possible
   *          values are <code>{T, F, * , 0, 1, 2}</code>.
   * @return {boolean} true if the dimension symbol encompasses the dimension
   *         value.
   */
  jsts.geom.IntersectionMatrix.matches = function(actualDimensionValue,
      requiredDimensionSymbol) {
    if (typeof actualDimensionValue === 'string') {
      return jsts.geom.IntersectionMatrix.matches2.call(this, arguments);
    }

    if (requiredDimensionSymbol === '*') {
      return true;
    }
    if (requiredDimensionSymbol === 'T' &&
        (actualDimensionValue >= 0 || actualDimensionValue === Dimension.TRUE)) {
      return true;
    }
    if (requiredDimensionSymbol === 'F' &&
        actualDimensionValue === Dimension.FALSE) {
      return true;
    }
    if (requiredDimensionSymbol === '0' && actualDimensionValue === Dimension.P) {
      return true;
    }
    if (requiredDimensionSymbol === '1' && actualDimensionValue === Dimension.L) {
      return true;
    }
    if (requiredDimensionSymbol === '2' && actualDimensionValue === Dimension.A) {
      return true;
    }
    return false;
  };


  /**
   * Returns true if each of the actual dimension symbols satisfies the
   * corresponding required dimension symbol.
   *
   * @param {string}
   *          actualDimensionSymbols nine dimension symbols to validate.
   *          Possible values are <code>{T, F, * , 0, 1, 2}</code>.
   * @param {string}
   *          requiredDimensionSymbols nine dimension symbols to validate
   *          against. Possible values are <code>{T, F, * , 0, 1, 2}</code>.
   * @return {boolean} true if each of the required dimension symbols encompass
   *         the corresponding actual dimension symbol.
   */
  jsts.geom.IntersectionMatrix.matches2 = function(actualDimensionSymbols,
      requiredDimensionSymbols) {
    var m = new jsts.geom.IntersectionMatrix(actualDimensionSymbols);
    return m.matches(requiredDimensionSymbols);
  };


  /**
   * Changes the value of one of this <code>IntersectionMatrix</code>s
   * elements.
   *
   * @param {int}
   *          row the row of this <code>IntersectionMatrix</code>, indicating
   *          the interior, boundary or exterior of the first
   *          <code>Geometry.</code>
   * @param {int}
   *          column the column of this <code>IntersectionMatrix</code>,
   *          indicating the interior, boundary or exterior of the second
   *          <code>Geometry.</code>
   * @param {int}
   *          dimensionValue the new value of the element.
   */
  jsts.geom.IntersectionMatrix.prototype.set = function(row, column, dimensionValue) {
    if (typeof row === 'string') {
      this.set2(row);
      return;
    }

    this.matrix[row][column] = dimensionValue;
  };


  /**
   * Changes the elements of this <code>IntersectionMatrix</code> to the
   * dimension symbols in <code>dimensionSymbols</code>.
   *
   * @param {String}
   *          dimensionSymbols nine dimension symbols to which to set this
   *          <code>IntersectionMatrix</code> s elements. Possible values are
   *          <code>{T, F, * , 0, 1, 2}.</code>
   */
  jsts.geom.IntersectionMatrix.prototype.set2 = function(dimensionSymbols) {
    for (var i = 0; i < dimensionSymbols.length(); i++) {
      var row = i / 3;
      var col = i % 3;
      this.matrix[row][col] = Dimension.toDimensionValue(dimensionSymbols
          .charAt(i));
    }
  };


  /**
   * Changes the specified element to <code>minimumDimensionValue</code> if
   * the element is less.
   *
   * @param {int}
   *          row the row of this <code>IntersectionMatrix</code> , indicating
   *          the interior, boundary or exterior of the first
   *          <code>Geometry.</code>
   * @param {int}
   *          column the column of this <code>IntersectionMatrix</code> ,
   *          indicating the interior, boundary or exterior of the second
   *          <code>Geometry.</code>
   * @param {int}
   *          minimumDimensionValue the dimension value with which to compare
   *          the element. The order of dimension values from least to greatest
   *          is <code>{DONTCARE, TRUE, FALSE, 0, 1, 2}</code>.
   */
  jsts.geom.IntersectionMatrix.prototype.setAtLeast = function(row, column,
      minimumDimensionValue) {
    if (arguments.length === 1) {
      this.setAtLeast2(arguments[0]);
      return;
    }

    if (this.matrix[row][column] < minimumDimensionValue) {
      this.matrix[row][column] = minimumDimensionValue;
    }
  };


  /**
   * If row >= 0 and column >= 0, changes the specified element to
   * <code>minimumDimensionValue</code> if the element is less. Does nothing
   * if row <0 or column < 0.
   *
   * @param {int}
   *          row the row of this <code>IntersectionMatrix</code> , indicating
   *          the interior, boundary or exterior of the first
   *          <code>Geometry.</code>
   * @param {int}
   *          column the column of this <code>IntersectionMatrix</code> ,
   *          indicating the interior, boundary or exterior of the second
   *          <code>Geometry.</code>
   * @param {int}
   *          minimumDimensionValue the dimension value with which to compare
   *          the element. The order of dimension values from least to greatest
   *          is <code>{DONTCARE, TRUE, FALSE, 0, 1, 2}</code>.
   */
  jsts.geom.IntersectionMatrix.prototype.setAtLeastIfValid = function(row, column,
      minimumDimensionValue) {
    if (row >= 0 && column >= 0) {
      this.setAtLeast(row, column, minimumDimensionValue);
    }
  };


  /**
   * For each element in this <code>IntersectionMatrix</code>, changes the
   * element to the corresponding minimum dimension symbol if the element is
   * less.
   *
   * @param {string}
   *          minimumDimensionSymbols nine dimension symbols with which to
   *          compare the elements of this <code>IntersectionMatrix</code>.
   *          The order of dimension values from least to greatest is
   *          <code>{DONTCARE, TRUE, FALSE, 0, 1, 2}</code> .
   */
  jsts.geom.IntersectionMatrix.prototype.setAtLeast2 = function(minimumDimensionSymbols) {
    var i;
    for (i = 0; i < minimumDimensionSymbols.length; i++) {
      var row = parseInt(i / 3);
      var col = parseInt(i % 3);
      this.setAtLeast(row, col, jsts.geom.Dimension
          .toDimensionValue(minimumDimensionSymbols.charAt(i)));
    }
  };


  /**
   * Changes the elements of this <code>IntersectionMatrix</code> to
   * <code>dimensionValue</code> .
   *
   * @param {int}
   *          dimensionValue the dimension value to which to set this
   *          <code>IntersectionMatrix</code> s elements. Possible values
   *          <code>{TRUE, FALSE, DONTCARE, 0, 1, 2}</code> .
   */
  jsts.geom.IntersectionMatrix.prototype.setAll = function(dimensionValue) {
    var ai, bi;
    for (ai = 0; ai < 3; ai++) {
      for (bi = 0; bi < 3; bi++) {
        this.matrix[ai][bi] = dimensionValue;
      }
    }
  };


  /**
   * Returns the value of one of this matrix entries. The value of the provided
   * index is one of the values from the {@link Location} class. The value
   * returned is a constant from the {@link Dimension} class.
   *
   * @param {int}
   *          row the row of this <code>IntersectionMatrix</code>, indicating
   *          the interior, boundary or exterior of the first
   *          <code>Geometry.</code>
   * @param {int}
   *          column the column of this <code>IntersectionMatrix</code>,
   *          indicating the interior, boundary or exterior of the second
   *          <code>Geometry.</code>
   * @return {int} the dimension value at the given matrix position.
   */
  jsts.geom.IntersectionMatrix.prototype.get = function(row, column) {
    return this.matrix[row][column];
  };


  /**
   * Returns <code>true</code> if this <code>IntersectionMatrix</code> is
   * FF*FF****.
   *
   * @return {boolean} <code>true</code> if the two <code>Geometry</code>s
   *         related by this <code>IntersectionMatrix</code> are disjoint.
   */
  jsts.geom.IntersectionMatrix.prototype.isDisjoint = function() {
    return this.matrix[Location.INTERIOR][Location.INTERIOR] === Dimension.FALSE &&
        this.matrix[Location.INTERIOR][Location.BOUNDARY] === Dimension.FALSE &&
        this.matrix[Location.BOUNDARY][Location.INTERIOR] === Dimension.FALSE &&
        this.matrix[Location.BOUNDARY][Location.BOUNDARY] === Dimension.FALSE;
  };


  /**
   * Returns <code>true</code> if <code>isDisjoint</code> returns false.
   *
   * @return {boolean} <code>true</code> if the two <code>Geometry</code>s
   *         related by this <code>IntersectionMatrix</code> intersect.
   */
  jsts.geom.IntersectionMatrix.prototype.isIntersects = function() {
    return !this.isDisjoint();
  };


  /**
   * Returns <code>true</code> if this <code>IntersectionMatrix</code> is
   * FT*******, F**T***** or F***T****.
   *
   * @param {int}
   *          dimensionOfGeometryA the dimension of the first
   *          <code>Geometry.</code>
   * @param {int}
   *          dimensionOfGeometryB the dimension of the second
   *          <code>Geometry.</code>
   * @return {boolean} <code>true</code> if the two <code>Geometry</code> s
   *         related by this <code>IntersectionMatrix</code> touch; Returns
   *         false if both <code>Geometry</code>s are points.
   */
  jsts.geom.IntersectionMatrix.prototype.isTouches = function(dimensionOfGeometryA,
      dimensionOfGeometryB) {
    if (dimensionOfGeometryA > dimensionOfGeometryB) {
      // no need to get transpose because pattern matrix is symmetrical
      return this.isTouches(dimensionOfGeometryB, dimensionOfGeometryA);
    }
    if ((dimensionOfGeometryA == Dimension.A && dimensionOfGeometryB == Dimension.A) ||
        (dimensionOfGeometryA == Dimension.L && dimensionOfGeometryB == Dimension.L) ||
        (dimensionOfGeometryA == Dimension.L && dimensionOfGeometryB == Dimension.A) ||
        (dimensionOfGeometryA == Dimension.P && dimensionOfGeometryB == Dimension.A) ||
        (dimensionOfGeometryA == Dimension.P && dimensionOfGeometryB == Dimension.L)) {
      return this.matrix[Location.INTERIOR][Location.INTERIOR] === Dimension.FALSE &&
          (jsts.geom.IntersectionMatrix.matches(
              this.matrix[Location.INTERIOR][Location.BOUNDARY], 'T') ||
              jsts.geom.IntersectionMatrix.matches(
                  this.matrix[Location.BOUNDARY][Location.INTERIOR], 'T') || jsts.geom.IntersectionMatrix
              .matches(this.matrix[Location.BOUNDARY][Location.BOUNDARY], 'T'));
    }
    return false;
  };


  /**
   * Tests whether this geometry crosses the specified geometry.
   * <p>
   * The <code>crosses</code> predicate has the following equivalent
   * definitions:
   * <ul>
   * <li>The geometries have some but not all interior points in common.
   * <li>The DE-9IM Intersection Matrix for the two geometries is
   * <ul>
   * <li>T*T****** (for P/L, P/A, and L/A situations)
   * <li>T*****T** (for L/P, L/A, and A/L situations)
   * <li>0******** (for L/L situations)
   * </ul>
   * </ul>
   * For any other combination of dimensions this predicate returns
   * <code>false</code>.
   * <p>
   * The SFS defined this predicate only for P/L, P/A, L/L, and L/A situations.
   * JTS extends the definition to apply to L/P, A/P and A/L situations as well.
   * This makes the relation symmetric.
   *
   * @param {int}
   *          dimensionOfGeometryA the dimension of the first
   *          <code>Geometry.</code>
   * @param {int}
   *          dimensionOfGeometryB the dimension of the second
   *          <code>Geometry.</code>
   * @return {boolean} <code>true</code> if the two <code>Geometry</code>s
   *         related by this <code>IntersectionMatrix</code> cross.
   */
  jsts.geom.IntersectionMatrix.prototype.isCrosses = function(dimensionOfGeometryA,
      dimensionOfGeometryB) {
    if ((dimensionOfGeometryA == Dimension.P && dimensionOfGeometryB == Dimension.L) ||
        (dimensionOfGeometryA == Dimension.P && dimensionOfGeometryB == Dimension.A) ||
        (dimensionOfGeometryA == Dimension.L && dimensionOfGeometryB == Dimension.A)) {
      return jsts.geom.IntersectionMatrix.matches(
          this.matrix[Location.INTERIOR][Location.INTERIOR], 'T') &&
          jsts.geom.IntersectionMatrix.matches(
              this.matrix[Location.INTERIOR][Location.EXTERIOR], 'T');
    }
    if ((dimensionOfGeometryA == Dimension.L && dimensionOfGeometryB == Dimension.P) ||
        (dimensionOfGeometryA == Dimension.A && dimensionOfGeometryB == Dimension.P) ||
        (dimensionOfGeometryA == Dimension.A && dimensionOfGeometryB == Dimension.L)) {
      return jsts.geom.IntersectionMatrix.matches(
          matrix[Location.INTERIOR][Location.INTERIOR], 'T') &&
          jsts.geom.IntersectionMatrix.matches(
              this.matrix[Location.EXTERIOR][Location.INTERIOR], 'T');
    }
    if (dimensionOfGeometryA === Dimension.L &&
        dimensionOfGeometryB === Dimension.L) {
      return this.matrix[Location.INTERIOR][Location.INTERIOR] === 0;
    }
    return false;
  };


  /**
   * Tests whether this <code>IntersectionMatrix</code> is T*F**F***.
   *
   * @return {boolean} <code>true</code> if the first <code>Geometry</code>
   *         is within the second.
   */
  jsts.geom.IntersectionMatrix.prototype.isWithin = function() {
    return jsts.geom.IntersectionMatrix.matches(
        this.matrix[Location.INTERIOR][Location.INTERIOR], 'T') &&
        this.matrix[Location.INTERIOR][Location.EXTERIOR] == Dimension.FALSE &&
        this.matrix[Location.BOUNDARY][Location.EXTERIOR] == Dimension.FALSE;
  };


  /**
   * Tests whether this <code>IntersectionMatrix</code> is T*****FF*.
   *
   * @return {boolean} <code>true</code> if the first <code>Geometry</code>
   *         contains the second.
   */
  jsts.geom.IntersectionMatrix.prototype.isContains = function() {
    return jsts.geom.IntersectionMatrix.matches(
        this.matrix[Location.INTERIOR][Location.INTERIOR], 'T') &&
        this.matrix[Location.EXTERIOR][Location.INTERIOR] == Dimension.FALSE &&
        this.matrix[Location.EXTERIOR][Location.BOUNDARY] == Dimension.FALSE;
  };


  /**
   * Returns <code>true</code> if this <code>IntersectionMatrix</code> is
   * <code>T*****FF*</code> or <code>*T****FF*</code> or
   * <code>***T**FF*</code> or <code>****T*FF*</code>
   *
   * @return {boolean} <code>true</code> if the first <code>Geometry</code>
   *         covers the second.
   */
  jsts.geom.IntersectionMatrix.prototype.isCovers = function() {
    var hasPointInCommon = jsts.geom.IntersectionMatrix.matches(
        this.matrix[Location.INTERIOR][Location.INTERIOR], 'T') ||
        jsts.geom.IntersectionMatrix.matches(
            this.matrix[Location.INTERIOR][Location.BOUNDARY], 'T') ||
        jsts.geom.IntersectionMatrix.matches(
            this.matrix[Location.BOUNDARY][Location.INTERIOR], 'T') ||
        jsts.geom.IntersectionMatrix.matches(
            this.matrix[Location.BOUNDARY][Location.BOUNDARY], 'T');

    return hasPointInCommon &&
        this.matrix[Location.EXTERIOR][Location.INTERIOR] == Dimension.FALSE &&
        this.matrix[Location.EXTERIOR][Location.BOUNDARY] == Dimension.FALSE;
  };


  /**
   * Returns <code>true</code> if this <code>IntersectionMatrix</code> is
   * <code>T*F**F***</code> or <code>*TF**F***</code> or
   * <code>**FT*F***</code> or <code>**F*TF***</code>
   *
   * @return {boolean} <code>true</code> if the first <code>Geometry</code>
   *         is covered by the second.
   */
  jsts.geom.IntersectionMatrix.prototype.isCoveredBy = function() {
    var hasPointInCommon = jsts.geom.IntersectionMatrix.matches(
        this.matrix[Location.INTERIOR][Location.INTERIOR], 'T') ||
        jsts.geom.IntersectionMatrix.matches(
            this.matrix[Location.INTERIOR][Location.BOUNDARY], 'T') ||
        jsts.geom.IntersectionMatrix.matches(
            this.matrix[Location.BOUNDARY][Location.INTERIOR], 'T') ||
        jsts.geom.IntersectionMatrix.matches(
            this.matrix[Location.BOUNDARY][Location.BOUNDARY], 'T');

    return hasPointInCommon &&
        this.matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE &&
        this.matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE;
  };


  /**
   * Returns <code>true</code> if this <code>IntersectionMatrix</code> is
   * T*F**FFF*.
   *
   * @param {int}
   *          dimensionOfGeometryA the dimension of the first
   *          <code>Geometry.</code>
   * @param {int}
   *          dimensionOfGeometryB the dimension of the second
   *          <code>Geometry.</code>
   * @return {boolean} <code>true</code> if the two <code>Geometry</code> s
   *         related by this <code>IntersectionMatrix</code> are equal; the
   *         <code>Geometry</code>s must have the same dimension for this
   *         function to return <code>true.</code>
   */
  jsts.geom.IntersectionMatrix.prototype.isEquals = function(dimensionOfGeometryA,
      dimensionOfGeometryB) {
    if (dimensionOfGeometryA !== dimensionOfGeometryB) {
      return false;
    }
    return jsts.geom.IntersectionMatrix.matches(
        this.matrix[Location.INTERIOR][Location.INTERIOR], 'T') &&
        this.matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE &&
        this.matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE &&
        this.matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE &&
        this.matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE;
  };


  /**
   * Returns <code>true</code> if this <code>IntersectionMatrix</code> is
   * <UL>
   * <LI> T*T***T** (for two points or two surfaces)
   * <LI> 1*T***T** (for two curves)
   * </UL>.
   *
   * @param {int}
   *          dimensionOfGeometryA the dimension of the first
   *          <code>Geometry.</code>
   * @param {int}
   *          dimensionOfGeometryB the dimension of the second
   *          <code>Geometry.</code>
   * @return {boolean} <code>true</code> if the two <code>Geometry</code>s
   *         related by this <code>IntersectionMatrix</code> overlap. For this
   *         function to return <code>true</code>, the <code>Geometry</code>s
   *         must be two points, two curves or two surfaces.
   */
  jsts.geom.IntersectionMatrix.prototype.isOverlaps = function(dimensionOfGeometryA,
      dimensionOfGeometryB) {
    if ((dimensionOfGeometryA == Dimension.P && dimensionOfGeometryB === Dimension.P) ||
        (dimensionOfGeometryA == Dimension.A && dimensionOfGeometryB === Dimension.A)) {
      return jsts.geom.IntersectionMatrix.matches(
          this.matrix[Location.INTERIOR][Location.INTERIOR], 'T') &&
          jsts.geom.IntersectionMatrix.matches(
              this.matrix[Location.INTERIOR][Location.EXTERIOR], 'T') &&
          jsts.geom.IntersectionMatrix.matches(
              this.matrix[Location.EXTERIOR][Location.INTERIOR], 'T');
    }
    if (dimensionOfGeometryA === Dimension.L &&
        dimensionOfGeometryB === Dimension.L) {
      return this.matrix[Location.INTERIOR][Location.INTERIOR] == 1 &&
          jsts.geom.IntersectionMatrix.matches(
              this.matrix[Location.INTERIOR][Location.EXTERIOR], 'T') &&
          jsts.geom.IntersectionMatrix.matches(
              this.matrix[Location.EXTERIOR][Location.INTERIOR], 'T');
    }
    return false;
  };


  /**
   * Returns whether the elements of this <code>IntersectionMatrix</code>
   * satisfies the required dimension symbols.
   *
   * @param {string}
   *          requiredDimensionSymbols nine dimension symbols with which to
   *          compare the elements of this <code>IntersectionMatrix</code>.
   *          Possible values are <code>{T, F, * , 0, 1, 2}</code>.
   * @return {boolean} <code>true</code> if this
   *         <code>IntersectionMatrix</code> matches the required dimension
   *         symbols.
   */
  jsts.geom.IntersectionMatrix.prototype.matches = function(requiredDimensionSymbols) {
    if (requiredDimensionSymbols.length != 9) {
      throw new jsts.error.IllegalArgumentException('Should be length 9: ' +
          requiredDimensionSymbols);
    }
    for (var ai = 0; ai < 3; ai++) {
      for (var bi = 0; bi < 3; bi++) {
        if (!jsts.geom.IntersectionMatrix.matches(this.matrix[ai][bi],
            requiredDimensionSymbols.charAt(3 * ai + bi))) {
          return false;
        }
      }
    }
    return true;
  };


  /**
   * Transposes this jsts.geom.IntersectionMatrix.
   *
   * @return {IntersectionMatrix} this <code>IntersectionMatrix</code> as a
   *         convenience.
   */
  jsts.geom.IntersectionMatrix.prototype.transpose = function() {
    var temp = matrix[1][0];
    this.matrix[1][0] = this.matrix[0][1];
    this.matrix[0][1] = temp;
    temp = this.matrix[2][0];
    this.matrix[2][0] = this.matrix[0][2];
    this.matrix[0][2] = temp;
    temp = this.matrix[2][1];
    this.matrix[2][1] = this.matrix[1][2];
    this.matrix[1][2] = temp;
    return this;
  };


  /**
   * Returns a nine-character <code>String</code> representation of this
   * <code>IntersectionMatrix</code> .
   *
   * @return {string} the nine dimension symbols of this
   *         <code>IntersectionMatrix</code> in row-major order.
   */
  jsts.geom.IntersectionMatrix.prototype.toString = function() {
    var ai, bi, buf = '';
    for (ai = 0; ai < 3; ai++) {
      for (bi = 0; bi < 3; bi++) {
        buf += Dimension.toDimensionSymbol(this.matrix[ai][bi]);
      }
    }
    return buf;
  };

})();
/* ======================================================================
    jsts/triangulate/quadedge/LastFoundQuadEdgeLocator.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * Locates {@link QuadEdge}s in a {@link QuadEdgeSubdivision},
 * optimizing the search by starting in the
 * locality of the last edge found.
 *
 * @author Martin Davis
 */

/**
 * @constructor
 * @param {jsts.triangulate.quadedge.QuadEdgeSubdivision}
 *          subdiv the subdivision.
 */
jsts.triangulate.quadedge.LastFoundQuadEdgeLocator = function(subdiv) {
  this.subdiv = subdiv;
  this.lastEdge = null;
  this.init();
};

jsts.triangulate.quadedge.LastFoundQuadEdgeLocator.prototype.init = function() {
  this.lastEdge = this.findEdge();
};

jsts.triangulate.quadedge.LastFoundQuadEdgeLocator.prototype.findEdge = function() {
  var edges = this.subdiv.getEdges();
  return edges[0];
};

/**
 * Locates an edge e, such that either v is on e, or e is an edge of a triangle containing v.
 * The search starts from the last located edge amd proceeds on the general direction of v.
 *
 * @param {jsts.triangulate.quadedge.Vertex}
 *          v the vertex.
 */
jsts.triangulate.quadedge.LastFoundQuadEdgeLocator.prototype.locate = function(v) {
    if (!this.lastEdge.isLive()) {
        this.init();
    }

    var e = this.subdiv.locateFromEdge(v, this.lastEdge);
    this.lastEdge = e;
    return e;
};
/* ======================================================================
    jsts/noding/SegmentNodeList.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Port source: /jts/jts/java/src/com/vividsolutions/jts/noding/SegmentNodeList.java
 * Revision: 478
 */


/**
 * A list of the {@link SegmentNode}s present along a noded
 * {@link SegmentString}.
 *
 * @constructor
 */
jsts.noding.SegmentNodeList = function(edge) {
  this.nodeMap = new javascript.util.TreeMap();

  this.edge = edge;
};


/**
 * @type {javascript.util.TreeMap}
 * @private
 */
jsts.noding.SegmentNodeList.prototype.nodeMap = null;

/**
 * returns an iterator of SegmentNodes
 */
jsts.noding.SegmentNodeList.prototype.iterator = function() {
  return this.nodeMap.values().iterator();
};


/**
 * the parent edge
 *
 * @type {NodedSegmentString}
 * @private
 */
jsts.noding.SegmentNodeList.prototype.edge = null;


jsts.noding.SegmentNodeList.prototype.getEdge = function() {
  return this.edge;
};


/**
 * Adds an intersection into the list, if it isn't already there. The input
 * segmentIndex and dist are expected to be normalized.
 *
 * @return the SegmentIntersection found or added.
 */
jsts.noding.SegmentNodeList.prototype.add = function(intPt, segmentIndex) {
  var eiNew = new jsts.noding.SegmentNode(this.edge, intPt, segmentIndex,
      this.edge.getSegmentOctant(segmentIndex));
  var ei = this.nodeMap.get(eiNew);
  if (ei !== null) {
    jsts.util.Assert.isTrue(ei.coord.equals2D(intPt),
        'Found equal nodes with different coordinates');
    return ei;
  }
  // node does not exist, so create it
  this.nodeMap.put(eiNew, eiNew);
  return eiNew;
};


/**
 * Adds nodes for the first and last points of the edge
 *
 * @private
 */
jsts.noding.SegmentNodeList.prototype.addEndpoints = function() {
  var maxSegIndex = this.edge.size() - 1;
  this.add(this.edge.getCoordinate(0), 0);
  this.add(this.edge.getCoordinate(maxSegIndex), maxSegIndex);
};


/**
 * Adds nodes for any collapsed edge pairs. Collapsed edge pairs can be caused
 * by inserted nodes, or they can be pre-existing in the edge vertex list. In
 * order to provide the correct fully noded semantics, the vertex at the base of
 * a collapsed pair must also be added as a node.
 *
 * @private
 */
jsts.noding.SegmentNodeList.prototype.addCollapsedNodes = function() {
  var collapsedVertexIndexes = [];

  this.findCollapsesFromInsertedNodes(collapsedVertexIndexes);
  this.findCollapsesFromExistingVertices(collapsedVertexIndexes);

  // node the collapses
  for (var i = 0; i < collapsedVertexIndexes.length; i++) {
    var vertexIndex = collapsedVertexIndexes[i];
    this.add(this.edge.getCoordinate(vertexIndex), vertexIndex);
  }
};


/**
 * Adds nodes for any collapsed edge pairs which are pre-existing in the vertex
 * list.
 *
 * @private
 */
jsts.noding.SegmentNodeList.prototype.findCollapsesFromExistingVertices = function(
    collapsedVertexIndexes) {
  for (var i = 0; i < this.edge.size() - 2; i++) {
    var p0 = this.edge.getCoordinate(i);
    var p1 = this.edge.getCoordinate(i + 1);
    var p2 = this.edge.getCoordinate(i + 2);
    if (p0.equals2D(p2)) {
      // add base of collapse as node
      collapsedVertexIndexes.push(i + 1);
    }
  }
};


/**
 * Adds nodes for any collapsed edge pairs caused by inserted nodes Collapsed
 * edge pairs occur when the same coordinate is inserted as a node both before
 * and after an existing edge vertex. To provide the correct fully noded
 * semantics, the vertex must be added as a node as well.
 *
 * @private
 */
jsts.noding.SegmentNodeList.prototype.findCollapsesFromInsertedNodes = function(
    collapsedVertexIndexes) {
  var collapsedVertexIndex = [null];
  var it = this.iterator();
  // there should always be at least two entries in the list, since the
  // endpoints are nodes
  var eiPrev = it.next();
  while (it.hasNext()) {
    var ei = it.next();
    var isCollapsed = this.findCollapseIndex(eiPrev, ei, collapsedVertexIndex);
    if (isCollapsed)
      collapsedVertexIndexes.push(collapsedVertexIndex[0]);

    eiPrev = ei;
  }
};


/**
 * @private
 */
jsts.noding.SegmentNodeList.prototype.findCollapseIndex = function(ei0, ei1,
    collapsedVertexIndex) {
  // only looking for equal nodes
  if (!ei0.coord.equals2D(ei1.coord))
    return false;

  var numVerticesBetween = ei1.segmentIndex - ei0.segmentIndex;
  if (!ei1.isInterior()) {
    numVerticesBetween--;
  }

  // if there is a single vertex between the two equal nodes, this is a collapse
  if (numVerticesBetween === 1) {
    collapsedVertexIndex[0] = ei0.segmentIndex + 1;
    return true;
  }
  return false;
};


/**
 * Creates new edges for all the edges that the intersections in this list split
 * the parent edge into. Adds the edges to the provided argument list (this is
 * so a single list can be used to accumulate all split edges for a set of
 * {@link SegmentString}s).
 *
 * @param {Array}
 *          edgeList
 */
jsts.noding.SegmentNodeList.prototype.addSplitEdges = function(edgeList) {
  // ensure that the list has entries for the first and last point of the edge
  this.addEndpoints();
  this.addCollapsedNodes();

  var it = this.iterator();
  // there should always be at least two entries in the list, since the
  // endpoints are nodes
  var eiPrev = it.next();
  while (it.hasNext()) {
    var ei = it.next();
    var newEdge = this.createSplitEdge(eiPrev, ei);
    edgeList.add(newEdge);
    eiPrev = ei;
  }
};


/**
 * Checks the correctness of the set of split edges corresponding to this edge.
 *
 * @param {Array}
 *          splitEdges the split edges for this edge (in order).
 * @private
 */
jsts.noding.SegmentNodeList.prototype.checkSplitEdgesCorrectness = function(
    splitEdges) {
  var edgePts = edge.getCoordinates();

  // check that first and last points of split edges are same as endpoints of
  // edge
  var split0 = splitEdges[0];
  var pt0 = split0.getCoordinate(0);
  if (!pt0.equals2D(edgePts[0]))
    throw new Error('bad split edge start point at ' + pt0);

  var splitn = splitEdges[splitEdges.length - 1];
  var splitnPts = splitn.getCoordinates();
  var ptn = splitnPts[splitnPts.length - 1];
  if (!ptn.equals2D(edgePts[edgePts.length - 1]))
    throw new Error('bad split edge end point at ' + ptn);
};


/**
 * Create a new "split edge" with the section of points between (and including)
 * the two intersections. The label for the new edge is the same as the label
 * for the parent edge.
 *
 * @private
 */
jsts.noding.SegmentNodeList.prototype.createSplitEdge = function(ei0, ei1) {
  var npts = ei1.segmentIndex - ei0.segmentIndex + 2;

  var lastSegStartPt = this.edge.getCoordinate(ei1.segmentIndex);
  // if the last intersection point is not equal to the its segment start pt,
  // add it to the points list as well.
  // (This check is needed because the distance metric is not totally reliable!)
  // The check for point equality is 2D only - Z values are ignored
  var useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);
  if (!useIntPt1) {
    npts--;
  }

  var pts = [];
  // pts.length = npts;
  var ipt = 0;
  pts[ipt++] = new jsts.geom.Coordinate(ei0.coord);
  for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {
    pts[ipt++] = this.edge.getCoordinate(i);
  }
  if (useIntPt1)
    pts[ipt] = ei1.coord;

  return new jsts.noding.NodedSegmentString(pts, this.edge.getData());
};
/* ======================================================================
    jsts/io/WKTWriter.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * Writes the Well-Known Text representation of a {@link Geometry}. The
 * Well-Known Text format is defined in the <A
 * HREF="http://www.opengis.org/techno/specs.htm"> OGC Simple Features
 * Specification for SQL</A>.
 * <p>
 * The <code>WKTWriter</code> outputs coordinates rounded to the precision
 * model. Only the maximum number of decimal places necessary to represent the
 * ordinates to the required precision will be output.
 * <p>
 * The SFS WKT spec does not define a special tag for {@link LinearRing}s.
 * Under the spec, rings are output as <code>LINESTRING</code>s.
 *
 * @see WKTReader
 * @constructor
 */
jsts.io.WKTWriter = function() {
  this.parser = new jsts.io.WKTParser(this.geometryFactory);
};


/**
 * Converts a <code>Geometry</code> to its Well-known Text representation.
 *
 * @param {jsts.geom.Geometry}
 *          geometry a <code>Geometry</code> to process.
 * @return {string} a <Geometry Tagged Text> string (see the OpenGIS Simple
 *         Features Specification).
 */
jsts.io.WKTWriter.prototype.write = function(geometry) {
  var wkt = this.parser.write(geometry);

  return wkt;
};

/**
 * Generates the WKT for a <tt>LINESTRING</tt> specified by two
 * {@link Coordinate}s.
 *
 * @param p0
 *          the first coordinate.
 * @param p1
 *          the second coordinate.
 *
 * @return the WKT.
 */
jsts.io.WKTWriter.toLineString = function(p0, p1) {
  if (arguments.length !== 2) {
    throw new jsts.error.NotImplementedError();
  }

  return 'LINESTRING ( ' + p0.x + ' ' + p0.y + ', ' + p1.x + ' ' + p1.y + ' )';
};
/* ======================================================================
    jsts/io/WKTReader.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * Converts a geometry in Well-Known Text format to a {@link Geometry}.
 * <p>
 * <code>WKTReader</code> supports extracting <code>Geometry</code> objects
 * from either {@link Reader}s or {@link String}s. This allows it to function
 * as a parser to read <code>Geometry</code> objects from text blocks embedded
 * in other data formats (e.g. XML).
 * <P>
 * <p>
 * A <code>WKTReader</code> is parameterized by a <code>GeometryFactory</code>,
 * to allow it to create <code>Geometry</code> objects of the appropriate
 * implementation. In particular, the <code>GeometryFactory</code> determines
 * the <code>PrecisionModel</code> and <code>SRID</code> that is used.
 * <P>
 *
 * @constructor
 */
jsts.io.WKTReader = function(geometryFactory) {
  this.geometryFactory = geometryFactory || new jsts.geom.GeometryFactory();
  this.precisionModel = this.geometryFactory.getPrecisionModel();
  this.parser = new jsts.io.WKTParser(this.geometryFactory);
};


/**
 * Reads a Well-Known Text representation of a {@link Geometry}
 *
 * @param {string}
 *          wkt a <Geometry Tagged Text> string (see the OpenGIS Simple Features
 *          Specification).
 * @return {jsts.geom.Geometry} a <code>Geometry</code> read from
 *         <code>string.</code>
 */
jsts.io.WKTReader.prototype.read = function(wkt) {
  var geometry = this.parser.read(wkt);

  // TODO: port and use GeometryPrecisionReducer, this is a hack
  if (this.precisionModel.getType() === jsts.geom.PrecisionModel.FIXED) {
    this.reducePrecision(geometry);
  }

  return geometry;
};

//NOTE: this is a hack
jsts.io.WKTReader.prototype.reducePrecision = function(geometry) {
  var i, len;

  if (geometry.coordinate) {
    this.precisionModel.makePrecise(geometry.coordinate);
  } else if (geometry.points) {
    for (i = 0, len = geometry.points.length; i < len; i++) {
      this.precisionModel.makePrecise(geometry.points[i]);
    }
  } else if (geometry.geometries) {
    for (i = 0, len = geometry.geometries.length; i < len; i++) {
      this.reducePrecision(geometry.geometries[i]);
    }
  }
};
/* ======================================================================
    jsts/index/strtree/BoundablePair.js
   ====================================================================== */


/* ======================================================================
    jsts/triangulate/quadedge/QuadEdgeSubdivision.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @requires jsts/io/WKTWriter.js
 */

/**
 * A class that contains the {@link QuadEdge}s representing a planar
 * subdivision that models a triangulation.
 * The subdivision is constructed using the
 * quadedge algebra defined in the classs {@link QuadEdge}.
 * All metric calculations
 * are done in the {@link Vertex} class.
 * In addition to a triangulation, subdivisions
 * support extraction of Voronoi diagrams.
 * This is easily accomplished, since the Voronoi diagram is the dual
 * of the Delaunay triangulation.
 * <p>
 * Subdivisions can be provided with a tolerance value. Inserted vertices which
 * are closer than this value to vertices already in the subdivision will be
 * ignored. Using a suitable tolerance value can prevent robustness failures
 * from happening during Delaunay triangulation.
 * <p>
 * Subdivisions maintain a <b>frame</b> triangle around the client-created
 * edges. The frame is used to provide a bounded "container" for all edges
 * within a TIN. Normally the frame edges, frame connecting edges, and frame
 * triangles are not included in client processing.
 *
 * @author David Skea
 * @author Martin Davis
 */

/**
 * Creates a new instance of a quad-edge subdivision based on a frame triangle
 * that encloses a supplied bounding box. A new super-bounding box that contains
 * the triangle is computed and stored.
 *
 * @param env
 *          the bouding box to surround.
 * @param tolerance
 *          the tolerance value for determining if two sites are equal.
 *
 * @constructor
 */
jsts.triangulate.quadedge.QuadEdgeSubdivision = function(env, tolerance) {
  this.tolerance = tolerance;
  this.edgeCoincidenceTolerance = tolerance / jsts.triangulate.quadedge.QuadEdgeSubdivision.EDGE_COINCIDENCE_TOL_FACTOR;

  //used for edge extraction to ensure edge uniqueness
  this.visitedKey = 0;
  this.quadEdges = [];
  this.startingEdge;
  this.tolerance;
  this.edgeCoincidenceTolerance;
  this.frameEnv;
  this.locator = null;
  this.seg = new jsts.geom.LineSegment();
  this.triEdges = new Array(3);
  this.frameVertex = new Array(3);
  this.createFrame(env);

  this.startingEdge = this.initSubdiv();
  this.locator = new jsts.triangulate.quadedge.LastFoundQuadEdgeLocator(this);
};

jsts.triangulate.quadedge.QuadEdgeSubdivision.EDGE_COINCIDENCE_TOL_FACTOR = 1000;

/**
 * Gets the edges for the triangle to the left of the given {@link QuadEdge}.
 *
 * @param {jsts.triangulate.quadedge.QuadEdge}
 *          startQE the starting quad-edge.
 * @param {jsts.triangulate.quadedge.QuadEdge[]}
 *          triEdge array of quadedges.
 *
 * @throws IllegalArgumentException
 *           if the edges do not form a triangle
 */
jsts.triangulate.quadedge.QuadEdgeSubdivision.getTriangleEdges = function(startQE, triEdge) {
  triEdge[0] = startQE;
  triEdge[1] = triEdge[0].lNext();
  triEdge[2] = triEdge[1].lNext();
  if (triEdge[2].lNext() != triEdge[0]) {
    throw new jsts.IllegalArgumentError('Edges do not form a triangle');
  }
};

/**
 * Creates the framing envelope
 *
 * @param {jsts.geom.Envelope}
 *          env an envelope.
 */
jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.createFrame = function(env) {
  var deltaX, deltaY, offset;

  deltaX = env.getWidth();
  deltaY = env.getHeight();
  offset = 0.0;

  if (deltaX > deltaY) {
    offset = deltaX * 10.0;
  }else {
    offset = deltaY * 10.0;
  }

  this.frameVertex[0] = new jsts.triangulate.quadedge.Vertex((env.getMaxX() + env.getMinX()) / 2.0, env
      .getMaxY()
      + offset);
  this.frameVertex[1] = new jsts.triangulate.quadedge.Vertex(env.getMinX() - offset, env.getMinY() - offset);
  this.frameVertex[2] = new jsts.triangulate.quadedge.Vertex(env.getMaxX() + offset, env.getMinY() - offset);

  this.frameEnv = new jsts.geom.Envelope(this.frameVertex[0].getCoordinate(), this.frameVertex[1]
      .getCoordinate());
  this.frameEnv.expandToInclude(this.frameVertex[2].getCoordinate());
};

/**
 * @return {jsts.geom.triangulate.quadedge.QuadEdge} The quadedge.
 */
jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.initSubdiv = function() {
  var ea, eb, ec;

  //build initial subdivision from frame
  ea = this.makeEdge(this.frameVertex[0], this.frameVertex[1]);
  eb = this.makeEdge(this.frameVertex[1], this.frameVertex[2]);
  jsts.triangulate.quadedge.QuadEdge.splice(ea.sym(), eb);
  ec = this.makeEdge(this.frameVertex[2], this.frameVertex[0]);
  jsts.triangulate.quadedge.QuadEdge.splice(eb.sym(), ec);
  jsts.triangulate.quadedge.QuadEdge.splice(ec.sym(), ea);

  return ea;
};

/**
 * Gets the vertex-equality tolerance value used in this subdivision
 *
 * @return {Number}
 *          the tolerance value.
 */
jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getTolerance = function() {
  return this.tolerance;
};



/**
 * Gets the envelope of the Subdivision (including the frame).
 *
 * @return {jsts.geom.Envelope}
 *         the envelope.
 */
jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getEnvelope = function() {
  return new jsts.geom.Envelope(this.frameEnv);
};

/**
 * Gets the collection of base {@link Quadedge}s (one for every pair of
 * vertices which is connected).
 *
 * @return {jsts.triangulate.quadedge.QuadEdge[]}
 *          a collection of QuadEdges.
 */
jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getEdges = function() {
    if (arguments.length > 0) {
      return this.getEdgesByFactory(arguments[0]);
    }else {
      return this.quadEdges;
    }
};

/**
 * Sets the {@link QuadEdgeLocator} to use for locating containing triangles
 * in this subdivision.
 *
 * @param {jsts.triangulate.quadedge.QuadEdgeLocator}
 *         locator a QuadEdgeLocator.
 */
jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.setLocator = function(locator) {
  this.locator = locator;
};

/**
 * Creates a new quadedge, recording it in the edges list.
 *
 * @param {jsts.triangulate.quadedge.Vertex}
 *         o a Vertex.
 * @param {jsts.triangulate.quadedge.Vertex}
 *         d another Vertex.
 *
 * @return {jsts.triangulate.quadedge.QuadEdge}
 */
jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.makeEdge = function(o, d) {
  var q = jsts.triangulate.quadedge.QuadEdge.makeEdge(o, d);
  this.quadEdges.push(q);

  return q;
};

/**
 * Creates a new QuadEdge connecting the destination of a to the origin of b,
 * in such a way that all three have the same left face after the connection
 * is complete. The quadedge is recorded in the edges list.
 *
 * @param {jsts.triangulate.quadedge.QuadEdge}
 *         a The first quadedge.
 * @param {jsts.triangulate.quadedge.QuadEdge}
 *         b The second quadedge.
 *
 * @return {jsts.triangulate.quadedge.QuadEdge}
 */
jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.connect = function(a, b) {
  var q = jsts.triangulate.quadedge.QuadEdge.connect(a, b);
  this.quadEdges.push(q);
  return q;
};

/**
 * Deletes a quadedge from the subdivision. Linked quadedges are updated to
 * reflect the deletion.
 *
 * @param {jsts.triangulate.quadedge.QuadEdge}
 *         e the quadedge to delete.
 */
jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.delete_jsts = function(e) {
  jsts.triangulate.quadedge.QuadEdge.splice(e, e.oPrev());
  jsts.triangulate.quadedge.QuadEdge.splice(e.sym(), e.sym().oPrev());

  var eSym, eRot, eRotSym;

  e.
  eSym = e.sym();
  eRot = e.rot;
  eRotSym = e.rot.sym();

  var idx = this.quadEdges.indexOf(e);
  if (idx !== -1) {
    this.quadEdges.splice(idx, 1);
  }

  idx = this.quadEdges.indexOf(eSym);
  if (idx !== -1) {
    this.quadEdges.splice(idx, 1);
  }

  idx = this.quadEdges.indexOf(eRot);
  if (idx !== -1) {
    this.quadEdges.splice(idx, 1);
  }

  idx = this.quadEdges.indexOf(eRotSym);
  if (idx !== -1) {
    this.quadEdges.splice(idx, 1);
  }

  e.delete_jsts();
  eSym.delete_jsts();
  eRot.delete_jsts();
  eRotSym.delete_jsts();
};

/**
 * Locates an edge of a triangle which contains a location specified by a
 * Vertex v. The edge returned has the property that either v is on e, or e is
 * an edge of a triangle containing v. The search starts from startEdge amd
 * proceeds on the general direction of v.
 * <p>
 * This locate algorithm relies on the subdivision being Delaunay. For
 * non-Delaunay subdivisions, this may loop for ever.
 *
 * @param {jsts.triangulate.quadedge.Vertex}
 *          v the location to search for.
 * @param {jsts.triangulate.quadedge.QuadEdge}
 *          startEdge an edge of the subdivision to start searching at.
 * @return {jsts.triangulate.quadedge.QuadEdge}
 *          a QuadEdge which contains v, or is on the edge of a triangle
 *          containing v.
 *
 * @throws jsts.error.LocateFailureError
 *           if the location algorithm fails to converge in a reasonable
 *           number of iterations
 */
jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.locateFromEdge = function(v, startEdge) {
  var iter = 0, maxIter = this.quadEdges.length, e;

  e = startEdge;

  while (true) {
    iter++;
    /**
     * So far it has always been the case that failure to locate indicates an
     * invalid subdivision. So just fail completely. (An alternative would be
     * to perform an exhaustive search for the containing triangle, but this
     * would mask errors in the subdivision topology)
     *
     * This can also happen if two vertices are located very close together,
     * since the orientation predicates may experience precision failures.
     */
    if (iter > maxIter) {
      throw new jsts.error.LocateFailureError(e.toLineSegment());
    }

    if ((v.equals(e.orig())) || (v.equals(e.dest()))) {
      break;
    } else if (v.rightOf(e)) {
      e = e.sym();
    } else if (!v.rightOf(e.oNext())) {
      e = e.oNext();
    } else if (!v.rightOf(e.dPrev())) {
      e = e.dPrev();
    } else {
      // on edge or in triangle containing edge
      break;
    }
  }

  return e;
};

/**
 * Locates a quadedge
 * Will call correct locate* -function based on arguments
 */
jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.locate = function() {
  if (arguments.length === 1) {
    if (arguments[0] instanceof jsts.triangulate.quadedge.Vertex) {
      return this.locateByVertex(arguments[0]);
    }else {
      return this.locateByCoordinate(arguments[0]);
    }
  }else {
    return this.locateByCoordinates(arguments[0], arguments[1]);
  }
};

/**
 * Finds a quadedge of a triangle containing a location specified by a
 * {@link Vertex}, if one exists.
 *
 * @param  {jsts.triangulate.quadedge.Vertex}
 *          x the vertex to locate.
 * @return {jsts.triangulate.quadedge.QuadEdge}
 *          a quadedge on the edge of a triangle which touches or contains the location, null of no such triangle exists.
 */

jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.locateByVertex = function(v) {
  return this.locator.locate(v);
};

/**
 * Finds a quadedge of a triangle containing a location specified by a
 * {@link Coordinate}, if one exists.
 *
 * @param {jsts.geom.Coordinate}
 *          p the Coordinate to locate.
 * @return {jsts.triangulate.quadedge.QuadEdge}
 *          a quadedge on the edge of a triangle which touches or contains the
 *          location or null if no such triangle exists.
 */
jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.locateByCoordinate = function(p) {
  return this.locator.locate(new jsts.triangulate.quadedge.Vertex(p));
};

/**
 * Locates the edge between the given vertices, if it exists in the
 * subdivision.
 *
 * @param {jsts.geom.Coordinate}
 *          p0 a coordinate.
 * @param {jsts.geom.Coordinate}
 *          p1 another coordinate.
 * @return {jsts.triangulate.quadedge.QuadEdge}
 *          the edge joining the coordinates, if present, null if no such edge exists.
 */
jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.locateByCoordinates = function(p0, p1) {
  var e, base, locEdge;
  // find an edge containing one of the points
  var e = this.locator.locate(new jsts.triangulate.quadedge.Vertex(p0));
  if (e === null) {
    return null;
  }

  // normalize so that p0 is origin of base edge
  base = e;
  if (e.dest().getCoordinate().equals2D(p0)) {
    base = e.sym();
  }

  // check all edges around origin of base edge
  locEdge = base;
  do {
    if (locEdge.dest().getCoordinate().equals2D(p1)) {
      return locEdge;
    }
    locEdge = locEdge.oNext();
  } while (locEdge != base);
  return null;
};

/**
 * Inserts a new site into the Subdivision, connecting it to the vertices of
 * the containing triangle (or quadrilateral, if the split point falls on an
 * existing edge).
 * <p>
 * This method does NOT maintain the Delaunay condition. If desired, this must
 * be checked and enforced by the caller.
 * <p>
 * This method does NOT check if the inserted vertex falls on an edge. This
 * must be checked by the caller, since this situation may cause erroneous
 * triangulation
 *
 * @param {jsts.triangulate.quadedge.Vertex}
 *          v the vertex to insert.
 * @return {jsts.triangulate.quadedge.QuadEdge}
 *          a new quad edge terminating in v.
 */
jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.insertSite = function(v) {
  var e, base, startEdge;

  e = this.locate(v);

  if ((v.equals(e.orig(), this.tolerance)) || (v.equals(e.dest(), this.tolerance))) {
    return e; // point already in subdivision.
  }

  // Connect the new point to the vertices of the containing
  // triangle (or quadrilateral, if the new point fell on an
  // existing edge.)
  base = this.makeEdge(e.orig(), v);
  jsts.triangulate.quadedge.QuadEdge.splice(base, e);
  startEdge = base;
  do {
    base = this.connect(e, base.sym());
    e = base.oPrev();
  } while (e.lNext() != startEdge);

  return startEdge;
};

/**
 * Tests whether a QuadEdge is an edge incident on a frame triangle vertex.
 *
 * @param {jsts.triangulate.quadedge.QuadEdge}
 *          e the edge to test.
 * @return {boolean}
 *          true if the edge is connected to the frame triangle.
 */
jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.isFrameEdge = function(e) {
  if (this.isFrameVertex(e.orig()) || this.isFrameVertex(e.dest())) {
    return true;
  }
  return false;
};

/**
 * Tests whether a QuadEdge is an edge on the border of the frame facets and
 * the internal facets. E.g. an edge which does not itself touch a frame
 * vertex, but which touches an edge which does.
 *
 * @param {jsts.triangulate.quadedge.QuadEdge}
 *        e the edge to test.
 * @return {boolean}
 *          true if the edge is on the border of the frame.
 */
jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.isFrameBorderEdge = function(e) {
  // MD debugging
  var leftTri, rightTri, vLeftTriOther, vRightTriOther;

  leftTri = new Array(3);
  this.getTriangleEdges(e, leftTri);

  rightTri = new Array(3);
  this.getTriangleEdges(e.sym(), rightTri);

  // check other vertex of triangle to left of edge
  vLeftTriOther = e.lNext().dest();

  if (this.isFrameVertex(vLeftTriOther)) {
    return true;
  }

  // check other vertex of triangle to right of edge
  vRightTriOther = e.sym().lNext().dest();
  if (this.isFrameVertex(vRightTriOther)) {
    return true;
  }

  return false;
};

/**
 * Tests whether a vertex is a vertex of the outer triangle.
 *
 * @param {jsts.triangulate.quadedge.Vertex}
 *          v the vertex to test.
 * @return {boolean}
 *          true if the vertex is an outer triangle vertex.
 */
jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.isFrameVertex = function(v) {
  if (v.equals(this.frameVertex[0])) {
    return true;
  }
  if (v.equals(this.frameVertex[1])) {
    return true;
  }
  if (v.equals(this.frameVertex[2])) {
    return true;
  }
  return false;
};

/**
 * Tests whether a {@link Coordinate} lies on a {@link QuadEdge}, up to a
 * tolerance determined by the subdivision tolerance.
 *
 * @param {jsts.triangulate.quadedge.QuadEdge}
 *          e a QuadEdge.
 * @param {jsts.geom.Coordinate}
 *          p a point.
 * @return {boolean}
 *          true if the vertex lies on the edge.
 */
jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.isOnEdge = function(e, p) {
  this.seg.setCoordinates(e.orig().getCoordinate(), e.dest().getCoordinate());
  var dist = this.seg.distance(p);

  // heuristic (hack?)
  return dist < this.edgeCoincidenceTolerance;
};

/**
 * Tests whether a {@link Vertex} is the start or end vertex of a
 * {@link QuadEdge}, up to the subdivision tolerance distance.
 *
 * @param {jsts.triangulate.quadedge.QuadEdge}
 *          e the quadedge to test.
 * @param {jsts.triangulate.quadedge.Vertex}
 *          v the vertex to test.
 *
 * @return {boolean}
 *          true if the vertex is a endpoint of the edge.
 */
jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.isVertexOfEdge = function(e, v) {
  if ((v.equals(e.orig(), this.tolerance)) || (v.equals(e.dest(), this.tolerance))) {
    return true;
  }
  return false;
};

/**
 * Gets the unique {@link Vertex}es in the subdivision, including the frame
 * vertices if desired.
 *
 * @param {boolean}
 *          includeFrame true if the frame vertices should be included.
 * @return {jsts.triangulate.quadedge.Vertex[]} an array of the subdivision vertices.
 *
 * @see #getVertexUniqueEdges
 */
jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getVertices = function(includeFrame) 
{
  var vertices = [], i, il, qe, v, vd;

  i = 0, il = this.quadEdges.length;

  for (i; i < il; i++) {
    qe = this.quadEdges[i];
    v = qe.orig();

    if (includeFrame || !this.isFrameVertex(v)) {
      vertices.push(v);
    }

    /**
     * Inspect the sym edge as well, since it is possible that a vertex is
     * only at the dest of all tracked quadedges.
     */

    vd = qe.dest();
    if (includeFrame || !this.isFrameVertex(vd)) {
      vertices.push(vd);
    }
  }

  return vertices;
};

/**
 * Gets a collection of {@link QuadEdge}s whose origin vertices are a unique
 * set which includes all vertices in the subdivision. The frame vertices can
 * be included if required.
 * <p>
 * This is useful for algorithms which require traversing the subdivision
 * starting at all vertices. Returning a quadedge for each vertex is more
 * efficient than the alternative of finding the actual vertices using
 * {@link #getVertices) and then locating  quadedges attached to them.
 *
 * @param {boolean}
 *          includeFrame true if the frame vertices should be included.
 * @return {jsts.triangulate.quadedge.QuadEdge[]}
 *          a collection of QuadEdge with the vertices of the subdivision as
 *            their origins.
 */
jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getVertexUniqueEdges = function(includeFrame) 
{
  var edges, visitedVertices, i, il, qe, v, qd, vd;

  edges = [];
  visitedVertices = [];

  i = 0, il = this.quadEdges.length;
  for (i; i < il; i++) {
    qe = this.quadEdges[i];
    v = qe.orig();

    if (visitedVertices.indexOf(v) === -1) {
      visitedVertices.push(v);
      if (includeFrame || ! this.isFrameVertex(v)) {
        edges.push(qe);
      }
    }

    /**
     * Inspect the sym edge as well, since it is possible that a vertex is
     * only at the dest of all tracked quadedges.
     */
    qd = qe.sym();
    vd = qd.orig();

    if (visitedVertices.indexOf(vd) === -1) {
      visitedVertices.push(vd);
      if (includeFrame || ! this.isFrameVertex(vd)) {
        edges.push(qd);
      }
    }
  }

  return edges;
};

/**
 * Gets all primary quadedges in the subdivision. A primary edge is a
 * {@link QuadEdge} which occupies the 0'th position in its array of
 * associated quadedges. These provide the unique geometric edges of the
 * triangulation.
 *
 * @param {boolean}
 *          includeFrame true if the frame edges are to be included.
 *
 * @return {jsts.triangulate.quadedge.QuadEdge[]}
 *          a List of QuadEdges.
 */
jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getPrimaryEdges = function(includeFrame) {
  this.visitedKey++;

  var edges, edgeStack, visitedEdges, edge, priQE;

  edges = [];
  edgeStack = [];
  edgeStack.push(this.startingEdge);

  visitedEdges = [];

  while (edgeStack.length > 0) {
    edge = edgeStack.pop();
    if (visitedEdges.indexOf(edge) === -1) {
      priQE = edge.getPrimary();

      if (includeFrame || !this.isFrameEdge(priQE)) {
        edges.push(priQE);
      }

      edgeStack.push(edge.oNext());
      edgeStack.push(edge.sym().oNext());

      visitedEdges.push(edge);
      visitedEdges.push(edge.sym());
    }
  }
  return edges;
};



/*****************************************************************************
 * Visitors
 ****************************************************************************/

/**
 * Visits all quadedges with the specified visitor.
 *
 * @param {jsts.triangulate.TriangleVisitor}
 *          triVisitor the visitor to use.
 *
 * @param {boolean}
 *          includeFrame true to include frame-edges.
 */
jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.visitTriangles = function(triVisitor, includeFrame) {
  this.visitedKey++;

  // visited flag is used to record visited edges of triangles
  // setVisitedAll(false);
  var edgeStack, visitedEdges, edge, triEdges;

  edgeStack = [];
  edgeStack.push(this.startingEdge);

  visitedEdges = [];

  while (edgeStack.length > 0) {
    edge = edgeStack.pop();
    if (visitedEdges.indexOf(edge) === -1) {
      triEdges = this.fetchTriangleToVisit(edge, edgeStack, includeFrame, visitedEdges);
      if (triEdges !== null)
        triVisitor.visit(triEdges);
    }
  }
};

/**
 * Stores the edges for a visited triangle. Also pushes sym (neighbour) edges
 * on stack to visit later.
 *
 * @param {jsts.triangulate.quadedge.QuadEdge}
 *          edge the quadedge.
 * @param {jsts.triangulate.quadedge.QuadEdge[]}
 *          edgeStack an array used as a stack.
 * @param {boolean}
 *          includeFrame true to include frame.
 * @param {jsts.traingulate.quadedge.QuadEdge[]}
 *          visitedEdges the edges that are already visited.
 * @return {jsts.triangulate.quadedge.QuadEdge[]}
 *          the visited triangle edges or null if the triangle should not be visited.
 */
jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.fetchTriangleToVisit = function(edge, edgeStack, includeFrame, visitedEdges) {
  var curr, edgeCount, isFrame, sym;

  curr = edge;
  edgeCount = 0;
  isFrame = false;

  do {
    this.triEdges[edgeCount] = curr;

    if (this.isFrameEdge(curr)) {
      isFrame = true;
    }
    // push sym edges to visit next
    sym = curr.sym();
    if (visitedEdges.indexOf(sym) === -1) {
      edgeStack.push(sym);
    }
    // mark this edge as visited
    visitedEdges.push(curr);

    edgeCount++;
    curr = curr.lNext();
  } while (curr !== edge);

  if (isFrame && !includeFrame) {
    return null;
  }
  return this.triEdges;
};

/**
 * Gets a list of the triangles in the subdivision, specified as an array of
 * the primary quadedges around the triangle.
 *
 * @param includeFrame
 *          true if the frame triangles should be included.
 * @return {jsts.triangulate.quadedge.QuadEdge[]}
 *          a List of QuadEdge[3] arrays.
 */
jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getTriangleEdges = function(includeFrame) {
  var visitor = new jsts.triangulate.quadedge.TriangleEdgesListVisitor();
  this.visitTriangles(visitor, includeFrame);
  return visitor.getTriangleEdges();
};

/**
 * Gets a list of the triangles in the subdivision, specified as an array of
 * the triangle {@link Vertex}es.
 *
 * @param {boolean}
 *          includeFrame true if the frame triangles should be included.
 * @return {jsts.triangulate.quadedge.Vertex[][]} a List of Vertex[3] arrays.
 */
jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getTriangleVertices = function(includeFrame) {
  var visitor = new TriangleVertexListVisitor();
  this.visitTriangles(visitor, includeFrame);

  return visitor.getTriangleVertices();
};

/**
 * Gets the coordinates for each triangle in the subdivision as an array.
 *
 * @param {boolean}
 *          includeFrame true if the frame triangles should be included.
 * @return {jsts.geom.Coordinate[][]}
 *          a list of Coordinate[4] representing each triangle.
 */
jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getTriangleCoordinates = function(includeFrame) {
  var visitor = new jsts.triangulate.quadedge.TriangleCoordinatesVisitor();
  this.visitTriangles(visitor, includeFrame);
  return visitor.getTriangles();
};



/**
 * Gets the geometry for the edges in the subdivision as a
 * {@link MultiLineString} containing 2-point lines.
 *
 * @param {jsts.geom.GeometryFactory}
 *          geomFact the GeometryFactory to use.
 * @return {jsts.geom.Geometry}
 *           a MultiLineString.
 */
jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getEdgesByFactory = function(geomFact) {
  var quadEdges, edges, i, il, qe, coords;

  quadEdges = this.getPrimaryEdges(false);
  edges = [];

  i = 0;
  il = quadEdges.length;

  for (i; i < il; i++) {
    qe = quadEdges[i];
    coords = [];
    coords[0] = (qe.orig().getCoordinate());
    coords[1] = (qe.dest().getCoordinate());
    edges[i] = geomFact.createLineString(coords);
  }

  return geomFact.createMultiLineString(edges);
};

/**
 * Gets the geometry for the triangles in a triangulated subdivision as a
 * {@link GeometryCollection} of triangular {@link Polygon}s.
 *
 * @param {jsts.geom.GeometryFactory}
 *          geomFact the GeometryFactory to use.
 * @return {jsts.geom.Geometry}
 *          a GeometryCollection of triangular Polygons.
 */
jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getTriangles = function(geomFact) {
  var triPtsList, tris, triPt, i, il;
  triPtsList = this.getTriangleCoordinates(false);
  tris = new Array(triPtsList.length);

  i = 0, il = triPtsList.length;
  for (i; i < il; i++) {
    triPt = triPtsList[i];
    tris[i] = geomFact.createPolygon(geomFact.createLinearRing(triPt, null));
  }

  return geomFact.createGeometryCollection(tris);
};

/**
 * Gets the cells in the Voronoi diagram for this triangulation. The cells are
 * returned as a {@link GeometryCollection} of {@link Polygon}s
 * <p>
 * The userData of each polygon is set to be the {@link Coordinate) of the
 * cell site. This allows easily associating external data associated with the
 * sites to the cells.
 *
 * @param {jsts.geom.GeometryFactory}
 *          geomFact a geometry factory.
 * @return {jsts.geom.Geometry}
 *          a GeometryCollection of Polygons.
 */
jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getVoronoiDiagram = function(geomFact)
{
  var vorCells = this.getVoronoiCellPolygons(geomFact);
  return geomFact.createGeometryCollection(vorCells);
};

/**
 * Gets a List of {@link Polygon}s for the Voronoi cells of this
 * triangulation.
 * <p>
 * The userData of each polygon is set to be the {@link Coordinate) of the
 * cell site. This allows easily associating external data associated with the
 * sites to the cells.
 *
 * @param {jsts.geom.GeometryFactory}
 *          geomFact a geometry factory.
 * @return {jsts.geom.Polygon[]}
 *          an array of Polygons.
 */
jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getVoronoiCellPolygons = function(geomFact)
{
  /*
   * Compute circumcentres of triangles as vertices for dual edges.
   * Precomputing the circumcentres is more efficient,
   * and more importantly ensures that the computed centres
   * are consistent across the Voronoi cells.
   */
  this.visitTriangles(new jsts.triangulate.quadedge.TriangleCircumcentreVisitor(), true);

  var cells, edges, i, il, qe;
  cells = [];
  edges = this.getVertexUniqueEdges(false);

  i = 0, il = edges.length;
  for (i; i < il; i++) {
    qe = edges[i];
    cells.push(this.getVoronoiCellPolygon(qe, geomFact));
  }

  return cells;
};

/**
 * Gets the Voronoi cell around a site specified by the origin of a QuadEdge.
 * <p>
 * The userData of the polygon is set to be the {@link Coordinate) of the
 * site. This allows attaching external data associated with the site to this
 * cell polygon.
 *
 * @param {jsts.triangulate.quadedge.QuadEdge}
 *          qe a quadedge originating at the cell site.
 * @param {jsts.geom.GeometryFactory}
 *          geomFact a factory for building the polygon.
 * @return {jsts.geom.Polygon}
 *          a polygon indicating the cell extent.
 */
jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getVoronoiCellPolygon = function(qe, geomFact)
{
  var cellPts, startQe, cc, coordList, cellPoly, v;

  cellPts = [];
  startQE = qe;
  do {
    // Coordinate cc = circumcentre(qe);
    // use previously computed circumcentre
    cc = qe.rot.orig().getCoordinate();
    cellPts.push(cc);

    // move to next triangle CW around vertex
    qe = qe.oPrev();
  } while (qe !== startQE);

  coordList = new jsts.geom.CoordinateList([], false);
  coordList.add(cellPts, false);
  coordList.closeRing();

  if (coordList.size() < 4) {
    //System.out.println(coordList);
    coordList.add(coordList.get(coordList.size() - 1), true);
  }

  cellPoly = geomFact.createPolygon(geomFact.createLinearRing(coordList.toArray()), null);

  v = startQE.orig();
  //cellPoly.setUserData(v.getCoordinate());
  return cellPoly;
};



/**
 * A TriangleVisitor which computes and sets the circumcentre as the origin of
 * the dual edges originating in each triangle.
 *
 * @author mbdavis
 *
 */
jsts.triangulate.quadedge.TriangleCircumcentreVisitor = function() {
};

/**
 * Visits all the edges
 *
 * @param {jsts.triangulate.quadedge.QuadEdge[]}
 *          triEdges the edges to visit.
 */
jsts.triangulate.quadedge.TriangleCircumcentreVisitor.prototype.visit = function(triEdges) {
  var a, b, c, cc, ccVertex, i;

  a = triEdges[0].orig().getCoordinate();
  b = triEdges[1].orig().getCoordinate();
  c = triEdges[2].orig().getCoordinate();

  //TODO: choose the most accurate circumcentre based on the edges
  cc = jsts.geom.Triangle.circumcentre(a, b, c);
  ccVertex = new jsts.triangulate.quadedge.Vertex(cc);

  //save the circumcentre as the origin for the dual edges originating in
  // this triangle
  i = 0;

  for (i; i < 3; i++) {
    triEdges[i].rot.setOrig(ccVertex);
  }
};

jsts.triangulate.quadedge.TriangleEdgesListVisitor = function() {
  this.triList = [];
};

jsts.triangulate.quadedge.TriangleEdgesListVisitor.prototype.visit = function(triEdges) {
  var clone = triEdges.concat(); //concat without arguments returns a copy of the array
  this.triList.push(clone);
};

jsts.triangulate.quadedge.TriangleEdgesListVisitor.prototype.getTriangleEdges = function() {
  return this.triList;
};

jsts.triangulate.quadedge.TriangleVertexListVisitor = function() {
  this.triList = [];
};

jsts.triangulate.quadedge.TriangleVertexListVisitor.prototype.visit = function(triEdges) {
  var vertices = [];
  vertices.push(trieEdges[0].orig());
  vertices.push(trieEdges[1].orig());
  vertices.push(trieEdges[2].orig());
  this.triList.push(vertices);
};

jsts.triangulate.quadedge.TriangleVertexListVisitor.prototype.getTriangleVertices = function() {
  return this.triList;
};

jsts.triangulate.quadedge.TriangleCoordinatesVisitor = function() {
  this.coordList = new jsts.geom.CoordinateList([], false);
  this.triCoords = [];
};

jsts.triangulate.quadedge.TriangleCoordinatesVisitor.prototype.visit = function(triEdges) {
  this.coordList = new jsts.geom.CoordinateList([], false);

  var i = 0, v, pts;

  for (i; i < 3; i++) {
    v = triEdges[i].orig();
    this.coordList.add(v.getCoordinate());
  }

  if (this.coordList.size() > 0) {
    this.coordList.closeRing();
    pts = this.coordList.toArray();
    if (pts.length !== 4) {
      return;
    }

    this.triCoords.push(pts);
  }
};

jsts.triangulate.quadedge.TriangleCoordinatesVisitor.prototype.getTriangles = function() {
  return this.triCoords;
};
/* ======================================================================
    jsts/operation/relate/EdgeEndBundle.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.

/**
 * @requires jsts/geomgraph/EdgeEnd.js
 */



/**
 * A collection of {@link EdgeEnd}s which obey the following invariant:
 * They originate at the same node and have the same direction.
 *
 * @augments {jsts.geomgraph.EdgeEnd}
 * @constructor
 */
jsts.operation.relate.EdgeEndBundle = function() {
  this.edgeEnds = [];

  var e = arguments[0] instanceof jsts.geomgraph.EdgeEnd ? arguments[0] : arguments[1];

  var edge = e.getEdge();
  var coord = e.getCoordinate();
  var dirCoord = e.getDirectedCoordinate();
  var label = new jsts.geomgraph.Label(e.getLabel());

  jsts.geomgraph.EdgeEnd.call(this, edge, coord,
      dirCoord, label);

  this.insert(e);
};

jsts.operation.relate.EdgeEndBundle.prototype = new jsts.geomgraph.EdgeEnd();


/**
 * @private
 */
jsts.operation.relate.EdgeEndBundle.prototype.edgeEnds = null;



jsts.operation.relate.EdgeEndBundle.prototype.getLabel = function() {
  return this.label;
};
jsts.operation.relate.EdgeEndBundle.prototype.getEdgeEnds = function() {
  return this.edgeEnds;
};

jsts.operation.relate.EdgeEndBundle.prototype.insert = function(e) {
  // Assert: start point is the same
  // Assert: direction is the same
  this.edgeEnds.push(e);
};


/**
 * This computes the overall edge label for the set of edges in this
 * EdgeStubBundle. It essentially merges the ON and side labels for each edge.
 * These labels must be compatible
 */
jsts.operation.relate.EdgeEndBundle.prototype.computeLabel = function(
    boundaryNodeRule) {
  // create the label. If any of the edges belong to areas,
  // the label must be an area label
  var isArea = false;
  for (var i = 0; i < this.edgeEnds.length; i++) {
    var e = this.edgeEnds[i];
    if (e.getLabel().isArea())
      isArea = true;
  }
  if (isArea)
    this.label = new jsts.geomgraph.Label(jsts.geom.Location.NONE, jsts.geom.Location.NONE,
        jsts.geom.Location.NONE);
  else
    this.label = new jsts.geomgraph.Label(jsts.geom.Location.NONE);

  // compute the On label, and the side labels if present
  for (var i = 0; i < 2; i++) {
    this.computeLabelOn(i, boundaryNodeRule);
    if (isArea)
      this.computeLabelSides(i);
  }
};


/**
 * Compute the overall ON location for the list of EdgeStubs. (This is
 * essentially equivalent to computing the self-overlay of a single Geometry)
 * edgeStubs can be either on the boundary (eg Polygon edge) OR in the interior
 * (e.g. segment of a LineString) of their parent Geometry. In addition,
 * GeometryCollections use a {@link BoundaryNodeRule} to determine whether a
 * segment is on the boundary or not. Finally, in GeometryCollections it can
 * occur that an edge is both on the boundary and in the interior (e.g. a
 * LineString segment lying on top of a Polygon edge.) In this case the Boundary
 * is given precendence. <br>
 * These observations result in the following rules for computing the ON
 * location:
 * <ul>
 * <li> if there are an odd number of Bdy edges, the attribute is Bdy
 * <li> if there are an even number >= 2 of Bdy edges, the attribute is Int
 * <li> if there are any Int edges, the attribute is Int
 * <li> otherwise, the attribute is NULL.
 * </ul>
 *
 * @private
 */
jsts.operation.relate.EdgeEndBundle.prototype.computeLabelOn = function(
    geomIndex, boundaryNodeRule) {
  // compute the ON location value
  var boundaryCount = 0;
  var foundInterior = false;

  for (var i = 0; i < this.edgeEnds.length; i++) {
    var e = this.edgeEnds[i];
    var loc = e.getLabel().getLocation(geomIndex);
    if (loc == jsts.geom.Location.BOUNDARY)
      boundaryCount++;
    if (loc == jsts.geom.Location.INTERIOR)
      foundInterior = true;
  }
  var loc = jsts.geom.Location.NONE;
  if (foundInterior)
    loc = jsts.geom.Location.INTERIOR;
  if (boundaryCount > 0) {
    loc = jsts.geomgraph.GeometryGraph.determineBoundary(boundaryNodeRule,
        boundaryCount);
  }
  this.label.setLocation(geomIndex, loc);

};


/**
 * Compute the labelling for each side
 *
 * @private
 */
jsts.operation.relate.EdgeEndBundle.prototype.computeLabelSides = function(
    geomIndex) {
  this.computeLabelSide(geomIndex, jsts.geomgraph.Position.LEFT);
  this.computeLabelSide(geomIndex, jsts.geomgraph.Position.RIGHT);
};


/**
 * To compute the summary label for a side, the algorithm is: FOR all edges IF
 * any edge's location is INTERIOR for the side, side location = INTERIOR ELSE
 * IF there is at least one EXTERIOR attribute, side location = EXTERIOR ELSE
 * side location = NULL <br>
 * Note that it is possible for two sides to have apparently contradictory
 * information i.e. one edge side may indicate that it is in the interior of a
 * geometry, while another edge side may indicate the exterior of the same
 * geometry. This is not an incompatibility - GeometryCollections may contain
 * two Polygons that touch along an edge. This is the reason for
 * Interior-primacy rule above - it results in the summary label having the
 * Geometry interior on <b>both</b> sides.
 *
 * @private
 */
jsts.operation.relate.EdgeEndBundle.prototype.computeLabelSide = function(
    geomIndex, side) {
  for (var i = 0; i < this.edgeEnds.length; i++) {
    var e = this.edgeEnds[i];
    if (e.getLabel().isArea()) {
      var loc = e.getLabel().getLocation(geomIndex, side);
      if (loc === jsts.geom.Location.INTERIOR) {
        this.label.setLocation(geomIndex, side, jsts.geom.Location.INTERIOR);
        return;
      } else if (loc === jsts.geom.Location.EXTERIOR)
        this.label.setLocation(geomIndex, side, jsts.geom.Location.EXTERIOR);
    }
  }
};


/**
 * Update the IM with the contribution for the computed label for the EdgeStubs.
 *
 * @private
 */
jsts.operation.relate.EdgeEndBundle.prototype.updateIM = function(im) {
  jsts.geomgraph.Edge.updateIM(this.label, im);
};
/* ======================================================================
    jsts/index/kdtree/KdTree.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of
 * the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * An implementation of a 2-D KD-Tree. KD-trees provide fast range searching on
 * point data.
 * <p>
 * This implementation supports detecting and snapping points which are closer
 * than a given tolerance value. If the same point (up to tolerance) is inserted
 * more than once a new node is not created but the count of the existing node
 * is incremented.
 *
 * Creates a new instance of a KdTree, specifying a snapping distance tolerance.
 * Points which lie closer than the tolerance to a point already in the tree
 * will be treated as identical to the existing point.
 *
 * @param {Number}
 *          tolerance (optional) the tolerance distance for considering two
 *          points equal.
 *
 * @constructor
 */
jsts.index.kdtree.KdTree = function(tolerance) {
  var tol = 0.0;
  if (tolerance !== undefined) {
    tol = tolerance;
  }

  this.root = null;
  this.last = null;
  this.numberOfNodes = 0;
  this.tolerance = tol;
};


/**
 * Inserts a new point in the kd-tree.
 *
 * Will call correct *insert function depending on arguments
 *
 * @return {jsts.index.kdtree.KdNode} The kd-node containing the point.
 */
jsts.index.kdtree.KdTree.prototype.insert = function() {
  if (arguments.length === 1) {
    return this.insertCoordinate.apply(this, arguments[0]);
  } else {
    return this.insertWithData.apply(this, arguments[0], arguments[1]);
  }
};


/**
 * Inserts a new point in the kd-tree, with no data.
 *
 * @param {jsts.geom.Coordinate}
 *          p the point to insert.
 * @return {jsts.index.kdtree.KdNode} the kdnode containing the point.
 */
jsts.index.kdtree.KdTree.prototype.insertCoordinate = function(p) {
  return this.insertWithData(p, null);
};


/**
 * Inserts a new point into the kd-tree.
 *
 * @param {jsts.geom.Coordinate}
 *          p the point to insert.
 * @param {Object}
 *          data a data item for the point.
 * @return {jsts.index.kdtree.KdNode} returns a new KdNode if a new point is
 *         inserted, else an existing node is returned with its counter
 *         incremented. This can be checked by testing returnedNode.getCount() >
 *         1.
 */
jsts.index.kdtree.KdTree.prototype.insertWithData = function(p, data) {
  if (this.root === null) {
    this.root = new jsts.index.kdtree.KdNode(p, data);
    return this.root;
  }

  var currentNode = this.root, leafNode = this.root, isOddLevel = true, isLessThan = true;

  // traverse the tree first cutting the plane left-right the top-bottom
  while (currentNode !== last) {
    if (isOddLevel) {
      isLessThan = p.x < currentNode.getX();
    } else {
      isLessThan = p.y < currentNode.getY();
    }
    leafNode = currentNode;
    if (isLessThan) {
      currentNode = currentNode.getLeft();
    } else {
      currentNode = currentNode.getRight();
    }

    // test if point is already a node
    if (currentNode !== null) {
      var isInTolerance = p.distance(currentNode.getCoordinate()) <= this.tolerance;

      // check if point is already in tree (up to tolerance) and if so simply
      // return existing node
      if (isInTolerance) {
        currentNode.increment();
        return currentNode;
      }
    }
    isOddLevel = !isOddLevel;
  }

  // no node found, add new leaf node to tree
  this.numberOfNodes = numberOfNodes + 1;
  var node = new jsts.index.kdtree.KdNode(p, data);
  node.setLeft(this.last);
  node.setRight(this.last);
  if (isLessThan) {
    leafNode.setLeft(node);
  } else {
    leafNode.setRight(node);
  }
  return node;
};


/**
 * Query's the tree
 *
 * @param {jsts.index.kdtree.KdNode}
 *          currentNode the current node.
 * @param {jsts.index.kdtree.KdNode}
 *          bottomNode the bottom node.
 * @param {jsts.geom.Envelope}
 *          queryEnv the query-envelope.
 * @param {Boolean}
 *          odd true if the level is odd.
 * @param {Array}
 *          result the array to fill the result with.
 */
jsts.index.kdtree.KdTree.prototype.queryNode = function(currentNode,
    bottomNode, queryEnv, odd, result) {
  if (currentNode === bottomNode) {
    return;
  }

  var min, max, discriminant;
  if (odd) {
    min = queryEnv.getMinX();
    max = queryEnv.getMaxX();
    discriminant = currentNode.getX();
  } else {
    min = queryEnv.getMinY();
    max = queryEnv.getMaxY();
    discriminant = currentNode.getY();
  }

  var searchLeft = min < discriminant;
  var searchRight = discriminant <= max;

  if (searchLeft) {
    this.queryNode(currentNode.getLeft(), bottomNode, queryEnv, !odd, result);
  }

  if (queryEnv.contains(currentNode.getCoordinate())) {
    result.add(currentNode);
  }

  if (searchRight) {
    this.queryNode(currentNode.getRight(), bottomNode, queryEnv, !odd, result);
  }
};


/**
 * Will call the correct *query-function depending on arguments
 *
 * @return {Array{jsts.index.KdNode}} The found nodes.
 */
jsts.index.kdtree.KdTree.prototype.query = function() {
  if (arguments.length === 1) {
    return this.queryByEnvelope.apply(this, arguments[0]);
  } else {
    return this.queryWithArray.apply(this, arguments[0], arguments[1]);
  }
};


/**
 * Performs a range search of the points in the index.
 *
 * @param {jsts.geom.Envelope}
 *          queryEnv the range rectangle to query.
 * @return {Array} a list of the KdNodes found.
 */
jsts.index.kdtree.KdTree.prototype.queryByEnvelope = function(queryEnv) {
  var result = [];
  this.queryNode(this.root, this.last, queryEnv, true, result);
  return result;
};


/**
 * Performs a range search of the points in the index.
 *
 * @param {jsts.geom.Envelope}
 *          queryEnv the range rectangle to query.
 * @param {Array}
 *          result a list to accumulate the result nodes into.
 */
jsts.index.kdtree.KdTree.prototype.queryWithArray = function(queryEnv, result) {
  this.queryNode(this.root, this.last, queryEnv, true, result);
};
/* ======================================================================
    jsts/geom/Triangle.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
*/



/**
 * Represents a planar triangle, and provides methods for calculating various
 * properties of triangles.
 *
 * @constructor
 * @param {jsts.geom.Coordinate}
 *          p0 a coordinate.
 * @param {jsts.geom.Coordinate}
 *          p1 a coordinate.
 * @param {jsts.geom.Coordinate}
 *          p2 a coordinate.
 */
jsts.geom.Triangle = function(p0, p1, p2) {
  this.p0 = p0;
  this.p1 = p1;
  this.p2 = p2;
};

/**
 * Tests whether a triangle is acute. A triangle is acute iff all interior
 * angles are acute. This is a strict test - right triangles will return
 * <tt>false</tt> A triangle which is not acute is either right or obtuse.
 * <p>
 * Note: this implementation is not robust for angles very close to 90 degrees.
 *
 * @param {jsts.geom.Coordinate}
 *          a a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          b a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          c a vertex of the triangle.
 * @return {Boolean} true if the triangle is acute.
 */
jsts.geom.Triangle.isAcute = function(a, b, c) {
  if (!jsts.algorithm.Angle.isAcute(a, b, c)) {
    return false;
  }
  if (!jsts.algorithm.Angle.isAcute(b, c, a)) {
    return false;
  }
  if (!jsts.algorithm.Angle.isAcute(c, a, b)) {
    return false;
  }
  return true;
};


/**
 * Computes the line which is the perpendicular bisector of the line segment
 * a-b.
 *
 * @param {jsts.geom.Coordinate}
 *          a a point.
 * @param {jsts.geom.Coordinate}
 *          b another point.
 * @return {jsts.algorithm.HCoordinate} the perpendicular bisector, as an
 *         HCoordinate.
 */
jsts.geom.Triangle.perpendicularBisector = function(a, b) {
  // returns the perpendicular bisector of the line segment ab
  var dx, dy, l1, l2;

  dx = b.x - a.x;
  dy = b.y - a.y;

  l1 = new jsts.algorithm.HCoordinate(a.x + dx / 2.0, a.y + dy / 2.0, 1.0);
  l2 = new jsts.algorithm.HCoordinate(a.x - dy + dx / 2.0, a.y + dx + dy / 2.0,
      1.0);
  return new jsts.algorithm.HCoordinate(l1, l2);
};


/**
 * Computes the circumcentre of a triangle. The circumcentre is the centre of
 * the circumcircle, the smallest circle which encloses the triangle. It is also
 * the common intersection point of the perpendicular bisectors of the sides of
 * the triangle, and is the only point which has equal distance to all three
 * vertices of the triangle.
 * <p>
 * This method uses an algorithm due to J.R.Shewchuk which uses normalization to
 * the origin to improve the accuracy of computation. (See <i>Lecture Notes on
 * Geometric Robustness</i>, Jonathan Richard Shewchuk, 1999).
 *
 * @param {jsts.geom.Coordinate}
 *          a a vertx of the triangle.
 * @param {jsts.geom.Coordinate}
 *          b a vertx of the triangle.
 * @param {jsts.geom.Coordinate}
 *          c a vertx of the triangle.
 * @return {jsts.geom.Coordinate} the circumcentre of the triangle.
 */
jsts.geom.Triangle.circumcentre = function(a, b, c) {
  var cx, cy, ax, ay, bx, by, denom, numx, numy, ccx, ccy;

  cx = c.x;
  cy = c.y;
  ax = a.x - cx;
  ay = a.y - cy;
  bx = b.x - cx;
  by = b.y - cy;

  denom = 2 * jsts.geom.Triangle.det(ax, ay, bx, by);
  numx = jsts.geom.Triangle.det(ay, ax * ax + ay * ay, by, bx * bx + by * by);
  numy = jsts.geom.Triangle.det(ax, ax * ax + ay * ay, bx, bx * bx + by * by);

  ccx = cx - numx / denom;
  ccy = cy + numy / denom;

  return new jsts.geom.Coordinate(ccx, ccy);
};


/**
 * Computes the determinant of a 2x2 matrix. Uses standard double-precision
 * arithmetic, so is susceptible to round-off error.
 *
 * @param {Number}
 *          m00 the [0,0] entry of the matrix.
 * @param {Number}
 *          m01 the [0,1] entry of the matrix.
 * @param {Number}
 *          m10 the [1,0] entry of the matrix.
 * @param {Number}
 *          m11 the [1,1] entry of the matrix.
 * @return {Number} the determinant.
 */
jsts.geom.Triangle.det = function(m00, m01, m10, m11) {
  return m00 * m11 - m01 * m10;
};


/**
 * Computes the incentre of a triangle. The <i>inCentre</i> of a triangle is
 * the point which is equidistant from the sides of the triangle. It is also the
 * point at which the bisectors of the triangle's angles meet. It is the centre
 * of the triangle's <i>incircle</i>, which is the unique circle that is
 * tangent to each of the triangle's three sides.
 *
 * @param {jsts.geom.Coordinate}
 *          a a vertx of the triangle.
 * @param {jsts.geom.Coordinate}
 *          b a vertx of the triangle.
 * @param {jsts.geom.Coordinate}
 *          c a vertx of the triangle.
 * @return {jsts.geom.Coordinate} the point which is the incentre of the
 *         triangle.
 */
jsts.geom.Triangle.inCentre = function(a, b, c) {
  var len0, len1, len2, circum, inCentreX, inCentreY;

  // the lengths of the sides, labelled by their opposite vertex
  len0 = b.distance(c);
  len1 = a.distance(c);
  len2 = a.distance(b);
  circum = len0 + len1 + len2;

  inCentreX = (len0 * a.x + len1 * b.x + len2 * c.x) / circum;
  inCentreY = (len0 * a.y + len1 * b.y + len2 * c.y) / circum;

  return new jsts.geom.Coordinate(inCentreX, inCentreY);
};


/**
 * Computes the centroid (centre of mass) of a triangle. This is also the point
 * at which the triangle's three medians intersect (a triangle median is the
 * segment from a vertex of the triangle to the midpoint of the opposite side).
 * The centroid divides each median in a ratio of 2:1. The centroid always lies
 * within the triangle.
 *
 *
 * @param {jsts.geom.Coordinate}
 *          a a vertx of the triangle.
 * @param {jsts.geom.Coordinate}
 *          b a vertx of the triangle.
 * @param {jsts.geom.Coordinate}
 *          c a vertx of the triangle.
 * @return {jsts.geom.Coordinate} the centroid of the triangle.
 */
jsts.geom.Triangle.centroid = function(a, b, c) {
  var x, y;

  x = (a.x + b.x + c.x) / 3;
  y = (a.y + b.y + c.y) / 3;

  return new jsts.geom.Coordinate(x, y);
};


/**
 * Computes the length of the longest side of a triangle
 *
 * @param {jsts.geom.Coordinate}
 *          a a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          b a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          c a vertex of the triangle.
 * @return {Number} the length of the longest side of the triangle.
 */
jsts.geom.Triangle.longestSideLength = function(a, b, c) {
  var lenAB, lenBC, lenCA, maxLen;

  lenAB = a.distance(b);
  lenBC = b.distance(c);
  lenCA = c.distance(a);
  maxLen = lenAB;

  if (lenBC > maxLen) {
    maxLen = lenBC;
  }
  if (lenCA > maxLen) {
    maxLen = lenCA;
  }
  return maxLen;
};


/**
 * Computes the point at which the bisector of the angle ABC cuts the segment
 * AC.
 *
 * @param {jsts.geom.Coordinate}
 *          a a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          b a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          c a vertex of the triangle.
 * @return {jsts.geom.Coordinate} the angle bisector cut point.
 */
jsts.geom.Triangle.angleBisector = function(a, b, c) {
  /**
   * Uses the fact that the lengths of the parts of the split segment are
   * proportional to the lengths of the adjacent triangle sides
   */
  var len0, len2, frac, dx, dy, splitPt;

  len0 = b.distance(a);
  len2 = b.distance(c);
  frac = len0 / (len0 + len2);
  dx = c.x - a.x;
  dy = c.y - a.y;

  splitPt = new jsts.geom.Coordinate(a.x + frac * dx, a.y + frac * dy);
  return splitPt;
};


/**
 * Computes the 2D area of a triangle. The area value is always non-negative.
 *
 * @param {jsts.geom.Coordinate}
 *          a a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          b a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          c a vertex of the triangle.
 * @return {Number} the area of the triangle.
 */
jsts.geom.Triangle.area = function(a, b, c) {
  return Math
      .abs(((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2.0);
};


/**
 * Computes the signed 2D area of a triangle. The area value is positive if the
 * triangle is oriented CW, and negative if it is oriented CCW.
 * <p>
 * The signed area value can be used to determine point orientation, but the
 * implementation in this method is susceptible to round-off errors. Use
 * {@link CGAlgorithms#orientationIndex(Coordinate, Coordinate, Coordinate)} for
 * robust orientation calculation.
 *
 * @param {jsts.geom.Coordinate}
 *          a a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          b a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          c a vertex of the triangle.
 * @return {Number} the signed 2D area of the triangle.
 *
 */
jsts.geom.Triangle.signedArea = function(a, b, c) {
  /**
   * Uses the formula 1/2 * | u x v | where u,v are the side vectors of the
   * triangle x is the vector cross-product For 2D vectors, this formula
   * simplifies to the expression below
   */
  return ((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2.0;
};

/**
 * Computes the incentre of a triangle. The <i>incentre</i> of a triangle is
 * the point which is equidistant from the sides of the triangle. It is also the
 * point at which the bisectors of the triangle's angles meet. It is the centre
 * of the triangle's <i>incircle</i>, which is the unique circle that is
 * tangent to each of the triangle's three sides.
 *
 * @return {jsts.geom.Coordinate} the point which is the inCentre of the
 *         triangle.
 */
jsts.geom.Triangle.prototype.inCentre = function() {
  return jsts.geom.Triangle.inCentre(this.p0, this.p1, this.p2);
};
/* ======================================================================
    jsts/noding/OrientedCoordinateArray.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */


/**
 * Allows comparing {@link Coordinate} arrays in an orientation-independent way.
 *
 * Creates a new {@link OrientedCoordinateArray} for the given
 * {@link Coordinate} array.
 *
 * @param pts
 *          the coordinates to orient.
 */
jsts.noding.OrientedCoordinateArray = function(pts) {
  this.pts = pts;
  this._orientation = jsts.noding.OrientedCoordinateArray.orientation(pts);
};


/**
 * @type {Array.<Coordinate>}
 * @private
 */
jsts.noding.OrientedCoordinateArray.prototype.pts = null;


/**
 * @type {boolean}
 * @private
 */
jsts.noding.OrientedCoordinateArray.prototype._orientation = undefined;


/**
 * Computes the canonical orientation for a coordinate array.
 *
 * @param {Array.
 *          <Coordinate>} pts the array to test.
 * @return <code>true</code> if the points are oriented forwards.
 * @return <code>false</code if the points are oriented in reverse.
 * @private
 */
jsts.noding.OrientedCoordinateArray.orientation = function(pts) {
  return jsts.geom.CoordinateArrays.increasingDirection(pts) === 1;
};

/**
 * Compares two {@link OrientedCoordinateArray}s for their relative order
 *
 * @return -1 this one is smaller.
 * @return 0 the two objects are equal.
 * @return 1 this one is greater.
 */

jsts.noding.OrientedCoordinateArray.prototype.compareTo = function(o1) {
  var oca = o1;
  var comp = jsts.noding.OrientedCoordinateArray.compareOriented(this.pts,
      this._orientation, oca.pts, oca._orientation);
  return comp;
};


/**
 * @private
 */
jsts.noding.OrientedCoordinateArray.compareOriented = function(pts1,
    orientation1, pts2, orientation2) {
  var dir1 = orientation1 ? 1 : -1;
  var dir2 = orientation2 ? 1 : -1;
  var limit1 = orientation1 ? pts1.length : -1;
  var limit2 = orientation2 ? pts2.length : -1;

  var i1 = orientation1 ? 0 : pts1.length - 1;
  var i2 = orientation2 ? 0 : pts2.length - 1;
  var comp = 0;
  while (true) {
    var compPt = pts1[i1].compareTo(pts2[i2]);
    if (compPt !== 0)
      return compPt;
    i1 += dir1;
    i2 += dir2;
    var done1 = i1 === limit1;
    var done2 = i2 === limit2;
    if (done1 && !done2)
      return -1;
    if (!done1 && done2)
      return 1;
    if (done1 && done2)
      return 0;
  }
};
/* ======================================================================
    jsts/algorithm/CentralEndpointIntersector.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * @param {Coordinate}
 *          p00
 * @param {Coordinate}
 *          p01
 * @param {Coordinate}
 *          p10
 * @param {Coordinate}
 *          p11
 * @constructor
 */
jsts.algorithm.CentralEndpointIntersector = function(p00, p01, p10, p11) {
  this.pts = [p00, p01, p10, p11];
  this.compute();
};


/**
 * @param {Coordinate}
 *          p00
 * @param {Coordinate}
 *          p01
 * @param {Coordinate}
 *          p10
 * @param {Coordinate}
 *          p11
 * @return {Coordinate}
 */
jsts.algorithm.CentralEndpointIntersector.getIntersection = function(p00, p01,
    p10, p11) {
  var intor = new jsts.algorithm.CentralEndpointIntersector(p00, p01, p10, p11);
  return intor.getIntersection();
};


/**
 * @type {Coordinate[]}
 * @private
 */
jsts.algorithm.CentralEndpointIntersector.prototype.pts = null;


/**
 * @type {Coordinate}
 * @private
 */
jsts.algorithm.CentralEndpointIntersector.prototype.intPt = null;


/**
 * @private
 */
jsts.algorithm.CentralEndpointIntersector.prototype.compute = function() {
  var centroid = jsts.algorithm.CentralEndpointIntersector.average(this.pts);
  this.intPt = this.findNearestPoint(centroid, this.pts);
};


/**
 * @return {Coordinate}
 */
jsts.algorithm.CentralEndpointIntersector.prototype.getIntersection = function() {
  return this.intPt;
};


/**
 * @param {Coordinate[]}
 *          pts
 * @return {Coordinate}
 * @private
 */
jsts.algorithm.CentralEndpointIntersector.average = function(pts) {
  var avg = new jsts.geom.Coordinate();
  var i, n = pts.length;
  for (i = 0; i < n; i++) {
    avg.x += pts[i].x;
    avg.y += pts[i].y;
  }
  if (n > 0) {
    avg.x /= n;
    avg.y /= n;
  }
  return avg;
};


/**
 * Determines a point closest to the given point.
 *
 * @param {Coordinate}
 *          p the point to compare against.
 * @param {Coordinate[]}
 *          pts
 * @return {Coordinate} the point closest to the input point p.
 * @private
 */
jsts.algorithm.CentralEndpointIntersector.prototype.findNearestPoint = function(
    p, pts) {
  var minDist = Number.MAX_VALUE;
  var i, result = null, dist;
  for (i = 0; i < pts.length; i++) {
    dist = p.distance(pts[i]);
    if (dist < minDist) {
      minDist = dist;
      result = pts[i];
    }
  }
  return result;
};
/* ======================================================================
    jsts/operation/buffer/BufferOp.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Computes the buffer of a geometry, for both positive and negative buffer
 * distances.
 *
 * In GIS, the positive buffer of a geometry is defined as
 * the Minkowski sum or difference of the geometry
 * with a circle of radius equal to the absolute value of the buffer distance.
 * In the CAD/CAM world buffers are known as </i>offset curves</i>.
 * In morphological analysis they are known as <i>erosion</i> and
 * <i>dilation</i>
 *
 * The buffer operation always returns a polygonal result.
 * The negative or zero-distance buffer of lines and points is always an empty
 * {@link Polygon}.
 *
 * Since true buffer curves may contain circular arcs,
 * computed buffer polygons can only be approximations to the true geometry.
 * The user can control the accuracy of the curve approximation by specifying
 * the number of linear segments used to approximate curves.
 *
 * The <b>end cap style</b> of a linear buffer may be specified. The
 * following end cap styles are supported:
 * <ul
 * <li>{@link #CAP_ROUND} - the usual round end caps
 * <li>{@link #CAP_BUTT} - end caps are truncated flat at the line ends
 * <li>{@link #CAP_SQUARE} - end caps are squared off at the buffer distance
 * beyond the line ends
 * </ul>
 *
 */



/**
 * Initializes a buffer computation for the given geometry with the given set of
 * parameters.
 *
 * @param {Geometry}
 *          g the geometry to buffer.
 * @param {BufferParameters}
 *          bufParams the buffer parameters to use.
 * @constructor
 */
jsts.operation.buffer.BufferOp = function(g, bufParams) {
  this.argGeom = g;
  this.bufParams = bufParams ? bufParams
      : new jsts.operation.buffer.BufferParameters();
};


/**
 * A number of digits of precision which leaves some computational "headroom"
 * for floating point operations.
 *
 * This value should be less than the decimal precision of double-precision
 * values (16).
 *
 * @type {int}
 */
jsts.operation.buffer.BufferOp.MAX_PRECISION_DIGITS = 12;


/**
 * Compute a scale factor to limit the precision of a given combination of
 * Geometry and buffer distance. The scale factor is determined by a combination
 * of the number of digits of precision in the (geometry + buffer distance),
 * limited by the supplied <code>maxPrecisionDigits</code> value.
 *
 * @param {Geometry}
 *          g the Geometry being buffered.
 * @param {double}
 *          distance the buffer distance.
 * @param {int}
 *          maxPrecisionDigits the max # of digits that should be allowed by the
 *          precision determined by the computed scale factor.
 *
 * @return {double} a scale factor for the buffer computation.
 */
jsts.operation.buffer.BufferOp.precisionScaleFactor = function(g, distance,
    maxPrecisionDigits) {
  var env = g.getEnvelopeInternal();
  var envSize = Math.max(env.getHeight(), env.getWidth());
  var expandByDistance = distance > 0.0 ? distance : 0.0;
  var bufEnvSize = envSize + 2 * expandByDistance;

  // the smallest power of 10 greater than the buffer envelope
  var bufEnvLog10 = (Math.log(bufEnvSize) / Math.log(10) + 1.0);
  var minUnitLog10 = bufEnvLog10 - maxPrecisionDigits;
  // scale factor is inverse of min Unit size, so flip sign of exponent
  var scaleFactor = Math.pow(10.0, -minUnitLog10);
  return scaleFactor;
};


/**
 * Computes the buffer of a geometry for a given buffer distance.
 *
 * @param {Geometry}
 *          g the geometry to buffer.
 * @param {double}
 *          distance the buffer distance.
 * @return {Geometry} the buffer of the input geometry.
 */
jsts.operation.buffer.BufferOp.bufferOp = function(g, distance) {
  if (arguments.length > 2) {
    return jsts.operation.buffer.BufferOp.bufferOp2.apply(this, arguments);
  }

  var gBuf = new jsts.operation.buffer.BufferOp(g);
  var geomBuf = gBuf.getResultGeometry(distance);
  return geomBuf;
};


/**
 * Computes the buffer for a geometry for a given buffer distance and accuracy
 * of approximation.
 *
 * @param {Geometry}
 *          g the geometry to buffer.
 * @param {double}
 *          distance the buffer distance.
 * @param {BufferParameters}
 *          params the buffer parameters to use.
 * @return {Geometry} the buffer of the input geometry.
 *
 */
jsts.operation.buffer.BufferOp.bufferOp2 = function(g, distance, params) {
  if (arguments.length > 3) {
    return jsts.operation.buffer.BufferOp.bufferOp3.apply(this, arguments);
  }

  var bufOp = new jsts.operation.buffer.BufferOp(g, params);
  var geomBuf = bufOp.getResultGeometry(distance);
  return geomBuf;
};


/**
 * Computes the buffer for a geometry for a given buffer distance and accuracy
 * of approximation.
 *
 * @param {Geometry}
 *          g the geometry to buffer.
 * @param {double}
 *          distance the buffer distance.
 * @param {int}
 *          quadrantSegments the number of segments used to approximate a
 *          quarter circle.
 * @return {Geometry} the buffer of the input geometry.
 *
 */
jsts.operation.buffer.BufferOp.bufferOp3 = function(g, distance,
    quadrantSegments) {
  if (arguments.length > 4) {
    return jsts.operation.buffer.BufferOp.bufferOp4.apply(this, arguments);
  }

  var bufOp = new jsts.operation.buffer.BufferOp(g);
  bufOp.setQuadrantSegments(quadrantSegments);
  var geomBuf = bufOp.getResultGeometry(distance);
  return geomBuf;
};


/**
 * Computes the buffer for a geometry for a given buffer distance and accuracy
 * of approximation.
 *
 * @param {Geometry}
 *          g the geometry to buffer.
 * @param {double}
 *          distance the buffer distance.
 * @param {int}
 *          quadrantSegments the number of segments used to approximate a
 *          quarter circle.
 * @param {int}
 *          endCapStyle the end cap style to use.
 * @return {Geometry} the buffer of the input geometry.
 *
 */
jsts.operation.buffer.BufferOp.bufferOp4 = function(g, distance,
    quadrantSegments, endCapStyle) {
  var bufOp = new jsts.operation.buffer.BufferOp(g);
  bufOp.setQuadrantSegments(quadrantSegments);
  bufOp.setEndCapStyle(endCapStyle);
  var geomBuf = bufOp.getResultGeometry(distance);
  return geomBuf;
};


/**
 * @type {Geometry}
 */
jsts.operation.buffer.BufferOp.prototype.argGeom = null;


/**
 * @type {double}
 */
jsts.operation.buffer.BufferOp.prototype.distance = null;


/**
 * @type {BufferParameters}
 */
jsts.operation.buffer.BufferOp.prototype.bufParams = null;


/**
 * @type {Geometry}
 */
jsts.operation.buffer.BufferOp.prototype.resultGeometry = null;


/**
 * Specifies the end cap style of the generated buffer. The styles supported are
 * {@link #CAP_ROUND}, {@link #CAP_BUTT}, and {@link #CAP_SQUARE}. The
 * default is CAP_ROUND.
 *
 * @param {int}
 *          endCapStyle the end cap style to specify.
 */
jsts.operation.buffer.BufferOp.prototype.setEndCapStyle = function(endCapStyle) {
  this.bufParams.setEndCapStyle(endCapStyle);
};


/**
 * Sets the number of segments used to approximate a angle fillet
 *
 * @param {int}
 *          quadrantSegments the number of segments in a fillet for a quadrant.
 */
jsts.operation.buffer.BufferOp.prototype.setQuadrantSegments = function(
    quadrantSegments) {
  this.bufParams.setQuadrantSegments(quadrantSegments);
};


/**
 * Returns the buffer computed for a geometry for a given buffer distance.
 *
 * @param {double}
 *          dist the buffer distance.
 * @return {Geometry} the buffer of the input geometry.
 */
jsts.operation.buffer.BufferOp.prototype.getResultGeometry = function(dist) {
  this.distance = dist;
  this.computeGeometry();
  return this.resultGeometry;
};

jsts.operation.buffer.BufferOp.prototype.computeGeometry = function() {
  this.bufferOriginalPrecision();
  if (this.resultGeometry !== null) {
    return;
  }

  var argPM = this.argGeom.getPrecisionModel();
  if (argPM.getType() === jsts.geom.PrecisionModel.FIXED) {
    this.bufferFixedPrecision(argPM);
  } else {
    this.bufferReducedPrecision();
  }
};


jsts.operation.buffer.BufferOp.prototype.bufferReducedPrecision = function() {
  var precDigits;
  var saveException = null;

  // try and compute with decreasing precision
  for (precDigits = jsts.operation.buffer.BufferOp.MAX_PRECISION_DIGITS; precDigits >= 0; precDigits--) {
    try {
      this.bufferReducedPrecision2(precDigits);
    } catch (/* TopologyException */ex) {
      saveException = ex;
      // don't propagate the exception - it will be detected by fact that
      // resultGeometry is null
    }
    if (this.resultGeometry !== null) {
      return;
    }
  }

  // tried everything - have to bail
  throw saveException;
};


jsts.operation.buffer.BufferOp.prototype.bufferOriginalPrecision = function() {
  try {
    // use fast noding by default
    var bufBuilder = new jsts.operation.buffer.BufferBuilder(this.bufParams);
    this.resultGeometry = bufBuilder.buffer(this.argGeom, this.distance);
  } catch (e) {
    // don't propagate the exception - it will be detected by fact that
    // resultGeometry is null
  }
};


/**
 * @param {int}
 *          precisionDigits
 */
jsts.operation.buffer.BufferOp.prototype.bufferReducedPrecision2 = function(
    precisionDigits) {

  var sizeBasedScaleFactor = jsts.operation.buffer.BufferOp
      .precisionScaleFactor(this.argGeom, this.distance, precisionDigits);

  var fixedPM = new jsts.geom.PrecisionModel(sizeBasedScaleFactor);
  this.bufferFixedPrecision(fixedPM);
};


/**
 * @param {PrecisionModel}
 *          fixedPM
 */
jsts.operation.buffer.BufferOp.prototype.bufferFixedPrecision = function(
    fixedPM) {
  var noder = new jsts.noding.ScaledNoder(
      new jsts.noding.snapround.MCIndexSnapRounder(
          new jsts.geom.PrecisionModel(1.0)), fixedPM.getScale());

  var bufBuilder = new jsts.operation.buffer.BufferBuilder(this.bufParams);
  bufBuilder.setWorkingPrecisionModel(fixedPM);
  bufBuilder.setNoder(noder);
  // this may throw an exception, if robustness errors are encountered
  this.resultGeometry = bufBuilder.buffer(this.argGeom, this.distance);
};
/* ======================================================================
    jsts/geomgraph/GeometryGraph.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * @requires jsts/geom/Location.js
   * @requires jsts/geomgraph/Position.js
   * @requires jsts/geomgraph/PlanarGraph.js
   * @requires jsts/util/Assert.js
   */

  var Location = jsts.geom.Location;
  var Position = jsts.geomgraph.Position;
  var Assert = jsts.util.Assert;



  /**
   * A GeometryGraph is a graph that models a given Geometry
   *
   * @param {int}
   *          argIndex
   * @param {Geometry}
   *          parentGeom
   * @param {BoundaryNodeRule}
   *          boundaryNodeRule
   * @augments jsts.planargraph.PlanarGraph
   */
  jsts.geomgraph.GeometryGraph = function(argIndex, parentGeom,
      boundaryNodeRule) {
    jsts.geomgraph.PlanarGraph.call(this);

    this.lineEdgeMap = new javascript.util.HashMap();

    this.ptLocator = new jsts.algorithm.PointLocator();

    this.argIndex = argIndex;
    this.parentGeom = parentGeom;
    this.boundaryNodeRule = boundaryNodeRule ||
        jsts.algorithm.BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;
    if (parentGeom !== null) {
      this.add(parentGeom);
    }
  };

  jsts.geomgraph.GeometryGraph.prototype = new jsts.geomgraph.PlanarGraph();
  jsts.geomgraph.GeometryGraph.constructor = jsts.geomgraph.GeometryGraph;

  /**
   * @return {EdgeSetIntersector}
   * @private
   */
  jsts.geomgraph.GeometryGraph.prototype.createEdgeSetIntersector = function() {
    //return new jsts.geomgraph.index.SimpleEdgeSetIntersector();
    // TODO: use optimized version when ported
    return new jsts.geomgraph.index.SimpleMCSweepLineIntersector();
    //return new jsts.geomgraph.index.SimpleSweepLineIntersector();
  };

  /**
   * @param {BoundaryNodeRule}
   *          boundaryNodeRule
   * @param {int}
   *          boundaryCount
   * @return {int}
   */
  jsts.geomgraph.GeometryGraph.determineBoundary = function(boundaryNodeRule,
      boundaryCount) {
    return boundaryNodeRule.isInBoundary(boundaryCount) ? Location.BOUNDARY
        : Location.INTERIOR;
  };


  /**
   * @type {Geometry}
   */
  jsts.geomgraph.GeometryGraph.prototype.parentGeom = null;


  /**
   * The lineEdgeMap is a map of the linestring components of the parentGeometry
   * to the edges which are derived from them. This is used to efficiently
   * perform findEdge queries
   *
   * @type {Object}
   * @private
   */
  jsts.geomgraph.GeometryGraph.prototype.lineEdgeMap = null;


  /**
   * @type {BoundaryNodeRule}
   */
  jsts.geomgraph.GeometryGraph.prototype.boundaryNodeRule = null;


  /**
   * If this flag is true, the Boundary Determination Rule will used when
   * deciding whether nodes are in the boundary or not
   */
  /**
   * @type {boolean}
   * @private
   */
  jsts.geomgraph.GeometryGraph.prototype.useBoundaryDeterminationRule = true;


  /**
   * the index of this geometry as an argument to a spatial function (used for
   * labelling)
   *
   * @type {number}
   * @private
   */
  jsts.geomgraph.GeometryGraph.prototype.argIndex = null;


  /**
   * @type {javascript.util.Collection}
   * @private
   */
  jsts.geomgraph.GeometryGraph.prototype.boundaryNodes = null;


  /**
   * @type {Coordinate}
   * @private
   */
  jsts.geomgraph.GeometryGraph.prototype.hasTooFewPoints = false;


  /**
   * @type {Coordinate}
   * @private
   */
  jsts.geomgraph.GeometryGraph.prototype.invalidPoint = null;


  /**
   * @type {PointOnGeometryLocator}
   * @private
   */
  jsts.geomgraph.GeometryGraph.prototype.areaPtLocator = null;


  /**
   * for use if geometry is not Polygonal
   *
   * @type {PointLocator}
   * @private
   */
  jsts.geomgraph.GeometryGraph.prototype.ptLocator = null;


  jsts.geomgraph.GeometryGraph.prototype.getGeometry = function() {
    return this.parentGeom;
  };

  jsts.geomgraph.GeometryGraph.prototype.getBoundaryNodes = function() {
    if (this.boundaryNodes === null)
      this.boundaryNodes = this.nodes.getBoundaryNodes(this.argIndex);
    return this.boundaryNodes;
  };

  jsts.geomgraph.GeometryGraph.prototype.getBoundaryNodeRule = function() {
    return this.boundaryNodeRule;
  };



  jsts.geomgraph.GeometryGraph.prototype.findEdge = function(line) {
    return this.lineEdgeMap.get(line);
  };

  jsts.geomgraph.GeometryGraph.prototype.computeSplitEdges = function(edgelist) {
    for (var i = this.edges.iterator(); i.hasNext();) {
      var e = i.next();
      e.eiList.addSplitEdges(edgelist);
    }
  }

  /**
   * @param {Geometry}
   *          g
   */
  jsts.geomgraph.GeometryGraph.prototype.add = function(g) {
    if (g.isEmpty()) {
      return;
    }

    // check if this Geometry should obey the Boundary Determination Rule
    // all collections except MultiPolygons obey the rule
    if (g instanceof jsts.geom.MultiPolygon)
      this.useBoundaryDeterminationRule = false;

    if (g instanceof jsts.geom.Polygon)
      this.addPolygon(g);
    // LineString also handles LinearRings
    else if (g instanceof jsts.geom.LineString)
      this.addLineString(g);
    else if (g instanceof jsts.geom.Point)
      this.addPoint(g);
    else if (g instanceof jsts.geom.MultiPoint)
      this.addCollection(g);
    else if (g instanceof jsts.geom.MultiLineString)
      this.addCollection(g);
    else if (g instanceof jsts.geom.MultiPolygon)
      this.addCollection(g);
    else if (g instanceof jsts.geom.GeometryCollection)
      this.addCollection(g);
    else
      throw new jsts.error.IllegalArgumentError('Geometry type not supported.');
  };


  /**
   * @private
   */
  jsts.geomgraph.GeometryGraph.prototype.addCollection = function(gc) {
    for (var i = 0; i < gc.getNumGeometries(); i++) {
      var g = gc.getGeometryN(i);
      this.add(g);
    }
  };


  /**
   * Add an Edge computed externally. The label on the Edge is assumed to be
   * correct.
   */
  jsts.geomgraph.GeometryGraph.prototype.addEdge = function(e) {
    this.insertEdge(e);
    var coord = e.getCoordinates();
    // insert the endpoint as a node, to mark that it is on the boundary
    this.insertPoint(this.argIndex, coord[0], Location.BOUNDARY);
    this.insertPoint(this.argIndex, coord[coord.length - 1], Location.BOUNDARY);
  };


  /**
   * Add a Point to the graph.
   */
  jsts.geomgraph.GeometryGraph.prototype.addPoint = function(p) {
    var coord = p.getCoordinate();
    this.insertPoint(this.argIndex, coord, Location.INTERIOR);
  };


  /**
   * @param {LineString}
   *          line
   * @private
   */
  jsts.geomgraph.GeometryGraph.prototype.addLineString = function(line) {
    var coord = jsts.geom.CoordinateArrays.removeRepeatedPoints(line
        .getCoordinates());

    if (coord.length < 2) {
      this.hasTooFewPoints = true;
      this.invalidPoint = coords[0];
      return;
    }

    // add the edge for the LineString
    // line edges do not have locations for their left and right sides
    var e = new jsts.geomgraph.Edge(coord, new jsts.geomgraph.Label(
        this.argIndex, Location.INTERIOR));
    this.lineEdgeMap.put(line, e);
    this.insertEdge(e);
    /**
     * Add the boundary points of the LineString, if any. Even if the LineString
     * is closed, add both points as if they were endpoints. This allows for the
     * case that the node already exists and is a boundary point.
     */
    Assert.isTrue(coord.length >= 2, 'found LineString with single point');
    this.insertBoundaryPoint(this.argIndex, coord[0]);
    this.insertBoundaryPoint(this.argIndex, coord[coord.length - 1]);
  };


  /**
   * Adds a polygon ring to the graph. Empty rings are ignored.
   *
   * The left and right topological location arguments assume that the ring is
   * oriented CW. If the ring is in the opposite orientation, the left and right
   * locations must be interchanged.
   *
   * @private
   */
  jsts.geomgraph.GeometryGraph.prototype.addPolygonRing = function(lr, cwLeft,
      cwRight) {
    // don't bother adding empty holes
    if (lr.isEmpty())
      return;

    var coord = jsts.geom.CoordinateArrays.removeRepeatedPoints(lr
        .getCoordinates());

    if (coord.length < 4) {
      this.hasTooFewPoints = true;
      this.invalidPoint = coord[0];
      return;
    }

    var left = cwLeft;
    var right = cwRight;
    if (jsts.algorithm.CGAlgorithms.isCCW(coord)) {
      left = cwRight;
      right = cwLeft;
    }
    var e = new jsts.geomgraph.Edge(coord, new jsts.geomgraph.Label(
        this.argIndex, Location.BOUNDARY, left, right));
    this.lineEdgeMap.put(lr, e);

    this.insertEdge(e);
    // insert the endpoint as a node, to mark that it is on the boundary
    this.insertPoint(this.argIndex, coord[0], Location.BOUNDARY);
  };


  /**
   * @private
   */
  jsts.geomgraph.GeometryGraph.prototype.addPolygon = function(p) {
    this.addPolygonRing(p.getExteriorRing(), Location.EXTERIOR,
        Location.INTERIOR);

    for (var i = 0; i < p.getNumInteriorRing(); i++) {
      var hole = p.getInteriorRingN(i);

      // Holes are topologically labelled opposite to the shell, since
      // the interior of the polygon lies on their opposite side
      // (on the left, if the hole is oriented CW)
      this.addPolygonRing(hole, Location.INTERIOR, Location.EXTERIOR);
    }
  };


  jsts.geomgraph.GeometryGraph.prototype.computeEdgeIntersections = function(g,
      li, includeProper) {
    var si = new jsts.geomgraph.index.SegmentIntersector(li, includeProper,
        true);
    si.setBoundaryNodes(this.getBoundaryNodes(), g.getBoundaryNodes());

    var esi = this.createEdgeSetIntersector();
    esi.computeIntersections(this.edges, g.edges, si);

    return si;
  };


  /**
   * Compute self-nodes, taking advantage of the Geometry type to minimize the
   * number of intersection tests. (E.g. rings are not tested for
   * self-intersection, since they are assumed to be valid).
   *
   * @param {LineIntersector}
   *          li the LineIntersector to use.
   * @param {boolean}
   *          computeRingSelfNodes if <false>, intersection checks are optimized
   *          to not test rings for self-intersection.
   * @return {SegmentIntersector} the SegmentIntersector used, containing
   *         information about the intersections found.
   */
  jsts.geomgraph.GeometryGraph.prototype.computeSelfNodes = function(li,
      computeRingSelfNodes) {
    var si = new jsts.geomgraph.index.SegmentIntersector(li, true, false);
    var esi = this.createEdgeSetIntersector();
    // optimized test for Polygons and Rings
    if (!computeRingSelfNodes &&
        (this.parentGeom instanceof jsts.geom.LinearRing ||
            this.parentGeom instanceof jsts.geom.Polygon || this.parentGeom instanceof jsts.geom.MultiPolygon)) {
      esi.computeIntersections(this.edges, si, false);
    } else {
      esi.computeIntersections(this.edges, si, true);
    }
    this.addSelfIntersectionNodes(this.argIndex);
    return si;
  };


  /**
   * @private
   */
  jsts.geomgraph.GeometryGraph.prototype.insertPoint = function(argIndex,
      coord, onLocation) {
    var n = this.nodes.addNode(coord);
    var lbl = n.getLabel();
    if (lbl == null) {
      n.label = new jsts.geomgraph.Label(argIndex, onLocation);
    } else
      lbl.setLocation(argIndex, onLocation);
  };


  /**
   * Adds candidate boundary points using the current {@link BoundaryNodeRule}.
   * This is used to add the boundary points of dim-1 geometries
   * (Curves/MultiCurves).
   */
  jsts.geomgraph.GeometryGraph.prototype.insertBoundaryPoint = function(
      argIndex, coord) {
    var n = this.nodes.addNode(coord);
    var lbl = n.getLabel();
    // the new point to insert is on a boundary
    var boundaryCount = 1;
    // determine the current location for the point (if any)
    var loc = Location.NONE;
    if (lbl !== null)
      loc = lbl.getLocation(argIndex, Position.ON);
    if (loc === Location.BOUNDARY)
      boundaryCount++;

    // determine the boundary status of the point according to the Boundary
    // Determination Rule
    var newLoc = jsts.geomgraph.GeometryGraph.determineBoundary(
        this.boundaryNodeRule, boundaryCount);
    lbl.setLocation(argIndex, newLoc);
  };


  /**
   * add edge intersections as self intersections from each edge intersection
   * list
   *
   * @param argIndex
   * @private
   */
  jsts.geomgraph.GeometryGraph.prototype.addSelfIntersectionNodes = function(
      argIndex) {
    for (var i = this.edges.iterator(); i.hasNext();) {
      var e = i.next();
      var eLoc = e.getLabel().getLocation(argIndex);
      for (var eiIt = e.eiList.iterator(); eiIt.hasNext();) {
        var ei = eiIt.next();
        this.addSelfIntersectionNode(argIndex, ei.coord, eLoc);
      }
    }
  };


  /**
   * Add a node for a self-intersection. If the node is a potential boundary
   * node (e.g. came from an edge which is a boundary) then insert it as a
   * potential boundary node. Otherwise, just add it as a regular node.
   *
   * @private
   */
  jsts.geomgraph.GeometryGraph.prototype.addSelfIntersectionNode = function(
      argIndex, coord, loc) {
    // if this node is already a boundary node, don't change it
    if (this.isBoundaryNode(argIndex, coord))
      return;
    if (loc === Location.BOUNDARY && this.useBoundaryDeterminationRule)
      this.insertBoundaryPoint(argIndex, coord);
    else
      this.insertPoint(argIndex, coord, loc);
  };

  jsts.geomgraph.GeometryGraph.prototype.getInvalidPoint = function() {
    return this.invalidPoint;
  };

})();

// TODO: port rest of class
/* ======================================================================
    jsts/operation/buffer/OffsetSegmentString.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */


/**
 * A dynamic list of the vertices in a constructed offset curve. Automatically
 * removes adjacent vertices which are closer than a given tolerance.
 * @constructor
 */
jsts.operation.buffer.OffsetSegmentString = function() {
  this.ptList = [];
};


/**
 * @private
 */
jsts.operation.buffer.OffsetSegmentString.prototype.ptList = null;


/**
 * @private
 */
jsts.operation.buffer.OffsetSegmentString.prototype.precisionModel = null;


/**
 * The distance below which two adjacent points on the curve are considered to
 * be coincident. This is chosen to be a small fraction of the offset distance.
 *
 * @private
 */
jsts.operation.buffer.OffsetSegmentString.prototype.minimimVertexDistance = 0.0;


jsts.operation.buffer.OffsetSegmentString.prototype.setPrecisionModel = function(
    precisionModel) {
  this.precisionModel = precisionModel;
};

jsts.operation.buffer.OffsetSegmentString.prototype.setMinimumVertexDistance = function(
    minimimVertexDistance) {
  this.minimimVertexDistance = minimimVertexDistance;
};

jsts.operation.buffer.OffsetSegmentString.prototype.addPt = function(pt) {
  var bufPt = new jsts.geom.Coordinate(pt);
  this.precisionModel.makePrecise(bufPt);
  // don't add duplicate (or near-duplicate) points
  if (this.isRedundant(bufPt))
    return;
  this.ptList.push(bufPt);
};

jsts.operation.buffer.OffsetSegmentString.prototype.addPts = function(pt,
    isForward) {
  if (isForward) {
    for (var i = 0; i < pt.length; i++) {
      this.addPt(pt[i]);
    }
  } else {
    for (var i = pt.length - 1; i >= 0; i--) {
      this.addPt(pt[i]);
    }
  }
};


/**
 * Tests whether the given point is redundant relative to the previous point in
 * the list (up to tolerance).
 *
 * @param pt
 * @return true if the point is redundant.
 * @private
 */
jsts.operation.buffer.OffsetSegmentString.prototype.isRedundant = function(pt) {
  if (this.ptList.length < 1)
    return false;
  var lastPt = this.ptList[this.ptList.length - 1];
  var ptDist = pt.distance(lastPt);
  if (ptDist < this.minimimVertexDistance)
    return true;
  return false;
};

jsts.operation.buffer.OffsetSegmentString.prototype.closeRing = function() {
  if (this.ptList.length < 1)
    return;
  var startPt = new jsts.geom.Coordinate(this.ptList[0]);
  var lastPt = this.ptList[this.ptList.length - 1];
  var last2Pt = null;
  if (this.ptList.length >= 2)
    last2Pt = this.ptList[this.ptList.length - 2];
  if (startPt.equals(lastPt))
    return;
  this.ptList.push(startPt);
};

jsts.operation.buffer.OffsetSegmentString.prototype.reverse = function() {

};

jsts.operation.buffer.OffsetSegmentString.prototype.getCoordinates = function() {
  return this.ptList;
};
/* ======================================================================
    jsts/algorithm/distance/PointPairDistance.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Port source: /jts/jts/java/src/com/vividsolutions/jts/algorithm/distance/PointPairDistance.java
 * Revision: 6
 */

/**
 * @requires jsts/geom/Coordinate.js
 */


/**
 * Contains a pair of points and the distance between them. Provides methods to
 * update with a new point pair with either maximum or minimum distance.
 */
jsts.algorithm.distance.PointPairDistance = function() {
  this.pt = [new jsts.geom.Coordinate(), new jsts.geom.Coordinate()];
};

jsts.algorithm.distance.PointPairDistance.prototype.pt = null;
jsts.algorithm.distance.PointPairDistance.prototype.distance = NaN;
jsts.algorithm.distance.PointPairDistance.prototype.isNull = true;

/**
 * Initializes the points, avoiding recomputing the distance.
 *
 * @param p0
 * @param p1
 * @param distance
 *          the distance between p0 and p1.
 */
jsts.algorithm.distance.PointPairDistance.prototype.initialize = function(p0,
    p1, distance) {
  if (p0 === undefined) {
    this.isNull = true;
    return;
  }

  this.pt[0].setCoordinate(p0);
  this.pt[1].setCoordinate(p1);
  this.distance = distance !== undefined ? distance : p0.distance(p1);
  this.isNull = false;
};

jsts.algorithm.distance.PointPairDistance.prototype.getDistance = function() {
  return this.distance;
};

jsts.algorithm.distance.PointPairDistance.prototype.getCoordinates = function() {
  return this.pt;
};

jsts.algorithm.distance.PointPairDistance.prototype.getCoordinate = function(i) {
  return this.pt[i];
};

jsts.algorithm.distance.PointPairDistance.prototype.setMaximum = function(
    ptDist) {
  if (arguments.length === 2) {
    this.setMaximum2.apply(this, arguments);
    return;
  }

  this.setMaximum(ptDist.pt[0], ptDist.pt[1]);
};

jsts.algorithm.distance.PointPairDistance.prototype.setMaximum2 = function(p0,
    p1) {
  if (this.isNull) {
    this.initialize(p0, p1);
    return;
  }
  var dist = p0.distance(p1);
  if (dist > this.distance)
    this.initialize(p0, p1, dist);
};

jsts.algorithm.distance.PointPairDistance.prototype.setMinimum = function(
    ptDist) {
  if (arguments.length === 2) {
    this.setMinimum2.apply(this, arguments);
    return;
  }

  this.setMinimum(ptDist.pt[0], ptDist.pt[1]);
};

jsts.algorithm.distance.PointPairDistance.prototype.setMinimum2 = function(p0,
    p1) {
  if (this.isNull) {
    this.initialize(p0, p1);
    return;
  }
  var dist = p0.distance(p1);
  if (dist < this.distance)
    this.initialize(p0, p1, dist);
};

// NOTE: toString not ported
/* ======================================================================
    jsts/algorithm/distance/DiscreteHausdorffDistance.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Port source:
 * /jts/jts/java/src/com/vividsolutions/jts/algorithm/distance/DiscreteHausdorffDistance.java
 * Revision: 6
 */

/**
 * @requires jsts/geom/CoordinateFilter.js
 * @requires jsts/geom/CoordinateSequenceFilter.js
 * @requires jsts/algorithm/distance/PointPairDistance.js
 * @requires jsts/algorithm/distance/DistanceToPoint.js
 */

(function() {

  var PointPairDistance = jsts.algorithm.distance.PointPairDistance;
  var DistanceToPoint = jsts.algorithm.distance.DistanceToPoint;

  var MaxPointDistanceFilter = function(geom) {
    this.maxPtDist = new PointPairDistance();
    this.minPtDist = new PointPairDistance();
    this.euclideanDist = new DistanceToPoint();

    this.geom = geom;
  };

  MaxPointDistanceFilter.prototype = new jsts.geom.CoordinateFilter();

  MaxPointDistanceFilter.prototype.maxPtDist = new PointPairDistance();
  MaxPointDistanceFilter.prototype.minPtDist = new PointPairDistance();
  MaxPointDistanceFilter.prototype.euclideanDist = new DistanceToPoint();
  MaxPointDistanceFilter.prototype.geom;

  MaxPointDistanceFilter.prototype.filter = function(pt) {
    this.minPtDist.initialize();
    DistanceToPoint.computeDistance(this.geom, pt, this.minPtDist);
    this.maxPtDist.setMaximum(this.minPtDist);
  };

  MaxPointDistanceFilter.prototype.getMaxPointDistance = function() {
    return this.maxPtDist;
  };


  var MaxDensifiedByFractionDistanceFilter = function(geom, fraction) {
    this.maxPtDist = new PointPairDistance();
    this.minPtDist = new PointPairDistance();

    this.geom = geom;
    // NOTE: Math.rint in JTS changed to Math.round
    this.numSubSegs = Math.round(1.0 / fraction);
  };

  MaxDensifiedByFractionDistanceFilter.prototype = new jsts.geom.CoordinateSequenceFilter();

  MaxDensifiedByFractionDistanceFilter.prototype.maxPtDist = new PointPairDistance();
  MaxDensifiedByFractionDistanceFilter.prototype.minPtDist = new PointPairDistance();
  MaxDensifiedByFractionDistanceFilter.prototype.geom;
  MaxDensifiedByFractionDistanceFilter.prototype.numSubSegs = 0;

  MaxDensifiedByFractionDistanceFilter.prototype.filter = function(seq, index) {
    /**
     * This logic also handles skipping Point geometries
     */
    if (index == 0)
      return;

    var p0 = seq[index - 1];
    var p1 = seq[index];

    var delx = (p1.x - p0.x) / this.numSubSegs;
    var dely = (p1.y - p0.y) / this.numSubSegs;

    for (var i = 0; i < this.numSubSegs; i++) {
      var x = p0.x + i * delx;
      var y = p0.y + i * dely;
      var pt = new jsts.geom.Coordinate(x, y);
      this.minPtDist.initialize();
      DistanceToPoint.computeDistance(this.geom, pt, this.minPtDist);
      this.maxPtDist.setMaximum(this.minPtDist);
    }
  };

  MaxDensifiedByFractionDistanceFilter.prototype.isGeometryChanged = function() {
    return false;
  };

  MaxDensifiedByFractionDistanceFilter.prototype.isDone = function() {
    return false;
  };

  MaxDensifiedByFractionDistanceFilter.prototype.getMaxPointDistance = function() {
    return this.maxPtDist;
  };

  /**
   * An algorithm for computing a distance metric which is an approximation to
   * the Hausdorff Distance based on a discretization of the input
   * {@link Geometry}. The algorithm computes the Hausdorff distance restricted
   * to discrete points for one of the geometries. The points can be either the
   * vertices of the geometries (the default), or the geometries with line
   * segments densified by a given fraction. Also determines two points of the
   * Geometries which are separated by the computed distance.
   * <p>
   * This algorithm is an approximation to the standard Hausdorff distance.
   * Specifically,
   *
   * <pre>
   *    for all geometries a, b:    DHD(a, b) &lt;= HD(a, b)
   * </pre>
   *
   * The approximation can be made as close as needed by densifying the input
   * geometries. In the limit, this value will approach the true Hausdorff
   * distance:
   *
   * <pre>
   *    DHD(A, B, densifyFactor) -&gt; HD(A, B) as densifyFactor -&gt; 0.0
   * </pre>
   *
   * The default approximation is exact or close enough for a large subset of
   * useful cases. Examples of these are:
   * <ul>
   * <li>computing distance between Linestrings that are roughly parallel to
   * each other, and roughly equal in length. This occurs in matching linear
   * networks.
   * <li>Testing similarity of geometries.
   * </ul>
   * An example where the default approximation is not close is:
   *
   * <pre>
   *   A = LINESTRING (0 0, 100 0, 10 100, 10 100)
   *   B = LINESTRING (0 100, 0 10, 80 10)
   *
   *   DHD(A, B) = 22.360679774997898
   *   HD(A, B) &tilde;= 47.8
   * </pre>
   */
  jsts.algorithm.distance.DiscreteHausdorffDistance = function(g0, g1) {
    this.g0 = g0;
    this.g1 = g1;

    this.ptDist = new jsts.algorithm.distance.PointPairDistance();
  };

  jsts.algorithm.distance.DiscreteHausdorffDistance.prototype.g0 = null;
  jsts.algorithm.distance.DiscreteHausdorffDistance.prototype.g1 = null;
  jsts.algorithm.distance.DiscreteHausdorffDistance.prototype.ptDist = null;
  /**
   * Value of 0.0 indicates that no densification should take place
   */
  jsts.algorithm.distance.DiscreteHausdorffDistance.prototype.densifyFrac = 0.0;

  jsts.algorithm.distance.DiscreteHausdorffDistance.distance = function(g0, g1,
      densifyFrac) {
    var dist = new jsts.algorithm.distance.DiscreteHausdorffDistance(g0, g1);
    if (densifyFrac !== undefined)
      dist.setDensifyFraction(densifyFrac);
    return dist.distance();
  };


  /**
   * Sets the fraction by which to densify each segment. Each segment will be
   * (virtually) split into a number of equal-length subsegments, whose fraction
   * of the total length is closest to the given fraction.
   *
   * @param densifyPercent
   */
  jsts.algorithm.distance.DiscreteHausdorffDistance.prototype.setDensifyFraction = function(
      densifyFrac) {
    if (densifyFrac > 1.0 || densifyFrac <= 0.0)
      throw new jsts.error.IllegalArgumentError(
          'Fraction is not in range (0.0 - 1.0]');

    this.densifyFrac = densifyFrac;
  };

  jsts.algorithm.distance.DiscreteHausdorffDistance.prototype.distance = function() {
    this.compute(this.g0, this.g1);
    return ptDist.getDistance();
  };

  jsts.algorithm.distance.DiscreteHausdorffDistance.prototype.orientedDistance = function() {
    this.computeOrientedDistance(this.g0, this.g1, this.ptDist);
    return this.ptDist.getDistance();
  };

  jsts.algorithm.distance.DiscreteHausdorffDistance.prototype.getCoordinates = function() {
    return ptDist.getCoordinates();
  };

  /**
   *
   * @private
   */
  jsts.algorithm.distance.DiscreteHausdorffDistance.prototype.compute = function(
      g0, g1) {
    this.computeOrientedDistance(g0, g1, this.ptDist);
    this.computeOrientedDistance(g1, g0, this.ptDist);
  };

  /**
   *
   * @private
   */
  jsts.algorithm.distance.DiscreteHausdorffDistance.prototype.computeOrientedDistance = function(
      discreteGeom, geom, ptDist) {
    var distFilter = new MaxPointDistanceFilter(geom);
    discreteGeom.apply(distFilter);
    ptDist.setMaximum(distFilter.getMaxPointDistance());

    if (this.densifyFrac > 0) {
      var fracFilter = new MaxDensifiedByFractionDistanceFilter(geom,
          this.densifyFrac);
      discreteGeom.apply(fracFilter);
      ptDist.setMaximum(fracFilter.getMaxPointDistance());

    }
  };


})();
/* ======================================================================
    jsts/algorithm/MinimumBoundingCircle.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @requires jsts/geom/Geometry.js
 * @requires jsts/geom/Coordinate.js
 * @requires jsts/geom/Triangle.js
 * @requires jsts/geom/CoordinateArrays.js
 * @requires jsts/algorithm/Angle.js
 */

/**
 * Computes the <b>Minimum Bounding Circle</b> (MBC)
 * for the points in a {@link Geometry}.
 * The MBC is the smallest circle which <tt>cover</tt>s
 * all the input points 
 * (this is also known as the <b>Smallest Enclosing Circle</b>).
 * This is equivalent to computing the Maximum Diameter 
 * of the input point set.
 * <p>
 * The computed circle can be specified in two equivalent ways,
 * both of which are provide as output by this class:
 * <ul>
 * <li>As a centre point and a radius
 * <li>By the set of points defining the circle.
 * Depending on the number of points in the input
 * and their relative positions, this
 * will be specified by anywhere from 0 to 3 points. 
 * <ul>
 * <li>0 or 1 points indicate an empty or trivial input point arrangement.
 * <li>2 or 3 points define a circle which contains 
 * all the input points.
 * </ul>
 * </ul>
 * The class can also output a {@link Geometry} which approximates the
 * shape of the MBC (although as an approximation 
 * it is <b>not</b> guaranteed to <tt>cover</tt> all the input points.)
 * 
 * @author Martin Davis
 * 
 * @see MinimumDiameter
 *
 */
jsts.algorithm.MinimumBoundingCircle = function (geom) {

    /*
     * The algorithm used is based on the one by Jon Rokne in 
     * the article "An Easy Bounding Circle" in <i>Graphic Gems II</i>.
     */

    /**
     * @type {jsts.geom.Geometry}
     * @private
     */
    this.input = null;

    /**
     * @type {jsts.geom.Coordinate[]}
     * @private
     */
    this.extremalPts = null;

    /**
     * @type {jsts.geom.Coordinate}
     * @private
     */
    this.centre = null;

    /**
     * @type {number}
     * @private
     */
    this.radius = 0;


    this.input = geom;
};

/**
 * Gets a geometry which represents the Minimum Bounding Circle.
 * If the input is degenerate (empty or a single unique point),
 * this method will return an empty geometry or a single Point geometry.
 * Otherwise, a Polygon will be returned which approximates the 
 * Minimum Bounding Circle. 
 * (Note that because the computed polygon is only an approximation, 
 * it may not precisely contain all the input points.)
 * 
 * @return a Geometry representing the Minimum Bounding Circle.
 */
jsts.algorithm.MinimumBoundingCircle.prototype.getCircle = function () {
    //TODO: ensure the output circle contains the extermal points.
    //TODO: or maybe even ensure that the returned geometry contains ALL the input points?

    this.compute();
    if (this.centre === null) {
        return this.input.getFactory().createPolygon(null, null);
    }
    var centrePoint = this.input.getFactory().createPoint(this.centre);
    if (this.radius === 0) {
        return centrePoint;
    }
    return centrePoint.buffer(this.radius);
};

/**
 * Gets the extremal points which define the computed Minimum Bounding Circle.
 * There may be zero, one, two or three of these points,
 * depending on the number of points in the input
 * and the geometry of those points.
 * 
 * @return {jsts.geom.Coordinate[]} the points defining the Minimum Bounding Circle
 */
jsts.algorithm.MinimumBoundingCircle.prototype.getExtremalPoints = function () {
    this.compute();
    return this.extremalPts;
};

/**
 * Gets the centre point of the computed Minimum Bounding Circle.
 * 
 * @return {jsts.geom.Coordinate} the centre point of the Minimum Bounding Circle
 * @return null if the input is empty
 */
jsts.algorithm.MinimumBoundingCircle.prototype.getCentre = function () {
    this.compute();
    return this.centre;
};

/**
 * Gets the radius of the computed Minimum Bounding Circle.
 * 
 * @return {number} the radius of the Minimum Bounding Circle
 */
jsts.algorithm.MinimumBoundingCircle.prototype.getRadius = function () {
    this.compute();
    return this.radius;
};

/**
 * @private
 */
jsts.algorithm.MinimumBoundingCircle.prototype.computeCentre = function () {
    switch (this.extremalPts.length) {
        case 0:
            this.centre = null;
            break;
        case 1:
            this.centre = this.extremalPts[0];
            break;
        case 2:
            this.centre = new jsts.geom.Coordinate(
				(this.extremalPts[0].x + this.extremalPts[1].x) / 2,
				(this.extremalPts[0].y + this.extremalPts[1].y) / 2
			);
            break;
        case 3:
            this.centre = jsts.geom.Triangle.circumcentre(
                this.extremalPts[0], this.extremalPts[1], this.extremalPts[2]);
            break;
    }
};

/**
 * @private
 */
jsts.algorithm.MinimumBoundingCircle.prototype.compute = function () {
    if (this.extremalPts !== null) {
        return;
    }

    this.computeCirclePoints();
    this.computeCentre();
    if (this.centre !== null) {
        this.radius = this.centre.distance(this.extremalPts[0]);
    }
};

/**
 * @private
 */
jsts.algorithm.MinimumBoundingCircle.prototype.computeCirclePoints = function () {
    // handle degenerate or trivial cases
    if (this.input.isEmpty()) {
        this.extremalPts = [];
        return;
    }

    var pts;
    if (this.input.getNumPoints() === 1) {
        pts = this.input.getCoordinates();
        this.extremalPts = [new jsts.geom.Coordinate(pts[0])];
        return;
    }

    /**
     * The problem is simplified by reducing to the convex hull.
     * Computing the convex hull also has the useful effect of eliminating duplicate points
     */
    var convexHull = this.input.convexHull();

    var hullPts = convexHull.getCoordinates();

    // strip duplicate final point, if any
    pts = hullPts;
    if (hullPts[0].equals2D(hullPts[hullPts.length - 1])) {
        pts = [];
        jsts.geom.CoordinateArrays.copyDeep(hullPts, 0, pts, 0, hullPts.length - 1);
    }

    /**
     * Optimization for the trivial case where the CH has fewer than 3 points
     */
    if (pts.length <= 2) {
        this.extremalPts = jsts.geom.CoordinateArrays.copyDeep(pts);
        return;
    }

    // find a point P with minimum Y ordinate
    var P = jsts.algorithm.MinimumBoundingCircle.lowestPoint(pts);

    // find a point Q such that the angle that PQ makes with the x-axis is minimal
    var Q = jsts.algorithm.MinimumBoundingCircle.pointWitMinAngleWithX(pts, P);

    /**
     * Iterate over the remaining points to find 
     * a pair or triplet of points which determine the minimal circle.
     * By the design of the algorithm, 
     * at most <tt>pts.length</tt> iterations are required to terminate 
     * with a correct result.
     */
    for (var i = 0; i < pts.length; i++) {
        var R = jsts.algorithm.MinimumBoundingCircle.pointWithMinAngleWithSegment(pts, P, Q);

        // if PRQ is obtuse, then MBC is determined by P and Q
        if (jsts.algorithm.Angle.isObtuse(P, R, Q)) {
            this.extremalPts = [new jsts.geom.Coordinate(P), new jsts.geom.Coordinate(Q)];
            return;
        }
        // if RPQ is obtuse, update baseline and iterate
        if (jsts.algorithm.Angle.isObtuse(R, P, Q)) {
            P = R;
            continue;
        }
        // if RQP is obtuse, update baseline and iterate
        if (jsts.algorithm.Angle.isObtuse(R, Q, P)) {
            Q = R;
            continue;
        }
        // otherwise all angles are acute, and the MBC is determined by the triangle PQR
        this.extremalPts = [new jsts.geom.Coordinate(P), new jsts.geom.Coordinate(Q), new jsts.geom.Coordinate(R)];
        return;
    }
    throw new Error("Logic failure in Minimum Bounding Circle algorithm!");
};

/**
 * @param {jsts.geom.Coordinate[]} pts
 * @return {jsts.geom.Coordinate}
 *
 * @private
 */
jsts.algorithm.MinimumBoundingCircle.lowestPoint = function (pts) {
    var min = pts[0];
    for (var i = 1; i < pts.length; i++) {
        if (pts[i].y < min.y) {
            min = pts[i];
        }
    }
    return min;
};

/**
 * @param {jsts.geom.Coordinate[]} pts
 * @param {jsts.geom.Coordinate} p
 * @return {jsts.geom.Coordinate}
 *
 * @private
 */
jsts.algorithm.MinimumBoundingCircle.pointWitMinAngleWithX = function (pts, P) {
    var minSin = Number.MAX_VALUE;
    var minAngPt = null;
    for (var i = 0; i < pts.length; i++) {

        var p = pts[i];
        if (p === P) continue;

        /**
         * The sin of the angle is a simpler proxy for the angle itself
         */
        var dx = p.x - P.x;
        var dy = p.y - P.y;
        if (dy < 0) dy = -dy;
        var len = Math.sqrt(dx * dx + dy * dy);
        var sin = dy / len;

        if (sin < minSin) {
            minSin = sin;
            minAngPt = p;
        }
    }
    return minAngPt;
};

/**
 * @param {jsts.geom.Coordinate[]} pts
 * @param {jsts.geom.Coordinate} P
 * @param {jsts.geom.Coordinate} Q
 * @return {jsts.geom.Coordinate}
 *
 * @private
 */
jsts.algorithm.MinimumBoundingCircle.pointWithMinAngleWithSegment = function (pts, P, Q) {
    var minAng = Number.MAX_VALUE;
    var minAngPt = null;
    for (var i = 0; i < pts.length; i++) {

        var p = pts[i];
        if (p === P) continue;
        if (p === Q) continue;

        var ang = jsts.algorithm.Angle.angleBetween(P, p, Q);
        if (ang < minAng) {
            minAng = ang;
            minAngPt = p;
        }
    }
    return minAngPt;
};
/* ======================================================================
    jsts/noding/ScaledNoder.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Port source: /jts/jts/java/src/com/vividsolutions/jts/noding/ScaledNoder.java
 * Revision: 478
 */

jsts.noding.ScaledNoder = function(noder, scaleFactor, offsetX, offsetY) {
  this.offsetX = offsetX ? offsetX : 0;
  this.offsetY = offsetY ? offsetY : 0;

  this.noder = noder;
  this.scaleFactor = scaleFactor;

  // no need to scale if input precision is already integral
  this.isScaled = !this.isIntegerPrecision();
};

jsts.noding.ScaledNoder.prototype = new jsts.noding.Noder();
jsts.noding.ScaledNoder.constructor = jsts.noding.ScaledNoder;

jsts.noding.ScaledNoder.prototype.noder = null;
jsts.noding.ScaledNoder.prototype.scaleFactor = undefined;
jsts.noding.ScaledNoder.prototype.offsetX = undefined;
jsts.noding.ScaledNoder.prototype.offsetY = undefined;
jsts.noding.ScaledNoder.prototype.isScaled = false;

jsts.noding.ScaledNoder.prototype.isIntegerPrecision = function() {
  return this.scaleFactor === 1.0;
};

jsts.noding.ScaledNoder.prototype.getNodedSubstrings = function() {
  var splitSS = this.noder.getNodedSubstrings();
  if (this.isScaled)
    this.rescale(splitSS);
  return splitSS;
};

jsts.noding.ScaledNoder.prototype.computeNodes = function(inputSegStrings) {
  var intSegStrings = inputSegStrings;
  if (this.isScaled)
    intSegStrings = this.scale(inputSegStrings);
  this.noder.computeNodes(intSegStrings);
};

/**
 * @private
 */
jsts.noding.ScaledNoder.prototype.scale = function(segStrings) {
  if (segStrings instanceof Array) {
    return this.scale2(segStrings);
  }

  var transformed = new javascript.util.ArrayList();
  for (var i = segStrings.iterator(); i.hasNext();) {
    var ss = i.next();
    transformed.add(new jsts.noding.NodedSegmentString(this.scale(ss
        .getCoordinates()), ss.getData()));
  }

  return transformed;
};

/**
 * @private
 */
jsts.noding.ScaledNoder.prototype.scale2 = function(pts) {
  var roundPts = [];
  for (var i = 0; i < pts.length; i++) {
    roundPts[i] = new jsts.geom.Coordinate(Math
        .round((pts[i].x - this.offsetX) * this.scaleFactor), Math
        .round((pts[i].y - this.offsetY) * this.scaleFactor));
  }
  var roundPtsNoDup = jsts.geom.CoordinateArrays.removeRepeatedPoints(roundPts);
  return roundPtsNoDup;
};

/**
 * @private
 */
jsts.noding.ScaledNoder.prototype.rescale = function(segStrings) {
  if (segStrings instanceof Array) {
    this.rescale2(segStrings);
    return;
  }

  for (var i = segStrings.iterator(); i.hasNext();) {
    var ss = i.next();
    this.rescale(ss.getCoordinates());
  }
};

/**
 * @private
 */
jsts.noding.ScaledNoder.prototype.rescale2 = function(pts) {
  for (var i = 0; i < pts.length; i++) {
    pts[i].x = pts[i].x / this.scaleFactor + this.offsetX;
    pts[i].y = pts[i].y / this.scaleFactor + this.offsetY;
  }
};
/* ======================================================================
    jsts/geomgraph/index/SegmentIntersector.js
   ====================================================================== */

/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  var ArrayList = javascript.util.ArrayList;

  /**
   * Computes the intersection of line segments, and adds the intersection to
   * the edges containing the segments.
   *
   * @param {LineIntersector}
   *          li
   * @param {boolean}
   *          includeProper
   * @param {boolean}
   *          recordIsolated
   * @constructor
   */
  jsts.geomgraph.index.SegmentIntersector = function(li, includeProper, recordIsolated) {
    this.li = li;
    this.includeProper = includeProper;
    this.recordIsolated = recordIsolated;
  };


  /**
   * @param {number}
   *          i1
   * @param {number}
   *          i2
   * @return {boolean}
   */
  jsts.geomgraph.index.SegmentIntersector.isAdjacentSegments = function(i1, i2) {
    return Math.abs(i1 - i2) === 1;
  };


  /**
   * @type {boolean}
   * @private
   */
  jsts.geomgraph.index.SegmentIntersector.prototype._hasIntersection = false;


  /**
   * @type {boolean}
   * @private
   */
  jsts.geomgraph.index.SegmentIntersector.prototype.hasProper = false;


  /**
   * @type {boolean}
   * @private
   */
  jsts.geomgraph.index.SegmentIntersector.prototype.hasProperInterior = false;


  /**
   * the proper intersection point found
   *
   * @type {Coordinate}
   * @private
   */
  jsts.geomgraph.index.SegmentIntersector.prototype.properIntersectionPoint = null;


  /**
   * @type {LineIntersector}
   * @private
   */
  jsts.geomgraph.index.SegmentIntersector.prototype.li = null;


  /**
   * @type {boolean}
   * @private
   */
  jsts.geomgraph.index.SegmentIntersector.prototype.includeProper = null;


  /**
   * @type {boolean}
   * @private
   */
  jsts.geomgraph.index.SegmentIntersector.prototype.recordIsolated = null;


  /**
   * @type {boolean}
   * @private
   */
  jsts.geomgraph.index.SegmentIntersector.prototype.isSelfIntersection = null;


  /**
   * @type {number}
   * @private
   */
  jsts.geomgraph.index.SegmentIntersector.prototype.numIntersections = 0;


  /**
   * testing only
   *
   * @type {number}
   */
  jsts.geomgraph.index.SegmentIntersector.prototype.numTests = 0;


  /**
   * @type {Array.<javascript.util.Collection>}
   * @private
   */
  jsts.geomgraph.index.SegmentIntersector.prototype.bdyNodes = null;


  /**
   * @param {javascript.util.Collection}
   *          bdyNodes0
   * @param {javascript.util.Collection}
   *          bdyNodes1
   */
  jsts.geomgraph.index.SegmentIntersector.prototype.setBoundaryNodes = function(bdyNodes0, bdyNodes1) {
    this.bdyNodes = [];
    this.bdyNodes[0] = bdyNodes0;
    this.bdyNodes[1] = bdyNodes1;
  };


  /**
   * @return {Coordinate} the proper intersection point, or <code>null</code>
   *         if none was found.
   */
  jsts.geomgraph.index.SegmentIntersector.prototype.getProperIntersectionPoint = function() {
    return this.properIntersectionPoint;
  };


  /**
   * @return {boolean}
   */
  jsts.geomgraph.index.SegmentIntersector.prototype.hasIntersection = function() {
    return this._hasIntersection;
  };


  /**
   * A proper intersection is an intersection which is interior to at least two
   * line segments. Note that a proper intersection is not necessarily in the
   * interior of the entire Geometry, since another edge may have an endpoint
   * equal to the intersection, which according to SFS semantics can result in
   * the point being on the Boundary of the Geometry.
   *
   * @return {boolean}
   */
  jsts.geomgraph.index.SegmentIntersector.prototype.hasProperIntersection = function() {
    return this.hasProper;
  };


  /**
   * A proper interior intersection is a proper intersection which is <b>not</b>
   * contained in the set of boundary nodes set for this jsts.geomgraph.index.SegmentIntersector.
   *
   * @return {boolean}
   */
  jsts.geomgraph.index.SegmentIntersector.prototype.hasProperInteriorIntersection = function() {
    return this.hasProperInterior;
  };


  /**
   * A trivial intersection is an apparent self-intersection which in fact is
   * simply the point shared by adjacent line segments. Note that closed edges
   * require a special check for the point shared by the beginning and end
   * segments.
   *
   * @param {Edge}
   *          e0
   * @param {int}
   *          segIndex0
   * @param {Edge}
   *          e1
   * @param {int}
   *          segIndex1
   * @return {boolean}
   */
  jsts.geomgraph.index.SegmentIntersector.prototype.isTrivialIntersection = function(e0, segIndex0,
      e1, segIndex1) {
    if (e0 === e1) {
      if (this.li.getIntersectionNum() === 1) {
        if (jsts.geomgraph.index.SegmentIntersector.isAdjacentSegments(segIndex0, segIndex1))
          return true;
        if (e0.isClosed()) {
          var maxSegIndex = e0.getNumPoints() - 1;
          if ((segIndex0 === 0 && segIndex1 === maxSegIndex) ||
              (segIndex1 === 0 && segIndex0 === maxSegIndex)) {
            return true;
          }
        }
      }
    }
    return false;
  };


  /**
   * This method is called by clients of the EdgeIntersector class to test for
   * and add intersections for two segments of the edges being intersected. Note
   * that clients (such as MonotoneChainEdges) may choose not to intersect
   * certain pairs of segments for efficiency reasons.
   *
   * @param {Edge}
   *          e0
   * @param {int}
   *          segIndex0
   * @param {Edge}
   *          e1
   * @param {int}
   *          segIndex1
   */
  jsts.geomgraph.index.SegmentIntersector.prototype.addIntersections = function(e0, segIndex0, e1,
      segIndex1) {
    if (e0 === e1 && segIndex0 === segIndex1)
      return;
    this.numTests++;
    var p00 = e0.getCoordinates()[segIndex0];
    var p01 = e0.getCoordinates()[segIndex0 + 1];
    var p10 = e1.getCoordinates()[segIndex1];
    var p11 = e1.getCoordinates()[segIndex1 + 1];

    this.li.computeIntersection(p00, p01, p10, p11);
    /**
     * Always record any non-proper intersections. If includeProper is true,
     * record any proper intersections as well.
     */
    if (this.li.hasIntersection()) {
      if (this.recordIsolated) {
        e0.setIsolated(false);
        e1.setIsolated(false);
      }
      this.numIntersections++;
      // if the segments are adjacent they have at least one trivial
      // intersection,
      // the shared endpoint. Don't bother adding it if it is the
      // only intersection.
      if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {
        this._hasIntersection = true;
        if (this.includeProper || !this.li.isProper()) {
          e0.addIntersections(this.li, segIndex0, 0);
          e1.addIntersections(this.li, segIndex1, 1);
        }
        if (this.li.isProper()) {
          this.properIntersectionPoint = this.li.getIntersection(0).clone();
          this.hasProper = true;
          if (!this.isBoundaryPoint(this.li, this.bdyNodes))
            this.hasProperInterior = true;
        }
      }
    }
  };


  /**
   * @param {LineIntersector}
   *          li
   * @param {Array.<javascript.util.Collection>|javascript.util.Collection}
   *          bdyNodes
   * @return {boolean}
   * @private
   */
  jsts.geomgraph.index.SegmentIntersector.prototype.isBoundaryPoint = function(li, bdyNodes) {
    if (bdyNodes === null)
      return false;

    if (bdyNodes instanceof Array) {
      if (this.isBoundaryPoint(li, bdyNodes[0]))
        return true;
      if (this.isBoundaryPoint(li, bdyNodes[1]))
        return true;
      return false;
    } else {
      for (var i = bdyNodes.iterator(); i.hasNext();) {
        var node = i.next();
        var pt = node.getCoordinate();
        if (li.isIntersection(pt))
          return true;
      }
      return false;
    }
  };

})();

},{}],21:[function(require,module,exports){
/*
  javascript.util is a port of selected parts of java.util to JavaScript which
  main purpose is to ease porting Java code to JavaScript.
  
  The MIT License (MIT)

  Copyright (C) 2011-2014 by The Authors

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
*/

(function(){var e=this;function f(a,b){var c=a.split("."),d=e;c[0]in d||!d.execScript||d.execScript("var "+c[0]);for(var u;c.length&&(u=c.shift());)c.length||void 0===b?d[u]?d=d[u]:d=d[u]={}:d[u]=b}function g(a,b){function c(){}c.prototype=b.prototype;a.l=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.k=function(a,c,Q){for(var K=Array(arguments.length-2),B=2;B<arguments.length;B++)K[B-2]=arguments[B];return b.prototype[c].apply(a,K)}};function h(){}f("javascript.util.Iterator",h);h.prototype.hasNext=h.prototype.b;h.prototype.next=h.prototype.c;h.prototype.remove=h.prototype.a;function k(a){this.message=a||""}g(k,Error);f("javascript.util.OperationNotSupported",k);k.prototype.name="OperationNotSupported";function l(){}f("javascript.util.Map",l);function m(){}g(m,l);f("javascript.util.SortedMap",m);function n(a){this.message=a||""}g(n,Error);f("javascript.util.IndexOutOfBoundsException",n);n.prototype.name="IndexOutOfBoundsException";function p(){}f("javascript.util.Collection",p);function q(){}g(q,p);f("javascript.util.Set",q);function r(){}g(r,q);f("javascript.util.SortedSet",r);function t(a){this.message=a||""}g(t,Error);f("javascript.util.EmptyStackException",t);t.prototype.name="EmptyStackException";function v(){}g(v,p);f("javascript.util.List",v);function w(){this.c=[]}g(w,v);f("javascript.util.Stack",w);w.prototype.push=function(a){this.c.push(a);return a};w.prototype.push=w.prototype.push;w.prototype.d=function(){if(0===this.c.length)throw new t;return this.c.pop()};w.prototype.pop=w.prototype.d;w.prototype.g=function(){if(0===this.c.length)throw new t;return this.c[this.c.length-1]};w.prototype.peek=w.prototype.g;w.prototype.a=function(){return 0===this.c.length?!0:!1};w.prototype.empty=w.prototype.a;w.prototype.f=function(){return this.a()};
w.prototype.isEmpty=w.prototype.f;w.prototype.i=function(a){return this.c.indexOf(a)};w.prototype.search=w.prototype.i;w.prototype.b=function(){return this.c.length};w.prototype.size=w.prototype.b;w.prototype.h=function(){for(var a=[],b=0,c=this.c.length;b<c;b++)a.push(this.c[b]);return a};w.prototype.toArray=w.prototype.h;function x(a){this.message=a||""}g(x,Error);f("javascript.util.NoSuchElementException",x);x.prototype.name="NoSuchElementException";function y(a){this.a=[];a instanceof p&&this.d(a)}g(y,r);f("javascript.util.TreeSet",y);y.prototype.g=function(a){for(var b=0,c=this.a.length;b<c;b++)if(0===this.a[b].compareTo(a))return!0;return!1};y.prototype.contains=y.prototype.g;y.prototype.c=function(a){if(this.g(a))return!1;for(var b=0,c=this.a.length;b<c;b++)if(1===this.a[b].compareTo(a))return this.a.splice(b,0,a),!0;this.a.push(a);return!0};y.prototype.add=y.prototype.c;y.prototype.d=function(a){for(a=a.e();a.b();)this.c(a.c());return!0};
y.prototype.addAll=y.prototype.d;y.prototype.i=function(){throw new k;};y.prototype.remove=y.prototype.i;y.prototype.b=function(){return this.a.length};y.prototype.size=y.prototype.b;y.prototype.f=function(){return 0===this.a.length};y.prototype.isEmpty=y.prototype.f;y.prototype.h=function(){for(var a=[],b=0,c=this.a.length;b<c;b++)a.push(this.a[b]);return a};y.prototype.toArray=y.prototype.h;y.prototype.e=function(){return new z(this)};y.prototype.iterator=y.prototype.e;
function z(a){this.e=a;this.d=0}f("$jscomp.scope.Iterator_",z);z.prototype.c=function(){if(this.d===this.e.b())throw new x;return this.e.a[this.d++]};z.prototype.next=z.prototype.c;z.prototype.b=function(){return this.d<this.e.b()?!0:!1};z.prototype.hasNext=z.prototype.b;z.prototype.a=function(){throw new k;};z.prototype.remove=z.prototype.a;function A(a){this.a=[];a instanceof p&&this.d(a)}g(A,v);f("javascript.util.ArrayList",A);A.prototype.c=function(a){this.a.push(a);return!0};A.prototype.add=A.prototype.c;A.prototype.d=function(a){for(a=a.e();a.b();)this.c(a.c());return!0};A.prototype.addAll=A.prototype.d;A.prototype.j=function(a,b){var c=this.a[a];this.a[a]=b;return c};A.prototype.set=A.prototype.j;A.prototype.e=function(){return new C(this)};A.prototype.iterator=A.prototype.e;
A.prototype.g=function(a){if(0>a||a>=this.b())throw new n;return this.a[a]};A.prototype.get=A.prototype.g;A.prototype.f=function(){return 0===this.a.length};A.prototype.isEmpty=A.prototype.f;A.prototype.b=function(){return this.a.length};A.prototype.size=A.prototype.b;A.prototype.h=function(){for(var a=[],b=0,c=this.a.length;b<c;b++)a.push(this.a[b]);return a};A.prototype.toArray=A.prototype.h;
A.prototype.i=function(a){for(var b=!1,c=0,d=this.a.length;c<d;c++)if(this.a[c]===a){this.a.splice(c,1);b=!0;break}return b};A.prototype.remove=A.prototype.i;function C(a){this.e=a;this.d=0}f("$jscomp.scope.Iterator_$1",C);C.prototype.c=function(){if(this.d===this.e.b())throw new x;return this.e.g(this.d++)};C.prototype.next=C.prototype.c;C.prototype.b=function(){return this.d<this.e.b()?!0:!1};C.prototype.hasNext=C.prototype.b;C.prototype.a=function(){throw new k;};C.prototype.remove=C.prototype.a;function D(){this.b={}}g(D,l);f("javascript.util.HashMap",D);D.prototype.a=function(a){return this.b[a]||null};D.prototype.get=D.prototype.a;D.prototype.d=function(a,b){return this.b[a]=b};D.prototype.put=D.prototype.d;D.prototype.c=function(){var a=new A,b;for(b in this.b)this.b.hasOwnProperty(b)&&a.c(this.b[b]);return a};D.prototype.values=D.prototype.c;D.prototype.e=function(){return this.c().b()};D.prototype.size=D.prototype.e;function E(){}f("javascript.util.Arrays",E);
E.sort=function(){var a=arguments[0],b,c,d;if(1===arguments.length)a.sort();else if(2===arguments.length)c=arguments[1],d=function(a,b){return c.compare(a,b)},a.sort(d);else if(3===arguments.length)for(b=a.slice(arguments[1],arguments[2]),b.sort(),d=a.slice(0,arguments[1]).concat(b,a.slice(arguments[2],a.length)),a.splice(0,a.length),b=0;b<d.length;b++)a.push(d[b]);else if(4===arguments.length)for(b=a.slice(arguments[1],arguments[2]),c=arguments[3],d=function(a,b){return c.compare(a,b)},b.sort(d),
d=a.slice(0,arguments[1]).concat(b,a.slice(arguments[2],a.length)),a.splice(0,a.length),b=0;b<d.length;b++)a.push(d[b])};E.asList=function(a){for(var b=new A,c=0,d=a.length;c<d;c++)b.c(a[c]);return b};function F(a){this.a=[];a instanceof p&&this.d(a)}g(F,q);f("javascript.util.HashSet",F);F.prototype.g=function(a){for(var b=0,c=this.a.length;b<c;b++)if(this.a[b]===a)return!0;return!1};F.prototype.contains=F.prototype.g;F.prototype.c=function(a){if(this.g(a))return!1;this.a.push(a);return!0};F.prototype.add=F.prototype.c;F.prototype.d=function(a){for(a=a.e();a.b();)this.c(a.c());return!0};F.prototype.addAll=F.prototype.d;F.prototype.i=function(){throw new k;};F.prototype.remove=F.prototype.i;
F.prototype.b=function(){return this.a.length};F.prototype.size=F.prototype.b;F.prototype.f=function(){return 0===this.a.length};F.prototype.isEmpty=F.prototype.f;F.prototype.h=function(){for(var a=[],b=0,c=this.a.length;b<c;b++)a.push(this.a[b]);return a};F.prototype.toArray=F.prototype.h;F.prototype.e=function(){return new G(this)};F.prototype.iterator=F.prototype.e;function G(a){this.e=a;this.d=0}f("$jscomp.scope.Iterator_$2",G);G.prototype.c=function(){if(this.d===this.e.b())throw new x;return this.e.a[this.d++]};
G.prototype.next=G.prototype.c;G.prototype.b=function(){return this.d<this.e.b()?!0:!1};G.prototype.hasNext=G.prototype.b;G.prototype.a=function(){throw new k;};G.prototype.remove=G.prototype.a;function H(a){return null==a?null:a.parent}function I(a,b){null!==a&&(a.color=b)}function J(a){return null==a?null:a.left}function L(a){return null==a?null:a.right}function M(){this.b=null;this.f=0}g(M,m);f("javascript.util.TreeMap",M);M.prototype.a=function(a){for(var b=this.b;null!==b;){var c=a.compareTo(b.key);if(0>c)b=b.left;else if(0<c)b=b.right;else return b.value}return null};M.prototype.get=M.prototype.a;
M.prototype.d=function(a,b){if(null===this.b)return this.b={key:a,value:b,left:null,right:null,parent:null,color:0},this.f=1,null;var c=this.b,d,u;do if(d=c,u=a.compareTo(c.key),0>u)c=c.left;else if(0<u)c=c.right;else return d=c.value,c.value=b,d;while(null!==c);c={key:a,left:null,right:null,value:b,parent:d,color:0};0>u?d.left=c:d.right=c;for(c.color=1;null!=c&&c!=this.b&&1==c.parent.color;)H(c)==J(H(H(c)))?(d=L(H(H(c))),1==(null==d?0:d.color)?(I(H(c),0),I(d,0),I(H(H(c)),1),c=H(H(c))):(c==L(H(c))&&
(c=H(c),N(this,c)),I(H(c),0),I(H(H(c)),1),O(this,H(H(c))))):(d=J(H(H(c))),1==(null==d?0:d.color)?(I(H(c),0),I(d,0),I(H(H(c)),1),c=H(H(c))):(c==J(H(c))&&(c=H(c),O(this,c)),I(H(c),0),I(H(H(c)),1),N(this,H(H(c)))));this.b.color=0;this.f++;return null};M.prototype.put=M.prototype.d;M.prototype.c=function(){var a=new A,b;b=this.b;if(null!=b)for(;null!=b.left;)b=b.left;if(null!==b)for(a.c(b.value);null!==(b=P(b));)a.c(b.value);return a};M.prototype.values=M.prototype.c;
function N(a,b){if(null!=b){var c=b.right;b.right=c.left;null!=c.left&&(c.left.parent=b);c.parent=b.parent;null==b.parent?a.b=c:b.parent.left==b?b.parent.left=c:b.parent.right=c;c.left=b;b.parent=c}}function O(a,b){if(null!=b){var c=b.left;b.left=c.right;null!=c.right&&(c.right.parent=b);c.parent=b.parent;null==b.parent?a.b=c:b.parent.right==b?b.parent.right=c:b.parent.left=c;c.right=b;b.parent=c}}
function P(a){if(null===a)return null;if(null!==a.right)for(var b=a.right;null!==b.left;)b=b.left;else for(b=a.parent;null!==b&&a===b.right;)a=b,b=b.parent;return b}M.prototype.e=function(){return this.f};M.prototype.size=M.prototype.e;})();

},{}],22:[function(require,module,exports){
require('./dist/javascript.util.min.js');

},{"./dist/javascript.util.min.js":21}],23:[function(require,module,exports){
// Packaging/modules magic dance.
(function (factory) {
    var L;
    if (typeof define === 'function' && define.amd) {
        // AMD
        define(['leaflet'], factory);
    } else if (typeof module !== 'undefined') {
        // Node/CommonJS
        L = require('leaflet');
        module.exports = factory(L);
    } else {
        // Browser globals
        if (typeof window.L === 'undefined')
            throw 'Leaflet must be loaded first';
        factory(window.L);
    }
}(function (L) {
"use strict";

/**
 * @fileOverview Leaflet Geometry utilities for distances and linear referencing.
 * @name L.GeometryUtil
 */

L.GeometryUtil = L.extend(L.GeometryUtil || {}, {

    /**
        Shortcut function for planar distance between two {L.LatLng} at current zoom.
        @param {L.Map} map
        @param {L.LatLng} latlngA
        @param {L.LatLng} latlngB
        @returns {Number} in pixels
     */
    distance: function (map, latlngA, latlngB) {
        return map.latLngToLayerPoint(latlngA).distanceTo(map.latLngToLayerPoint(latlngB));
    },

    /**
        Shortcut function for planar distance between a {L.LatLng} and a segment (A-B).
        @param {L.Map} map
        @param {L.LatLng} latlng
        @param {L.LatLng} latlngA
        @param {L.LatLng} latlngB
        @returns {Number} in pixels
    */
    distanceSegment: function (map, latlng, latlngA, latlngB) {
        var p = map.latLngToLayerPoint(latlng),
           p1 = map.latLngToLayerPoint(latlngA),
           p2 = map.latLngToLayerPoint(latlngB);
        return L.LineUtil.pointToSegmentDistance(p, p1, p2);
    },

    /**
        Shortcut function for converting distance to readable distance.
        @param {Number} distance
        @param {String} unit ('metric' or 'imperial')
        @returns {Number} in yard or miles
    */
    readableDistance: function (distance, unit) {
        var isMetric = (unit !== 'imperial'),
            distanceStr;
        if (isMetric) {
            // show metres when distance is < 1km, then show km
            if (distance > 1000) {
                distanceStr = (distance  / 1000).toFixed(2) + ' km';
            }
            else {
                distanceStr = Math.ceil(distance) + ' m';
            }
        }
        else {
            distance *= 1.09361;
            if (distance > 1760) {
                distanceStr = (distance / 1760).toFixed(2) + ' miles';
            }
            else {
                distanceStr = Math.ceil(distance) + ' yd';
            }
        }
        return distanceStr;
    },

    /**
        Returns true if the latlng belongs to segment.
        param {L.LatLng} latlng
        @param {L.LatLng} latlngA
        @param {L.LatLng} latlngB
        @param {?Number} [tolerance=0.2]
        @returns {boolean}
     */
    belongsSegment: function(latlng, latlngA, latlngB, tolerance) {
        tolerance = tolerance === undefined ? 0.2 : tolerance;
        var hypotenuse = latlngA.distanceTo(latlngB),
            delta = latlngA.distanceTo(latlng) + latlng.distanceTo(latlngB) - hypotenuse;
        return delta/hypotenuse < tolerance;
    },

    /**
     * Returns total length of line
     * @param {L.Polyline|Array<L.Point>|Array<L.LatLng>}
     * @returns {Number} in meters
     */
    length: function (coords) {
        var accumulated = L.GeometryUtil.accumulatedLengths(coords);
        return accumulated.length > 0 ? accumulated[accumulated.length-1] : 0;
    },

    /**
     * Returns a list of accumulated length along a line.
     * @param {L.Polyline|Array<L.Point>|Array<L.LatLng>}
     * @returns {Number} in meters
     */
    accumulatedLengths: function (coords) {
        if (typeof coords.getLatLngs == 'function') {
            coords = coords.getLatLngs();
        }
        if (coords.length === 0)
            return [];
        var total = 0,
            lengths = [0];
        for (var i = 0, n = coords.length - 1; i< n; i++) {
            total += coords[i].distanceTo(coords[i+1]);
            lengths.push(total);
        }
        return lengths;
    },

    /**
        Returns the closest point of a {L.LatLng} on the segment (A-B)
        @param {L.Map} map
        @param {L.LatLng} latlng
        @param {L.LatLng} latlngA
        @param {L.LatLng} latlngB
        @returns {L.LatLng}
    */
    closestOnSegment: function (map, latlng, latlngA, latlngB) {
        var maxzoom = map.getMaxZoom();
        if (maxzoom === Infinity)
            maxzoom = map.getZoom();
        var p = map.project(latlng, maxzoom),
           p1 = map.project(latlngA, maxzoom),
           p2 = map.project(latlngB, maxzoom),
           closest = L.LineUtil.closestPointOnSegment(p, p1, p2);
        return map.unproject(closest, maxzoom);
    },

    /**
        Returns the closest latlng on layer.
        @param {L.Map} map
        @param {Array<L.LatLng>|L.PolyLine} layer - Layer that contains the result.
        @param {L.LatLng} latlng
        @param {?boolean} [vertices=false] - Whether to restrict to path vertices.
        @returns {L.LatLng}
    */
    closest: function (map, layer, latlng, vertices) {
        if (typeof layer.getLatLngs != 'function')
            layer = L.polyline(layer);

        var latlngs = layer.getLatLngs().slice(0),
            mindist = Infinity,
            result = null,
            i, n, distance;

        // Lookup vertices
        if (vertices) {
            for(i = 0, n = latlngs.length; i < n; i++) {
                var ll = latlngs[i];
                distance = L.GeometryUtil.distance(map, latlng, ll);
                if (distance < mindist) {
                    mindist = distance;
                    result = ll;
                    result.distance = distance;
                }
            }
            return result;
        }

        if (layer instanceof L.Polygon) {
            latlngs.push(latlngs[0]);
        }

        // Keep the closest point of all segments
        for (i = 0, n = latlngs.length; i < n-1; i++) {
            var latlngA = latlngs[i],
                latlngB = latlngs[i+1];
            distance = L.GeometryUtil.distanceSegment(map, latlng, latlngA, latlngB);
            if (distance <= mindist) {
                mindist = distance;
                result = L.GeometryUtil.closestOnSegment(map, latlng, latlngA, latlngB);
                result.distance = distance;
            }
        }
        return result;
    },

    /**
        Returns the closest layer to latlng among a list of layers.
        @param {L.Map} map
        @param {Array<L.ILayer>} layers
        @param {L.LatLng} latlng
        @returns {object} with layer, latlng and distance or {null} if list is empty;
    */
    closestLayer: function (map, layers, latlng) {
        var mindist = Infinity,
            result = null,
            ll = null,
            distance = Infinity;

        for (var i = 0, n = layers.length; i < n; i++) {
            var layer = layers[i];
            // Single dimension, snap on points, else snap on closest
            if (typeof layer.getLatLng == 'function') {
                ll = layer.getLatLng();
                distance = L.GeometryUtil.distance(map, latlng, ll);
            }
            else {
                ll = L.GeometryUtil.closest(map, layer, latlng);
                if (ll) distance = ll.distance;  // Can return null if layer has no points.
            }
            if (distance < mindist) {
                mindist = distance;
                result = {layer: layer, latlng: ll, distance: distance};
            }
        }
        return result;
    },

    /**
        Returns the closest position from specified {LatLng} among specified layers,
        with a maximum tolerance in pixels, providing snapping behaviour.
        @param {L.Map} map
        @param {Array<ILayer>} layers - A list of layers to snap on.
        @param {L.LatLng} latlng - The position to snap.
        @param {?Number} [tolerance=Infinity] - Maximum number of pixels.
        @param {?boolean} [withVertices=true] - Snap to layers vertices.
        @returns {object} with snapped {LatLng} and snapped {Layer} or null if tolerance exceeded.
    */
    closestLayerSnap: function (map, layers, latlng, tolerance, withVertices) {
        tolerance = typeof tolerance == 'number' ? tolerance : Infinity;
        withVertices = typeof withVertices == 'boolean' ? withVertices : true;

        var result = L.GeometryUtil.closestLayer(map, layers, latlng);
        if (!result || result.distance > tolerance)
            return null;

        // If snapped layer is linear, try to snap on vertices (extremities and middle points)
        if (withVertices && typeof result.layer.getLatLngs == 'function') {
            var closest = L.GeometryUtil.closest(map, result.layer, result.latlng, true);
            if (closest.distance < tolerance) {
                result.latlng = closest;
                result.distance = L.GeometryUtil.distance(map, closest, latlng);
            }
        }
        return result;
    },

    /**
        Returns the Point located on a segment at the specified ratio of the segment length.
        @param {L.Point} pA
        @param {L.Point} pB
        @param {Number} the length ratio, expressed as a decimal between 0 and 1, inclusive.
        @returns {L.Point} the interpolated point.
    */
    interpolateOnPointSegment: function (pA, pB, ratio) {
        return L.point(
            (pA.x * (1 - ratio)) + (ratio * pB.x),
            (pA.y * (1 - ratio)) + (ratio * pB.y)
        );
    },

    /**
        Returns the coordinate of the point located on a line at the specified ratio of the line length.
        @param {L.Map} map
        @param {Array<L.LatLng>|L.PolyLine} latlngs
        @param {Number} the length ratio, expressed as a decimal between 0 and 1, inclusive
        @returns {Object} an object with latLng ({LatLng}) and predecessor ({Number}), the index of the preceding vertex in the Polyline
        (-1 if the interpolated point is the first vertex)
    */
    interpolateOnLine: function (map, latLngs, ratio) {
        latLngs = (latLngs instanceof L.Polyline) ? latLngs.getLatLngs() : latLngs;
        var n = latLngs.length;
        if (n < 2) {
            return null;
        }

        if (ratio === 0) {
            return {
                latLng: latLngs[0] instanceof L.LatLng ? latLngs[0] : L.latLng(latLngs[0]),
                predecessor: -1
            };
        }
        if (ratio == 1) {
            return {
                latLng: latLngs[latLngs.length -1] instanceof L.LatLng ? latLngs[latLngs.length -1] : L.latLng(latLngs[latLngs.length -1]),
                predecessor: latLngs.length - 2
            };
        }

        // ensure the ratio is between 0 and 1;
        ratio = Math.max(Math.min(ratio, 1), 0);

        // project the LatLngs as Points,
        // and compute total planar length of the line at max precision
        var maxzoom = map.getMaxZoom();
        if (maxzoom === Infinity)
            maxzoom = map.getZoom();
        var pts = [];
        var lineLength = 0;
        for(var i = 0; i < n; i++) {
            pts[i] = map.project(latLngs[i], maxzoom);
            if(i > 0)
              lineLength += pts[i-1].distanceTo(pts[i]);
        }

        var ratioDist = lineLength * ratio;
        var a = pts[0],
            b = pts[1],
            distA = 0,
            distB = a.distanceTo(b);
        // follow the line segments [ab], adding lengths,
        // until we find the segment where the points should lie on
        var index = 1;
        for (; index < n && distB < ratioDist; index++) {
            a = b;
            distA = distB;
            b = pts[index];
            distB += a.distanceTo(b);
        }
        // compute the ratio relative to the segment [ab]
        var segmentRatio = ((distB - distA) !== 0) ? ((ratioDist - distA) / (distB - distA)) : 0;
        var interpolatedPoint = L.GeometryUtil.interpolateOnPointSegment(a, b, segmentRatio);
        return {
            latLng: map.unproject(interpolatedPoint, maxzoom),
            predecessor: index-2
        };
    },

    /**
        Returns a float between 0 and 1 representing the location of the
        closest point on polyline to the given latlng, as a fraction of total 2d line length.
        (opposite of L.GeometryUtil.interpolateOnLine())
        @param {L.Map} map
        @param {L.PolyLine} polyline
        @param {L.LatLng} latlng
        @returns {Number}
    */
    locateOnLine: function (map, polyline, latlng) {
        var latlngs = polyline.getLatLngs();
        if (latlng.equals(latlngs[0]))
            return 0.0;
        if (latlng.equals(latlngs[latlngs.length-1]))
            return 1.0;

        var point = L.GeometryUtil.closest(map, polyline, latlng, false),
            lengths = L.GeometryUtil.accumulatedLengths(latlngs),
            total_length = lengths[lengths.length-1],
            portion = 0,
            found = false;
        for (var i=0, n = latlngs.length-1; i < n; i++) {
            var l1 = latlngs[i],
                l2 = latlngs[i+1];
            portion = lengths[i];
            if (L.GeometryUtil.belongsSegment(point, l1, l2)) {
                portion += l1.distanceTo(point);
                found = true;
                break;
            }
        }
        if (!found) {
            throw "Could not interpolate " + latlng.toString() + " within " + polyline.toString();
        }
        return portion / total_length;
    },

    /**
        Returns a clone with reversed coordinates.
        @param {L.PolyLine} polyline
        @returns {L.PolyLine}
    */
    reverse: function (polyline) {
        return L.polyline(polyline.getLatLngs().slice(0).reverse());
    },

    /**
        Returns a sub-part of the polyline, from start to end.
        If start is superior to end, returns extraction from inverted line.
        @param {L.Map} map
        @param {L.PolyLine} latlngs
        @param {Number} start ratio, expressed as a decimal between 0 and 1, inclusive
        @param {Number} end ratio, expressed as a decimal between 0 and 1, inclusive
        @returns {Array<L.LatLng>}
     */
    extract: function (map, polyline, start, end) {
        if (start > end) {
            return L.GeometryUtil.extract(map, L.GeometryUtil.reverse(polyline), 1.0-start, 1.0-end);
        }

        // Bound start and end to [0-1]
        start = Math.max(Math.min(start, 1), 0);
        end = Math.max(Math.min(end, 1), 0);

        var latlngs = polyline.getLatLngs(),
            startpoint = L.GeometryUtil.interpolateOnLine(map, polyline, start),
            endpoint = L.GeometryUtil.interpolateOnLine(map, polyline, end);
        // Return single point if start == end
        if (start == end) {
            var point = L.GeometryUtil.interpolateOnLine(map, polyline, end);
            return [point.latLng];
        }
        // Array.slice() works indexes at 0
        if (startpoint.predecessor == -1)
            startpoint.predecessor = 0;
        if (endpoint.predecessor == -1)
            endpoint.predecessor = 0;
        var result = latlngs.slice(startpoint.predecessor+1, endpoint.predecessor+1);
        result.unshift(startpoint.latLng);
        result.push(endpoint.latLng);
        return result;
    },

    /**
        Returns true if first polyline ends where other second starts.
        @param {L.PolyLine} polyline
        @param {L.PolyLine} other
        @returns {bool}
    */
    isBefore: function (polyline, other) {
        if (!other) return false;
        var lla = polyline.getLatLngs(),
            llb = other.getLatLngs();
        return (lla[lla.length-1]).equals(llb[0]);
    },

    /**
        Returns true if first polyline starts where second ends.
        @param {L.PolyLine} polyline
        @param {L.PolyLine} other
        @returns {bool}
    */
    isAfter: function (polyline, other) {
        if (!other) return false;
        var lla = polyline.getLatLngs(),
            llb = other.getLatLngs();
        return (lla[0]).equals(llb[llb.length-1]);
    },

    /**
        Returns true if first polyline starts where second ends or start.
        @param {L.PolyLine} polyline
        @param {L.PolyLine} other
        @returns {bool}
    */
    startsAtExtremity: function (polyline, other) {
        if (!other) return false;
        var lla = polyline.getLatLngs(),
            llb = other.getLatLngs(),
            start = lla[0];
        return start.equals(llb[0]) || start.equals(llb[llb.length-1]);
    },

    /**
        Returns horizontal angle in degres between two points.
        @param {L.Point} a
        @param {L.Point} b
        @returns {float}
     */
    computeAngle: function(a, b) {
        return (Math.atan2(b.y - a.y, b.x - a.x) * 180 / Math.PI);
    },

    /**
       Returns slope (Ax+B) between two points.
        @param {L.Point} a
        @param {L.Point} b
        @returns {Object} with ``a`` and ``b`` properties.
     */
    computeSlope: function(a, b) {
        var s = (b.y - a.y) / (b.x - a.x),
            o = a.y - (s * a.x);
        return {'a': s, 'b': o};
    },

    /**
       Returns LatLng of rotated point around specified LatLng center.
        @param {L.LatLng} latlngPoint: point to rotate
        @param {double} angleDeg: angle to rotate in degrees
        @param {L.LatLng} latlngCenter: center of rotation
        @returns {L.LatLng} rotated point
     */
    rotatePoint: function(map, latlngPoint, angleDeg, latlngCenter) {
        var maxzoom = map.getMaxZoom();
        if (maxzoom === Infinity)
            maxzoom = map.getZoom();
        var angleRad = angleDeg*Math.PI/180,
            pPoint = map.project(latlngPoint, maxzoom),
            pCenter = map.project(latlngCenter, maxzoom),
            x2 = Math.cos(angleRad)*(pPoint.x-pCenter.x) - Math.sin(angleRad)*(pPoint.y-pCenter.y) + pCenter.x,
            y2 = Math.sin(angleRad)*(pPoint.x-pCenter.x) + Math.cos(angleRad)*(pPoint.y-pCenter.y) + pCenter.y;
        return map.unproject(new L.Point(x2,y2), maxzoom);
    },

    /**
       Returns the bearing in degrees clockwise from north (0 degrees)
       from the first L.LatLng to the second, at the first LatLng 
       @param {L.LatLng} latlng1: origin point of the bearing
       @param {L.LatLng} latlng2: destination point of the bearing
       @returns {float} degrees clockwise from north.
    */
    bearing: function(latlng1, latlng2) {
        var rad = Math.PI / 180,
            lat1 = latlng1.lat * rad,
            lat2 = latlng2.lat * rad,
            lon1 = latlng1.lng * rad,
            lon2 = latlng2.lng * rad,
            y = Math.sin(lon2 - lon1) * Math.cos(lat2),
            x = Math.cos(lat1) * Math.sin(lat2) -
                Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);

        var bearing = ((Math.atan2(y, x) * 180 / Math.PI) + 360) % 360;
        return bearing >= 180 ? bearing-360 : bearing;
    },

    /**
       Returns the point that is a distance and heading away from
       the given origin point.
       @param {L.LatLng} latlng: origin point
       @param {float}: heading in degrees, clockwise from 0 degrees north.
       @param {float}: distance in meters
       @returns {L.latLng} the destination point.
       Many thanks to Chris Veness at http://www.movable-type.co.uk/scripts/latlong.html
       for a great reference and examples.
    */
    destination: function(latlng, heading, distance) {
        heading = (heading + 360) % 360;
        var rad = Math.PI / 180,
            radInv = 180 / Math.PI,
            R = 6378137, // approximation of Earth's radius
            lon1 = latlng.lng * rad,
            lat1 = latlng.lat * rad,
            rheading = heading * rad,
            sinLat1 = Math.sin(lat1),
            cosLat1 = Math.cos(lat1),
            cosDistR = Math.cos(distance / R),
            sinDistR = Math.sin(distance / R),
            lat2 = Math.asin(sinLat1 * cosDistR + cosLat1 *
                sinDistR * Math.cos(rheading)),
            lon2 = lon1 + Math.atan2(Math.sin(rheading) * sinDistR *
                cosLat1, cosDistR - sinLat1 * Math.sin(lat2));
        lon2 = lon2 * radInv;
        lon2 = lon2 > 180 ? lon2 - 360 : lon2 < -180 ? lon2 + 360 : lon2;
        return L.latLng([lat2 * radInv, lon2]);
    }
});

return L.GeometryUtil;

}));

},{"leaflet":25}],24:[function(require,module,exports){
(function(window) {
	var HAS_HASHCHANGE = (function() {
		var doc_mode = window.documentMode;
		return ('onhashchange' in window) &&
			(doc_mode === undefined || doc_mode > 7);
	})();

	L.Hash = function(map) {
		this.onHashChange = L.Util.bind(this.onHashChange, this);

		if (map) {
			this.init(map);
		}
	};

	L.Hash.parseHash = function(hash) {
		if(hash.indexOf('#') === 0) {
			hash = hash.substr(1);
		}
		var args = hash.split("/");
		if (args.length == 3) {
			var zoom = parseInt(args[0], 10),
			lat = parseFloat(args[1]),
			lon = parseFloat(args[2]);
			if (isNaN(zoom) || isNaN(lat) || isNaN(lon)) {
				return false;
			} else {
				return {
					center: new L.LatLng(lat, lon),
					zoom: zoom
				};
			}
		} else {
			return false;
		}
	};

	L.Hash.formatHash = function(map) {
		var center = map.getCenter(),
		    zoom = map.getZoom(),
		    precision = Math.max(0, Math.ceil(Math.log(zoom) / Math.LN2));

		return "#" + [zoom,
			center.lat.toFixed(precision),
			center.lng.toFixed(precision)
		].join("/");
	},

	L.Hash.prototype = {
		map: null,
		lastHash: null,

		parseHash: L.Hash.parseHash,
		formatHash: L.Hash.formatHash,

		init: function(map) {
			this.map = map;

			// reset the hash
			this.lastHash = null;
			this.onHashChange();

			if (!this.isListening) {
				this.startListening();
			}
		},

		removeFrom: function(map) {
			if (this.changeTimeout) {
				clearTimeout(this.changeTimeout);
			}

			if (this.isListening) {
				this.stopListening();
			}

			this.map = null;
		},

		onMapMove: function() {
			// bail if we're moving the map (updating from a hash),
			// or if the map is not yet loaded

			if (this.movingMap || !this.map._loaded) {
				return false;
			}

			var hash = this.formatHash(this.map);
			if (this.lastHash != hash) {
				location.replace(hash);
				this.lastHash = hash;
			}
		},

		movingMap: false,
		update: function() {
			var hash = location.hash;
			if (hash === this.lastHash) {
				return;
			}
			var parsed = this.parseHash(hash);
			if (parsed) {
				this.movingMap = true;

				this.map.setView(parsed.center, parsed.zoom);

				this.movingMap = false;
			} else {
				this.onMapMove(this.map);
			}
		},

		// defer hash change updates every 100ms
		changeDefer: 100,
		changeTimeout: null,
		onHashChange: function() {
			// throttle calls to update() so that they only happen every
			// `changeDefer` ms
			if (!this.changeTimeout) {
				var that = this;
				this.changeTimeout = setTimeout(function() {
					that.update();
					that.changeTimeout = null;
				}, this.changeDefer);
			}
		},

		isListening: false,
		hashChangeInterval: null,
		startListening: function() {
			this.map.on("moveend", this.onMapMove, this);

			if (HAS_HASHCHANGE) {
				L.DomEvent.addListener(window, "hashchange", this.onHashChange);
			} else {
				clearInterval(this.hashChangeInterval);
				this.hashChangeInterval = setInterval(this.onHashChange, 50);
			}
			this.isListening = true;
		},

		stopListening: function() {
			this.map.off("moveend", this.onMapMove, this);

			if (HAS_HASHCHANGE) {
				L.DomEvent.removeListener(window, "hashchange", this.onHashChange);
			} else {
				clearInterval(this.hashChangeInterval);
			}
			this.isListening = false;
		}
	};
	L.hash = function(map) {
		return new L.Hash(map);
	};
	L.Map.prototype.addHash = function() {
		this._hash = L.hash(this);
	};
	L.Map.prototype.removeHash = function() {
		this._hash.removeFrom();
	};
})(window);

},{}],25:[function(require,module,exports){
/*
 Leaflet, a JavaScript library for mobile-friendly interactive maps. http://leafletjs.com
 (c) 2010-2013, Vladimir Agafonkin
 (c) 2010-2011, CloudMade
*/
(function (window, document, undefined) {
var oldL = window.L,
    L = {};

L.version = '0.7.5';

// define Leaflet for Node module pattern loaders, including Browserify
if (typeof module === 'object' && typeof module.exports === 'object') {
	module.exports = L;

// define Leaflet as an AMD module
} else if (typeof define === 'function' && define.amd) {
	define(L);
}

// define Leaflet as a global L variable, saving the original L to restore later if needed

L.noConflict = function () {
	window.L = oldL;
	return this;
};

window.L = L;


/*
 * L.Util contains various utility functions used throughout Leaflet code.
 */

L.Util = {
	extend: function (dest) { // (Object[, Object, ...]) ->
		var sources = Array.prototype.slice.call(arguments, 1),
		    i, j, len, src;

		for (j = 0, len = sources.length; j < len; j++) {
			src = sources[j] || {};
			for (i in src) {
				if (src.hasOwnProperty(i)) {
					dest[i] = src[i];
				}
			}
		}
		return dest;
	},

	bind: function (fn, obj) { // (Function, Object) -> Function
		var args = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;
		return function () {
			return fn.apply(obj, args || arguments);
		};
	},

	stamp: (function () {
		var lastId = 0,
		    key = '_leaflet_id';
		return function (obj) {
			obj[key] = obj[key] || ++lastId;
			return obj[key];
		};
	}()),

	invokeEach: function (obj, method, context) {
		var i, args;

		if (typeof obj === 'object') {
			args = Array.prototype.slice.call(arguments, 3);

			for (i in obj) {
				method.apply(context, [i, obj[i]].concat(args));
			}
			return true;
		}

		return false;
	},

	limitExecByInterval: function (fn, time, context) {
		var lock, execOnUnlock;

		return function wrapperFn() {
			var args = arguments;

			if (lock) {
				execOnUnlock = true;
				return;
			}

			lock = true;

			setTimeout(function () {
				lock = false;

				if (execOnUnlock) {
					wrapperFn.apply(context, args);
					execOnUnlock = false;
				}
			}, time);

			fn.apply(context, args);
		};
	},

	falseFn: function () {
		return false;
	},

	formatNum: function (num, digits) {
		var pow = Math.pow(10, digits || 5);
		return Math.round(num * pow) / pow;
	},

	trim: function (str) {
		return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
	},

	splitWords: function (str) {
		return L.Util.trim(str).split(/\s+/);
	},

	setOptions: function (obj, options) {
		obj.options = L.extend({}, obj.options, options);
		return obj.options;
	},

	getParamString: function (obj, existingUrl, uppercase) {
		var params = [];
		for (var i in obj) {
			params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
		}
		return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
	},
	template: function (str, data) {
		return str.replace(/\{ *([\w_]+) *\}/g, function (str, key) {
			var value = data[key];
			if (value === undefined) {
				throw new Error('No value provided for variable ' + str);
			} else if (typeof value === 'function') {
				value = value(data);
			}
			return value;
		});
	},

	isArray: Array.isArray || function (obj) {
		return (Object.prototype.toString.call(obj) === '[object Array]');
	},

	emptyImageUrl: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='
};

(function () {

	// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

	function getPrefixed(name) {
		var i, fn,
		    prefixes = ['webkit', 'moz', 'o', 'ms'];

		for (i = 0; i < prefixes.length && !fn; i++) {
			fn = window[prefixes[i] + name];
		}

		return fn;
	}

	var lastTime = 0;

	function timeoutDefer(fn) {
		var time = +new Date(),
		    timeToCall = Math.max(0, 16 - (time - lastTime));

		lastTime = time + timeToCall;
		return window.setTimeout(fn, timeToCall);
	}

	var requestFn = window.requestAnimationFrame ||
	        getPrefixed('RequestAnimationFrame') || timeoutDefer;

	var cancelFn = window.cancelAnimationFrame ||
	        getPrefixed('CancelAnimationFrame') ||
	        getPrefixed('CancelRequestAnimationFrame') ||
	        function (id) { window.clearTimeout(id); };


	L.Util.requestAnimFrame = function (fn, context, immediate, element) {
		fn = L.bind(fn, context);

		if (immediate && requestFn === timeoutDefer) {
			fn();
		} else {
			return requestFn.call(window, fn, element);
		}
	};

	L.Util.cancelAnimFrame = function (id) {
		if (id) {
			cancelFn.call(window, id);
		}
	};

}());

// shortcuts for most used utility functions
L.extend = L.Util.extend;
L.bind = L.Util.bind;
L.stamp = L.Util.stamp;
L.setOptions = L.Util.setOptions;


/*
 * L.Class powers the OOP facilities of the library.
 * Thanks to John Resig and Dean Edwards for inspiration!
 */

L.Class = function () {};

L.Class.extend = function (props) {

	// extended class with the new prototype
	var NewClass = function () {

		// call the constructor
		if (this.initialize) {
			this.initialize.apply(this, arguments);
		}

		// call all constructor hooks
		if (this._initHooks) {
			this.callInitHooks();
		}
	};

	// instantiate class without calling constructor
	var F = function () {};
	F.prototype = this.prototype;

	var proto = new F();
	proto.constructor = NewClass;

	NewClass.prototype = proto;

	//inherit parent's statics
	for (var i in this) {
		if (this.hasOwnProperty(i) && i !== 'prototype') {
			NewClass[i] = this[i];
		}
	}

	// mix static properties into the class
	if (props.statics) {
		L.extend(NewClass, props.statics);
		delete props.statics;
	}

	// mix includes into the prototype
	if (props.includes) {
		L.Util.extend.apply(null, [proto].concat(props.includes));
		delete props.includes;
	}

	// merge options
	if (props.options && proto.options) {
		props.options = L.extend({}, proto.options, props.options);
	}

	// mix given properties into the prototype
	L.extend(proto, props);

	proto._initHooks = [];

	var parent = this;
	// jshint camelcase: false
	NewClass.__super__ = parent.prototype;

	// add method for calling all hooks
	proto.callInitHooks = function () {

		if (this._initHooksCalled) { return; }

		if (parent.prototype.callInitHooks) {
			parent.prototype.callInitHooks.call(this);
		}

		this._initHooksCalled = true;

		for (var i = 0, len = proto._initHooks.length; i < len; i++) {
			proto._initHooks[i].call(this);
		}
	};

	return NewClass;
};


// method for adding properties to prototype
L.Class.include = function (props) {
	L.extend(this.prototype, props);
};

// merge new default options to the Class
L.Class.mergeOptions = function (options) {
	L.extend(this.prototype.options, options);
};

// add a constructor hook
L.Class.addInitHook = function (fn) { // (Function) || (String, args...)
	var args = Array.prototype.slice.call(arguments, 1);

	var init = typeof fn === 'function' ? fn : function () {
		this[fn].apply(this, args);
	};

	this.prototype._initHooks = this.prototype._initHooks || [];
	this.prototype._initHooks.push(init);
};


/*
 * L.Mixin.Events is used to add custom events functionality to Leaflet classes.
 */

var eventsKey = '_leaflet_events';

L.Mixin = {};

L.Mixin.Events = {

	addEventListener: function (types, fn, context) { // (String, Function[, Object]) or (Object[, Object])

		// types can be a map of types/handlers
		if (L.Util.invokeEach(types, this.addEventListener, this, fn, context)) { return this; }

		var events = this[eventsKey] = this[eventsKey] || {},
		    contextId = context && context !== this && L.stamp(context),
		    i, len, event, type, indexKey, indexLenKey, typeIndex;

		// types can be a string of space-separated words
		types = L.Util.splitWords(types);

		for (i = 0, len = types.length; i < len; i++) {
			event = {
				action: fn,
				context: context || this
			};
			type = types[i];

			if (contextId) {
				// store listeners of a particular context in a separate hash (if it has an id)
				// gives a major performance boost when removing thousands of map layers

				indexKey = type + '_idx';
				indexLenKey = indexKey + '_len';

				typeIndex = events[indexKey] = events[indexKey] || {};

				if (!typeIndex[contextId]) {
					typeIndex[contextId] = [];

					// keep track of the number of keys in the index to quickly check if it's empty
					events[indexLenKey] = (events[indexLenKey] || 0) + 1;
				}

				typeIndex[contextId].push(event);


			} else {
				events[type] = events[type] || [];
				events[type].push(event);
			}
		}

		return this;
	},

	hasEventListeners: function (type) { // (String) -> Boolean
		var events = this[eventsKey];
		return !!events && ((type in events && events[type].length > 0) ||
		                    (type + '_idx' in events && events[type + '_idx_len'] > 0));
	},

	removeEventListener: function (types, fn, context) { // ([String, Function, Object]) or (Object[, Object])

		if (!this[eventsKey]) {
			return this;
		}

		if (!types) {
			return this.clearAllEventListeners();
		}

		if (L.Util.invokeEach(types, this.removeEventListener, this, fn, context)) { return this; }

		var events = this[eventsKey],
		    contextId = context && context !== this && L.stamp(context),
		    i, len, type, listeners, j, indexKey, indexLenKey, typeIndex, removed;

		types = L.Util.splitWords(types);

		for (i = 0, len = types.length; i < len; i++) {
			type = types[i];
			indexKey = type + '_idx';
			indexLenKey = indexKey + '_len';

			typeIndex = events[indexKey];

			if (!fn) {
				// clear all listeners for a type if function isn't specified
				delete events[type];
				delete events[indexKey];
				delete events[indexLenKey];

			} else {
				listeners = contextId && typeIndex ? typeIndex[contextId] : events[type];

				if (listeners) {
					for (j = listeners.length - 1; j >= 0; j--) {
						if ((listeners[j].action === fn) && (!context || (listeners[j].context === context))) {
							removed = listeners.splice(j, 1);
							// set the old action to a no-op, because it is possible
							// that the listener is being iterated over as part of a dispatch
							removed[0].action = L.Util.falseFn;
						}
					}

					if (context && typeIndex && (listeners.length === 0)) {
						delete typeIndex[contextId];
						events[indexLenKey]--;
					}
				}
			}
		}

		return this;
	},

	clearAllEventListeners: function () {
		delete this[eventsKey];
		return this;
	},

	fireEvent: function (type, data) { // (String[, Object])
		if (!this.hasEventListeners(type)) {
			return this;
		}

		var event = L.Util.extend({}, data, { type: type, target: this });

		var events = this[eventsKey],
		    listeners, i, len, typeIndex, contextId;

		if (events[type]) {
			// make sure adding/removing listeners inside other listeners won't cause infinite loop
			listeners = events[type].slice();

			for (i = 0, len = listeners.length; i < len; i++) {
				listeners[i].action.call(listeners[i].context, event);
			}
		}

		// fire event for the context-indexed listeners as well
		typeIndex = events[type + '_idx'];

		for (contextId in typeIndex) {
			listeners = typeIndex[contextId].slice();

			if (listeners) {
				for (i = 0, len = listeners.length; i < len; i++) {
					listeners[i].action.call(listeners[i].context, event);
				}
			}
		}

		return this;
	},

	addOneTimeEventListener: function (types, fn, context) {

		if (L.Util.invokeEach(types, this.addOneTimeEventListener, this, fn, context)) { return this; }

		var handler = L.bind(function () {
			this
			    .removeEventListener(types, fn, context)
			    .removeEventListener(types, handler, context);
		}, this);

		return this
		    .addEventListener(types, fn, context)
		    .addEventListener(types, handler, context);
	}
};

L.Mixin.Events.on = L.Mixin.Events.addEventListener;
L.Mixin.Events.off = L.Mixin.Events.removeEventListener;
L.Mixin.Events.once = L.Mixin.Events.addOneTimeEventListener;
L.Mixin.Events.fire = L.Mixin.Events.fireEvent;


/*
 * L.Browser handles different browser and feature detections for internal Leaflet use.
 */

(function () {

	var ie = 'ActiveXObject' in window,
		ielt9 = ie && !document.addEventListener,

	    // terrible browser detection to work around Safari / iOS / Android browser bugs
	    ua = navigator.userAgent.toLowerCase(),
	    webkit = ua.indexOf('webkit') !== -1,
	    chrome = ua.indexOf('chrome') !== -1,
	    phantomjs = ua.indexOf('phantom') !== -1,
	    android = ua.indexOf('android') !== -1,
	    android23 = ua.search('android [23]') !== -1,
		gecko = ua.indexOf('gecko') !== -1,

	    mobile = typeof orientation !== undefined + '',
	    msPointer = !window.PointerEvent && window.MSPointerEvent,
		pointer = (window.PointerEvent && window.navigator.pointerEnabled && window.navigator.maxTouchPoints) ||
				  msPointer,
	    retina = ('devicePixelRatio' in window && window.devicePixelRatio > 1) ||
	             ('matchMedia' in window && window.matchMedia('(min-resolution:144dpi)') &&
	              window.matchMedia('(min-resolution:144dpi)').matches),

	    doc = document.documentElement,
	    ie3d = ie && ('transition' in doc.style),
	    webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,
	    gecko3d = 'MozPerspective' in doc.style,
	    opera3d = 'OTransition' in doc.style,
	    any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d || opera3d) && !phantomjs;

	var touch = !window.L_NO_TOUCH && !phantomjs && (pointer || 'ontouchstart' in window ||
		(window.DocumentTouch && document instanceof window.DocumentTouch));

	L.Browser = {
		ie: ie,
		ielt9: ielt9,
		webkit: webkit,
		gecko: gecko && !webkit && !window.opera && !ie,

		android: android,
		android23: android23,

		chrome: chrome,

		ie3d: ie3d,
		webkit3d: webkit3d,
		gecko3d: gecko3d,
		opera3d: opera3d,
		any3d: any3d,

		mobile: mobile,
		mobileWebkit: mobile && webkit,
		mobileWebkit3d: mobile && webkit3d,
		mobileOpera: mobile && window.opera,

		touch: touch,
		msPointer: msPointer,
		pointer: pointer,

		retina: retina
	};

}());


/*
 * L.Point represents a point with x and y coordinates.
 */

L.Point = function (/*Number*/ x, /*Number*/ y, /*Boolean*/ round) {
	this.x = (round ? Math.round(x) : x);
	this.y = (round ? Math.round(y) : y);
};

L.Point.prototype = {

	clone: function () {
		return new L.Point(this.x, this.y);
	},

	// non-destructive, returns a new point
	add: function (point) {
		return this.clone()._add(L.point(point));
	},

	// destructive, used directly for performance in situations where it's safe to modify existing point
	_add: function (point) {
		this.x += point.x;
		this.y += point.y;
		return this;
	},

	subtract: function (point) {
		return this.clone()._subtract(L.point(point));
	},

	_subtract: function (point) {
		this.x -= point.x;
		this.y -= point.y;
		return this;
	},

	divideBy: function (num) {
		return this.clone()._divideBy(num);
	},

	_divideBy: function (num) {
		this.x /= num;
		this.y /= num;
		return this;
	},

	multiplyBy: function (num) {
		return this.clone()._multiplyBy(num);
	},

	_multiplyBy: function (num) {
		this.x *= num;
		this.y *= num;
		return this;
	},

	round: function () {
		return this.clone()._round();
	},

	_round: function () {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		return this;
	},

	floor: function () {
		return this.clone()._floor();
	},

	_floor: function () {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		return this;
	},

	distanceTo: function (point) {
		point = L.point(point);

		var x = point.x - this.x,
		    y = point.y - this.y;

		return Math.sqrt(x * x + y * y);
	},

	equals: function (point) {
		point = L.point(point);

		return point.x === this.x &&
		       point.y === this.y;
	},

	contains: function (point) {
		point = L.point(point);

		return Math.abs(point.x) <= Math.abs(this.x) &&
		       Math.abs(point.y) <= Math.abs(this.y);
	},

	toString: function () {
		return 'Point(' +
		        L.Util.formatNum(this.x) + ', ' +
		        L.Util.formatNum(this.y) + ')';
	}
};

L.point = function (x, y, round) {
	if (x instanceof L.Point) {
		return x;
	}
	if (L.Util.isArray(x)) {
		return new L.Point(x[0], x[1]);
	}
	if (x === undefined || x === null) {
		return x;
	}
	return new L.Point(x, y, round);
};


/*
 * L.Bounds represents a rectangular area on the screen in pixel coordinates.
 */

L.Bounds = function (a, b) { //(Point, Point) or Point[]
	if (!a) { return; }

	var points = b ? [a, b] : a;

	for (var i = 0, len = points.length; i < len; i++) {
		this.extend(points[i]);
	}
};

L.Bounds.prototype = {
	// extend the bounds to contain the given point
	extend: function (point) { // (Point)
		point = L.point(point);

		if (!this.min && !this.max) {
			this.min = point.clone();
			this.max = point.clone();
		} else {
			this.min.x = Math.min(point.x, this.min.x);
			this.max.x = Math.max(point.x, this.max.x);
			this.min.y = Math.min(point.y, this.min.y);
			this.max.y = Math.max(point.y, this.max.y);
		}
		return this;
	},

	getCenter: function (round) { // (Boolean) -> Point
		return new L.Point(
		        (this.min.x + this.max.x) / 2,
		        (this.min.y + this.max.y) / 2, round);
	},

	getBottomLeft: function () { // -> Point
		return new L.Point(this.min.x, this.max.y);
	},

	getTopRight: function () { // -> Point
		return new L.Point(this.max.x, this.min.y);
	},

	getSize: function () {
		return this.max.subtract(this.min);
	},

	contains: function (obj) { // (Bounds) or (Point) -> Boolean
		var min, max;

		if (typeof obj[0] === 'number' || obj instanceof L.Point) {
			obj = L.point(obj);
		} else {
			obj = L.bounds(obj);
		}

		if (obj instanceof L.Bounds) {
			min = obj.min;
			max = obj.max;
		} else {
			min = max = obj;
		}

		return (min.x >= this.min.x) &&
		       (max.x <= this.max.x) &&
		       (min.y >= this.min.y) &&
		       (max.y <= this.max.y);
	},

	intersects: function (bounds) { // (Bounds) -> Boolean
		bounds = L.bounds(bounds);

		var min = this.min,
		    max = this.max,
		    min2 = bounds.min,
		    max2 = bounds.max,
		    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),
		    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);

		return xIntersects && yIntersects;
	},

	isValid: function () {
		return !!(this.min && this.max);
	}
};

L.bounds = function (a, b) { // (Bounds) or (Point, Point) or (Point[])
	if (!a || a instanceof L.Bounds) {
		return a;
	}
	return new L.Bounds(a, b);
};


/*
 * L.Transformation is an utility class to perform simple point transformations through a 2d-matrix.
 */

L.Transformation = function (a, b, c, d) {
	this._a = a;
	this._b = b;
	this._c = c;
	this._d = d;
};

L.Transformation.prototype = {
	transform: function (point, scale) { // (Point, Number) -> Point
		return this._transform(point.clone(), scale);
	},

	// destructive transform (faster)
	_transform: function (point, scale) {
		scale = scale || 1;
		point.x = scale * (this._a * point.x + this._b);
		point.y = scale * (this._c * point.y + this._d);
		return point;
	},

	untransform: function (point, scale) {
		scale = scale || 1;
		return new L.Point(
		        (point.x / scale - this._b) / this._a,
		        (point.y / scale - this._d) / this._c);
	}
};


/*
 * L.DomUtil contains various utility functions for working with DOM.
 */

L.DomUtil = {
	get: function (id) {
		return (typeof id === 'string' ? document.getElementById(id) : id);
	},

	getStyle: function (el, style) {

		var value = el.style[style];

		if (!value && el.currentStyle) {
			value = el.currentStyle[style];
		}

		if ((!value || value === 'auto') && document.defaultView) {
			var css = document.defaultView.getComputedStyle(el, null);
			value = css ? css[style] : null;
		}

		return value === 'auto' ? null : value;
	},

	getViewportOffset: function (element) {

		var top = 0,
		    left = 0,
		    el = element,
		    docBody = document.body,
		    docEl = document.documentElement,
		    pos;

		do {
			top  += el.offsetTop  || 0;
			left += el.offsetLeft || 0;

			//add borders
			top += parseInt(L.DomUtil.getStyle(el, 'borderTopWidth'), 10) || 0;
			left += parseInt(L.DomUtil.getStyle(el, 'borderLeftWidth'), 10) || 0;

			pos = L.DomUtil.getStyle(el, 'position');

			if (el.offsetParent === docBody && pos === 'absolute') { break; }

			if (pos === 'fixed') {
				top  += docBody.scrollTop  || docEl.scrollTop  || 0;
				left += docBody.scrollLeft || docEl.scrollLeft || 0;
				break;
			}

			if (pos === 'relative' && !el.offsetLeft) {
				var width = L.DomUtil.getStyle(el, 'width'),
				    maxWidth = L.DomUtil.getStyle(el, 'max-width'),
				    r = el.getBoundingClientRect();

				if (width !== 'none' || maxWidth !== 'none') {
					left += r.left + el.clientLeft;
				}

				//calculate full y offset since we're breaking out of the loop
				top += r.top + (docBody.scrollTop  || docEl.scrollTop  || 0);

				break;
			}

			el = el.offsetParent;

		} while (el);

		el = element;

		do {
			if (el === docBody) { break; }

			top  -= el.scrollTop  || 0;
			left -= el.scrollLeft || 0;

			el = el.parentNode;
		} while (el);

		return new L.Point(left, top);
	},

	documentIsLtr: function () {
		if (!L.DomUtil._docIsLtrCached) {
			L.DomUtil._docIsLtrCached = true;
			L.DomUtil._docIsLtr = L.DomUtil.getStyle(document.body, 'direction') === 'ltr';
		}
		return L.DomUtil._docIsLtr;
	},

	create: function (tagName, className, container) {

		var el = document.createElement(tagName);
		el.className = className;

		if (container) {
			container.appendChild(el);
		}

		return el;
	},

	hasClass: function (el, name) {
		if (el.classList !== undefined) {
			return el.classList.contains(name);
		}
		var className = L.DomUtil._getClass(el);
		return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
	},

	addClass: function (el, name) {
		if (el.classList !== undefined) {
			var classes = L.Util.splitWords(name);
			for (var i = 0, len = classes.length; i < len; i++) {
				el.classList.add(classes[i]);
			}
		} else if (!L.DomUtil.hasClass(el, name)) {
			var className = L.DomUtil._getClass(el);
			L.DomUtil._setClass(el, (className ? className + ' ' : '') + name);
		}
	},

	removeClass: function (el, name) {
		if (el.classList !== undefined) {
			el.classList.remove(name);
		} else {
			L.DomUtil._setClass(el, L.Util.trim((' ' + L.DomUtil._getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
		}
	},

	_setClass: function (el, name) {
		if (el.className.baseVal === undefined) {
			el.className = name;
		} else {
			// in case of SVG element
			el.className.baseVal = name;
		}
	},

	_getClass: function (el) {
		return el.className.baseVal === undefined ? el.className : el.className.baseVal;
	},

	setOpacity: function (el, value) {

		if ('opacity' in el.style) {
			el.style.opacity = value;

		} else if ('filter' in el.style) {

			var filter = false,
			    filterName = 'DXImageTransform.Microsoft.Alpha';

			// filters collection throws an error if we try to retrieve a filter that doesn't exist
			try {
				filter = el.filters.item(filterName);
			} catch (e) {
				// don't set opacity to 1 if we haven't already set an opacity,
				// it isn't needed and breaks transparent pngs.
				if (value === 1) { return; }
			}

			value = Math.round(value * 100);

			if (filter) {
				filter.Enabled = (value !== 100);
				filter.Opacity = value;
			} else {
				el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
			}
		}
	},

	testProp: function (props) {

		var style = document.documentElement.style;

		for (var i = 0; i < props.length; i++) {
			if (props[i] in style) {
				return props[i];
			}
		}
		return false;
	},

	getTranslateString: function (point) {
		// on WebKit browsers (Chrome/Safari/iOS Safari/Android) using translate3d instead of translate
		// makes animation smoother as it ensures HW accel is used. Firefox 13 doesn't care
		// (same speed either way), Opera 12 doesn't support translate3d

		var is3d = L.Browser.webkit3d,
		    open = 'translate' + (is3d ? '3d' : '') + '(',
		    close = (is3d ? ',0' : '') + ')';

		return open + point.x + 'px,' + point.y + 'px' + close;
	},

	getScaleString: function (scale, origin) {

		var preTranslateStr = L.DomUtil.getTranslateString(origin.add(origin.multiplyBy(-1 * scale))),
		    scaleStr = ' scale(' + scale + ') ';

		return preTranslateStr + scaleStr;
	},

	setPosition: function (el, point, disable3D) { // (HTMLElement, Point[, Boolean])

		// jshint camelcase: false
		el._leaflet_pos = point;

		if (!disable3D && L.Browser.any3d) {
			el.style[L.DomUtil.TRANSFORM] =  L.DomUtil.getTranslateString(point);
		} else {
			el.style.left = point.x + 'px';
			el.style.top = point.y + 'px';
		}
	},

	getPosition: function (el) {
		// this method is only used for elements previously positioned using setPosition,
		// so it's safe to cache the position for performance

		// jshint camelcase: false
		return el._leaflet_pos;
	}
};


// prefix style property names

L.DomUtil.TRANSFORM = L.DomUtil.testProp(
        ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);

// webkitTransition comes first because some browser versions that drop vendor prefix don't do
// the same for the transitionend event, in particular the Android 4.1 stock browser

L.DomUtil.TRANSITION = L.DomUtil.testProp(
        ['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

L.DomUtil.TRANSITION_END =
        L.DomUtil.TRANSITION === 'webkitTransition' || L.DomUtil.TRANSITION === 'OTransition' ?
        L.DomUtil.TRANSITION + 'End' : 'transitionend';

(function () {
    if ('onselectstart' in document) {
        L.extend(L.DomUtil, {
            disableTextSelection: function () {
                L.DomEvent.on(window, 'selectstart', L.DomEvent.preventDefault);
            },

            enableTextSelection: function () {
                L.DomEvent.off(window, 'selectstart', L.DomEvent.preventDefault);
            }
        });
    } else {
        var userSelectProperty = L.DomUtil.testProp(
            ['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

        L.extend(L.DomUtil, {
            disableTextSelection: function () {
                if (userSelectProperty) {
                    var style = document.documentElement.style;
                    this._userSelect = style[userSelectProperty];
                    style[userSelectProperty] = 'none';
                }
            },

            enableTextSelection: function () {
                if (userSelectProperty) {
                    document.documentElement.style[userSelectProperty] = this._userSelect;
                    delete this._userSelect;
                }
            }
        });
    }

	L.extend(L.DomUtil, {
		disableImageDrag: function () {
			L.DomEvent.on(window, 'dragstart', L.DomEvent.preventDefault);
		},

		enableImageDrag: function () {
			L.DomEvent.off(window, 'dragstart', L.DomEvent.preventDefault);
		}
	});
})();


/*
 * L.LatLng represents a geographical point with latitude and longitude coordinates.
 */

L.LatLng = function (lat, lng, alt) { // (Number, Number, Number)
	lat = parseFloat(lat);
	lng = parseFloat(lng);

	if (isNaN(lat) || isNaN(lng)) {
		throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
	}

	this.lat = lat;
	this.lng = lng;

	if (alt !== undefined) {
		this.alt = parseFloat(alt);
	}
};

L.extend(L.LatLng, {
	DEG_TO_RAD: Math.PI / 180,
	RAD_TO_DEG: 180 / Math.PI,
	MAX_MARGIN: 1.0E-9 // max margin of error for the "equals" check
});

L.LatLng.prototype = {
	equals: function (obj) { // (LatLng) -> Boolean
		if (!obj) { return false; }

		obj = L.latLng(obj);

		var margin = Math.max(
		        Math.abs(this.lat - obj.lat),
		        Math.abs(this.lng - obj.lng));

		return margin <= L.LatLng.MAX_MARGIN;
	},

	toString: function (precision) { // (Number) -> String
		return 'LatLng(' +
		        L.Util.formatNum(this.lat, precision) + ', ' +
		        L.Util.formatNum(this.lng, precision) + ')';
	},

	// Haversine distance formula, see http://en.wikipedia.org/wiki/Haversine_formula
	// TODO move to projection code, LatLng shouldn't know about Earth
	distanceTo: function (other) { // (LatLng) -> Number
		other = L.latLng(other);

		var R = 6378137, // earth radius in meters
		    d2r = L.LatLng.DEG_TO_RAD,
		    dLat = (other.lat - this.lat) * d2r,
		    dLon = (other.lng - this.lng) * d2r,
		    lat1 = this.lat * d2r,
		    lat2 = other.lat * d2r,
		    sin1 = Math.sin(dLat / 2),
		    sin2 = Math.sin(dLon / 2);

		var a = sin1 * sin1 + sin2 * sin2 * Math.cos(lat1) * Math.cos(lat2);

		return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
	},

	wrap: function (a, b) { // (Number, Number) -> LatLng
		var lng = this.lng;

		a = a || -180;
		b = b ||  180;

		lng = (lng + b) % (b - a) + (lng < a || lng === b ? b : a);

		return new L.LatLng(this.lat, lng);
	}
};

L.latLng = function (a, b) { // (LatLng) or ([Number, Number]) or (Number, Number)
	if (a instanceof L.LatLng) {
		return a;
	}
	if (L.Util.isArray(a)) {
		if (typeof a[0] === 'number' || typeof a[0] === 'string') {
			return new L.LatLng(a[0], a[1], a[2]);
		} else {
			return null;
		}
	}
	if (a === undefined || a === null) {
		return a;
	}
	if (typeof a === 'object' && 'lat' in a) {
		return new L.LatLng(a.lat, 'lng' in a ? a.lng : a.lon);
	}
	if (b === undefined) {
		return null;
	}
	return new L.LatLng(a, b);
};



/*
 * L.LatLngBounds represents a rectangular area on the map in geographical coordinates.
 */

L.LatLngBounds = function (southWest, northEast) { // (LatLng, LatLng) or (LatLng[])
	if (!southWest) { return; }

	var latlngs = northEast ? [southWest, northEast] : southWest;

	for (var i = 0, len = latlngs.length; i < len; i++) {
		this.extend(latlngs[i]);
	}
};

L.LatLngBounds.prototype = {
	// extend the bounds to contain the given point or bounds
	extend: function (obj) { // (LatLng) or (LatLngBounds)
		if (!obj) { return this; }

		var latLng = L.latLng(obj);
		if (latLng !== null) {
			obj = latLng;
		} else {
			obj = L.latLngBounds(obj);
		}

		if (obj instanceof L.LatLng) {
			if (!this._southWest && !this._northEast) {
				this._southWest = new L.LatLng(obj.lat, obj.lng);
				this._northEast = new L.LatLng(obj.lat, obj.lng);
			} else {
				this._southWest.lat = Math.min(obj.lat, this._southWest.lat);
				this._southWest.lng = Math.min(obj.lng, this._southWest.lng);

				this._northEast.lat = Math.max(obj.lat, this._northEast.lat);
				this._northEast.lng = Math.max(obj.lng, this._northEast.lng);
			}
		} else if (obj instanceof L.LatLngBounds) {
			this.extend(obj._southWest);
			this.extend(obj._northEast);
		}
		return this;
	},

	// extend the bounds by a percentage
	pad: function (bufferRatio) { // (Number) -> LatLngBounds
		var sw = this._southWest,
		    ne = this._northEast,
		    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
		    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

		return new L.LatLngBounds(
		        new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
		        new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
	},

	getCenter: function () { // -> LatLng
		return new L.LatLng(
		        (this._southWest.lat + this._northEast.lat) / 2,
		        (this._southWest.lng + this._northEast.lng) / 2);
	},

	getSouthWest: function () {
		return this._southWest;
	},

	getNorthEast: function () {
		return this._northEast;
	},

	getNorthWest: function () {
		return new L.LatLng(this.getNorth(), this.getWest());
	},

	getSouthEast: function () {
		return new L.LatLng(this.getSouth(), this.getEast());
	},

	getWest: function () {
		return this._southWest.lng;
	},

	getSouth: function () {
		return this._southWest.lat;
	},

	getEast: function () {
		return this._northEast.lng;
	},

	getNorth: function () {
		return this._northEast.lat;
	},

	contains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean
		if (typeof obj[0] === 'number' || obj instanceof L.LatLng) {
			obj = L.latLng(obj);
		} else {
			obj = L.latLngBounds(obj);
		}

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2, ne2;

		if (obj instanceof L.LatLngBounds) {
			sw2 = obj.getSouthWest();
			ne2 = obj.getNorthEast();
		} else {
			sw2 = ne2 = obj;
		}

		return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&
		       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);
	},

	intersects: function (bounds) { // (LatLngBounds)
		bounds = L.latLngBounds(bounds);

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2 = bounds.getSouthWest(),
		    ne2 = bounds.getNorthEast(),

		    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),
		    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);

		return latIntersects && lngIntersects;
	},

	toBBoxString: function () {
		return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
	},

	equals: function (bounds) { // (LatLngBounds)
		if (!bounds) { return false; }

		bounds = L.latLngBounds(bounds);

		return this._southWest.equals(bounds.getSouthWest()) &&
		       this._northEast.equals(bounds.getNorthEast());
	},

	isValid: function () {
		return !!(this._southWest && this._northEast);
	}
};

//TODO International date line?

L.latLngBounds = function (a, b) { // (LatLngBounds) or (LatLng, LatLng)
	if (!a || a instanceof L.LatLngBounds) {
		return a;
	}
	return new L.LatLngBounds(a, b);
};


/*
 * L.Projection contains various geographical projections used by CRS classes.
 */

L.Projection = {};


/*
 * Spherical Mercator is the most popular map projection, used by EPSG:3857 CRS used by default.
 */

L.Projection.SphericalMercator = {
	MAX_LATITUDE: 85.0511287798,

	project: function (latlng) { // (LatLng) -> Point
		var d = L.LatLng.DEG_TO_RAD,
		    max = this.MAX_LATITUDE,
		    lat = Math.max(Math.min(max, latlng.lat), -max),
		    x = latlng.lng * d,
		    y = lat * d;

		y = Math.log(Math.tan((Math.PI / 4) + (y / 2)));

		return new L.Point(x, y);
	},

	unproject: function (point) { // (Point, Boolean) -> LatLng
		var d = L.LatLng.RAD_TO_DEG,
		    lng = point.x * d,
		    lat = (2 * Math.atan(Math.exp(point.y)) - (Math.PI / 2)) * d;

		return new L.LatLng(lat, lng);
	}
};


/*
 * Simple equirectangular (Plate Carree) projection, used by CRS like EPSG:4326 and Simple.
 */

L.Projection.LonLat = {
	project: function (latlng) {
		return new L.Point(latlng.lng, latlng.lat);
	},

	unproject: function (point) {
		return new L.LatLng(point.y, point.x);
	}
};


/*
 * L.CRS is a base object for all defined CRS (Coordinate Reference Systems) in Leaflet.
 */

L.CRS = {
	latLngToPoint: function (latlng, zoom) { // (LatLng, Number) -> Point
		var projectedPoint = this.projection.project(latlng),
		    scale = this.scale(zoom);

		return this.transformation._transform(projectedPoint, scale);
	},

	pointToLatLng: function (point, zoom) { // (Point, Number[, Boolean]) -> LatLng
		var scale = this.scale(zoom),
		    untransformedPoint = this.transformation.untransform(point, scale);

		return this.projection.unproject(untransformedPoint);
	},

	project: function (latlng) {
		return this.projection.project(latlng);
	},

	scale: function (zoom) {
		return 256 * Math.pow(2, zoom);
	},

	getSize: function (zoom) {
		var s = this.scale(zoom);
		return L.point(s, s);
	}
};


/*
 * A simple CRS that can be used for flat non-Earth maps like panoramas or game maps.
 */

L.CRS.Simple = L.extend({}, L.CRS, {
	projection: L.Projection.LonLat,
	transformation: new L.Transformation(1, 0, -1, 0),

	scale: function (zoom) {
		return Math.pow(2, zoom);
	}
});


/*
 * L.CRS.EPSG3857 (Spherical Mercator) is the most common CRS for web mapping
 * and is used by Leaflet by default.
 */

L.CRS.EPSG3857 = L.extend({}, L.CRS, {
	code: 'EPSG:3857',

	projection: L.Projection.SphericalMercator,
	transformation: new L.Transformation(0.5 / Math.PI, 0.5, -0.5 / Math.PI, 0.5),

	project: function (latlng) { // (LatLng) -> Point
		var projectedPoint = this.projection.project(latlng),
		    earthRadius = 6378137;
		return projectedPoint.multiplyBy(earthRadius);
	}
});

L.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {
	code: 'EPSG:900913'
});


/*
 * L.CRS.EPSG4326 is a CRS popular among advanced GIS specialists.
 */

L.CRS.EPSG4326 = L.extend({}, L.CRS, {
	code: 'EPSG:4326',

	projection: L.Projection.LonLat,
	transformation: new L.Transformation(1 / 360, 0.5, -1 / 360, 0.5)
});


/*
 * L.Map is the central class of the API - it is used to create a map.
 */

L.Map = L.Class.extend({

	includes: L.Mixin.Events,

	options: {
		crs: L.CRS.EPSG3857,

		/*
		center: LatLng,
		zoom: Number,
		layers: Array,
		*/

		fadeAnimation: L.DomUtil.TRANSITION && !L.Browser.android23,
		trackResize: true,
		markerZoomAnimation: L.DomUtil.TRANSITION && L.Browser.any3d
	},

	initialize: function (id, options) { // (HTMLElement or String, Object)
		options = L.setOptions(this, options);


		this._initContainer(id);
		this._initLayout();

		// hack for https://github.com/Leaflet/Leaflet/issues/1980
		this._onResize = L.bind(this._onResize, this);

		this._initEvents();

		if (options.maxBounds) {
			this.setMaxBounds(options.maxBounds);
		}

		if (options.center && options.zoom !== undefined) {
			this.setView(L.latLng(options.center), options.zoom, {reset: true});
		}

		this._handlers = [];

		this._layers = {};
		this._zoomBoundLayers = {};
		this._tileLayersNum = 0;

		this.callInitHooks();

		this._addLayers(options.layers);
	},


	// public methods that modify map state

	// replaced by animation-powered implementation in Map.PanAnimation.js
	setView: function (center, zoom) {
		zoom = zoom === undefined ? this.getZoom() : zoom;
		this._resetView(L.latLng(center), this._limitZoom(zoom));
		return this;
	},

	setZoom: function (zoom, options) {
		if (!this._loaded) {
			this._zoom = this._limitZoom(zoom);
			return this;
		}
		return this.setView(this.getCenter(), zoom, {zoom: options});
	},

	zoomIn: function (delta, options) {
		return this.setZoom(this._zoom + (delta || 1), options);
	},

	zoomOut: function (delta, options) {
		return this.setZoom(this._zoom - (delta || 1), options);
	},

	setZoomAround: function (latlng, zoom, options) {
		var scale = this.getZoomScale(zoom),
		    viewHalf = this.getSize().divideBy(2),
		    containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng),

		    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
		    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

		return this.setView(newCenter, zoom, {zoom: options});
	},

	fitBounds: function (bounds, options) {

		options = options || {};
		bounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);

		var paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),
		    paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),

		    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));

		zoom = (options.maxZoom) ? Math.min(options.maxZoom, zoom) : zoom;

		var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),

		    swPoint = this.project(bounds.getSouthWest(), zoom),
		    nePoint = this.project(bounds.getNorthEast(), zoom),
		    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

		return this.setView(center, zoom, options);
	},

	fitWorld: function (options) {
		return this.fitBounds([[-90, -180], [90, 180]], options);
	},

	panTo: function (center, options) { // (LatLng)
		return this.setView(center, this._zoom, {pan: options});
	},

	panBy: function (offset) { // (Point)
		// replaced with animated panBy in Map.PanAnimation.js
		this.fire('movestart');

		this._rawPanBy(L.point(offset));

		this.fire('move');
		return this.fire('moveend');
	},

	setMaxBounds: function (bounds) {
		bounds = L.latLngBounds(bounds);

		this.options.maxBounds = bounds;

		if (!bounds) {
			return this.off('moveend', this._panInsideMaxBounds, this);
		}

		if (this._loaded) {
			this._panInsideMaxBounds();
		}

		return this.on('moveend', this._panInsideMaxBounds, this);
	},

	panInsideBounds: function (bounds, options) {
		var center = this.getCenter(),
			newCenter = this._limitCenter(center, this._zoom, bounds);

		if (center.equals(newCenter)) { return this; }

		return this.panTo(newCenter, options);
	},

	addLayer: function (layer) {
		// TODO method is too big, refactor

		var id = L.stamp(layer);

		if (this._layers[id]) { return this; }

		this._layers[id] = layer;

		// TODO getMaxZoom, getMinZoom in ILayer (instead of options)
		if (layer.options && (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom))) {
			this._zoomBoundLayers[id] = layer;
			this._updateZoomLevels();
		}

		// TODO looks ugly, refactor!!!
		if (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {
			this._tileLayersNum++;
			this._tileLayersToLoad++;
			layer.on('load', this._onTileLayerLoad, this);
		}

		if (this._loaded) {
			this._layerAdd(layer);
		}

		return this;
	},

	removeLayer: function (layer) {
		var id = L.stamp(layer);

		if (!this._layers[id]) { return this; }

		if (this._loaded) {
			layer.onRemove(this);
		}

		delete this._layers[id];

		if (this._loaded) {
			this.fire('layerremove', {layer: layer});
		}

		if (this._zoomBoundLayers[id]) {
			delete this._zoomBoundLayers[id];
			this._updateZoomLevels();
		}

		// TODO looks ugly, refactor
		if (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {
			this._tileLayersNum--;
			this._tileLayersToLoad--;
			layer.off('load', this._onTileLayerLoad, this);
		}

		return this;
	},

	hasLayer: function (layer) {
		if (!layer) { return false; }

		return (L.stamp(layer) in this._layers);
	},

	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	invalidateSize: function (options) {
		if (!this._loaded) { return this; }

		options = L.extend({
			animate: false,
			pan: true
		}, options === true ? {animate: true} : options);

		var oldSize = this.getSize();
		this._sizeChanged = true;
		this._initialCenter = null;

		var newSize = this.getSize(),
		    oldCenter = oldSize.divideBy(2).round(),
		    newCenter = newSize.divideBy(2).round(),
		    offset = oldCenter.subtract(newCenter);

		if (!offset.x && !offset.y) { return this; }

		if (options.animate && options.pan) {
			this.panBy(offset);

		} else {
			if (options.pan) {
				this._rawPanBy(offset);
			}

			this.fire('move');

			if (options.debounceMoveend) {
				clearTimeout(this._sizeTimer);
				this._sizeTimer = setTimeout(L.bind(this.fire, this, 'moveend'), 200);
			} else {
				this.fire('moveend');
			}
		}

		return this.fire('resize', {
			oldSize: oldSize,
			newSize: newSize
		});
	},

	// TODO handler.addTo
	addHandler: function (name, HandlerClass) {
		if (!HandlerClass) { return this; }

		var handler = this[name] = new HandlerClass(this);

		this._handlers.push(handler);

		if (this.options[name]) {
			handler.enable();
		}

		return this;
	},

	remove: function () {
		if (this._loaded) {
			this.fire('unload');
		}

		this._initEvents('off');

		try {
			// throws error in IE6-8
			delete this._container._leaflet;
		} catch (e) {
			this._container._leaflet = undefined;
		}

		this._clearPanes();
		if (this._clearControlPos) {
			this._clearControlPos();
		}

		this._clearHandlers();

		return this;
	},


	// public methods for getting map state

	getCenter: function () { // (Boolean) -> LatLng
		this._checkIfLoaded();

		if (this._initialCenter && !this._moved()) {
			return this._initialCenter;
		}
		return this.layerPointToLatLng(this._getCenterLayerPoint());
	},

	getZoom: function () {
		return this._zoom;
	},

	getBounds: function () {
		var bounds = this.getPixelBounds(),
		    sw = this.unproject(bounds.getBottomLeft()),
		    ne = this.unproject(bounds.getTopRight());

		return new L.LatLngBounds(sw, ne);
	},

	getMinZoom: function () {
		return this.options.minZoom === undefined ?
			(this._layersMinZoom === undefined ? 0 : this._layersMinZoom) :
			this.options.minZoom;
	},

	getMaxZoom: function () {
		return this.options.maxZoom === undefined ?
			(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :
			this.options.maxZoom;
	},

	getBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number
		bounds = L.latLngBounds(bounds);

		var zoom = this.getMinZoom() - (inside ? 1 : 0),
		    maxZoom = this.getMaxZoom(),
		    size = this.getSize(),

		    nw = bounds.getNorthWest(),
		    se = bounds.getSouthEast(),

		    zoomNotFound = true,
		    boundsSize;

		padding = L.point(padding || [0, 0]);

		do {
			zoom++;
			boundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)).add(padding);
			zoomNotFound = !inside ? size.contains(boundsSize) : boundsSize.x < size.x || boundsSize.y < size.y;

		} while (zoomNotFound && zoom <= maxZoom);

		if (zoomNotFound && inside) {
			return null;
		}

		return inside ? zoom : zoom - 1;
	},

	getSize: function () {
		if (!this._size || this._sizeChanged) {
			this._size = new L.Point(
				this._container.clientWidth,
				this._container.clientHeight);

			this._sizeChanged = false;
		}
		return this._size.clone();
	},

	getPixelBounds: function () {
		var topLeftPoint = this._getTopLeftPoint();
		return new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
	},

	getPixelOrigin: function () {
		this._checkIfLoaded();
		return this._initialTopLeftPoint;
	},

	getPanes: function () {
		return this._panes;
	},

	getContainer: function () {
		return this._container;
	},


	// TODO replace with universal implementation after refactoring projections

	getZoomScale: function (toZoom) {
		var crs = this.options.crs;
		return crs.scale(toZoom) / crs.scale(this._zoom);
	},

	getScaleZoom: function (scale) {
		return this._zoom + (Math.log(scale) / Math.LN2);
	},


	// conversion methods

	project: function (latlng, zoom) { // (LatLng[, Number]) -> Point
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.latLngToPoint(L.latLng(latlng), zoom);
	},

	unproject: function (point, zoom) { // (Point[, Number]) -> LatLng
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.pointToLatLng(L.point(point), zoom);
	},

	layerPointToLatLng: function (point) { // (Point)
		var projectedPoint = L.point(point).add(this.getPixelOrigin());
		return this.unproject(projectedPoint);
	},

	latLngToLayerPoint: function (latlng) { // (LatLng)
		var projectedPoint = this.project(L.latLng(latlng))._round();
		return projectedPoint._subtract(this.getPixelOrigin());
	},

	containerPointToLayerPoint: function (point) { // (Point)
		return L.point(point).subtract(this._getMapPanePos());
	},

	layerPointToContainerPoint: function (point) { // (Point)
		return L.point(point).add(this._getMapPanePos());
	},

	containerPointToLatLng: function (point) {
		var layerPoint = this.containerPointToLayerPoint(L.point(point));
		return this.layerPointToLatLng(layerPoint);
	},

	latLngToContainerPoint: function (latlng) {
		return this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)));
	},

	mouseEventToContainerPoint: function (e) { // (MouseEvent)
		return L.DomEvent.getMousePosition(e, this._container);
	},

	mouseEventToLayerPoint: function (e) { // (MouseEvent)
		return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
	},

	mouseEventToLatLng: function (e) { // (MouseEvent)
		return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
	},


	// map initialization methods

	_initContainer: function (id) {
		var container = this._container = L.DomUtil.get(id);

		if (!container) {
			throw new Error('Map container not found.');
		} else if (container._leaflet) {
			throw new Error('Map container is already initialized.');
		}

		container._leaflet = true;
	},

	_initLayout: function () {
		var container = this._container;

		L.DomUtil.addClass(container, 'leaflet-container' +
			(L.Browser.touch ? ' leaflet-touch' : '') +
			(L.Browser.retina ? ' leaflet-retina' : '') +
			(L.Browser.ielt9 ? ' leaflet-oldie' : '') +
			(this.options.fadeAnimation ? ' leaflet-fade-anim' : ''));

		var position = L.DomUtil.getStyle(container, 'position');

		if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
			container.style.position = 'relative';
		}

		this._initPanes();

		if (this._initControlPos) {
			this._initControlPos();
		}
	},

	_initPanes: function () {
		var panes = this._panes = {};

		this._mapPane = panes.mapPane = this._createPane('leaflet-map-pane', this._container);

		this._tilePane = panes.tilePane = this._createPane('leaflet-tile-pane', this._mapPane);
		panes.objectsPane = this._createPane('leaflet-objects-pane', this._mapPane);
		panes.shadowPane = this._createPane('leaflet-shadow-pane');
		panes.overlayPane = this._createPane('leaflet-overlay-pane');
		panes.markerPane = this._createPane('leaflet-marker-pane');
		panes.popupPane = this._createPane('leaflet-popup-pane');

		var zoomHide = ' leaflet-zoom-hide';

		if (!this.options.markerZoomAnimation) {
			L.DomUtil.addClass(panes.markerPane, zoomHide);
			L.DomUtil.addClass(panes.shadowPane, zoomHide);
			L.DomUtil.addClass(panes.popupPane, zoomHide);
		}
	},

	_createPane: function (className, container) {
		return L.DomUtil.create('div', className, container || this._panes.objectsPane);
	},

	_clearPanes: function () {
		this._container.removeChild(this._mapPane);
	},

	_addLayers: function (layers) {
		layers = layers ? (L.Util.isArray(layers) ? layers : [layers]) : [];

		for (var i = 0, len = layers.length; i < len; i++) {
			this.addLayer(layers[i]);
		}
	},


	// private methods that modify map state

	_resetView: function (center, zoom, preserveMapOffset, afterZoomAnim) {

		var zoomChanged = (this._zoom !== zoom);

		if (!afterZoomAnim) {
			this.fire('movestart');

			if (zoomChanged) {
				this.fire('zoomstart');
			}
		}

		this._zoom = zoom;
		this._initialCenter = center;

		this._initialTopLeftPoint = this._getNewTopLeftPoint(center);

		if (!preserveMapOffset) {
			L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));
		} else {
			this._initialTopLeftPoint._add(this._getMapPanePos());
		}

		this._tileLayersToLoad = this._tileLayersNum;

		var loading = !this._loaded;
		this._loaded = true;

		this.fire('viewreset', {hard: !preserveMapOffset});

		if (loading) {
			this.fire('load');
			this.eachLayer(this._layerAdd, this);
		}

		this.fire('move');

		if (zoomChanged || afterZoomAnim) {
			this.fire('zoomend');
		}

		this.fire('moveend', {hard: !preserveMapOffset});
	},

	_rawPanBy: function (offset) {
		L.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
	},

	_getZoomSpan: function () {
		return this.getMaxZoom() - this.getMinZoom();
	},

	_updateZoomLevels: function () {
		var i,
			minZoom = Infinity,
			maxZoom = -Infinity,
			oldZoomSpan = this._getZoomSpan();

		for (i in this._zoomBoundLayers) {
			var layer = this._zoomBoundLayers[i];
			if (!isNaN(layer.options.minZoom)) {
				minZoom = Math.min(minZoom, layer.options.minZoom);
			}
			if (!isNaN(layer.options.maxZoom)) {
				maxZoom = Math.max(maxZoom, layer.options.maxZoom);
			}
		}

		if (i === undefined) { // we have no tilelayers
			this._layersMaxZoom = this._layersMinZoom = undefined;
		} else {
			this._layersMaxZoom = maxZoom;
			this._layersMinZoom = minZoom;
		}

		if (oldZoomSpan !== this._getZoomSpan()) {
			this.fire('zoomlevelschange');
		}
	},

	_panInsideMaxBounds: function () {
		this.panInsideBounds(this.options.maxBounds);
	},

	_checkIfLoaded: function () {
		if (!this._loaded) {
			throw new Error('Set map center and zoom first.');
		}
	},

	// map events

	_initEvents: function (onOff) {
		if (!L.DomEvent) { return; }

		onOff = onOff || 'on';

		L.DomEvent[onOff](this._container, 'click', this._onMouseClick, this);

		var events = ['dblclick', 'mousedown', 'mouseup', 'mouseenter',
		              'mouseleave', 'mousemove', 'contextmenu'],
		    i, len;

		for (i = 0, len = events.length; i < len; i++) {
			L.DomEvent[onOff](this._container, events[i], this._fireMouseEvent, this);
		}

		if (this.options.trackResize) {
			L.DomEvent[onOff](window, 'resize', this._onResize, this);
		}
	},

	_onResize: function () {
		L.Util.cancelAnimFrame(this._resizeRequest);
		this._resizeRequest = L.Util.requestAnimFrame(
		        function () { this.invalidateSize({debounceMoveend: true}); }, this, false, this._container);
	},

	_onMouseClick: function (e) {
		if (!this._loaded || (!e._simulated &&
		        ((this.dragging && this.dragging.moved()) ||
		         (this.boxZoom  && this.boxZoom.moved()))) ||
		            L.DomEvent._skipped(e)) { return; }

		this.fire('preclick');
		this._fireMouseEvent(e);
	},

	_fireMouseEvent: function (e) {
		if (!this._loaded || L.DomEvent._skipped(e)) { return; }

		var type = e.type;

		type = (type === 'mouseenter' ? 'mouseover' : (type === 'mouseleave' ? 'mouseout' : type));

		if (!this.hasEventListeners(type)) { return; }

		if (type === 'contextmenu') {
			L.DomEvent.preventDefault(e);
		}

		var containerPoint = this.mouseEventToContainerPoint(e),
		    layerPoint = this.containerPointToLayerPoint(containerPoint),
		    latlng = this.layerPointToLatLng(layerPoint);

		this.fire(type, {
			latlng: latlng,
			layerPoint: layerPoint,
			containerPoint: containerPoint,
			originalEvent: e
		});
	},

	_onTileLayerLoad: function () {
		this._tileLayersToLoad--;
		if (this._tileLayersNum && !this._tileLayersToLoad) {
			this.fire('tilelayersload');
		}
	},

	_clearHandlers: function () {
		for (var i = 0, len = this._handlers.length; i < len; i++) {
			this._handlers[i].disable();
		}
	},

	whenReady: function (callback, context) {
		if (this._loaded) {
			callback.call(context || this, this);
		} else {
			this.on('load', callback, context);
		}
		return this;
	},

	_layerAdd: function (layer) {
		layer.onAdd(this);
		this.fire('layeradd', {layer: layer});
	},


	// private methods for getting map state

	_getMapPanePos: function () {
		return L.DomUtil.getPosition(this._mapPane);
	},

	_moved: function () {
		var pos = this._getMapPanePos();
		return pos && !pos.equals([0, 0]);
	},

	_getTopLeftPoint: function () {
		return this.getPixelOrigin().subtract(this._getMapPanePos());
	},

	_getNewTopLeftPoint: function (center, zoom) {
		var viewHalf = this.getSize()._divideBy(2);
		// TODO round on display, not calculation to increase precision?
		return this.project(center, zoom)._subtract(viewHalf)._round();
	},

	_latLngToNewLayerPoint: function (latlng, newZoom, newCenter) {
		var topLeft = this._getNewTopLeftPoint(newCenter, newZoom).add(this._getMapPanePos());
		return this.project(latlng, newZoom)._subtract(topLeft);
	},

	// layer point of the current center
	_getCenterLayerPoint: function () {
		return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
	},

	// offset of the specified place to the current center in pixels
	_getCenterOffset: function (latlng) {
		return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
	},

	// adjust center for view to get inside bounds
	_limitCenter: function (center, zoom, bounds) {

		if (!bounds) { return center; }

		var centerPoint = this.project(center, zoom),
		    viewHalf = this.getSize().divideBy(2),
		    viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
		    offset = this._getBoundsOffset(viewBounds, bounds, zoom);

		return this.unproject(centerPoint.add(offset), zoom);
	},

	// adjust offset for view to get inside bounds
	_limitOffset: function (offset, bounds) {
		if (!bounds) { return offset; }

		var viewBounds = this.getPixelBounds(),
		    newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

		return offset.add(this._getBoundsOffset(newBounds, bounds));
	},

	// returns offset needed for pxBounds to get inside maxBounds at a specified zoom
	_getBoundsOffset: function (pxBounds, maxBounds, zoom) {
		var nwOffset = this.project(maxBounds.getNorthWest(), zoom).subtract(pxBounds.min),
		    seOffset = this.project(maxBounds.getSouthEast(), zoom).subtract(pxBounds.max),

		    dx = this._rebound(nwOffset.x, -seOffset.x),
		    dy = this._rebound(nwOffset.y, -seOffset.y);

		return new L.Point(dx, dy);
	},

	_rebound: function (left, right) {
		return left + right > 0 ?
			Math.round(left - right) / 2 :
			Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
	},

	_limitZoom: function (zoom) {
		var min = this.getMinZoom(),
		    max = this.getMaxZoom();

		return Math.max(min, Math.min(max, zoom));
	}
});

L.map = function (id, options) {
	return new L.Map(id, options);
};


/*
 * Mercator projection that takes into account that the Earth is not a perfect sphere.
 * Less popular than spherical mercator; used by projections like EPSG:3395.
 */

L.Projection.Mercator = {
	MAX_LATITUDE: 85.0840591556,

	R_MINOR: 6356752.314245179,
	R_MAJOR: 6378137,

	project: function (latlng) { // (LatLng) -> Point
		var d = L.LatLng.DEG_TO_RAD,
		    max = this.MAX_LATITUDE,
		    lat = Math.max(Math.min(max, latlng.lat), -max),
		    r = this.R_MAJOR,
		    r2 = this.R_MINOR,
		    x = latlng.lng * d * r,
		    y = lat * d,
		    tmp = r2 / r,
		    eccent = Math.sqrt(1.0 - tmp * tmp),
		    con = eccent * Math.sin(y);

		con = Math.pow((1 - con) / (1 + con), eccent * 0.5);

		var ts = Math.tan(0.5 * ((Math.PI * 0.5) - y)) / con;
		y = -r * Math.log(ts);

		return new L.Point(x, y);
	},

	unproject: function (point) { // (Point, Boolean) -> LatLng
		var d = L.LatLng.RAD_TO_DEG,
		    r = this.R_MAJOR,
		    r2 = this.R_MINOR,
		    lng = point.x * d / r,
		    tmp = r2 / r,
		    eccent = Math.sqrt(1 - (tmp * tmp)),
		    ts = Math.exp(- point.y / r),
		    phi = (Math.PI / 2) - 2 * Math.atan(ts),
		    numIter = 15,
		    tol = 1e-7,
		    i = numIter,
		    dphi = 0.1,
		    con;

		while ((Math.abs(dphi) > tol) && (--i > 0)) {
			con = eccent * Math.sin(phi);
			dphi = (Math.PI / 2) - 2 * Math.atan(ts *
			            Math.pow((1.0 - con) / (1.0 + con), 0.5 * eccent)) - phi;
			phi += dphi;
		}

		return new L.LatLng(phi * d, lng);
	}
};



L.CRS.EPSG3395 = L.extend({}, L.CRS, {
	code: 'EPSG:3395',

	projection: L.Projection.Mercator,

	transformation: (function () {
		var m = L.Projection.Mercator,
		    r = m.R_MAJOR,
		    scale = 0.5 / (Math.PI * r);

		return new L.Transformation(scale, 0.5, -scale, 0.5);
	}())
});


/*
 * L.TileLayer is used for standard xyz-numbered tile layers.
 */

L.TileLayer = L.Class.extend({
	includes: L.Mixin.Events,

	options: {
		minZoom: 0,
		maxZoom: 18,
		tileSize: 256,
		subdomains: 'abc',
		errorTileUrl: '',
		attribution: '',
		zoomOffset: 0,
		opacity: 1,
		/*
		maxNativeZoom: null,
		zIndex: null,
		tms: false,
		continuousWorld: false,
		noWrap: false,
		zoomReverse: false,
		detectRetina: false,
		reuseTiles: false,
		bounds: false,
		*/
		unloadInvisibleTiles: L.Browser.mobile,
		updateWhenIdle: L.Browser.mobile
	},

	initialize: function (url, options) {
		options = L.setOptions(this, options);

		// detecting retina displays, adjusting tileSize and zoom levels
		if (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {

			options.tileSize = Math.floor(options.tileSize / 2);
			options.zoomOffset++;

			if (options.minZoom > 0) {
				options.minZoom--;
			}
			this.options.maxZoom--;
		}

		if (options.bounds) {
			options.bounds = L.latLngBounds(options.bounds);
		}

		this._url = url;

		var subdomains = this.options.subdomains;

		if (typeof subdomains === 'string') {
			this.options.subdomains = subdomains.split('');
		}
	},

	onAdd: function (map) {
		this._map = map;
		this._animated = map._zoomAnimated;

		// create a container div for tiles
		this._initContainer();

		// set up events
		map.on({
			'viewreset': this._reset,
			'moveend': this._update
		}, this);

		if (this._animated) {
			map.on({
				'zoomanim': this._animateZoom,
				'zoomend': this._endZoomAnim
			}, this);
		}

		if (!this.options.updateWhenIdle) {
			this._limitedUpdate = L.Util.limitExecByInterval(this._update, 150, this);
			map.on('move', this._limitedUpdate, this);
		}

		this._reset();
		this._update();
	},

	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	onRemove: function (map) {
		this._container.parentNode.removeChild(this._container);

		map.off({
			'viewreset': this._reset,
			'moveend': this._update
		}, this);

		if (this._animated) {
			map.off({
				'zoomanim': this._animateZoom,
				'zoomend': this._endZoomAnim
			}, this);
		}

		if (!this.options.updateWhenIdle) {
			map.off('move', this._limitedUpdate, this);
		}

		this._container = null;
		this._map = null;
	},

	bringToFront: function () {
		var pane = this._map._panes.tilePane;

		if (this._container) {
			pane.appendChild(this._container);
			this._setAutoZIndex(pane, Math.max);
		}

		return this;
	},

	bringToBack: function () {
		var pane = this._map._panes.tilePane;

		if (this._container) {
			pane.insertBefore(this._container, pane.firstChild);
			this._setAutoZIndex(pane, Math.min);
		}

		return this;
	},

	getAttribution: function () {
		return this.options.attribution;
	},

	getContainer: function () {
		return this._container;
	},

	setOpacity: function (opacity) {
		this.options.opacity = opacity;

		if (this._map) {
			this._updateOpacity();
		}

		return this;
	},

	setZIndex: function (zIndex) {
		this.options.zIndex = zIndex;
		this._updateZIndex();

		return this;
	},

	setUrl: function (url, noRedraw) {
		this._url = url;

		if (!noRedraw) {
			this.redraw();
		}

		return this;
	},

	redraw: function () {
		if (this._map) {
			this._reset({hard: true});
			this._update();
		}
		return this;
	},

	_updateZIndex: function () {
		if (this._container && this.options.zIndex !== undefined) {
			this._container.style.zIndex = this.options.zIndex;
		}
	},

	_setAutoZIndex: function (pane, compare) {

		var layers = pane.children,
		    edgeZIndex = -compare(Infinity, -Infinity), // -Infinity for max, Infinity for min
		    zIndex, i, len;

		for (i = 0, len = layers.length; i < len; i++) {

			if (layers[i] !== this._container) {
				zIndex = parseInt(layers[i].style.zIndex, 10);

				if (!isNaN(zIndex)) {
					edgeZIndex = compare(edgeZIndex, zIndex);
				}
			}
		}

		this.options.zIndex = this._container.style.zIndex =
		        (isFinite(edgeZIndex) ? edgeZIndex : 0) + compare(1, -1);
	},

	_updateOpacity: function () {
		var i,
		    tiles = this._tiles;

		if (L.Browser.ielt9) {
			for (i in tiles) {
				L.DomUtil.setOpacity(tiles[i], this.options.opacity);
			}
		} else {
			L.DomUtil.setOpacity(this._container, this.options.opacity);
		}
	},

	_initContainer: function () {
		var tilePane = this._map._panes.tilePane;

		if (!this._container) {
			this._container = L.DomUtil.create('div', 'leaflet-layer');

			this._updateZIndex();

			if (this._animated) {
				var className = 'leaflet-tile-container';

				this._bgBuffer = L.DomUtil.create('div', className, this._container);
				this._tileContainer = L.DomUtil.create('div', className, this._container);

			} else {
				this._tileContainer = this._container;
			}

			tilePane.appendChild(this._container);

			if (this.options.opacity < 1) {
				this._updateOpacity();
			}
		}
	},

	_reset: function (e) {
		for (var key in this._tiles) {
			this.fire('tileunload', {tile: this._tiles[key]});
		}

		this._tiles = {};
		this._tilesToLoad = 0;

		if (this.options.reuseTiles) {
			this._unusedTiles = [];
		}

		this._tileContainer.innerHTML = '';

		if (this._animated && e && e.hard) {
			this._clearBgBuffer();
		}

		this._initContainer();
	},

	_getTileSize: function () {
		var map = this._map,
		    zoom = map.getZoom() + this.options.zoomOffset,
		    zoomN = this.options.maxNativeZoom,
		    tileSize = this.options.tileSize;

		if (zoomN && zoom > zoomN) {
			tileSize = Math.round(map.getZoomScale(zoom) / map.getZoomScale(zoomN) * tileSize);
		}

		return tileSize;
	},

	_update: function () {

		if (!this._map) { return; }

		var map = this._map,
		    bounds = map.getPixelBounds(),
		    zoom = map.getZoom(),
		    tileSize = this._getTileSize();

		if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
			return;
		}

		var tileBounds = L.bounds(
		        bounds.min.divideBy(tileSize)._floor(),
		        bounds.max.divideBy(tileSize)._floor());

		this._addTilesFromCenterOut(tileBounds);

		if (this.options.unloadInvisibleTiles || this.options.reuseTiles) {
			this._removeOtherTiles(tileBounds);
		}
	},

	_addTilesFromCenterOut: function (bounds) {
		var queue = [],
		    center = bounds.getCenter();

		var j, i, point;

		for (j = bounds.min.y; j <= bounds.max.y; j++) {
			for (i = bounds.min.x; i <= bounds.max.x; i++) {
				point = new L.Point(i, j);

				if (this._tileShouldBeLoaded(point)) {
					queue.push(point);
				}
			}
		}

		var tilesToLoad = queue.length;

		if (tilesToLoad === 0) { return; }

		// load tiles in order of their distance to center
		queue.sort(function (a, b) {
			return a.distanceTo(center) - b.distanceTo(center);
		});

		var fragment = document.createDocumentFragment();

		// if its the first batch of tiles to load
		if (!this._tilesToLoad) {
			this.fire('loading');
		}

		this._tilesToLoad += tilesToLoad;

		for (i = 0; i < tilesToLoad; i++) {
			this._addTile(queue[i], fragment);
		}

		this._tileContainer.appendChild(fragment);
	},

	_tileShouldBeLoaded: function (tilePoint) {
		if ((tilePoint.x + ':' + tilePoint.y) in this._tiles) {
			return false; // already loaded
		}

		var options = this.options;

		if (!options.continuousWorld) {
			var limit = this._getWrapTileNum();

			// don't load if exceeds world bounds
			if ((options.noWrap && (tilePoint.x < 0 || tilePoint.x >= limit.x)) ||
				tilePoint.y < 0 || tilePoint.y >= limit.y) { return false; }
		}

		if (options.bounds) {
			var tileSize = this._getTileSize(),
			    nwPoint = tilePoint.multiplyBy(tileSize),
			    sePoint = nwPoint.add([tileSize, tileSize]),
			    nw = this._map.unproject(nwPoint),
			    se = this._map.unproject(sePoint);

			// TODO temporary hack, will be removed after refactoring projections
			// https://github.com/Leaflet/Leaflet/issues/1618
			if (!options.continuousWorld && !options.noWrap) {
				nw = nw.wrap();
				se = se.wrap();
			}

			if (!options.bounds.intersects([nw, se])) { return false; }
		}

		return true;
	},

	_removeOtherTiles: function (bounds) {
		var kArr, x, y, key;

		for (key in this._tiles) {
			kArr = key.split(':');
			x = parseInt(kArr[0], 10);
			y = parseInt(kArr[1], 10);

			// remove tile if it's out of bounds
			if (x < bounds.min.x || x > bounds.max.x || y < bounds.min.y || y > bounds.max.y) {
				this._removeTile(key);
			}
		}
	},

	_removeTile: function (key) {
		var tile = this._tiles[key];

		this.fire('tileunload', {tile: tile, url: tile.src});

		if (this.options.reuseTiles) {
			L.DomUtil.removeClass(tile, 'leaflet-tile-loaded');
			this._unusedTiles.push(tile);

		} else if (tile.parentNode === this._tileContainer) {
			this._tileContainer.removeChild(tile);
		}

		// for https://github.com/CloudMade/Leaflet/issues/137
		if (!L.Browser.android) {
			tile.onload = null;
			tile.src = L.Util.emptyImageUrl;
		}

		delete this._tiles[key];
	},

	_addTile: function (tilePoint, container) {
		var tilePos = this._getTilePos(tilePoint);

		// get unused tile - or create a new tile
		var tile = this._getTile();

		/*
		Chrome 20 layouts much faster with top/left (verify with timeline, frames)
		Android 4 browser has display issues with top/left and requires transform instead
		(other browsers don't currently care) - see debug/hacks/jitter.html for an example
		*/
		L.DomUtil.setPosition(tile, tilePos, L.Browser.chrome);

		this._tiles[tilePoint.x + ':' + tilePoint.y] = tile;

		this._loadTile(tile, tilePoint);

		if (tile.parentNode !== this._tileContainer) {
			container.appendChild(tile);
		}
	},

	_getZoomForUrl: function () {

		var options = this.options,
		    zoom = this._map.getZoom();

		if (options.zoomReverse) {
			zoom = options.maxZoom - zoom;
		}

		zoom += options.zoomOffset;

		return options.maxNativeZoom ? Math.min(zoom, options.maxNativeZoom) : zoom;
	},

	_getTilePos: function (tilePoint) {
		var origin = this._map.getPixelOrigin(),
		    tileSize = this._getTileSize();

		return tilePoint.multiplyBy(tileSize).subtract(origin);
	},

	// image-specific code (override to implement e.g. Canvas or SVG tile layer)

	getTileUrl: function (tilePoint) {
		return L.Util.template(this._url, L.extend({
			s: this._getSubdomain(tilePoint),
			z: tilePoint.z,
			x: tilePoint.x,
			y: tilePoint.y
		}, this.options));
	},

	_getWrapTileNum: function () {
		var crs = this._map.options.crs,
		    size = crs.getSize(this._map.getZoom());
		return size.divideBy(this._getTileSize())._floor();
	},

	_adjustTilePoint: function (tilePoint) {

		var limit = this._getWrapTileNum();

		// wrap tile coordinates
		if (!this.options.continuousWorld && !this.options.noWrap) {
			tilePoint.x = ((tilePoint.x % limit.x) + limit.x) % limit.x;
		}

		if (this.options.tms) {
			tilePoint.y = limit.y - tilePoint.y - 1;
		}

		tilePoint.z = this._getZoomForUrl();
	},

	_getSubdomain: function (tilePoint) {
		var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
		return this.options.subdomains[index];
	},

	_getTile: function () {
		if (this.options.reuseTiles && this._unusedTiles.length > 0) {
			var tile = this._unusedTiles.pop();
			this._resetTile(tile);
			return tile;
		}
		return this._createTile();
	},

	// Override if data stored on a tile needs to be cleaned up before reuse
	_resetTile: function (/*tile*/) {},

	_createTile: function () {
		var tile = L.DomUtil.create('img', 'leaflet-tile');
		tile.style.width = tile.style.height = this._getTileSize() + 'px';
		tile.galleryimg = 'no';

		tile.onselectstart = tile.onmousemove = L.Util.falseFn;

		if (L.Browser.ielt9 && this.options.opacity !== undefined) {
			L.DomUtil.setOpacity(tile, this.options.opacity);
		}
		// without this hack, tiles disappear after zoom on Chrome for Android
		// https://github.com/Leaflet/Leaflet/issues/2078
		if (L.Browser.mobileWebkit3d) {
			tile.style.WebkitBackfaceVisibility = 'hidden';
		}
		return tile;
	},

	_loadTile: function (tile, tilePoint) {
		tile._layer  = this;
		tile.onload  = this._tileOnLoad;
		tile.onerror = this._tileOnError;

		this._adjustTilePoint(tilePoint);
		tile.src     = this.getTileUrl(tilePoint);

		this.fire('tileloadstart', {
			tile: tile,
			url: tile.src
		});
	},

	_tileLoaded: function () {
		this._tilesToLoad--;

		if (this._animated) {
			L.DomUtil.addClass(this._tileContainer, 'leaflet-zoom-animated');
		}

		if (!this._tilesToLoad) {
			this.fire('load');

			if (this._animated) {
				// clear scaled tiles after all new tiles are loaded (for performance)
				clearTimeout(this._clearBgBufferTimer);
				this._clearBgBufferTimer = setTimeout(L.bind(this._clearBgBuffer, this), 500);
			}
		}
	},

	_tileOnLoad: function () {
		var layer = this._layer;

		//Only if we are loading an actual image
		if (this.src !== L.Util.emptyImageUrl) {
			L.DomUtil.addClass(this, 'leaflet-tile-loaded');

			layer.fire('tileload', {
				tile: this,
				url: this.src
			});
		}

		layer._tileLoaded();
	},

	_tileOnError: function () {
		var layer = this._layer;

		layer.fire('tileerror', {
			tile: this,
			url: this.src
		});

		var newUrl = layer.options.errorTileUrl;
		if (newUrl) {
			this.src = newUrl;
		}

		layer._tileLoaded();
	}
});

L.tileLayer = function (url, options) {
	return new L.TileLayer(url, options);
};


/*
 * L.TileLayer.WMS is used for putting WMS tile layers on the map.
 */

L.TileLayer.WMS = L.TileLayer.extend({

	defaultWmsParams: {
		service: 'WMS',
		request: 'GetMap',
		version: '1.1.1',
		layers: '',
		styles: '',
		format: 'image/jpeg',
		transparent: false
	},

	initialize: function (url, options) { // (String, Object)

		this._url = url;

		var wmsParams = L.extend({}, this.defaultWmsParams),
		    tileSize = options.tileSize || this.options.tileSize;

		if (options.detectRetina && L.Browser.retina) {
			wmsParams.width = wmsParams.height = tileSize * 2;
		} else {
			wmsParams.width = wmsParams.height = tileSize;
		}

		for (var i in options) {
			// all keys that are not TileLayer options go to WMS params
			if (!this.options.hasOwnProperty(i) && i !== 'crs') {
				wmsParams[i] = options[i];
			}
		}

		this.wmsParams = wmsParams;

		L.setOptions(this, options);
	},

	onAdd: function (map) {

		this._crs = this.options.crs || map.options.crs;

		this._wmsVersion = parseFloat(this.wmsParams.version);

		var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
		this.wmsParams[projectionKey] = this._crs.code;

		L.TileLayer.prototype.onAdd.call(this, map);
	},

	getTileUrl: function (tilePoint) { // (Point, Number) -> String

		var map = this._map,
		    tileSize = this.options.tileSize,

		    nwPoint = tilePoint.multiplyBy(tileSize),
		    sePoint = nwPoint.add([tileSize, tileSize]),

		    nw = this._crs.project(map.unproject(nwPoint, tilePoint.z)),
		    se = this._crs.project(map.unproject(sePoint, tilePoint.z)),
		    bbox = this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ?
		        [se.y, nw.x, nw.y, se.x].join(',') :
		        [nw.x, se.y, se.x, nw.y].join(','),

		    url = L.Util.template(this._url, {s: this._getSubdomain(tilePoint)});

		return url + L.Util.getParamString(this.wmsParams, url, true) + '&BBOX=' + bbox;
	},

	setParams: function (params, noRedraw) {

		L.extend(this.wmsParams, params);

		if (!noRedraw) {
			this.redraw();
		}

		return this;
	}
});

L.tileLayer.wms = function (url, options) {
	return new L.TileLayer.WMS(url, options);
};


/*
 * L.TileLayer.Canvas is a class that you can use as a base for creating
 * dynamically drawn Canvas-based tile layers.
 */

L.TileLayer.Canvas = L.TileLayer.extend({
	options: {
		async: false
	},

	initialize: function (options) {
		L.setOptions(this, options);
	},

	redraw: function () {
		if (this._map) {
			this._reset({hard: true});
			this._update();
		}

		for (var i in this._tiles) {
			this._redrawTile(this._tiles[i]);
		}
		return this;
	},

	_redrawTile: function (tile) {
		this.drawTile(tile, tile._tilePoint, this._map._zoom);
	},

	_createTile: function () {
		var tile = L.DomUtil.create('canvas', 'leaflet-tile');
		tile.width = tile.height = this.options.tileSize;
		tile.onselectstart = tile.onmousemove = L.Util.falseFn;
		return tile;
	},

	_loadTile: function (tile, tilePoint) {
		tile._layer = this;
		tile._tilePoint = tilePoint;

		this._redrawTile(tile);

		if (!this.options.async) {
			this.tileDrawn(tile);
		}
	},

	drawTile: function (/*tile, tilePoint*/) {
		// override with rendering code
	},

	tileDrawn: function (tile) {
		this._tileOnLoad.call(tile);
	}
});


L.tileLayer.canvas = function (options) {
	return new L.TileLayer.Canvas(options);
};


/*
 * L.ImageOverlay is used to overlay images over the map (to specific geographical bounds).
 */

L.ImageOverlay = L.Class.extend({
	includes: L.Mixin.Events,

	options: {
		opacity: 1
	},

	initialize: function (url, bounds, options) { // (String, LatLngBounds, Object)
		this._url = url;
		this._bounds = L.latLngBounds(bounds);

		L.setOptions(this, options);
	},

	onAdd: function (map) {
		this._map = map;

		if (!this._image) {
			this._initImage();
		}

		map._panes.overlayPane.appendChild(this._image);

		map.on('viewreset', this._reset, this);

		if (map.options.zoomAnimation && L.Browser.any3d) {
			map.on('zoomanim', this._animateZoom, this);
		}

		this._reset();
	},

	onRemove: function (map) {
		map.getPanes().overlayPane.removeChild(this._image);

		map.off('viewreset', this._reset, this);

		if (map.options.zoomAnimation) {
			map.off('zoomanim', this._animateZoom, this);
		}
	},

	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		this._updateOpacity();
		return this;
	},

	// TODO remove bringToFront/bringToBack duplication from TileLayer/Path
	bringToFront: function () {
		if (this._image) {
			this._map._panes.overlayPane.appendChild(this._image);
		}
		return this;
	},

	bringToBack: function () {
		var pane = this._map._panes.overlayPane;
		if (this._image) {
			pane.insertBefore(this._image, pane.firstChild);
		}
		return this;
	},

	setUrl: function (url) {
		this._url = url;
		this._image.src = this._url;
	},

	getAttribution: function () {
		return this.options.attribution;
	},

	_initImage: function () {
		this._image = L.DomUtil.create('img', 'leaflet-image-layer');

		if (this._map.options.zoomAnimation && L.Browser.any3d) {
			L.DomUtil.addClass(this._image, 'leaflet-zoom-animated');
		} else {
			L.DomUtil.addClass(this._image, 'leaflet-zoom-hide');
		}

		this._updateOpacity();

		//TODO createImage util method to remove duplication
		L.extend(this._image, {
			galleryimg: 'no',
			onselectstart: L.Util.falseFn,
			onmousemove: L.Util.falseFn,
			onload: L.bind(this._onImageLoad, this),
			src: this._url
		});
	},

	_animateZoom: function (e) {
		var map = this._map,
		    image = this._image,
		    scale = map.getZoomScale(e.zoom),
		    nw = this._bounds.getNorthWest(),
		    se = this._bounds.getSouthEast(),

		    topLeft = map._latLngToNewLayerPoint(nw, e.zoom, e.center),
		    size = map._latLngToNewLayerPoint(se, e.zoom, e.center)._subtract(topLeft),
		    origin = topLeft._add(size._multiplyBy((1 / 2) * (1 - 1 / scale)));

		image.style[L.DomUtil.TRANSFORM] =
		        L.DomUtil.getTranslateString(origin) + ' scale(' + scale + ') ';
	},

	_reset: function () {
		var image   = this._image,
		    topLeft = this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
		    size = this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(topLeft);

		L.DomUtil.setPosition(image, topLeft);

		image.style.width  = size.x + 'px';
		image.style.height = size.y + 'px';
	},

	_onImageLoad: function () {
		this.fire('load');
	},

	_updateOpacity: function () {
		L.DomUtil.setOpacity(this._image, this.options.opacity);
	}
});

L.imageOverlay = function (url, bounds, options) {
	return new L.ImageOverlay(url, bounds, options);
};


/*
 * L.Icon is an image-based icon class that you can use with L.Marker for custom markers.
 */

L.Icon = L.Class.extend({
	options: {
		/*
		iconUrl: (String) (required)
		iconRetinaUrl: (String) (optional, used for retina devices if detected)
		iconSize: (Point) (can be set through CSS)
		iconAnchor: (Point) (centered by default, can be set in CSS with negative margins)
		popupAnchor: (Point) (if not specified, popup opens in the anchor point)
		shadowUrl: (String) (no shadow by default)
		shadowRetinaUrl: (String) (optional, used for retina devices if detected)
		shadowSize: (Point)
		shadowAnchor: (Point)
		*/
		className: ''
	},

	initialize: function (options) {
		L.setOptions(this, options);
	},

	createIcon: function (oldIcon) {
		return this._createIcon('icon', oldIcon);
	},

	createShadow: function (oldIcon) {
		return this._createIcon('shadow', oldIcon);
	},

	_createIcon: function (name, oldIcon) {
		var src = this._getIconUrl(name);

		if (!src) {
			if (name === 'icon') {
				throw new Error('iconUrl not set in Icon options (see the docs).');
			}
			return null;
		}

		var img;
		if (!oldIcon || oldIcon.tagName !== 'IMG') {
			img = this._createImg(src);
		} else {
			img = this._createImg(src, oldIcon);
		}
		this._setIconStyles(img, name);

		return img;
	},

	_setIconStyles: function (img, name) {
		var options = this.options,
		    size = L.point(options[name + 'Size']),
		    anchor;

		if (name === 'shadow') {
			anchor = L.point(options.shadowAnchor || options.iconAnchor);
		} else {
			anchor = L.point(options.iconAnchor);
		}

		if (!anchor && size) {
			anchor = size.divideBy(2, true);
		}

		img.className = 'leaflet-marker-' + name + ' ' + options.className;

		if (anchor) {
			img.style.marginLeft = (-anchor.x) + 'px';
			img.style.marginTop  = (-anchor.y) + 'px';
		}

		if (size) {
			img.style.width  = size.x + 'px';
			img.style.height = size.y + 'px';
		}
	},

	_createImg: function (src, el) {
		el = el || document.createElement('img');
		el.src = src;
		return el;
	},

	_getIconUrl: function (name) {
		if (L.Browser.retina && this.options[name + 'RetinaUrl']) {
			return this.options[name + 'RetinaUrl'];
		}
		return this.options[name + 'Url'];
	}
});

L.icon = function (options) {
	return new L.Icon(options);
};


/*
 * L.Icon.Default is the blue marker icon used by default in Leaflet.
 */

L.Icon.Default = L.Icon.extend({

	options: {
		iconSize: [25, 41],
		iconAnchor: [12, 41],
		popupAnchor: [1, -34],

		shadowSize: [41, 41]
	},

	_getIconUrl: function (name) {
		var key = name + 'Url';

		if (this.options[key]) {
			return this.options[key];
		}

		if (L.Browser.retina && name === 'icon') {
			name += '-2x';
		}

		var path = L.Icon.Default.imagePath;

		if (!path) {
			throw new Error('Couldn\'t autodetect L.Icon.Default.imagePath, set it manually.');
		}

		return path + '/marker-' + name + '.png';
	}
});

L.Icon.Default.imagePath = (function () {
	var scripts = document.getElementsByTagName('script'),
	    leafletRe = /[\/^]leaflet[\-\._]?([\w\-\._]*)\.js\??/;

	var i, len, src, matches, path;

	for (i = 0, len = scripts.length; i < len; i++) {
		src = scripts[i].src;
		matches = src.match(leafletRe);

		if (matches) {
			path = src.split(leafletRe)[0];
			return (path ? path + '/' : '') + 'images';
		}
	}
}());


/*
 * L.Marker is used to display clickable/draggable icons on the map.
 */

L.Marker = L.Class.extend({

	includes: L.Mixin.Events,

	options: {
		icon: new L.Icon.Default(),
		title: '',
		alt: '',
		clickable: true,
		draggable: false,
		keyboard: true,
		zIndexOffset: 0,
		opacity: 1,
		riseOnHover: false,
		riseOffset: 250
	},

	initialize: function (latlng, options) {
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng);
	},

	onAdd: function (map) {
		this._map = map;

		map.on('viewreset', this.update, this);

		this._initIcon();
		this.update();
		this.fire('add');

		if (map.options.zoomAnimation && map.options.markerZoomAnimation) {
			map.on('zoomanim', this._animateZoom, this);
		}
	},

	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	onRemove: function (map) {
		if (this.dragging) {
			this.dragging.disable();
		}

		this._removeIcon();
		this._removeShadow();

		this.fire('remove');

		map.off({
			'viewreset': this.update,
			'zoomanim': this._animateZoom
		}, this);

		this._map = null;
	},

	getLatLng: function () {
		return this._latlng;
	},

	setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);

		this.update();

		return this.fire('move', { latlng: this._latlng });
	},

	setZIndexOffset: function (offset) {
		this.options.zIndexOffset = offset;
		this.update();

		return this;
	},

	setIcon: function (icon) {

		this.options.icon = icon;

		if (this._map) {
			this._initIcon();
			this.update();
		}

		if (this._popup) {
			this.bindPopup(this._popup);
		}

		return this;
	},

	update: function () {
		if (this._icon) {
			this._setPos(this._map.latLngToLayerPoint(this._latlng).round());
		}
		return this;
	},

	_initIcon: function () {
		var options = this.options,
		    map = this._map,
		    animation = (map.options.zoomAnimation && map.options.markerZoomAnimation),
		    classToAdd = animation ? 'leaflet-zoom-animated' : 'leaflet-zoom-hide';

		var icon = options.icon.createIcon(this._icon),
			addIcon = false;

		// if we're not reusing the icon, remove the old one and init new one
		if (icon !== this._icon) {
			if (this._icon) {
				this._removeIcon();
			}
			addIcon = true;

			if (options.title) {
				icon.title = options.title;
			}

			if (options.alt) {
				icon.alt = options.alt;
			}
		}

		L.DomUtil.addClass(icon, classToAdd);

		if (options.keyboard) {
			icon.tabIndex = '0';
		}

		this._icon = icon;

		this._initInteraction();

		if (options.riseOnHover) {
			L.DomEvent
				.on(icon, 'mouseover', this._bringToFront, this)
				.on(icon, 'mouseout', this._resetZIndex, this);
		}

		var newShadow = options.icon.createShadow(this._shadow),
			addShadow = false;

		if (newShadow !== this._shadow) {
			this._removeShadow();
			addShadow = true;
		}

		if (newShadow) {
			L.DomUtil.addClass(newShadow, classToAdd);
		}
		this._shadow = newShadow;


		if (options.opacity < 1) {
			this._updateOpacity();
		}


		var panes = this._map._panes;

		if (addIcon) {
			panes.markerPane.appendChild(this._icon);
		}

		if (newShadow && addShadow) {
			panes.shadowPane.appendChild(this._shadow);
		}
	},

	_removeIcon: function () {
		if (this.options.riseOnHover) {
			L.DomEvent
			    .off(this._icon, 'mouseover', this._bringToFront)
			    .off(this._icon, 'mouseout', this._resetZIndex);
		}

		this._map._panes.markerPane.removeChild(this._icon);

		this._icon = null;
	},

	_removeShadow: function () {
		if (this._shadow) {
			this._map._panes.shadowPane.removeChild(this._shadow);
		}
		this._shadow = null;
	},

	_setPos: function (pos) {
		L.DomUtil.setPosition(this._icon, pos);

		if (this._shadow) {
			L.DomUtil.setPosition(this._shadow, pos);
		}

		this._zIndex = pos.y + this.options.zIndexOffset;

		this._resetZIndex();
	},

	_updateZIndex: function (offset) {
		this._icon.style.zIndex = this._zIndex + offset;
	},

	_animateZoom: function (opt) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

		this._setPos(pos);
	},

	_initInteraction: function () {

		if (!this.options.clickable) { return; }

		// TODO refactor into something shared with Map/Path/etc. to DRY it up

		var icon = this._icon,
		    events = ['dblclick', 'mousedown', 'mouseover', 'mouseout', 'contextmenu'];

		L.DomUtil.addClass(icon, 'leaflet-clickable');
		L.DomEvent.on(icon, 'click', this._onMouseClick, this);
		L.DomEvent.on(icon, 'keypress', this._onKeyPress, this);

		for (var i = 0; i < events.length; i++) {
			L.DomEvent.on(icon, events[i], this._fireMouseEvent, this);
		}

		if (L.Handler.MarkerDrag) {
			this.dragging = new L.Handler.MarkerDrag(this);

			if (this.options.draggable) {
				this.dragging.enable();
			}
		}
	},

	_onMouseClick: function (e) {
		var wasDragged = this.dragging && this.dragging.moved();

		if (this.hasEventListeners(e.type) || wasDragged) {
			L.DomEvent.stopPropagation(e);
		}

		if (wasDragged) { return; }

		if ((!this.dragging || !this.dragging._enabled) && this._map.dragging && this._map.dragging.moved()) { return; }

		this.fire(e.type, {
			originalEvent: e,
			latlng: this._latlng
		});
	},

	_onKeyPress: function (e) {
		if (e.keyCode === 13) {
			this.fire('click', {
				originalEvent: e,
				latlng: this._latlng
			});
		}
	},

	_fireMouseEvent: function (e) {

		this.fire(e.type, {
			originalEvent: e,
			latlng: this._latlng
		});

		// TODO proper custom event propagation
		// this line will always be called if marker is in a FeatureGroup
		if (e.type === 'contextmenu' && this.hasEventListeners(e.type)) {
			L.DomEvent.preventDefault(e);
		}
		if (e.type !== 'mousedown') {
			L.DomEvent.stopPropagation(e);
		} else {
			L.DomEvent.preventDefault(e);
		}
	},

	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		if (this._map) {
			this._updateOpacity();
		}

		return this;
	},

	_updateOpacity: function () {
		L.DomUtil.setOpacity(this._icon, this.options.opacity);
		if (this._shadow) {
			L.DomUtil.setOpacity(this._shadow, this.options.opacity);
		}
	},

	_bringToFront: function () {
		this._updateZIndex(this.options.riseOffset);
	},

	_resetZIndex: function () {
		this._updateZIndex(0);
	}
});

L.marker = function (latlng, options) {
	return new L.Marker(latlng, options);
};


/*
 * L.DivIcon is a lightweight HTML-based icon class (as opposed to the image-based L.Icon)
 * to use with L.Marker.
 */

L.DivIcon = L.Icon.extend({
	options: {
		iconSize: [12, 12], // also can be set through CSS
		/*
		iconAnchor: (Point)
		popupAnchor: (Point)
		html: (String)
		bgPos: (Point)
		*/
		className: 'leaflet-div-icon',
		html: false
	},

	createIcon: function (oldIcon) {
		var div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),
		    options = this.options;

		if (options.html !== false) {
			div.innerHTML = options.html;
		} else {
			div.innerHTML = '';
		}

		if (options.bgPos) {
			div.style.backgroundPosition =
			        (-options.bgPos.x) + 'px ' + (-options.bgPos.y) + 'px';
		}

		this._setIconStyles(div, 'icon');
		return div;
	},

	createShadow: function () {
		return null;
	}
});

L.divIcon = function (options) {
	return new L.DivIcon(options);
};


/*
 * L.Popup is used for displaying popups on the map.
 */

L.Map.mergeOptions({
	closePopupOnClick: true
});

L.Popup = L.Class.extend({
	includes: L.Mixin.Events,

	options: {
		minWidth: 50,
		maxWidth: 300,
		// maxHeight: null,
		autoPan: true,
		closeButton: true,
		offset: [0, 7],
		autoPanPadding: [5, 5],
		// autoPanPaddingTopLeft: null,
		// autoPanPaddingBottomRight: null,
		keepInView: false,
		className: '',
		zoomAnimation: true
	},

	initialize: function (options, source) {
		L.setOptions(this, options);

		this._source = source;
		this._animated = L.Browser.any3d && this.options.zoomAnimation;
		this._isOpen = false;
	},

	onAdd: function (map) {
		this._map = map;

		if (!this._container) {
			this._initLayout();
		}

		var animFade = map.options.fadeAnimation;

		if (animFade) {
			L.DomUtil.setOpacity(this._container, 0);
		}
		map._panes.popupPane.appendChild(this._container);

		map.on(this._getEvents(), this);

		this.update();

		if (animFade) {
			L.DomUtil.setOpacity(this._container, 1);
		}

		this.fire('open');

		map.fire('popupopen', {popup: this});

		if (this._source) {
			this._source.fire('popupopen', {popup: this});
		}
	},

	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	openOn: function (map) {
		map.openPopup(this);
		return this;
	},

	onRemove: function (map) {
		map._panes.popupPane.removeChild(this._container);

		L.Util.falseFn(this._container.offsetWidth); // force reflow

		map.off(this._getEvents(), this);

		if (map.options.fadeAnimation) {
			L.DomUtil.setOpacity(this._container, 0);
		}

		this._map = null;

		this.fire('close');

		map.fire('popupclose', {popup: this});

		if (this._source) {
			this._source.fire('popupclose', {popup: this});
		}
	},

	getLatLng: function () {
		return this._latlng;
	},

	setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);
		if (this._map) {
			this._updatePosition();
			this._adjustPan();
		}
		return this;
	},

	getContent: function () {
		return this._content;
	},

	setContent: function (content) {
		this._content = content;
		this.update();
		return this;
	},

	update: function () {
		if (!this._map) { return; }

		this._container.style.visibility = 'hidden';

		this._updateContent();
		this._updateLayout();
		this._updatePosition();

		this._container.style.visibility = '';

		this._adjustPan();
	},

	_getEvents: function () {
		var events = {
			viewreset: this._updatePosition
		};

		if (this._animated) {
			events.zoomanim = this._zoomAnimation;
		}
		if ('closeOnClick' in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
			events.preclick = this._close;
		}
		if (this.options.keepInView) {
			events.moveend = this._adjustPan;
		}

		return events;
	},

	_close: function () {
		if (this._map) {
			this._map.closePopup(this);
		}
	},

	_initLayout: function () {
		var prefix = 'leaflet-popup',
			containerClass = prefix + ' ' + this.options.className + ' leaflet-zoom-' +
			        (this._animated ? 'animated' : 'hide'),
			container = this._container = L.DomUtil.create('div', containerClass),
			closeButton;

		if (this.options.closeButton) {
			closeButton = this._closeButton =
			        L.DomUtil.create('a', prefix + '-close-button', container);
			closeButton.href = '#close';
			closeButton.innerHTML = '&#215;';
			L.DomEvent.disableClickPropagation(closeButton);

			L.DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);
		}

		var wrapper = this._wrapper =
		        L.DomUtil.create('div', prefix + '-content-wrapper', container);
		L.DomEvent.disableClickPropagation(wrapper);

		this._contentNode = L.DomUtil.create('div', prefix + '-content', wrapper);

		L.DomEvent.disableScrollPropagation(this._contentNode);
		L.DomEvent.on(wrapper, 'contextmenu', L.DomEvent.stopPropagation);

		this._tipContainer = L.DomUtil.create('div', prefix + '-tip-container', container);
		this._tip = L.DomUtil.create('div', prefix + '-tip', this._tipContainer);
	},

	_updateContent: function () {
		if (!this._content) { return; }

		if (typeof this._content === 'string') {
			this._contentNode.innerHTML = this._content;
		} else {
			while (this._contentNode.hasChildNodes()) {
				this._contentNode.removeChild(this._contentNode.firstChild);
			}
			this._contentNode.appendChild(this._content);
		}
		this.fire('contentupdate');
	},

	_updateLayout: function () {
		var container = this._contentNode,
		    style = container.style;

		style.width = '';
		style.whiteSpace = 'nowrap';

		var width = container.offsetWidth;
		width = Math.min(width, this.options.maxWidth);
		width = Math.max(width, this.options.minWidth);

		style.width = (width + 1) + 'px';
		style.whiteSpace = '';

		style.height = '';

		var height = container.offsetHeight,
		    maxHeight = this.options.maxHeight,
		    scrolledClass = 'leaflet-popup-scrolled';

		if (maxHeight && height > maxHeight) {
			style.height = maxHeight + 'px';
			L.DomUtil.addClass(container, scrolledClass);
		} else {
			L.DomUtil.removeClass(container, scrolledClass);
		}

		this._containerWidth = this._container.offsetWidth;
	},

	_updatePosition: function () {
		if (!this._map) { return; }

		var pos = this._map.latLngToLayerPoint(this._latlng),
		    animated = this._animated,
		    offset = L.point(this.options.offset);

		if (animated) {
			L.DomUtil.setPosition(this._container, pos);
		}

		this._containerBottom = -offset.y - (animated ? 0 : pos.y);
		this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x + (animated ? 0 : pos.x);

		// bottom position the popup in case the height of the popup changes (images loading etc)
		this._container.style.bottom = this._containerBottom + 'px';
		this._container.style.left = this._containerLeft + 'px';
	},

	_zoomAnimation: function (opt) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center);

		L.DomUtil.setPosition(this._container, pos);
	},

	_adjustPan: function () {
		if (!this.options.autoPan) { return; }

		var map = this._map,
		    containerHeight = this._container.offsetHeight,
		    containerWidth = this._containerWidth,

		    layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);

		if (this._animated) {
			layerPos._add(L.DomUtil.getPosition(this._container));
		}

		var containerPos = map.layerPointToContainerPoint(layerPos),
		    padding = L.point(this.options.autoPanPadding),
		    paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),
		    paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),
		    size = map.getSize(),
		    dx = 0,
		    dy = 0;

		if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
			dx = containerPos.x + containerWidth - size.x + paddingBR.x;
		}
		if (containerPos.x - dx - paddingTL.x < 0) { // left
			dx = containerPos.x - paddingTL.x;
		}
		if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
			dy = containerPos.y + containerHeight - size.y + paddingBR.y;
		}
		if (containerPos.y - dy - paddingTL.y < 0) { // top
			dy = containerPos.y - paddingTL.y;
		}

		if (dx || dy) {
			map
			    .fire('autopanstart')
			    .panBy([dx, dy]);
		}
	},

	_onCloseButtonClick: function (e) {
		this._close();
		L.DomEvent.stop(e);
	}
});

L.popup = function (options, source) {
	return new L.Popup(options, source);
};


L.Map.include({
	openPopup: function (popup, latlng, options) { // (Popup) or (String || HTMLElement, LatLng[, Object])
		this.closePopup();

		if (!(popup instanceof L.Popup)) {
			var content = popup;

			popup = new L.Popup(options)
			    .setLatLng(latlng)
			    .setContent(content);
		}
		popup._isOpen = true;

		this._popup = popup;
		return this.addLayer(popup);
	},

	closePopup: function (popup) {
		if (!popup || popup === this._popup) {
			popup = this._popup;
			this._popup = null;
		}
		if (popup) {
			this.removeLayer(popup);
			popup._isOpen = false;
		}
		return this;
	}
});


/*
 * Popup extension to L.Marker, adding popup-related methods.
 */

L.Marker.include({
	openPopup: function () {
		if (this._popup && this._map && !this._map.hasLayer(this._popup)) {
			this._popup.setLatLng(this._latlng);
			this._map.openPopup(this._popup);
		}

		return this;
	},

	closePopup: function () {
		if (this._popup) {
			this._popup._close();
		}
		return this;
	},

	togglePopup: function () {
		if (this._popup) {
			if (this._popup._isOpen) {
				this.closePopup();
			} else {
				this.openPopup();
			}
		}
		return this;
	},

	bindPopup: function (content, options) {
		var anchor = L.point(this.options.icon.options.popupAnchor || [0, 0]);

		anchor = anchor.add(L.Popup.prototype.options.offset);

		if (options && options.offset) {
			anchor = anchor.add(options.offset);
		}

		options = L.extend({offset: anchor}, options);

		if (!this._popupHandlersAdded) {
			this
			    .on('click', this.togglePopup, this)
			    .on('remove', this.closePopup, this)
			    .on('move', this._movePopup, this);
			this._popupHandlersAdded = true;
		}

		if (content instanceof L.Popup) {
			L.setOptions(content, options);
			this._popup = content;
			content._source = this;
		} else {
			this._popup = new L.Popup(options, this)
				.setContent(content);
		}

		return this;
	},

	setPopupContent: function (content) {
		if (this._popup) {
			this._popup.setContent(content);
		}
		return this;
	},

	unbindPopup: function () {
		if (this._popup) {
			this._popup = null;
			this
			    .off('click', this.togglePopup, this)
			    .off('remove', this.closePopup, this)
			    .off('move', this._movePopup, this);
			this._popupHandlersAdded = false;
		}
		return this;
	},

	getPopup: function () {
		return this._popup;
	},

	_movePopup: function (e) {
		this._popup.setLatLng(e.latlng);
	}
});


/*
 * L.LayerGroup is a class to combine several layers into one so that
 * you can manipulate the group (e.g. add/remove it) as one layer.
 */

L.LayerGroup = L.Class.extend({
	initialize: function (layers) {
		this._layers = {};

		var i, len;

		if (layers) {
			for (i = 0, len = layers.length; i < len; i++) {
				this.addLayer(layers[i]);
			}
		}
	},

	addLayer: function (layer) {
		var id = this.getLayerId(layer);

		this._layers[id] = layer;

		if (this._map) {
			this._map.addLayer(layer);
		}

		return this;
	},

	removeLayer: function (layer) {
		var id = layer in this._layers ? layer : this.getLayerId(layer);

		if (this._map && this._layers[id]) {
			this._map.removeLayer(this._layers[id]);
		}

		delete this._layers[id];

		return this;
	},

	hasLayer: function (layer) {
		if (!layer) { return false; }

		return (layer in this._layers || this.getLayerId(layer) in this._layers);
	},

	clearLayers: function () {
		this.eachLayer(this.removeLayer, this);
		return this;
	},

	invoke: function (methodName) {
		var args = Array.prototype.slice.call(arguments, 1),
		    i, layer;

		for (i in this._layers) {
			layer = this._layers[i];

			if (layer[methodName]) {
				layer[methodName].apply(layer, args);
			}
		}

		return this;
	},

	onAdd: function (map) {
		this._map = map;
		this.eachLayer(map.addLayer, map);
	},

	onRemove: function (map) {
		this.eachLayer(map.removeLayer, map);
		this._map = null;
	},

	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	getLayer: function (id) {
		return this._layers[id];
	},

	getLayers: function () {
		var layers = [];

		for (var i in this._layers) {
			layers.push(this._layers[i]);
		}
		return layers;
	},

	setZIndex: function (zIndex) {
		return this.invoke('setZIndex', zIndex);
	},

	getLayerId: function (layer) {
		return L.stamp(layer);
	}
});

L.layerGroup = function (layers) {
	return new L.LayerGroup(layers);
};


/*
 * L.FeatureGroup extends L.LayerGroup by introducing mouse events and additional methods
 * shared between a group of interactive layers (like vectors or markers).
 */

L.FeatureGroup = L.LayerGroup.extend({
	includes: L.Mixin.Events,

	statics: {
		EVENTS: 'click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose'
	},

	addLayer: function (layer) {
		if (this.hasLayer(layer)) {
			return this;
		}

		if ('on' in layer) {
			layer.on(L.FeatureGroup.EVENTS, this._propagateEvent, this);
		}

		L.LayerGroup.prototype.addLayer.call(this, layer);

		if (this._popupContent && layer.bindPopup) {
			layer.bindPopup(this._popupContent, this._popupOptions);
		}

		return this.fire('layeradd', {layer: layer});
	},

	removeLayer: function (layer) {
		if (!this.hasLayer(layer)) {
			return this;
		}
		if (layer in this._layers) {
			layer = this._layers[layer];
		}

		layer.off(L.FeatureGroup.EVENTS, this._propagateEvent, this);

		L.LayerGroup.prototype.removeLayer.call(this, layer);

		if (this._popupContent) {
			this.invoke('unbindPopup');
		}

		return this.fire('layerremove', {layer: layer});
	},

	bindPopup: function (content, options) {
		this._popupContent = content;
		this._popupOptions = options;
		return this.invoke('bindPopup', content, options);
	},

	openPopup: function (latlng) {
		// open popup on the first layer
		for (var id in this._layers) {
			this._layers[id].openPopup(latlng);
			break;
		}
		return this;
	},

	setStyle: function (style) {
		return this.invoke('setStyle', style);
	},

	bringToFront: function () {
		return this.invoke('bringToFront');
	},

	bringToBack: function () {
		return this.invoke('bringToBack');
	},

	getBounds: function () {
		var bounds = new L.LatLngBounds();

		this.eachLayer(function (layer) {
			bounds.extend(layer instanceof L.Marker ? layer.getLatLng() : layer.getBounds());
		});

		return bounds;
	},

	_propagateEvent: function (e) {
		e = L.extend({
			layer: e.target,
			target: this
		}, e);
		this.fire(e.type, e);
	}
});

L.featureGroup = function (layers) {
	return new L.FeatureGroup(layers);
};


/*
 * L.Path is a base class for rendering vector paths on a map. Inherited by Polyline, Circle, etc.
 */

L.Path = L.Class.extend({
	includes: [L.Mixin.Events],

	statics: {
		// how much to extend the clip area around the map view
		// (relative to its size, e.g. 0.5 is half the screen in each direction)
		// set it so that SVG element doesn't exceed 1280px (vectors flicker on dragend if it is)
		CLIP_PADDING: (function () {
			var max = L.Browser.mobile ? 1280 : 2000,
			    target = (max / Math.max(window.outerWidth, window.outerHeight) - 1) / 2;
			return Math.max(0, Math.min(0.5, target));
		})()
	},

	options: {
		stroke: true,
		color: '#0033ff',
		dashArray: null,
		lineCap: null,
		lineJoin: null,
		weight: 5,
		opacity: 0.5,

		fill: false,
		fillColor: null, //same as color by default
		fillOpacity: 0.2,

		clickable: true
	},

	initialize: function (options) {
		L.setOptions(this, options);
	},

	onAdd: function (map) {
		this._map = map;

		if (!this._container) {
			this._initElements();
			this._initEvents();
		}

		this.projectLatlngs();
		this._updatePath();

		if (this._container) {
			this._map._pathRoot.appendChild(this._container);
		}

		this.fire('add');

		map.on({
			'viewreset': this.projectLatlngs,
			'moveend': this._updatePath
		}, this);
	},

	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	onRemove: function (map) {
		map._pathRoot.removeChild(this._container);

		// Need to fire remove event before we set _map to null as the event hooks might need the object
		this.fire('remove');
		this._map = null;

		if (L.Browser.vml) {
			this._container = null;
			this._stroke = null;
			this._fill = null;
		}

		map.off({
			'viewreset': this.projectLatlngs,
			'moveend': this._updatePath
		}, this);
	},

	projectLatlngs: function () {
		// do all projection stuff here
	},

	setStyle: function (style) {
		L.setOptions(this, style);

		if (this._container) {
			this._updateStyle();
		}

		return this;
	},

	redraw: function () {
		if (this._map) {
			this.projectLatlngs();
			this._updatePath();
		}
		return this;
	}
});

L.Map.include({
	_updatePathViewport: function () {
		var p = L.Path.CLIP_PADDING,
		    size = this.getSize(),
		    panePos = L.DomUtil.getPosition(this._mapPane),
		    min = panePos.multiplyBy(-1)._subtract(size.multiplyBy(p)._round()),
		    max = min.add(size.multiplyBy(1 + p * 2)._round());

		this._pathViewport = new L.Bounds(min, max);
	}
});


/*
 * Extends L.Path with SVG-specific rendering code.
 */

L.Path.SVG_NS = 'http://www.w3.org/2000/svg';

L.Browser.svg = !!(document.createElementNS && document.createElementNS(L.Path.SVG_NS, 'svg').createSVGRect);

L.Path = L.Path.extend({
	statics: {
		SVG: L.Browser.svg
	},

	bringToFront: function () {
		var root = this._map._pathRoot,
		    path = this._container;

		if (path && root.lastChild !== path) {
			root.appendChild(path);
		}
		return this;
	},

	bringToBack: function () {
		var root = this._map._pathRoot,
		    path = this._container,
		    first = root.firstChild;

		if (path && first !== path) {
			root.insertBefore(path, first);
		}
		return this;
	},

	getPathString: function () {
		// form path string here
	},

	_createElement: function (name) {
		return document.createElementNS(L.Path.SVG_NS, name);
	},

	_initElements: function () {
		this._map._initPathRoot();
		this._initPath();
		this._initStyle();
	},

	_initPath: function () {
		this._container = this._createElement('g');

		this._path = this._createElement('path');

		if (this.options.className) {
			L.DomUtil.addClass(this._path, this.options.className);
		}

		this._container.appendChild(this._path);
	},

	_initStyle: function () {
		if (this.options.stroke) {
			this._path.setAttribute('stroke-linejoin', 'round');
			this._path.setAttribute('stroke-linecap', 'round');
		}
		if (this.options.fill) {
			this._path.setAttribute('fill-rule', 'evenodd');
		}
		if (this.options.pointerEvents) {
			this._path.setAttribute('pointer-events', this.options.pointerEvents);
		}
		if (!this.options.clickable && !this.options.pointerEvents) {
			this._path.setAttribute('pointer-events', 'none');
		}
		this._updateStyle();
	},

	_updateStyle: function () {
		if (this.options.stroke) {
			this._path.setAttribute('stroke', this.options.color);
			this._path.setAttribute('stroke-opacity', this.options.opacity);
			this._path.setAttribute('stroke-width', this.options.weight);
			if (this.options.dashArray) {
				this._path.setAttribute('stroke-dasharray', this.options.dashArray);
			} else {
				this._path.removeAttribute('stroke-dasharray');
			}
			if (this.options.lineCap) {
				this._path.setAttribute('stroke-linecap', this.options.lineCap);
			}
			if (this.options.lineJoin) {
				this._path.setAttribute('stroke-linejoin', this.options.lineJoin);
			}
		} else {
			this._path.setAttribute('stroke', 'none');
		}
		if (this.options.fill) {
			this._path.setAttribute('fill', this.options.fillColor || this.options.color);
			this._path.setAttribute('fill-opacity', this.options.fillOpacity);
		} else {
			this._path.setAttribute('fill', 'none');
		}
	},

	_updatePath: function () {
		var str = this.getPathString();
		if (!str) {
			// fix webkit empty string parsing bug
			str = 'M0 0';
		}
		this._path.setAttribute('d', str);
	},

	// TODO remove duplication with L.Map
	_initEvents: function () {
		if (this.options.clickable) {
			if (L.Browser.svg || !L.Browser.vml) {
				L.DomUtil.addClass(this._path, 'leaflet-clickable');
			}

			L.DomEvent.on(this._container, 'click', this._onMouseClick, this);

			var events = ['dblclick', 'mousedown', 'mouseover',
			              'mouseout', 'mousemove', 'contextmenu'];
			for (var i = 0; i < events.length; i++) {
				L.DomEvent.on(this._container, events[i], this._fireMouseEvent, this);
			}
		}
	},

	_onMouseClick: function (e) {
		if (this._map.dragging && this._map.dragging.moved()) { return; }

		this._fireMouseEvent(e);
	},

	_fireMouseEvent: function (e) {
		if (!this.hasEventListeners(e.type)) { return; }

		var map = this._map,
		    containerPoint = map.mouseEventToContainerPoint(e),
		    layerPoint = map.containerPointToLayerPoint(containerPoint),
		    latlng = map.layerPointToLatLng(layerPoint);

		this.fire(e.type, {
			latlng: latlng,
			layerPoint: layerPoint,
			containerPoint: containerPoint,
			originalEvent: e
		});

		if (e.type === 'contextmenu') {
			L.DomEvent.preventDefault(e);
		}
		if (e.type !== 'mousemove') {
			L.DomEvent.stopPropagation(e);
		}
	}
});

L.Map.include({
	_initPathRoot: function () {
		if (!this._pathRoot) {
			this._pathRoot = L.Path.prototype._createElement('svg');
			this._panes.overlayPane.appendChild(this._pathRoot);

			if (this.options.zoomAnimation && L.Browser.any3d) {
				L.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-animated');

				this.on({
					'zoomanim': this._animatePathZoom,
					'zoomend': this._endPathZoom
				});
			} else {
				L.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-hide');
			}

			this.on('moveend', this._updateSvgViewport);
			this._updateSvgViewport();
		}
	},

	_animatePathZoom: function (e) {
		var scale = this.getZoomScale(e.zoom),
		    offset = this._getCenterOffset(e.center)._multiplyBy(-scale)._add(this._pathViewport.min);

		this._pathRoot.style[L.DomUtil.TRANSFORM] =
		        L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ') ';

		this._pathZooming = true;
	},

	_endPathZoom: function () {
		this._pathZooming = false;
	},

	_updateSvgViewport: function () {

		if (this._pathZooming) {
			// Do not update SVGs while a zoom animation is going on otherwise the animation will break.
			// When the zoom animation ends we will be updated again anyway
			// This fixes the case where you do a momentum move and zoom while the move is still ongoing.
			return;
		}

		this._updatePathViewport();

		var vp = this._pathViewport,
		    min = vp.min,
		    max = vp.max,
		    width = max.x - min.x,
		    height = max.y - min.y,
		    root = this._pathRoot,
		    pane = this._panes.overlayPane;

		// Hack to make flicker on drag end on mobile webkit less irritating
		if (L.Browser.mobileWebkit) {
			pane.removeChild(root);
		}

		L.DomUtil.setPosition(root, min);
		root.setAttribute('width', width);
		root.setAttribute('height', height);
		root.setAttribute('viewBox', [min.x, min.y, width, height].join(' '));

		if (L.Browser.mobileWebkit) {
			pane.appendChild(root);
		}
	}
});


/*
 * Popup extension to L.Path (polylines, polygons, circles), adding popup-related methods.
 */

L.Path.include({

	bindPopup: function (content, options) {

		if (content instanceof L.Popup) {
			this._popup = content;
		} else {
			if (!this._popup || options) {
				this._popup = new L.Popup(options, this);
			}
			this._popup.setContent(content);
		}

		if (!this._popupHandlersAdded) {
			this
			    .on('click', this._openPopup, this)
			    .on('remove', this.closePopup, this);

			this._popupHandlersAdded = true;
		}

		return this;
	},

	unbindPopup: function () {
		if (this._popup) {
			this._popup = null;
			this
			    .off('click', this._openPopup)
			    .off('remove', this.closePopup);

			this._popupHandlersAdded = false;
		}
		return this;
	},

	openPopup: function (latlng) {

		if (this._popup) {
			// open the popup from one of the path's points if not specified
			latlng = latlng || this._latlng ||
			         this._latlngs[Math.floor(this._latlngs.length / 2)];

			this._openPopup({latlng: latlng});
		}

		return this;
	},

	closePopup: function () {
		if (this._popup) {
			this._popup._close();
		}
		return this;
	},

	_openPopup: function (e) {
		this._popup.setLatLng(e.latlng);
		this._map.openPopup(this._popup);
	}
});


/*
 * Vector rendering for IE6-8 through VML.
 * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
 */

L.Browser.vml = !L.Browser.svg && (function () {
	try {
		var div = document.createElement('div');
		div.innerHTML = '<v:shape adj="1"/>';

		var shape = div.firstChild;
		shape.style.behavior = 'url(#default#VML)';

		return shape && (typeof shape.adj === 'object');

	} catch (e) {
		return false;
	}
}());

L.Path = L.Browser.svg || !L.Browser.vml ? L.Path : L.Path.extend({
	statics: {
		VML: true,
		CLIP_PADDING: 0.02
	},

	_createElement: (function () {
		try {
			document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
			return function (name) {
				return document.createElement('<lvml:' + name + ' class="lvml">');
			};
		} catch (e) {
			return function (name) {
				return document.createElement(
				        '<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
			};
		}
	}()),

	_initPath: function () {
		var container = this._container = this._createElement('shape');

		L.DomUtil.addClass(container, 'leaflet-vml-shape' +
			(this.options.className ? ' ' + this.options.className : ''));

		if (this.options.clickable) {
			L.DomUtil.addClass(container, 'leaflet-clickable');
		}

		container.coordsize = '1 1';

		this._path = this._createElement('path');
		container.appendChild(this._path);

		this._map._pathRoot.appendChild(container);
	},

	_initStyle: function () {
		this._updateStyle();
	},

	_updateStyle: function () {
		var stroke = this._stroke,
		    fill = this._fill,
		    options = this.options,
		    container = this._container;

		container.stroked = options.stroke;
		container.filled = options.fill;

		if (options.stroke) {
			if (!stroke) {
				stroke = this._stroke = this._createElement('stroke');
				stroke.endcap = 'round';
				container.appendChild(stroke);
			}
			stroke.weight = options.weight + 'px';
			stroke.color = options.color;
			stroke.opacity = options.opacity;

			if (options.dashArray) {
				stroke.dashStyle = L.Util.isArray(options.dashArray) ?
				    options.dashArray.join(' ') :
				    options.dashArray.replace(/( *, *)/g, ' ');
			} else {
				stroke.dashStyle = '';
			}
			if (options.lineCap) {
				stroke.endcap = options.lineCap.replace('butt', 'flat');
			}
			if (options.lineJoin) {
				stroke.joinstyle = options.lineJoin;
			}

		} else if (stroke) {
			container.removeChild(stroke);
			this._stroke = null;
		}

		if (options.fill) {
			if (!fill) {
				fill = this._fill = this._createElement('fill');
				container.appendChild(fill);
			}
			fill.color = options.fillColor || options.color;
			fill.opacity = options.fillOpacity;

		} else if (fill) {
			container.removeChild(fill);
			this._fill = null;
		}
	},

	_updatePath: function () {
		var style = this._container.style;

		style.display = 'none';
		this._path.v = this.getPathString() + ' '; // the space fixes IE empty path string bug
		style.display = '';
	}
});

L.Map.include(L.Browser.svg || !L.Browser.vml ? {} : {
	_initPathRoot: function () {
		if (this._pathRoot) { return; }

		var root = this._pathRoot = document.createElement('div');
		root.className = 'leaflet-vml-container';
		this._panes.overlayPane.appendChild(root);

		this.on('moveend', this._updatePathViewport);
		this._updatePathViewport();
	}
});


/*
 * Vector rendering for all browsers that support canvas.
 */

L.Browser.canvas = (function () {
	return !!document.createElement('canvas').getContext;
}());

L.Path = (L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? L.Path : L.Path.extend({
	statics: {
		//CLIP_PADDING: 0.02, // not sure if there's a need to set it to a small value
		CANVAS: true,
		SVG: false
	},

	redraw: function () {
		if (this._map) {
			this.projectLatlngs();
			this._requestUpdate();
		}
		return this;
	},

	setStyle: function (style) {
		L.setOptions(this, style);

		if (this._map) {
			this._updateStyle();
			this._requestUpdate();
		}
		return this;
	},

	onRemove: function (map) {
		map
		    .off('viewreset', this.projectLatlngs, this)
		    .off('moveend', this._updatePath, this);

		if (this.options.clickable) {
			this._map.off('click', this._onClick, this);
			this._map.off('mousemove', this._onMouseMove, this);
		}

		this._requestUpdate();
		
		this.fire('remove');
		this._map = null;
	},

	_requestUpdate: function () {
		if (this._map && !L.Path._updateRequest) {
			L.Path._updateRequest = L.Util.requestAnimFrame(this._fireMapMoveEnd, this._map);
		}
	},

	_fireMapMoveEnd: function () {
		L.Path._updateRequest = null;
		this.fire('moveend');
	},

	_initElements: function () {
		this._map._initPathRoot();
		this._ctx = this._map._canvasCtx;
	},

	_updateStyle: function () {
		var options = this.options;

		if (options.stroke) {
			this._ctx.lineWidth = options.weight;
			this._ctx.strokeStyle = options.color;
		}
		if (options.fill) {
			this._ctx.fillStyle = options.fillColor || options.color;
		}

		if (options.lineCap) {
			this._ctx.lineCap = options.lineCap;
		}
		if (options.lineJoin) {
			this._ctx.lineJoin = options.lineJoin;
		}
	},

	_drawPath: function () {
		var i, j, len, len2, point, drawMethod;

		this._ctx.beginPath();

		for (i = 0, len = this._parts.length; i < len; i++) {
			for (j = 0, len2 = this._parts[i].length; j < len2; j++) {
				point = this._parts[i][j];
				drawMethod = (j === 0 ? 'move' : 'line') + 'To';

				this._ctx[drawMethod](point.x, point.y);
			}
			// TODO refactor ugly hack
			if (this instanceof L.Polygon) {
				this._ctx.closePath();
			}
		}
	},

	_checkIfEmpty: function () {
		return !this._parts.length;
	},

	_updatePath: function () {
		if (this._checkIfEmpty()) { return; }

		var ctx = this._ctx,
		    options = this.options;

		this._drawPath();
		ctx.save();
		this._updateStyle();

		if (options.fill) {
			ctx.globalAlpha = options.fillOpacity;
			ctx.fill(options.fillRule || 'evenodd');
		}

		if (options.stroke) {
			ctx.globalAlpha = options.opacity;
			ctx.stroke();
		}

		ctx.restore();

		// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
	},

	_initEvents: function () {
		if (this.options.clickable) {
			this._map.on('mousemove', this._onMouseMove, this);
			this._map.on('click dblclick contextmenu', this._fireMouseEvent, this);
		}
	},

	_fireMouseEvent: function (e) {
		if (this._containsPoint(e.layerPoint)) {
			this.fire(e.type, e);
		}
	},

	_onMouseMove: function (e) {
		if (!this._map || this._map._animatingZoom) { return; }

		// TODO don't do on each move
		if (this._containsPoint(e.layerPoint)) {
			this._ctx.canvas.style.cursor = 'pointer';
			this._mouseInside = true;
			this.fire('mouseover', e);

		} else if (this._mouseInside) {
			this._ctx.canvas.style.cursor = '';
			this._mouseInside = false;
			this.fire('mouseout', e);
		}
	}
});

L.Map.include((L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? {} : {
	_initPathRoot: function () {
		var root = this._pathRoot,
		    ctx;

		if (!root) {
			root = this._pathRoot = document.createElement('canvas');
			root.style.position = 'absolute';
			ctx = this._canvasCtx = root.getContext('2d');

			ctx.lineCap = 'round';
			ctx.lineJoin = 'round';

			this._panes.overlayPane.appendChild(root);

			if (this.options.zoomAnimation) {
				this._pathRoot.className = 'leaflet-zoom-animated';
				this.on('zoomanim', this._animatePathZoom);
				this.on('zoomend', this._endPathZoom);
			}
			this.on('moveend', this._updateCanvasViewport);
			this._updateCanvasViewport();
		}
	},

	_updateCanvasViewport: function () {
		// don't redraw while zooming. See _updateSvgViewport for more details
		if (this._pathZooming) { return; }
		this._updatePathViewport();

		var vp = this._pathViewport,
		    min = vp.min,
		    size = vp.max.subtract(min),
		    root = this._pathRoot;

		//TODO check if this works properly on mobile webkit
		L.DomUtil.setPosition(root, min);
		root.width = size.x;
		root.height = size.y;
		root.getContext('2d').translate(-min.x, -min.y);
	}
});


/*
 * L.LineUtil contains different utility functions for line segments
 * and polylines (clipping, simplification, distances, etc.)
 */

/*jshint bitwise:false */ // allow bitwise operations for this file

L.LineUtil = {

	// Simplify polyline with vertex reduction and Douglas-Peucker simplification.
	// Improves rendering performance dramatically by lessening the number of points to draw.

	simplify: function (/*Point[]*/ points, /*Number*/ tolerance) {
		if (!tolerance || !points.length) {
			return points.slice();
		}

		var sqTolerance = tolerance * tolerance;

		// stage 1: vertex reduction
		points = this._reducePoints(points, sqTolerance);

		// stage 2: Douglas-Peucker simplification
		points = this._simplifyDP(points, sqTolerance);

		return points;
	},

	// distance from a point to a segment between two points
	pointToSegmentDistance:  function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {
		return Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));
	},

	closestPointOnSegment: function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {
		return this._sqClosestPointOnSegment(p, p1, p2);
	},

	// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm
	_simplifyDP: function (points, sqTolerance) {

		var len = points.length,
		    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
		    markers = new ArrayConstructor(len);

		markers[0] = markers[len - 1] = 1;

		this._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

		var i,
		    newPoints = [];

		for (i = 0; i < len; i++) {
			if (markers[i]) {
				newPoints.push(points[i]);
			}
		}

		return newPoints;
	},

	_simplifyDPStep: function (points, markers, sqTolerance, first, last) {

		var maxSqDist = 0,
		    index, i, sqDist;

		for (i = first + 1; i <= last - 1; i++) {
			sqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);

			if (sqDist > maxSqDist) {
				index = i;
				maxSqDist = sqDist;
			}
		}

		if (maxSqDist > sqTolerance) {
			markers[index] = 1;

			this._simplifyDPStep(points, markers, sqTolerance, first, index);
			this._simplifyDPStep(points, markers, sqTolerance, index, last);
		}
	},

	// reduce points that are too close to each other to a single point
	_reducePoints: function (points, sqTolerance) {
		var reducedPoints = [points[0]];

		for (var i = 1, prev = 0, len = points.length; i < len; i++) {
			if (this._sqDist(points[i], points[prev]) > sqTolerance) {
				reducedPoints.push(points[i]);
				prev = i;
			}
		}
		if (prev < len - 1) {
			reducedPoints.push(points[len - 1]);
		}
		return reducedPoints;
	},

	// Cohen-Sutherland line clipping algorithm.
	// Used to avoid rendering parts of a polyline that are not currently visible.

	clipSegment: function (a, b, bounds, useLastCode) {
		var codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds),
		    codeB = this._getBitCode(b, bounds),

		    codeOut, p, newCode;

		// save 2nd code to avoid calculating it on the next segment
		this._lastCode = codeB;

		while (true) {
			// if a,b is inside the clip window (trivial accept)
			if (!(codeA | codeB)) {
				return [a, b];
			// if a,b is outside the clip window (trivial reject)
			} else if (codeA & codeB) {
				return false;
			// other cases
			} else {
				codeOut = codeA || codeB;
				p = this._getEdgeIntersection(a, b, codeOut, bounds);
				newCode = this._getBitCode(p, bounds);

				if (codeOut === codeA) {
					a = p;
					codeA = newCode;
				} else {
					b = p;
					codeB = newCode;
				}
			}
		}
	},

	_getEdgeIntersection: function (a, b, code, bounds) {
		var dx = b.x - a.x,
		    dy = b.y - a.y,
		    min = bounds.min,
		    max = bounds.max;

		if (code & 8) { // top
			return new L.Point(a.x + dx * (max.y - a.y) / dy, max.y);
		} else if (code & 4) { // bottom
			return new L.Point(a.x + dx * (min.y - a.y) / dy, min.y);
		} else if (code & 2) { // right
			return new L.Point(max.x, a.y + dy * (max.x - a.x) / dx);
		} else if (code & 1) { // left
			return new L.Point(min.x, a.y + dy * (min.x - a.x) / dx);
		}
	},

	_getBitCode: function (/*Point*/ p, bounds) {
		var code = 0;

		if (p.x < bounds.min.x) { // left
			code |= 1;
		} else if (p.x > bounds.max.x) { // right
			code |= 2;
		}
		if (p.y < bounds.min.y) { // bottom
			code |= 4;
		} else if (p.y > bounds.max.y) { // top
			code |= 8;
		}

		return code;
	},

	// square distance (to avoid unnecessary Math.sqrt calls)
	_sqDist: function (p1, p2) {
		var dx = p2.x - p1.x,
		    dy = p2.y - p1.y;
		return dx * dx + dy * dy;
	},

	// return closest point on segment or distance to that point
	_sqClosestPointOnSegment: function (p, p1, p2, sqDist) {
		var x = p1.x,
		    y = p1.y,
		    dx = p2.x - x,
		    dy = p2.y - y,
		    dot = dx * dx + dy * dy,
		    t;

		if (dot > 0) {
			t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

			if (t > 1) {
				x = p2.x;
				y = p2.y;
			} else if (t > 0) {
				x += dx * t;
				y += dy * t;
			}
		}

		dx = p.x - x;
		dy = p.y - y;

		return sqDist ? dx * dx + dy * dy : new L.Point(x, y);
	}
};


/*
 * L.Polyline is used to display polylines on a map.
 */

L.Polyline = L.Path.extend({
	initialize: function (latlngs, options) {
		L.Path.prototype.initialize.call(this, options);

		this._latlngs = this._convertLatLngs(latlngs);
	},

	options: {
		// how much to simplify the polyline on each zoom level
		// more = better performance and smoother look, less = more accurate
		smoothFactor: 1.0,
		noClip: false
	},

	projectLatlngs: function () {
		this._originalPoints = [];

		for (var i = 0, len = this._latlngs.length; i < len; i++) {
			this._originalPoints[i] = this._map.latLngToLayerPoint(this._latlngs[i]);
		}
	},

	getPathString: function () {
		for (var i = 0, len = this._parts.length, str = ''; i < len; i++) {
			str += this._getPathPartStr(this._parts[i]);
		}
		return str;
	},

	getLatLngs: function () {
		return this._latlngs;
	},

	setLatLngs: function (latlngs) {
		this._latlngs = this._convertLatLngs(latlngs);
		return this.redraw();
	},

	addLatLng: function (latlng) {
		this._latlngs.push(L.latLng(latlng));
		return this.redraw();
	},

	spliceLatLngs: function () { // (Number index, Number howMany)
		var removed = [].splice.apply(this._latlngs, arguments);
		this._convertLatLngs(this._latlngs, true);
		this.redraw();
		return removed;
	},

	closestLayerPoint: function (p) {
		var minDistance = Infinity, parts = this._parts, p1, p2, minPoint = null;

		for (var j = 0, jLen = parts.length; j < jLen; j++) {
			var points = parts[j];
			for (var i = 1, len = points.length; i < len; i++) {
				p1 = points[i - 1];
				p2 = points[i];
				var sqDist = L.LineUtil._sqClosestPointOnSegment(p, p1, p2, true);
				if (sqDist < minDistance) {
					minDistance = sqDist;
					minPoint = L.LineUtil._sqClosestPointOnSegment(p, p1, p2);
				}
			}
		}
		if (minPoint) {
			minPoint.distance = Math.sqrt(minDistance);
		}
		return minPoint;
	},

	getBounds: function () {
		return new L.LatLngBounds(this.getLatLngs());
	},

	_convertLatLngs: function (latlngs, overwrite) {
		var i, len, target = overwrite ? latlngs : [];

		for (i = 0, len = latlngs.length; i < len; i++) {
			if (L.Util.isArray(latlngs[i]) && typeof latlngs[i][0] !== 'number') {
				return;
			}
			target[i] = L.latLng(latlngs[i]);
		}
		return target;
	},

	_initEvents: function () {
		L.Path.prototype._initEvents.call(this);
	},

	_getPathPartStr: function (points) {
		var round = L.Path.VML;

		for (var j = 0, len2 = points.length, str = '', p; j < len2; j++) {
			p = points[j];
			if (round) {
				p._round();
			}
			str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
		}
		return str;
	},

	_clipPoints: function () {
		var points = this._originalPoints,
		    len = points.length,
		    i, k, segment;

		if (this.options.noClip) {
			this._parts = [points];
			return;
		}

		this._parts = [];

		var parts = this._parts,
		    vp = this._map._pathViewport,
		    lu = L.LineUtil;

		for (i = 0, k = 0; i < len - 1; i++) {
			segment = lu.clipSegment(points[i], points[i + 1], vp, i);
			if (!segment) {
				continue;
			}

			parts[k] = parts[k] || [];
			parts[k].push(segment[0]);

			// if segment goes out of screen, or it's the last one, it's the end of the line part
			if ((segment[1] !== points[i + 1]) || (i === len - 2)) {
				parts[k].push(segment[1]);
				k++;
			}
		}
	},

	// simplify each clipped part of the polyline
	_simplifyPoints: function () {
		var parts = this._parts,
		    lu = L.LineUtil;

		for (var i = 0, len = parts.length; i < len; i++) {
			parts[i] = lu.simplify(parts[i], this.options.smoothFactor);
		}
	},

	_updatePath: function () {
		if (!this._map) { return; }

		this._clipPoints();
		this._simplifyPoints();

		L.Path.prototype._updatePath.call(this);
	}
});

L.polyline = function (latlngs, options) {
	return new L.Polyline(latlngs, options);
};


/*
 * L.PolyUtil contains utility functions for polygons (clipping, etc.).
 */

/*jshint bitwise:false */ // allow bitwise operations here

L.PolyUtil = {};

/*
 * Sutherland-Hodgeman polygon clipping algorithm.
 * Used to avoid rendering parts of a polygon that are not currently visible.
 */
L.PolyUtil.clipPolygon = function (points, bounds) {
	var clippedPoints,
	    edges = [1, 4, 2, 8],
	    i, j, k,
	    a, b,
	    len, edge, p,
	    lu = L.LineUtil;

	for (i = 0, len = points.length; i < len; i++) {
		points[i]._code = lu._getBitCode(points[i], bounds);
	}

	// for each edge (left, bottom, right, top)
	for (k = 0; k < 4; k++) {
		edge = edges[k];
		clippedPoints = [];

		for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
			a = points[i];
			b = points[j];

			// if a is inside the clip window
			if (!(a._code & edge)) {
				// if b is outside the clip window (a->b goes out of screen)
				if (b._code & edge) {
					p = lu._getEdgeIntersection(b, a, edge, bounds);
					p._code = lu._getBitCode(p, bounds);
					clippedPoints.push(p);
				}
				clippedPoints.push(a);

			// else if b is inside the clip window (a->b enters the screen)
			} else if (!(b._code & edge)) {
				p = lu._getEdgeIntersection(b, a, edge, bounds);
				p._code = lu._getBitCode(p, bounds);
				clippedPoints.push(p);
			}
		}
		points = clippedPoints;
	}

	return points;
};


/*
 * L.Polygon is used to display polygons on a map.
 */

L.Polygon = L.Polyline.extend({
	options: {
		fill: true
	},

	initialize: function (latlngs, options) {
		L.Polyline.prototype.initialize.call(this, latlngs, options);
		this._initWithHoles(latlngs);
	},

	_initWithHoles: function (latlngs) {
		var i, len, hole;
		if (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {
			this._latlngs = this._convertLatLngs(latlngs[0]);
			this._holes = latlngs.slice(1);

			for (i = 0, len = this._holes.length; i < len; i++) {
				hole = this._holes[i] = this._convertLatLngs(this._holes[i]);
				if (hole[0].equals(hole[hole.length - 1])) {
					hole.pop();
				}
			}
		}

		// filter out last point if its equal to the first one
		latlngs = this._latlngs;

		if (latlngs.length >= 2 && latlngs[0].equals(latlngs[latlngs.length - 1])) {
			latlngs.pop();
		}
	},

	projectLatlngs: function () {
		L.Polyline.prototype.projectLatlngs.call(this);

		// project polygon holes points
		// TODO move this logic to Polyline to get rid of duplication
		this._holePoints = [];

		if (!this._holes) { return; }

		var i, j, len, len2;

		for (i = 0, len = this._holes.length; i < len; i++) {
			this._holePoints[i] = [];

			for (j = 0, len2 = this._holes[i].length; j < len2; j++) {
				this._holePoints[i][j] = this._map.latLngToLayerPoint(this._holes[i][j]);
			}
		}
	},

	setLatLngs: function (latlngs) {
		if (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {
			this._initWithHoles(latlngs);
			return this.redraw();
		} else {
			return L.Polyline.prototype.setLatLngs.call(this, latlngs);
		}
	},

	_clipPoints: function () {
		var points = this._originalPoints,
		    newParts = [];

		this._parts = [points].concat(this._holePoints);

		if (this.options.noClip) { return; }

		for (var i = 0, len = this._parts.length; i < len; i++) {
			var clipped = L.PolyUtil.clipPolygon(this._parts[i], this._map._pathViewport);
			if (clipped.length) {
				newParts.push(clipped);
			}
		}

		this._parts = newParts;
	},

	_getPathPartStr: function (points) {
		var str = L.Polyline.prototype._getPathPartStr.call(this, points);
		return str + (L.Browser.svg ? 'z' : 'x');
	}
});

L.polygon = function (latlngs, options) {
	return new L.Polygon(latlngs, options);
};


/*
 * Contains L.MultiPolyline and L.MultiPolygon layers.
 */

(function () {
	function createMulti(Klass) {

		return L.FeatureGroup.extend({

			initialize: function (latlngs, options) {
				this._layers = {};
				this._options = options;
				this.setLatLngs(latlngs);
			},

			setLatLngs: function (latlngs) {
				var i = 0,
				    len = latlngs.length;

				this.eachLayer(function (layer) {
					if (i < len) {
						layer.setLatLngs(latlngs[i++]);
					} else {
						this.removeLayer(layer);
					}
				}, this);

				while (i < len) {
					this.addLayer(new Klass(latlngs[i++], this._options));
				}

				return this;
			},

			getLatLngs: function () {
				var latlngs = [];

				this.eachLayer(function (layer) {
					latlngs.push(layer.getLatLngs());
				});

				return latlngs;
			}
		});
	}

	L.MultiPolyline = createMulti(L.Polyline);
	L.MultiPolygon = createMulti(L.Polygon);

	L.multiPolyline = function (latlngs, options) {
		return new L.MultiPolyline(latlngs, options);
	};

	L.multiPolygon = function (latlngs, options) {
		return new L.MultiPolygon(latlngs, options);
	};
}());


/*
 * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
 */

L.Rectangle = L.Polygon.extend({
	initialize: function (latLngBounds, options) {
		L.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
	},

	setBounds: function (latLngBounds) {
		this.setLatLngs(this._boundsToLatLngs(latLngBounds));
	},

	_boundsToLatLngs: function (latLngBounds) {
		latLngBounds = L.latLngBounds(latLngBounds);
		return [
			latLngBounds.getSouthWest(),
			latLngBounds.getNorthWest(),
			latLngBounds.getNorthEast(),
			latLngBounds.getSouthEast()
		];
	}
});

L.rectangle = function (latLngBounds, options) {
	return new L.Rectangle(latLngBounds, options);
};


/*
 * L.Circle is a circle overlay (with a certain radius in meters).
 */

L.Circle = L.Path.extend({
	initialize: function (latlng, radius, options) {
		L.Path.prototype.initialize.call(this, options);

		this._latlng = L.latLng(latlng);
		this._mRadius = radius;
	},

	options: {
		fill: true
	},

	setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);
		return this.redraw();
	},

	setRadius: function (radius) {
		this._mRadius = radius;
		return this.redraw();
	},

	projectLatlngs: function () {
		var lngRadius = this._getLngRadius(),
		    latlng = this._latlng,
		    pointLeft = this._map.latLngToLayerPoint([latlng.lat, latlng.lng - lngRadius]);

		this._point = this._map.latLngToLayerPoint(latlng);
		this._radius = Math.max(this._point.x - pointLeft.x, 1);
	},

	getBounds: function () {
		var lngRadius = this._getLngRadius(),
		    latRadius = (this._mRadius / 40075017) * 360,
		    latlng = this._latlng;

		return new L.LatLngBounds(
		        [latlng.lat - latRadius, latlng.lng - lngRadius],
		        [latlng.lat + latRadius, latlng.lng + lngRadius]);
	},

	getLatLng: function () {
		return this._latlng;
	},

	getPathString: function () {
		var p = this._point,
		    r = this._radius;

		if (this._checkIfEmpty()) {
			return '';
		}

		if (L.Browser.svg) {
			return 'M' + p.x + ',' + (p.y - r) +
			       'A' + r + ',' + r + ',0,1,1,' +
			       (p.x - 0.1) + ',' + (p.y - r) + ' z';
		} else {
			p._round();
			r = Math.round(r);
			return 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r + ' 0,' + (65535 * 360);
		}
	},

	getRadius: function () {
		return this._mRadius;
	},

	// TODO Earth hardcoded, move into projection code!

	_getLatRadius: function () {
		return (this._mRadius / 40075017) * 360;
	},

	_getLngRadius: function () {
		return this._getLatRadius() / Math.cos(L.LatLng.DEG_TO_RAD * this._latlng.lat);
	},

	_checkIfEmpty: function () {
		if (!this._map) {
			return false;
		}
		var vp = this._map._pathViewport,
		    r = this._radius,
		    p = this._point;

		return p.x - r > vp.max.x || p.y - r > vp.max.y ||
		       p.x + r < vp.min.x || p.y + r < vp.min.y;
	}
});

L.circle = function (latlng, radius, options) {
	return new L.Circle(latlng, radius, options);
};


/*
 * L.CircleMarker is a circle overlay with a permanent pixel radius.
 */

L.CircleMarker = L.Circle.extend({
	options: {
		radius: 10,
		weight: 2
	},

	initialize: function (latlng, options) {
		L.Circle.prototype.initialize.call(this, latlng, null, options);
		this._radius = this.options.radius;
	},

	projectLatlngs: function () {
		this._point = this._map.latLngToLayerPoint(this._latlng);
	},

	_updateStyle : function () {
		L.Circle.prototype._updateStyle.call(this);
		this.setRadius(this.options.radius);
	},

	setLatLng: function (latlng) {
		L.Circle.prototype.setLatLng.call(this, latlng);
		if (this._popup && this._popup._isOpen) {
			this._popup.setLatLng(latlng);
		}
		return this;
	},

	setRadius: function (radius) {
		this.options.radius = this._radius = radius;
		return this.redraw();
	},

	getRadius: function () {
		return this._radius;
	}
});

L.circleMarker = function (latlng, options) {
	return new L.CircleMarker(latlng, options);
};


/*
 * Extends L.Polyline to be able to manually detect clicks on Canvas-rendered polylines.
 */

L.Polyline.include(!L.Path.CANVAS ? {} : {
	_containsPoint: function (p, closed) {
		var i, j, k, len, len2, dist, part,
		    w = this.options.weight / 2;

		if (L.Browser.touch) {
			w += 10; // polyline click tolerance on touch devices
		}

		for (i = 0, len = this._parts.length; i < len; i++) {
			part = this._parts[i];
			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
				if (!closed && (j === 0)) {
					continue;
				}

				dist = L.LineUtil.pointToSegmentDistance(p, part[k], part[j]);

				if (dist <= w) {
					return true;
				}
			}
		}
		return false;
	}
});


/*
 * Extends L.Polygon to be able to manually detect clicks on Canvas-rendered polygons.
 */

L.Polygon.include(!L.Path.CANVAS ? {} : {
	_containsPoint: function (p) {
		var inside = false,
		    part, p1, p2,
		    i, j, k,
		    len, len2;

		// TODO optimization: check if within bounds first

		if (L.Polyline.prototype._containsPoint.call(this, p, true)) {
			// click on polygon border
			return true;
		}

		// ray casting algorithm for detecting if point is in polygon

		for (i = 0, len = this._parts.length; i < len; i++) {
			part = this._parts[i];

			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
				p1 = part[j];
				p2 = part[k];

				if (((p1.y > p.y) !== (p2.y > p.y)) &&
						(p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
					inside = !inside;
				}
			}
		}

		return inside;
	}
});


/*
 * Extends L.Circle with Canvas-specific code.
 */

L.Circle.include(!L.Path.CANVAS ? {} : {
	_drawPath: function () {
		var p = this._point;
		this._ctx.beginPath();
		this._ctx.arc(p.x, p.y, this._radius, 0, Math.PI * 2, false);
	},

	_containsPoint: function (p) {
		var center = this._point,
		    w2 = this.options.stroke ? this.options.weight / 2 : 0;

		return (p.distanceTo(center) <= this._radius + w2);
	}
});


/*
 * CircleMarker canvas specific drawing parts.
 */

L.CircleMarker.include(!L.Path.CANVAS ? {} : {
	_updateStyle: function () {
		L.Path.prototype._updateStyle.call(this);
	}
});


/*
 * L.GeoJSON turns any GeoJSON data into a Leaflet layer.
 */

L.GeoJSON = L.FeatureGroup.extend({

	initialize: function (geojson, options) {
		L.setOptions(this, options);

		this._layers = {};

		if (geojson) {
			this.addData(geojson);
		}
	},

	addData: function (geojson) {
		var features = L.Util.isArray(geojson) ? geojson : geojson.features,
		    i, len, feature;

		if (features) {
			for (i = 0, len = features.length; i < len; i++) {
				// Only add this if geometry or geometries are set and not null
				feature = features[i];
				if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
					this.addData(features[i]);
				}
			}
			return this;
		}

		var options = this.options;

		if (options.filter && !options.filter(geojson)) { return; }

		var layer = L.GeoJSON.geometryToLayer(geojson, options.pointToLayer, options.coordsToLatLng, options);
		layer.feature = L.GeoJSON.asFeature(geojson);

		layer.defaultOptions = layer.options;
		this.resetStyle(layer);

		if (options.onEachFeature) {
			options.onEachFeature(geojson, layer);
		}

		return this.addLayer(layer);
	},

	resetStyle: function (layer) {
		var style = this.options.style;
		if (style) {
			// reset any custom styles
			L.Util.extend(layer.options, layer.defaultOptions);

			this._setLayerStyle(layer, style);
		}
	},

	setStyle: function (style) {
		this.eachLayer(function (layer) {
			this._setLayerStyle(layer, style);
		}, this);
	},

	_setLayerStyle: function (layer, style) {
		if (typeof style === 'function') {
			style = style(layer.feature);
		}
		if (layer.setStyle) {
			layer.setStyle(style);
		}
	}
});

L.extend(L.GeoJSON, {
	geometryToLayer: function (geojson, pointToLayer, coordsToLatLng, vectorOptions) {
		var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
		    coords = geometry.coordinates,
		    layers = [],
		    latlng, latlngs, i, len;

		coordsToLatLng = coordsToLatLng || this.coordsToLatLng;

		switch (geometry.type) {
		case 'Point':
			latlng = coordsToLatLng(coords);
			return pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);

		case 'MultiPoint':
			for (i = 0, len = coords.length; i < len; i++) {
				latlng = coordsToLatLng(coords[i]);
				layers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));
			}
			return new L.FeatureGroup(layers);

		case 'LineString':
			latlngs = this.coordsToLatLngs(coords, 0, coordsToLatLng);
			return new L.Polyline(latlngs, vectorOptions);

		case 'Polygon':
			if (coords.length === 2 && !coords[1].length) {
				throw new Error('Invalid GeoJSON object.');
			}
			latlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);
			return new L.Polygon(latlngs, vectorOptions);

		case 'MultiLineString':
			latlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);
			return new L.MultiPolyline(latlngs, vectorOptions);

		case 'MultiPolygon':
			latlngs = this.coordsToLatLngs(coords, 2, coordsToLatLng);
			return new L.MultiPolygon(latlngs, vectorOptions);

		case 'GeometryCollection':
			for (i = 0, len = geometry.geometries.length; i < len; i++) {

				layers.push(this.geometryToLayer({
					geometry: geometry.geometries[i],
					type: 'Feature',
					properties: geojson.properties
				}, pointToLayer, coordsToLatLng, vectorOptions));
			}
			return new L.FeatureGroup(layers);

		default:
			throw new Error('Invalid GeoJSON object.');
		}
	},

	coordsToLatLng: function (coords) { // (Array[, Boolean]) -> LatLng
		return new L.LatLng(coords[1], coords[0], coords[2]);
	},

	coordsToLatLngs: function (coords, levelsDeep, coordsToLatLng) { // (Array[, Number, Function]) -> Array
		var latlng, i, len,
		    latlngs = [];

		for (i = 0, len = coords.length; i < len; i++) {
			latlng = levelsDeep ?
			        this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) :
			        (coordsToLatLng || this.coordsToLatLng)(coords[i]);

			latlngs.push(latlng);
		}

		return latlngs;
	},

	latLngToCoords: function (latlng) {
		var coords = [latlng.lng, latlng.lat];

		if (latlng.alt !== undefined) {
			coords.push(latlng.alt);
		}
		return coords;
	},

	latLngsToCoords: function (latLngs) {
		var coords = [];

		for (var i = 0, len = latLngs.length; i < len; i++) {
			coords.push(L.GeoJSON.latLngToCoords(latLngs[i]));
		}

		return coords;
	},

	getFeature: function (layer, newGeometry) {
		return layer.feature ? L.extend({}, layer.feature, {geometry: newGeometry}) : L.GeoJSON.asFeature(newGeometry);
	},

	asFeature: function (geoJSON) {
		if (geoJSON.type === 'Feature') {
			return geoJSON;
		}

		return {
			type: 'Feature',
			properties: {},
			geometry: geoJSON
		};
	}
});

var PointToGeoJSON = {
	toGeoJSON: function () {
		return L.GeoJSON.getFeature(this, {
			type: 'Point',
			coordinates: L.GeoJSON.latLngToCoords(this.getLatLng())
		});
	}
};

L.Marker.include(PointToGeoJSON);
L.Circle.include(PointToGeoJSON);
L.CircleMarker.include(PointToGeoJSON);

L.Polyline.include({
	toGeoJSON: function () {
		return L.GeoJSON.getFeature(this, {
			type: 'LineString',
			coordinates: L.GeoJSON.latLngsToCoords(this.getLatLngs())
		});
	}
});

L.Polygon.include({
	toGeoJSON: function () {
		var coords = [L.GeoJSON.latLngsToCoords(this.getLatLngs())],
		    i, len, hole;

		coords[0].push(coords[0][0]);

		if (this._holes) {
			for (i = 0, len = this._holes.length; i < len; i++) {
				hole = L.GeoJSON.latLngsToCoords(this._holes[i]);
				hole.push(hole[0]);
				coords.push(hole);
			}
		}

		return L.GeoJSON.getFeature(this, {
			type: 'Polygon',
			coordinates: coords
		});
	}
});

(function () {
	function multiToGeoJSON(type) {
		return function () {
			var coords = [];

			this.eachLayer(function (layer) {
				coords.push(layer.toGeoJSON().geometry.coordinates);
			});

			return L.GeoJSON.getFeature(this, {
				type: type,
				coordinates: coords
			});
		};
	}

	L.MultiPolyline.include({toGeoJSON: multiToGeoJSON('MultiLineString')});
	L.MultiPolygon.include({toGeoJSON: multiToGeoJSON('MultiPolygon')});

	L.LayerGroup.include({
		toGeoJSON: function () {

			var geometry = this.feature && this.feature.geometry,
				jsons = [],
				json;

			if (geometry && geometry.type === 'MultiPoint') {
				return multiToGeoJSON('MultiPoint').call(this);
			}

			var isGeometryCollection = geometry && geometry.type === 'GeometryCollection';

			this.eachLayer(function (layer) {
				if (layer.toGeoJSON) {
					json = layer.toGeoJSON();
					jsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json));
				}
			});

			if (isGeometryCollection) {
				return L.GeoJSON.getFeature(this, {
					geometries: jsons,
					type: 'GeometryCollection'
				});
			}

			return {
				type: 'FeatureCollection',
				features: jsons
			};
		}
	});
}());

L.geoJson = function (geojson, options) {
	return new L.GeoJSON(geojson, options);
};


/*
 * L.DomEvent contains functions for working with DOM events.
 */

L.DomEvent = {
	/* inspired by John Resig, Dean Edwards and YUI addEvent implementations */
	addListener: function (obj, type, fn, context) { // (HTMLElement, String, Function[, Object])

		var id = L.stamp(fn),
		    key = '_leaflet_' + type + id,
		    handler, originalHandler, newType;

		if (obj[key]) { return this; }

		handler = function (e) {
			return fn.call(context || obj, e || L.DomEvent._getEvent());
		};

		if (L.Browser.pointer && type.indexOf('touch') === 0) {
			return this.addPointerListener(obj, type, handler, id);
		}
		if (L.Browser.touch && (type === 'dblclick') && this.addDoubleTapListener) {
			this.addDoubleTapListener(obj, handler, id);
		}

		if ('addEventListener' in obj) {

			if (type === 'mousewheel') {
				obj.addEventListener('DOMMouseScroll', handler, false);
				obj.addEventListener(type, handler, false);

			} else if ((type === 'mouseenter') || (type === 'mouseleave')) {

				originalHandler = handler;
				newType = (type === 'mouseenter' ? 'mouseover' : 'mouseout');

				handler = function (e) {
					if (!L.DomEvent._checkMouse(obj, e)) { return; }
					return originalHandler(e);
				};

				obj.addEventListener(newType, handler, false);

			} else if (type === 'click' && L.Browser.android) {
				originalHandler = handler;
				handler = function (e) {
					return L.DomEvent._filterClick(e, originalHandler);
				};

				obj.addEventListener(type, handler, false);
			} else {
				obj.addEventListener(type, handler, false);
			}

		} else if ('attachEvent' in obj) {
			obj.attachEvent('on' + type, handler);
		}

		obj[key] = handler;

		return this;
	},

	removeListener: function (obj, type, fn) {  // (HTMLElement, String, Function)

		var id = L.stamp(fn),
		    key = '_leaflet_' + type + id,
		    handler = obj[key];

		if (!handler) { return this; }

		if (L.Browser.pointer && type.indexOf('touch') === 0) {
			this.removePointerListener(obj, type, id);
		} else if (L.Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {
			this.removeDoubleTapListener(obj, id);

		} else if ('removeEventListener' in obj) {

			if (type === 'mousewheel') {
				obj.removeEventListener('DOMMouseScroll', handler, false);
				obj.removeEventListener(type, handler, false);

			} else if ((type === 'mouseenter') || (type === 'mouseleave')) {
				obj.removeEventListener((type === 'mouseenter' ? 'mouseover' : 'mouseout'), handler, false);
			} else {
				obj.removeEventListener(type, handler, false);
			}
		} else if ('detachEvent' in obj) {
			obj.detachEvent('on' + type, handler);
		}

		obj[key] = null;

		return this;
	},

	stopPropagation: function (e) {

		if (e.stopPropagation) {
			e.stopPropagation();
		} else {
			e.cancelBubble = true;
		}
		L.DomEvent._skipped(e);

		return this;
	},

	disableScrollPropagation: function (el) {
		var stop = L.DomEvent.stopPropagation;

		return L.DomEvent
			.on(el, 'mousewheel', stop)
			.on(el, 'MozMousePixelScroll', stop);
	},

	disableClickPropagation: function (el) {
		var stop = L.DomEvent.stopPropagation;

		for (var i = L.Draggable.START.length - 1; i >= 0; i--) {
			L.DomEvent.on(el, L.Draggable.START[i], stop);
		}

		return L.DomEvent
			.on(el, 'click', L.DomEvent._fakeStop)
			.on(el, 'dblclick', stop);
	},

	preventDefault: function (e) {

		if (e.preventDefault) {
			e.preventDefault();
		} else {
			e.returnValue = false;
		}
		return this;
	},

	stop: function (e) {
		return L.DomEvent
			.preventDefault(e)
			.stopPropagation(e);
	},

	getMousePosition: function (e, container) {
		if (!container) {
			return new L.Point(e.clientX, e.clientY);
		}

		var rect = container.getBoundingClientRect();

		return new L.Point(
			e.clientX - rect.left - container.clientLeft,
			e.clientY - rect.top - container.clientTop);
	},

	getWheelDelta: function (e) {

		var delta = 0;

		if (e.wheelDelta) {
			delta = e.wheelDelta / 120;
		}
		if (e.detail) {
			delta = -e.detail / 3;
		}
		return delta;
	},

	_skipEvents: {},

	_fakeStop: function (e) {
		// fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)
		L.DomEvent._skipEvents[e.type] = true;
	},

	_skipped: function (e) {
		var skipped = this._skipEvents[e.type];
		// reset when checking, as it's only used in map container and propagates outside of the map
		this._skipEvents[e.type] = false;
		return skipped;
	},

	// check if element really left/entered the event target (for mouseenter/mouseleave)
	_checkMouse: function (el, e) {

		var related = e.relatedTarget;

		if (!related) { return true; }

		try {
			while (related && (related !== el)) {
				related = related.parentNode;
			}
		} catch (err) {
			return false;
		}
		return (related !== el);
	},

	_getEvent: function () { // evil magic for IE
		/*jshint noarg:false */
		var e = window.event;
		if (!e) {
			var caller = arguments.callee.caller;
			while (caller) {
				e = caller['arguments'][0];
				if (e && window.Event === e.constructor) {
					break;
				}
				caller = caller.caller;
			}
		}
		return e;
	},

	// this is a horrible workaround for a bug in Android where a single touch triggers two click events
	_filterClick: function (e, handler) {
		var timeStamp = (e.timeStamp || e.originalEvent.timeStamp),
			elapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);

		// are they closer together than 500ms yet more than 100ms?
		// Android typically triggers them ~300ms apart while multiple listeners
		// on the same event should be triggered far faster;
		// or check if click is simulated on the element, and if it is, reject any non-simulated events

		if ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {
			L.DomEvent.stop(e);
			return;
		}
		L.DomEvent._lastClick = timeStamp;

		return handler(e);
	}
};

L.DomEvent.on = L.DomEvent.addListener;
L.DomEvent.off = L.DomEvent.removeListener;


/*
 * L.Draggable allows you to add dragging capabilities to any element. Supports mobile devices too.
 */

L.Draggable = L.Class.extend({
	includes: L.Mixin.Events,

	statics: {
		START: L.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],
		END: {
			mousedown: 'mouseup',
			touchstart: 'touchend',
			pointerdown: 'touchend',
			MSPointerDown: 'touchend'
		},
		MOVE: {
			mousedown: 'mousemove',
			touchstart: 'touchmove',
			pointerdown: 'touchmove',
			MSPointerDown: 'touchmove'
		}
	},

	initialize: function (element, dragStartTarget) {
		this._element = element;
		this._dragStartTarget = dragStartTarget || element;
	},

	enable: function () {
		if (this._enabled) { return; }

		for (var i = L.Draggable.START.length - 1; i >= 0; i--) {
			L.DomEvent.on(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);
		}

		this._enabled = true;
	},

	disable: function () {
		if (!this._enabled) { return; }

		for (var i = L.Draggable.START.length - 1; i >= 0; i--) {
			L.DomEvent.off(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);
		}

		this._enabled = false;
		this._moved = false;
	},

	_onDown: function (e) {
		this._moved = false;

		if (e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }

		L.DomEvent.stopPropagation(e);

		if (L.Draggable._disabled) { return; }

		L.DomUtil.disableImageDrag();
		L.DomUtil.disableTextSelection();

		if (this._moving) { return; }

		var first = e.touches ? e.touches[0] : e;

		this._startPoint = new L.Point(first.clientX, first.clientY);
		this._startPos = this._newPos = L.DomUtil.getPosition(this._element);

		L.DomEvent
		    .on(document, L.Draggable.MOVE[e.type], this._onMove, this)
		    .on(document, L.Draggable.END[e.type], this._onUp, this);
	},

	_onMove: function (e) {
		if (e.touches && e.touches.length > 1) {
			this._moved = true;
			return;
		}

		var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
		    newPoint = new L.Point(first.clientX, first.clientY),
		    offset = newPoint.subtract(this._startPoint);

		if (!offset.x && !offset.y) { return; }
		if (L.Browser.touch && Math.abs(offset.x) + Math.abs(offset.y) < 3) { return; }

		L.DomEvent.preventDefault(e);

		if (!this._moved) {
			this.fire('dragstart');

			this._moved = true;
			this._startPos = L.DomUtil.getPosition(this._element).subtract(offset);

			L.DomUtil.addClass(document.body, 'leaflet-dragging');
			this._lastTarget = e.target || e.srcElement;
			L.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');
		}

		this._newPos = this._startPos.add(offset);
		this._moving = true;

		L.Util.cancelAnimFrame(this._animRequest);
		this._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true, this._dragStartTarget);
	},

	_updatePosition: function () {
		this.fire('predrag');
		L.DomUtil.setPosition(this._element, this._newPos);
		this.fire('drag');
	},

	_onUp: function () {
		L.DomUtil.removeClass(document.body, 'leaflet-dragging');

		if (this._lastTarget) {
			L.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');
			this._lastTarget = null;
		}

		for (var i in L.Draggable.MOVE) {
			L.DomEvent
			    .off(document, L.Draggable.MOVE[i], this._onMove)
			    .off(document, L.Draggable.END[i], this._onUp);
		}

		L.DomUtil.enableImageDrag();
		L.DomUtil.enableTextSelection();

		if (this._moved && this._moving) {
			// ensure drag is not fired after dragend
			L.Util.cancelAnimFrame(this._animRequest);

			this.fire('dragend', {
				distance: this._newPos.distanceTo(this._startPos)
			});
		}

		this._moving = false;
	}
});


/*
	L.Handler is a base class for handler classes that are used internally to inject
	interaction features like dragging to classes like Map and Marker.
*/

L.Handler = L.Class.extend({
	initialize: function (map) {
		this._map = map;
	},

	enable: function () {
		if (this._enabled) { return; }

		this._enabled = true;
		this.addHooks();
	},

	disable: function () {
		if (!this._enabled) { return; }

		this._enabled = false;
		this.removeHooks();
	},

	enabled: function () {
		return !!this._enabled;
	}
});


/*
 * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
 */

L.Map.mergeOptions({
	dragging: true,

	inertia: !L.Browser.android23,
	inertiaDeceleration: 3400, // px/s^2
	inertiaMaxSpeed: Infinity, // px/s
	inertiaThreshold: L.Browser.touch ? 32 : 18, // ms
	easeLinearity: 0.25,

	// TODO refactor, move to CRS
	worldCopyJump: false
});

L.Map.Drag = L.Handler.extend({
	addHooks: function () {
		if (!this._draggable) {
			var map = this._map;

			this._draggable = new L.Draggable(map._mapPane, map._container);

			this._draggable.on({
				'dragstart': this._onDragStart,
				'drag': this._onDrag,
				'dragend': this._onDragEnd
			}, this);

			if (map.options.worldCopyJump) {
				this._draggable.on('predrag', this._onPreDrag, this);
				map.on('viewreset', this._onViewReset, this);

				map.whenReady(this._onViewReset, this);
			}
		}
		this._draggable.enable();
	},

	removeHooks: function () {
		this._draggable.disable();
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	_onDragStart: function () {
		var map = this._map;

		if (map._panAnim) {
			map._panAnim.stop();
		}

		map
		    .fire('movestart')
		    .fire('dragstart');

		if (map.options.inertia) {
			this._positions = [];
			this._times = [];
		}
	},

	_onDrag: function () {
		if (this._map.options.inertia) {
			var time = this._lastTime = +new Date(),
			    pos = this._lastPos = this._draggable._newPos;

			this._positions.push(pos);
			this._times.push(time);

			if (time - this._times[0] > 200) {
				this._positions.shift();
				this._times.shift();
			}
		}

		this._map
		    .fire('move')
		    .fire('drag');
	},

	_onViewReset: function () {
		// TODO fix hardcoded Earth values
		var pxCenter = this._map.getSize()._divideBy(2),
		    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

		this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
		this._worldWidth = this._map.project([0, 180]).x;
	},

	_onPreDrag: function () {
		// TODO refactor to be able to adjust map pane position after zoom
		var worldWidth = this._worldWidth,
		    halfWidth = Math.round(worldWidth / 2),
		    dx = this._initialWorldOffset,
		    x = this._draggable._newPos.x,
		    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
		    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
		    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

		this._draggable._newPos.x = newX;
	},

	_onDragEnd: function (e) {
		var map = this._map,
		    options = map.options,
		    delay = +new Date() - this._lastTime,

		    noInertia = !options.inertia || delay > options.inertiaThreshold || !this._positions[0];

		map.fire('dragend', e);

		if (noInertia) {
			map.fire('moveend');

		} else {

			var direction = this._lastPos.subtract(this._positions[0]),
			    duration = (this._lastTime + delay - this._times[0]) / 1000,
			    ease = options.easeLinearity,

			    speedVector = direction.multiplyBy(ease / duration),
			    speed = speedVector.distanceTo([0, 0]),

			    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
			    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),

			    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
			    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

			if (!offset.x || !offset.y) {
				map.fire('moveend');

			} else {
				offset = map._limitOffset(offset, map.options.maxBounds);

				L.Util.requestAnimFrame(function () {
					map.panBy(offset, {
						duration: decelerationDuration,
						easeLinearity: ease,
						noMoveStart: true
					});
				});
			}
		}
	}
});

L.Map.addInitHook('addHandler', 'dragging', L.Map.Drag);


/*
 * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
 */

L.Map.mergeOptions({
	doubleClickZoom: true
});

L.Map.DoubleClickZoom = L.Handler.extend({
	addHooks: function () {
		this._map.on('dblclick', this._onDoubleClick, this);
	},

	removeHooks: function () {
		this._map.off('dblclick', this._onDoubleClick, this);
	},

	_onDoubleClick: function (e) {
		var map = this._map,
		    zoom = map.getZoom() + (e.originalEvent.shiftKey ? -1 : 1);

		if (map.options.doubleClickZoom === 'center') {
			map.setZoom(zoom);
		} else {
			map.setZoomAround(e.containerPoint, zoom);
		}
	}
});

L.Map.addInitHook('addHandler', 'doubleClickZoom', L.Map.DoubleClickZoom);


/*
 * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
 */

L.Map.mergeOptions({
	scrollWheelZoom: true
});

L.Map.ScrollWheelZoom = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, 'mousewheel', this._onWheelScroll, this);
		L.DomEvent.on(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);
		this._delta = 0;
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, 'mousewheel', this._onWheelScroll);
		L.DomEvent.off(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);
	},

	_onWheelScroll: function (e) {
		var delta = L.DomEvent.getWheelDelta(e);

		this._delta += delta;
		this._lastMousePos = this._map.mouseEventToContainerPoint(e);

		if (!this._startTime) {
			this._startTime = +new Date();
		}

		var left = Math.max(40 - (+new Date() - this._startTime), 0);

		clearTimeout(this._timer);
		this._timer = setTimeout(L.bind(this._performZoom, this), left);

		L.DomEvent.preventDefault(e);
		L.DomEvent.stopPropagation(e);
	},

	_performZoom: function () {
		var map = this._map,
		    delta = this._delta,
		    zoom = map.getZoom();

		delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);
		delta = Math.max(Math.min(delta, 4), -4);
		delta = map._limitZoom(zoom + delta) - zoom;

		this._delta = 0;
		this._startTime = null;

		if (!delta) { return; }

		if (map.options.scrollWheelZoom === 'center') {
			map.setZoom(zoom + delta);
		} else {
			map.setZoomAround(this._lastMousePos, zoom + delta);
		}
	}
});

L.Map.addInitHook('addHandler', 'scrollWheelZoom', L.Map.ScrollWheelZoom);


/*
 * Extends the event handling code with double tap support for mobile browsers.
 */

L.extend(L.DomEvent, {

	_touchstart: L.Browser.msPointer ? 'MSPointerDown' : L.Browser.pointer ? 'pointerdown' : 'touchstart',
	_touchend: L.Browser.msPointer ? 'MSPointerUp' : L.Browser.pointer ? 'pointerup' : 'touchend',

	// inspired by Zepto touch code by Thomas Fuchs
	addDoubleTapListener: function (obj, handler, id) {
		var last,
		    doubleTap = false,
		    delay = 250,
		    touch,
		    pre = '_leaflet_',
		    touchstart = this._touchstart,
		    touchend = this._touchend,
		    trackedTouches = [];

		function onTouchStart(e) {
			var count;

			if (L.Browser.pointer) {
				trackedTouches.push(e.pointerId);
				count = trackedTouches.length;
			} else {
				count = e.touches.length;
			}
			if (count > 1) {
				return;
			}

			var now = Date.now(),
				delta = now - (last || now);

			touch = e.touches ? e.touches[0] : e;
			doubleTap = (delta > 0 && delta <= delay);
			last = now;
		}

		function onTouchEnd(e) {
			if (L.Browser.pointer) {
				var idx = trackedTouches.indexOf(e.pointerId);
				if (idx === -1) {
					return;
				}
				trackedTouches.splice(idx, 1);
			}

			if (doubleTap) {
				if (L.Browser.pointer) {
					// work around .type being readonly with MSPointer* events
					var newTouch = { },
						prop;

					// jshint forin:false
					for (var i in touch) {
						prop = touch[i];
						if (typeof prop === 'function') {
							newTouch[i] = prop.bind(touch);
						} else {
							newTouch[i] = prop;
						}
					}
					touch = newTouch;
				}
				touch.type = 'dblclick';
				handler(touch);
				last = null;
			}
		}
		obj[pre + touchstart + id] = onTouchStart;
		obj[pre + touchend + id] = onTouchEnd;

		// on pointer we need to listen on the document, otherwise a drag starting on the map and moving off screen
		// will not come through to us, so we will lose track of how many touches are ongoing
		var endElement = L.Browser.pointer ? document.documentElement : obj;

		obj.addEventListener(touchstart, onTouchStart, false);
		endElement.addEventListener(touchend, onTouchEnd, false);

		if (L.Browser.pointer) {
			endElement.addEventListener(L.DomEvent.POINTER_CANCEL, onTouchEnd, false);
		}

		return this;
	},

	removeDoubleTapListener: function (obj, id) {
		var pre = '_leaflet_';

		obj.removeEventListener(this._touchstart, obj[pre + this._touchstart + id], false);
		(L.Browser.pointer ? document.documentElement : obj).removeEventListener(
		        this._touchend, obj[pre + this._touchend + id], false);

		if (L.Browser.pointer) {
			document.documentElement.removeEventListener(L.DomEvent.POINTER_CANCEL, obj[pre + this._touchend + id],
				false);
		}

		return this;
	}
});


/*
 * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
 */

L.extend(L.DomEvent, {

	//static
	POINTER_DOWN: L.Browser.msPointer ? 'MSPointerDown' : 'pointerdown',
	POINTER_MOVE: L.Browser.msPointer ? 'MSPointerMove' : 'pointermove',
	POINTER_UP: L.Browser.msPointer ? 'MSPointerUp' : 'pointerup',
	POINTER_CANCEL: L.Browser.msPointer ? 'MSPointerCancel' : 'pointercancel',

	_pointers: [],
	_pointerDocumentListener: false,

	// Provides a touch events wrapper for (ms)pointer events.
	// Based on changes by veproza https://github.com/CloudMade/Leaflet/pull/1019
	//ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

	addPointerListener: function (obj, type, handler, id) {

		switch (type) {
		case 'touchstart':
			return this.addPointerListenerStart(obj, type, handler, id);
		case 'touchend':
			return this.addPointerListenerEnd(obj, type, handler, id);
		case 'touchmove':
			return this.addPointerListenerMove(obj, type, handler, id);
		default:
			throw 'Unknown touch event type';
		}
	},

	addPointerListenerStart: function (obj, type, handler, id) {
		var pre = '_leaflet_',
		    pointers = this._pointers;

		var cb = function (e) {

			L.DomEvent.preventDefault(e);

			var alreadyInArray = false;
			for (var i = 0; i < pointers.length; i++) {
				if (pointers[i].pointerId === e.pointerId) {
					alreadyInArray = true;
					break;
				}
			}
			if (!alreadyInArray) {
				pointers.push(e);
			}

			e.touches = pointers.slice();
			e.changedTouches = [e];

			handler(e);
		};

		obj[pre + 'touchstart' + id] = cb;
		obj.addEventListener(this.POINTER_DOWN, cb, false);

		// need to also listen for end events to keep the _pointers list accurate
		// this needs to be on the body and never go away
		if (!this._pointerDocumentListener) {
			var internalCb = function (e) {
				for (var i = 0; i < pointers.length; i++) {
					if (pointers[i].pointerId === e.pointerId) {
						pointers.splice(i, 1);
						break;
					}
				}
			};
			//We listen on the documentElement as any drags that end by moving the touch off the screen get fired there
			document.documentElement.addEventListener(this.POINTER_UP, internalCb, false);
			document.documentElement.addEventListener(this.POINTER_CANCEL, internalCb, false);

			this._pointerDocumentListener = true;
		}

		return this;
	},

	addPointerListenerMove: function (obj, type, handler, id) {
		var pre = '_leaflet_',
		    touches = this._pointers;

		function cb(e) {

			// don't fire touch moves when mouse isn't down
			if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }

			for (var i = 0; i < touches.length; i++) {
				if (touches[i].pointerId === e.pointerId) {
					touches[i] = e;
					break;
				}
			}

			e.touches = touches.slice();
			e.changedTouches = [e];

			handler(e);
		}

		obj[pre + 'touchmove' + id] = cb;
		obj.addEventListener(this.POINTER_MOVE, cb, false);

		return this;
	},

	addPointerListenerEnd: function (obj, type, handler, id) {
		var pre = '_leaflet_',
		    touches = this._pointers;

		var cb = function (e) {
			for (var i = 0; i < touches.length; i++) {
				if (touches[i].pointerId === e.pointerId) {
					touches.splice(i, 1);
					break;
				}
			}

			e.touches = touches.slice();
			e.changedTouches = [e];

			handler(e);
		};

		obj[pre + 'touchend' + id] = cb;
		obj.addEventListener(this.POINTER_UP, cb, false);
		obj.addEventListener(this.POINTER_CANCEL, cb, false);

		return this;
	},

	removePointerListener: function (obj, type, id) {
		var pre = '_leaflet_',
		    cb = obj[pre + type + id];

		switch (type) {
		case 'touchstart':
			obj.removeEventListener(this.POINTER_DOWN, cb, false);
			break;
		case 'touchmove':
			obj.removeEventListener(this.POINTER_MOVE, cb, false);
			break;
		case 'touchend':
			obj.removeEventListener(this.POINTER_UP, cb, false);
			obj.removeEventListener(this.POINTER_CANCEL, cb, false);
			break;
		}

		return this;
	}
});


/*
 * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
 */

L.Map.mergeOptions({
	touchZoom: L.Browser.touch && !L.Browser.android23,
	bounceAtZoomLimits: true
});

L.Map.TouchZoom = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	_onTouchStart: function (e) {
		var map = this._map;

		if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }

		var p1 = map.mouseEventToLayerPoint(e.touches[0]),
		    p2 = map.mouseEventToLayerPoint(e.touches[1]),
		    viewCenter = map._getCenterLayerPoint();

		this._startCenter = p1.add(p2)._divideBy(2);
		this._startDist = p1.distanceTo(p2);

		this._moved = false;
		this._zooming = true;

		this._centerOffset = viewCenter.subtract(this._startCenter);

		if (map._panAnim) {
			map._panAnim.stop();
		}

		L.DomEvent
		    .on(document, 'touchmove', this._onTouchMove, this)
		    .on(document, 'touchend', this._onTouchEnd, this);

		L.DomEvent.preventDefault(e);
	},

	_onTouchMove: function (e) {
		var map = this._map;

		if (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }

		var p1 = map.mouseEventToLayerPoint(e.touches[0]),
		    p2 = map.mouseEventToLayerPoint(e.touches[1]);

		this._scale = p1.distanceTo(p2) / this._startDist;
		this._delta = p1._add(p2)._divideBy(2)._subtract(this._startCenter);

		if (this._scale === 1) { return; }

		if (!map.options.bounceAtZoomLimits) {
			if ((map.getZoom() === map.getMinZoom() && this._scale < 1) ||
			    (map.getZoom() === map.getMaxZoom() && this._scale > 1)) { return; }
		}

		if (!this._moved) {
			L.DomUtil.addClass(map._mapPane, 'leaflet-touching');

			map
			    .fire('movestart')
			    .fire('zoomstart');

			this._moved = true;
		}

		L.Util.cancelAnimFrame(this._animRequest);
		this._animRequest = L.Util.requestAnimFrame(
		        this._updateOnMove, this, true, this._map._container);

		L.DomEvent.preventDefault(e);
	},

	_updateOnMove: function () {
		var map = this._map,
		    origin = this._getScaleOrigin(),
		    center = map.layerPointToLatLng(origin),
		    zoom = map.getScaleZoom(this._scale);

		map._animateZoom(center, zoom, this._startCenter, this._scale, this._delta, false, true);
	},

	_onTouchEnd: function () {
		if (!this._moved || !this._zooming) {
			this._zooming = false;
			return;
		}

		var map = this._map;

		this._zooming = false;
		L.DomUtil.removeClass(map._mapPane, 'leaflet-touching');
		L.Util.cancelAnimFrame(this._animRequest);

		L.DomEvent
		    .off(document, 'touchmove', this._onTouchMove)
		    .off(document, 'touchend', this._onTouchEnd);

		var origin = this._getScaleOrigin(),
		    center = map.layerPointToLatLng(origin),

		    oldZoom = map.getZoom(),
		    floatZoomDelta = map.getScaleZoom(this._scale) - oldZoom,
		    roundZoomDelta = (floatZoomDelta > 0 ?
		            Math.ceil(floatZoomDelta) : Math.floor(floatZoomDelta)),

		    zoom = map._limitZoom(oldZoom + roundZoomDelta),
		    scale = map.getZoomScale(zoom) / this._scale;

		map._animateZoom(center, zoom, origin, scale);
	},

	_getScaleOrigin: function () {
		var centerOffset = this._centerOffset.subtract(this._delta).divideBy(this._scale);
		return this._startCenter.add(centerOffset);
	}
});

L.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);


/*
 * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
 */

L.Map.mergeOptions({
	tap: true,
	tapTolerance: 15
});

L.Map.Tap = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, 'touchstart', this._onDown, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, 'touchstart', this._onDown, this);
	},

	_onDown: function (e) {
		if (!e.touches) { return; }

		L.DomEvent.preventDefault(e);

		this._fireClick = true;

		// don't simulate click or track longpress if more than 1 touch
		if (e.touches.length > 1) {
			this._fireClick = false;
			clearTimeout(this._holdTimeout);
			return;
		}

		var first = e.touches[0],
		    el = first.target;

		this._startPos = this._newPos = new L.Point(first.clientX, first.clientY);

		// if touching a link, highlight it
		if (el.tagName && el.tagName.toLowerCase() === 'a') {
			L.DomUtil.addClass(el, 'leaflet-active');
		}

		// simulate long hold but setting a timeout
		this._holdTimeout = setTimeout(L.bind(function () {
			if (this._isTapValid()) {
				this._fireClick = false;
				this._onUp();
				this._simulateEvent('contextmenu', first);
			}
		}, this), 1000);

		L.DomEvent
			.on(document, 'touchmove', this._onMove, this)
			.on(document, 'touchend', this._onUp, this);
	},

	_onUp: function (e) {
		clearTimeout(this._holdTimeout);

		L.DomEvent
			.off(document, 'touchmove', this._onMove, this)
			.off(document, 'touchend', this._onUp, this);

		if (this._fireClick && e && e.changedTouches) {

			var first = e.changedTouches[0],
			    el = first.target;

			if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
				L.DomUtil.removeClass(el, 'leaflet-active');
			}

			// simulate click if the touch didn't move too much
			if (this._isTapValid()) {
				this._simulateEvent('click', first);
			}
		}
	},

	_isTapValid: function () {
		return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
	},

	_onMove: function (e) {
		var first = e.touches[0];
		this._newPos = new L.Point(first.clientX, first.clientY);
	},

	_simulateEvent: function (type, e) {
		var simulatedEvent = document.createEvent('MouseEvents');

		simulatedEvent._simulated = true;
		e.target._simulatedClick = true;

		simulatedEvent.initMouseEvent(
		        type, true, true, window, 1,
		        e.screenX, e.screenY,
		        e.clientX, e.clientY,
		        false, false, false, false, 0, null);

		e.target.dispatchEvent(simulatedEvent);
	}
});

if (L.Browser.touch && !L.Browser.pointer) {
	L.Map.addInitHook('addHandler', 'tap', L.Map.Tap);
}


/*
 * L.Handler.ShiftDragZoom is used to add shift-drag zoom interaction to the map
  * (zoom to a selected bounding box), enabled by default.
 */

L.Map.mergeOptions({
	boxZoom: true
});

L.Map.BoxZoom = L.Handler.extend({
	initialize: function (map) {
		this._map = map;
		this._container = map._container;
		this._pane = map._panes.overlayPane;
		this._moved = false;
	},

	addHooks: function () {
		L.DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._container, 'mousedown', this._onMouseDown);
		this._moved = false;
	},

	moved: function () {
		return this._moved;
	},

	_onMouseDown: function (e) {
		this._moved = false;

		if (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }

		L.DomUtil.disableTextSelection();
		L.DomUtil.disableImageDrag();

		this._startLayerPoint = this._map.mouseEventToLayerPoint(e);

		L.DomEvent
		    .on(document, 'mousemove', this._onMouseMove, this)
		    .on(document, 'mouseup', this._onMouseUp, this)
		    .on(document, 'keydown', this._onKeyDown, this);
	},

	_onMouseMove: function (e) {
		if (!this._moved) {
			this._box = L.DomUtil.create('div', 'leaflet-zoom-box', this._pane);
			L.DomUtil.setPosition(this._box, this._startLayerPoint);

			//TODO refactor: move cursor to styles
			this._container.style.cursor = 'crosshair';
			this._map.fire('boxzoomstart');
		}

		var startPoint = this._startLayerPoint,
		    box = this._box,

		    layerPoint = this._map.mouseEventToLayerPoint(e),
		    offset = layerPoint.subtract(startPoint),

		    newPos = new L.Point(
		        Math.min(layerPoint.x, startPoint.x),
		        Math.min(layerPoint.y, startPoint.y));

		L.DomUtil.setPosition(box, newPos);

		this._moved = true;

		// TODO refactor: remove hardcoded 4 pixels
		box.style.width  = (Math.max(0, Math.abs(offset.x) - 4)) + 'px';
		box.style.height = (Math.max(0, Math.abs(offset.y) - 4)) + 'px';
	},

	_finish: function () {
		if (this._moved) {
			this._pane.removeChild(this._box);
			this._container.style.cursor = '';
		}

		L.DomUtil.enableTextSelection();
		L.DomUtil.enableImageDrag();

		L.DomEvent
		    .off(document, 'mousemove', this._onMouseMove)
		    .off(document, 'mouseup', this._onMouseUp)
		    .off(document, 'keydown', this._onKeyDown);
	},

	_onMouseUp: function (e) {

		this._finish();

		var map = this._map,
		    layerPoint = map.mouseEventToLayerPoint(e);

		if (this._startLayerPoint.equals(layerPoint)) { return; }

		var bounds = new L.LatLngBounds(
		        map.layerPointToLatLng(this._startLayerPoint),
		        map.layerPointToLatLng(layerPoint));

		map.fitBounds(bounds);

		map.fire('boxzoomend', {
			boxZoomBounds: bounds
		});
	},

	_onKeyDown: function (e) {
		if (e.keyCode === 27) {
			this._finish();
		}
	}
});

L.Map.addInitHook('addHandler', 'boxZoom', L.Map.BoxZoom);


/*
 * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
 */

L.Map.mergeOptions({
	keyboard: true,
	keyboardPanOffset: 80,
	keyboardZoomOffset: 1
});

L.Map.Keyboard = L.Handler.extend({

	keyCodes: {
		left:    [37],
		right:   [39],
		down:    [40],
		up:      [38],
		zoomIn:  [187, 107, 61, 171],
		zoomOut: [189, 109, 173]
	},

	initialize: function (map) {
		this._map = map;

		this._setPanOffset(map.options.keyboardPanOffset);
		this._setZoomOffset(map.options.keyboardZoomOffset);
	},

	addHooks: function () {
		var container = this._map._container;

		// make the container focusable by tabbing
		if (container.tabIndex === -1) {
			container.tabIndex = '0';
		}

		L.DomEvent
		    .on(container, 'focus', this._onFocus, this)
		    .on(container, 'blur', this._onBlur, this)
		    .on(container, 'mousedown', this._onMouseDown, this);

		this._map
		    .on('focus', this._addHooks, this)
		    .on('blur', this._removeHooks, this);
	},

	removeHooks: function () {
		this._removeHooks();

		var container = this._map._container;

		L.DomEvent
		    .off(container, 'focus', this._onFocus, this)
		    .off(container, 'blur', this._onBlur, this)
		    .off(container, 'mousedown', this._onMouseDown, this);

		this._map
		    .off('focus', this._addHooks, this)
		    .off('blur', this._removeHooks, this);
	},

	_onMouseDown: function () {
		if (this._focused) { return; }

		var body = document.body,
		    docEl = document.documentElement,
		    top = body.scrollTop || docEl.scrollTop,
		    left = body.scrollLeft || docEl.scrollLeft;

		this._map._container.focus();

		window.scrollTo(left, top);
	},

	_onFocus: function () {
		this._focused = true;
		this._map.fire('focus');
	},

	_onBlur: function () {
		this._focused = false;
		this._map.fire('blur');
	},

	_setPanOffset: function (pan) {
		var keys = this._panKeys = {},
		    codes = this.keyCodes,
		    i, len;

		for (i = 0, len = codes.left.length; i < len; i++) {
			keys[codes.left[i]] = [-1 * pan, 0];
		}
		for (i = 0, len = codes.right.length; i < len; i++) {
			keys[codes.right[i]] = [pan, 0];
		}
		for (i = 0, len = codes.down.length; i < len; i++) {
			keys[codes.down[i]] = [0, pan];
		}
		for (i = 0, len = codes.up.length; i < len; i++) {
			keys[codes.up[i]] = [0, -1 * pan];
		}
	},

	_setZoomOffset: function (zoom) {
		var keys = this._zoomKeys = {},
		    codes = this.keyCodes,
		    i, len;

		for (i = 0, len = codes.zoomIn.length; i < len; i++) {
			keys[codes.zoomIn[i]] = zoom;
		}
		for (i = 0, len = codes.zoomOut.length; i < len; i++) {
			keys[codes.zoomOut[i]] = -zoom;
		}
	},

	_addHooks: function () {
		L.DomEvent.on(document, 'keydown', this._onKeyDown, this);
	},

	_removeHooks: function () {
		L.DomEvent.off(document, 'keydown', this._onKeyDown, this);
	},

	_onKeyDown: function (e) {
		var key = e.keyCode,
		    map = this._map;

		if (key in this._panKeys) {

			if (map._panAnim && map._panAnim._inProgress) { return; }

			map.panBy(this._panKeys[key]);

			if (map.options.maxBounds) {
				map.panInsideBounds(map.options.maxBounds);
			}

		} else if (key in this._zoomKeys) {
			map.setZoom(map.getZoom() + this._zoomKeys[key]);

		} else {
			return;
		}

		L.DomEvent.stop(e);
	}
});

L.Map.addInitHook('addHandler', 'keyboard', L.Map.Keyboard);


/*
 * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
 */

L.Handler.MarkerDrag = L.Handler.extend({
	initialize: function (marker) {
		this._marker = marker;
	},

	addHooks: function () {
		var icon = this._marker._icon;
		if (!this._draggable) {
			this._draggable = new L.Draggable(icon, icon);
		}

		this._draggable
			.on('dragstart', this._onDragStart, this)
			.on('drag', this._onDrag, this)
			.on('dragend', this._onDragEnd, this);
		this._draggable.enable();
		L.DomUtil.addClass(this._marker._icon, 'leaflet-marker-draggable');
	},

	removeHooks: function () {
		this._draggable
			.off('dragstart', this._onDragStart, this)
			.off('drag', this._onDrag, this)
			.off('dragend', this._onDragEnd, this);

		this._draggable.disable();
		L.DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	_onDragStart: function () {
		this._marker
		    .closePopup()
		    .fire('movestart')
		    .fire('dragstart');
	},

	_onDrag: function () {
		var marker = this._marker,
		    shadow = marker._shadow,
		    iconPos = L.DomUtil.getPosition(marker._icon),
		    latlng = marker._map.layerPointToLatLng(iconPos);

		// update shadow position
		if (shadow) {
			L.DomUtil.setPosition(shadow, iconPos);
		}

		marker._latlng = latlng;

		marker
		    .fire('move', {latlng: latlng})
		    .fire('drag');
	},

	_onDragEnd: function (e) {
		this._marker
		    .fire('moveend')
		    .fire('dragend', e);
	}
});


/*
 * L.Control is a base class for implementing map controls. Handles positioning.
 * All other controls extend from this class.
 */

L.Control = L.Class.extend({
	options: {
		position: 'topright'
	},

	initialize: function (options) {
		L.setOptions(this, options);
	},

	getPosition: function () {
		return this.options.position;
	},

	setPosition: function (position) {
		var map = this._map;

		if (map) {
			map.removeControl(this);
		}

		this.options.position = position;

		if (map) {
			map.addControl(this);
		}

		return this;
	},

	getContainer: function () {
		return this._container;
	},

	addTo: function (map) {
		this._map = map;

		var container = this._container = this.onAdd(map),
		    pos = this.getPosition(),
		    corner = map._controlCorners[pos];

		L.DomUtil.addClass(container, 'leaflet-control');

		if (pos.indexOf('bottom') !== -1) {
			corner.insertBefore(container, corner.firstChild);
		} else {
			corner.appendChild(container);
		}

		return this;
	},

	removeFrom: function (map) {
		var pos = this.getPosition(),
		    corner = map._controlCorners[pos];

		corner.removeChild(this._container);
		this._map = null;

		if (this.onRemove) {
			this.onRemove(map);
		}

		return this;
	},

	_refocusOnMap: function () {
		if (this._map) {
			this._map.getContainer().focus();
		}
	}
});

L.control = function (options) {
	return new L.Control(options);
};


// adds control-related methods to L.Map

L.Map.include({
	addControl: function (control) {
		control.addTo(this);
		return this;
	},

	removeControl: function (control) {
		control.removeFrom(this);
		return this;
	},

	_initControlPos: function () {
		var corners = this._controlCorners = {},
		    l = 'leaflet-',
		    container = this._controlContainer =
		            L.DomUtil.create('div', l + 'control-container', this._container);

		function createCorner(vSide, hSide) {
			var className = l + vSide + ' ' + l + hSide;

			corners[vSide + hSide] = L.DomUtil.create('div', className, container);
		}

		createCorner('top', 'left');
		createCorner('top', 'right');
		createCorner('bottom', 'left');
		createCorner('bottom', 'right');
	},

	_clearControlPos: function () {
		this._container.removeChild(this._controlContainer);
	}
});


/*
 * L.Control.Zoom is used for the default zoom buttons on the map.
 */

L.Control.Zoom = L.Control.extend({
	options: {
		position: 'topleft',
		zoomInText: '+',
		zoomInTitle: 'Zoom in',
		zoomOutText: '-',
		zoomOutTitle: 'Zoom out'
	},

	onAdd: function (map) {
		var zoomName = 'leaflet-control-zoom',
		    container = L.DomUtil.create('div', zoomName + ' leaflet-bar');

		this._map = map;

		this._zoomInButton  = this._createButton(
		        this.options.zoomInText, this.options.zoomInTitle,
		        zoomName + '-in',  container, this._zoomIn,  this);
		this._zoomOutButton = this._createButton(
		        this.options.zoomOutText, this.options.zoomOutTitle,
		        zoomName + '-out', container, this._zoomOut, this);

		this._updateDisabled();
		map.on('zoomend zoomlevelschange', this._updateDisabled, this);

		return container;
	},

	onRemove: function (map) {
		map.off('zoomend zoomlevelschange', this._updateDisabled, this);
	},

	_zoomIn: function (e) {
		this._map.zoomIn(e.shiftKey ? 3 : 1);
	},

	_zoomOut: function (e) {
		this._map.zoomOut(e.shiftKey ? 3 : 1);
	},

	_createButton: function (html, title, className, container, fn, context) {
		var link = L.DomUtil.create('a', className, container);
		link.innerHTML = html;
		link.href = '#';
		link.title = title;

		var stop = L.DomEvent.stopPropagation;

		L.DomEvent
		    .on(link, 'click', stop)
		    .on(link, 'mousedown', stop)
		    .on(link, 'dblclick', stop)
		    .on(link, 'click', L.DomEvent.preventDefault)
		    .on(link, 'click', fn, context)
		    .on(link, 'click', this._refocusOnMap, context);

		return link;
	},

	_updateDisabled: function () {
		var map = this._map,
			className = 'leaflet-disabled';

		L.DomUtil.removeClass(this._zoomInButton, className);
		L.DomUtil.removeClass(this._zoomOutButton, className);

		if (map._zoom === map.getMinZoom()) {
			L.DomUtil.addClass(this._zoomOutButton, className);
		}
		if (map._zoom === map.getMaxZoom()) {
			L.DomUtil.addClass(this._zoomInButton, className);
		}
	}
});

L.Map.mergeOptions({
	zoomControl: true
});

L.Map.addInitHook(function () {
	if (this.options.zoomControl) {
		this.zoomControl = new L.Control.Zoom();
		this.addControl(this.zoomControl);
	}
});

L.control.zoom = function (options) {
	return new L.Control.Zoom(options);
};



/*
 * L.Control.Attribution is used for displaying attribution on the map (added by default).
 */

L.Control.Attribution = L.Control.extend({
	options: {
		position: 'bottomright',
		prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
	},

	initialize: function (options) {
		L.setOptions(this, options);

		this._attributions = {};
	},

	onAdd: function (map) {
		this._container = L.DomUtil.create('div', 'leaflet-control-attribution');
		L.DomEvent.disableClickPropagation(this._container);

		for (var i in map._layers) {
			if (map._layers[i].getAttribution) {
				this.addAttribution(map._layers[i].getAttribution());
			}
		}
		
		map
		    .on('layeradd', this._onLayerAdd, this)
		    .on('layerremove', this._onLayerRemove, this);

		this._update();

		return this._container;
	},

	onRemove: function (map) {
		map
		    .off('layeradd', this._onLayerAdd)
		    .off('layerremove', this._onLayerRemove);

	},

	setPrefix: function (prefix) {
		this.options.prefix = prefix;
		this._update();
		return this;
	},

	addAttribution: function (text) {
		if (!text) { return; }

		if (!this._attributions[text]) {
			this._attributions[text] = 0;
		}
		this._attributions[text]++;

		this._update();

		return this;
	},

	removeAttribution: function (text) {
		if (!text) { return; }

		if (this._attributions[text]) {
			this._attributions[text]--;
			this._update();
		}

		return this;
	},

	_update: function () {
		if (!this._map) { return; }

		var attribs = [];

		for (var i in this._attributions) {
			if (this._attributions[i]) {
				attribs.push(i);
			}
		}

		var prefixAndAttribs = [];

		if (this.options.prefix) {
			prefixAndAttribs.push(this.options.prefix);
		}
		if (attribs.length) {
			prefixAndAttribs.push(attribs.join(', '));
		}

		this._container.innerHTML = prefixAndAttribs.join(' | ');
	},

	_onLayerAdd: function (e) {
		if (e.layer.getAttribution) {
			this.addAttribution(e.layer.getAttribution());
		}
	},

	_onLayerRemove: function (e) {
		if (e.layer.getAttribution) {
			this.removeAttribution(e.layer.getAttribution());
		}
	}
});

L.Map.mergeOptions({
	attributionControl: true
});

L.Map.addInitHook(function () {
	if (this.options.attributionControl) {
		this.attributionControl = (new L.Control.Attribution()).addTo(this);
	}
});

L.control.attribution = function (options) {
	return new L.Control.Attribution(options);
};


/*
 * L.Control.Scale is used for displaying metric/imperial scale on the map.
 */

L.Control.Scale = L.Control.extend({
	options: {
		position: 'bottomleft',
		maxWidth: 100,
		metric: true,
		imperial: true,
		updateWhenIdle: false
	},

	onAdd: function (map) {
		this._map = map;

		var className = 'leaflet-control-scale',
		    container = L.DomUtil.create('div', className),
		    options = this.options;

		this._addScales(options, className, container);

		map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
		map.whenReady(this._update, this);

		return container;
	},

	onRemove: function (map) {
		map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
	},

	_addScales: function (options, className, container) {
		if (options.metric) {
			this._mScale = L.DomUtil.create('div', className + '-line', container);
		}
		if (options.imperial) {
			this._iScale = L.DomUtil.create('div', className + '-line', container);
		}
	},

	_update: function () {
		var bounds = this._map.getBounds(),
		    centerLat = bounds.getCenter().lat,
		    halfWorldMeters = 6378137 * Math.PI * Math.cos(centerLat * Math.PI / 180),
		    dist = halfWorldMeters * (bounds.getNorthEast().lng - bounds.getSouthWest().lng) / 180,

		    size = this._map.getSize(),
		    options = this.options,
		    maxMeters = 0;

		if (size.x > 0) {
			maxMeters = dist * (options.maxWidth / size.x);
		}

		this._updateScales(options, maxMeters);
	},

	_updateScales: function (options, maxMeters) {
		if (options.metric && maxMeters) {
			this._updateMetric(maxMeters);
		}

		if (options.imperial && maxMeters) {
			this._updateImperial(maxMeters);
		}
	},

	_updateMetric: function (maxMeters) {
		var meters = this._getRoundNum(maxMeters);

		this._mScale.style.width = this._getScaleWidth(meters / maxMeters) + 'px';
		this._mScale.innerHTML = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';
	},

	_updateImperial: function (maxMeters) {
		var maxFeet = maxMeters * 3.2808399,
		    scale = this._iScale,
		    maxMiles, miles, feet;

		if (maxFeet > 5280) {
			maxMiles = maxFeet / 5280;
			miles = this._getRoundNum(maxMiles);

			scale.style.width = this._getScaleWidth(miles / maxMiles) + 'px';
			scale.innerHTML = miles + ' mi';

		} else {
			feet = this._getRoundNum(maxFeet);

			scale.style.width = this._getScaleWidth(feet / maxFeet) + 'px';
			scale.innerHTML = feet + ' ft';
		}
	},

	_getScaleWidth: function (ratio) {
		return Math.round(this.options.maxWidth * ratio) - 10;
	},

	_getRoundNum: function (num) {
		var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
		    d = num / pow10;

		d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;

		return pow10 * d;
	}
});

L.control.scale = function (options) {
	return new L.Control.Scale(options);
};


/*
 * L.Control.Layers is a control to allow users to switch between different layers on the map.
 */

L.Control.Layers = L.Control.extend({
	options: {
		collapsed: true,
		position: 'topright',
		autoZIndex: true
	},

	initialize: function (baseLayers, overlays, options) {
		L.setOptions(this, options);

		this._layers = {};
		this._lastZIndex = 0;
		this._handlingClick = false;

		for (var i in baseLayers) {
			this._addLayer(baseLayers[i], i);
		}

		for (i in overlays) {
			this._addLayer(overlays[i], i, true);
		}
	},

	onAdd: function (map) {
		this._initLayout();
		this._update();

		map
		    .on('layeradd', this._onLayerChange, this)
		    .on('layerremove', this._onLayerChange, this);

		return this._container;
	},

	onRemove: function (map) {
		map
		    .off('layeradd', this._onLayerChange, this)
		    .off('layerremove', this._onLayerChange, this);
	},

	addBaseLayer: function (layer, name) {
		this._addLayer(layer, name);
		this._update();
		return this;
	},

	addOverlay: function (layer, name) {
		this._addLayer(layer, name, true);
		this._update();
		return this;
	},

	removeLayer: function (layer) {
		var id = L.stamp(layer);
		delete this._layers[id];
		this._update();
		return this;
	},

	_initLayout: function () {
		var className = 'leaflet-control-layers',
		    container = this._container = L.DomUtil.create('div', className);

		//Makes this work on IE10 Touch devices by stopping it from firing a mouseout event when the touch is released
		container.setAttribute('aria-haspopup', true);

		if (!L.Browser.touch) {
			L.DomEvent
				.disableClickPropagation(container)
				.disableScrollPropagation(container);
		} else {
			L.DomEvent.on(container, 'click', L.DomEvent.stopPropagation);
		}

		var form = this._form = L.DomUtil.create('form', className + '-list');

		if (this.options.collapsed) {
			if (!L.Browser.android) {
				L.DomEvent
				    .on(container, 'mouseover', this._expand, this)
				    .on(container, 'mouseout', this._collapse, this);
			}
			var link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);
			link.href = '#';
			link.title = 'Layers';

			if (L.Browser.touch) {
				L.DomEvent
				    .on(link, 'click', L.DomEvent.stop)
				    .on(link, 'click', this._expand, this);
			}
			else {
				L.DomEvent.on(link, 'focus', this._expand, this);
			}
			//Work around for Firefox android issue https://github.com/Leaflet/Leaflet/issues/2033
			L.DomEvent.on(form, 'click', function () {
				setTimeout(L.bind(this._onInputClick, this), 0);
			}, this);

			this._map.on('click', this._collapse, this);
			// TODO keyboard accessibility
		} else {
			this._expand();
		}

		this._baseLayersList = L.DomUtil.create('div', className + '-base', form);
		this._separator = L.DomUtil.create('div', className + '-separator', form);
		this._overlaysList = L.DomUtil.create('div', className + '-overlays', form);

		container.appendChild(form);
	},

	_addLayer: function (layer, name, overlay) {
		var id = L.stamp(layer);

		this._layers[id] = {
			layer: layer,
			name: name,
			overlay: overlay
		};

		if (this.options.autoZIndex && layer.setZIndex) {
			this._lastZIndex++;
			layer.setZIndex(this._lastZIndex);
		}
	},

	_update: function () {
		if (!this._container) {
			return;
		}

		this._baseLayersList.innerHTML = '';
		this._overlaysList.innerHTML = '';

		var baseLayersPresent = false,
		    overlaysPresent = false,
		    i, obj;

		for (i in this._layers) {
			obj = this._layers[i];
			this._addItem(obj);
			overlaysPresent = overlaysPresent || obj.overlay;
			baseLayersPresent = baseLayersPresent || !obj.overlay;
		}

		this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';
	},

	_onLayerChange: function (e) {
		var obj = this._layers[L.stamp(e.layer)];

		if (!obj) { return; }

		if (!this._handlingClick) {
			this._update();
		}

		var type = obj.overlay ?
			(e.type === 'layeradd' ? 'overlayadd' : 'overlayremove') :
			(e.type === 'layeradd' ? 'baselayerchange' : null);

		if (type) {
			this._map.fire(type, obj);
		}
	},

	// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
	_createRadioElement: function (name, checked) {

		var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"';
		if (checked) {
			radioHtml += ' checked="checked"';
		}
		radioHtml += '/>';

		var radioFragment = document.createElement('div');
		radioFragment.innerHTML = radioHtml;

		return radioFragment.firstChild;
	},

	_addItem: function (obj) {
		var label = document.createElement('label'),
		    input,
		    checked = this._map.hasLayer(obj.layer);

		if (obj.overlay) {
			input = document.createElement('input');
			input.type = 'checkbox';
			input.className = 'leaflet-control-layers-selector';
			input.defaultChecked = checked;
		} else {
			input = this._createRadioElement('leaflet-base-layers', checked);
		}

		input.layerId = L.stamp(obj.layer);

		L.DomEvent.on(input, 'click', this._onInputClick, this);

		var name = document.createElement('span');
		name.innerHTML = ' ' + obj.name;

		label.appendChild(input);
		label.appendChild(name);

		var container = obj.overlay ? this._overlaysList : this._baseLayersList;
		container.appendChild(label);

		return label;
	},

	_onInputClick: function () {
		var i, input, obj,
		    inputs = this._form.getElementsByTagName('input'),
		    inputsLen = inputs.length;

		this._handlingClick = true;

		for (i = 0; i < inputsLen; i++) {
			input = inputs[i];
			obj = this._layers[input.layerId];

			if (input.checked && !this._map.hasLayer(obj.layer)) {
				this._map.addLayer(obj.layer);

			} else if (!input.checked && this._map.hasLayer(obj.layer)) {
				this._map.removeLayer(obj.layer);
			}
		}

		this._handlingClick = false;

		this._refocusOnMap();
	},

	_expand: function () {
		L.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');
	},

	_collapse: function () {
		this._container.className = this._container.className.replace(' leaflet-control-layers-expanded', '');
	}
});

L.control.layers = function (baseLayers, overlays, options) {
	return new L.Control.Layers(baseLayers, overlays, options);
};


/*
 * L.PosAnimation is used by Leaflet internally for pan animations.
 */

L.PosAnimation = L.Class.extend({
	includes: L.Mixin.Events,

	run: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])
		this.stop();

		this._el = el;
		this._inProgress = true;
		this._newPos = newPos;

		this.fire('start');

		el.style[L.DomUtil.TRANSITION] = 'all ' + (duration || 0.25) +
		        's cubic-bezier(0,0,' + (easeLinearity || 0.5) + ',1)';

		L.DomEvent.on(el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);
		L.DomUtil.setPosition(el, newPos);

		// toggle reflow, Chrome flickers for some reason if you don't do this
		L.Util.falseFn(el.offsetWidth);

		// there's no native way to track value updates of transitioned properties, so we imitate this
		this._stepTimer = setInterval(L.bind(this._onStep, this), 50);
	},

	stop: function () {
		if (!this._inProgress) { return; }

		// if we just removed the transition property, the element would jump to its final position,
		// so we need to make it stay at the current position

		L.DomUtil.setPosition(this._el, this._getPos());
		this._onTransitionEnd();
		L.Util.falseFn(this._el.offsetWidth); // force reflow in case we are about to start a new animation
	},

	_onStep: function () {
		var stepPos = this._getPos();
		if (!stepPos) {
			this._onTransitionEnd();
			return;
		}
		// jshint camelcase: false
		// make L.DomUtil.getPosition return intermediate position value during animation
		this._el._leaflet_pos = stepPos;

		this.fire('step');
	},

	// you can't easily get intermediate values of properties animated with CSS3 Transitions,
	// we need to parse computed style (in case of transform it returns matrix string)

	_transformRe: /([-+]?(?:\d*\.)?\d+)\D*, ([-+]?(?:\d*\.)?\d+)\D*\)/,

	_getPos: function () {
		var left, top, matches,
		    el = this._el,
		    style = window.getComputedStyle(el);

		if (L.Browser.any3d) {
			matches = style[L.DomUtil.TRANSFORM].match(this._transformRe);
			if (!matches) { return; }
			left = parseFloat(matches[1]);
			top  = parseFloat(matches[2]);
		} else {
			left = parseFloat(style.left);
			top  = parseFloat(style.top);
		}

		return new L.Point(left, top, true);
	},

	_onTransitionEnd: function () {
		L.DomEvent.off(this._el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);

		if (!this._inProgress) { return; }
		this._inProgress = false;

		this._el.style[L.DomUtil.TRANSITION] = '';

		// jshint camelcase: false
		// make sure L.DomUtil.getPosition returns the final position value after animation
		this._el._leaflet_pos = this._newPos;

		clearInterval(this._stepTimer);

		this.fire('step').fire('end');
	}

});


/*
 * Extends L.Map to handle panning animations.
 */

L.Map.include({

	setView: function (center, zoom, options) {

		zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
		center = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);
		options = options || {};

		if (this._panAnim) {
			this._panAnim.stop();
		}

		if (this._loaded && !options.reset && options !== true) {

			if (options.animate !== undefined) {
				options.zoom = L.extend({animate: options.animate}, options.zoom);
				options.pan = L.extend({animate: options.animate}, options.pan);
			}

			// try animating pan or zoom
			var animated = (this._zoom !== zoom) ?
				this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :
				this._tryAnimatedPan(center, options.pan);

			if (animated) {
				// prevent resize handler call, the view will refresh after animation anyway
				clearTimeout(this._sizeTimer);
				return this;
			}
		}

		// animation didn't start, just reset the map view
		this._resetView(center, zoom);

		return this;
	},

	panBy: function (offset, options) {
		offset = L.point(offset).round();
		options = options || {};

		if (!offset.x && !offset.y) {
			return this;
		}

		if (!this._panAnim) {
			this._panAnim = new L.PosAnimation();

			this._panAnim.on({
				'step': this._onPanTransitionStep,
				'end': this._onPanTransitionEnd
			}, this);
		}

		// don't fire movestart if animating inertia
		if (!options.noMoveStart) {
			this.fire('movestart');
		}

		// animate pan unless animate: false specified
		if (options.animate !== false) {
			L.DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');

			var newPos = this._getMapPanePos().subtract(offset);
			this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
		} else {
			this._rawPanBy(offset);
			this.fire('move').fire('moveend');
		}

		return this;
	},

	_onPanTransitionStep: function () {
		this.fire('move');
	},

	_onPanTransitionEnd: function () {
		L.DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');
		this.fire('moveend');
	},

	_tryAnimatedPan: function (center, options) {
		// difference between the new and current centers in pixels
		var offset = this._getCenterOffset(center)._floor();

		// don't animate too far unless animate: true specified in options
		if ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }

		this.panBy(offset, options);

		return true;
	}
});


/*
 * L.PosAnimation fallback implementation that powers Leaflet pan animations
 * in browsers that don't support CSS3 Transitions.
 */

L.PosAnimation = L.DomUtil.TRANSITION ? L.PosAnimation : L.PosAnimation.extend({

	run: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])
		this.stop();

		this._el = el;
		this._inProgress = true;
		this._duration = duration || 0.25;
		this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

		this._startPos = L.DomUtil.getPosition(el);
		this._offset = newPos.subtract(this._startPos);
		this._startTime = +new Date();

		this.fire('start');

		this._animate();
	},

	stop: function () {
		if (!this._inProgress) { return; }

		this._step();
		this._complete();
	},

	_animate: function () {
		// animation loop
		this._animId = L.Util.requestAnimFrame(this._animate, this);
		this._step();
	},

	_step: function () {
		var elapsed = (+new Date()) - this._startTime,
		    duration = this._duration * 1000;

		if (elapsed < duration) {
			this._runFrame(this._easeOut(elapsed / duration));
		} else {
			this._runFrame(1);
			this._complete();
		}
	},

	_runFrame: function (progress) {
		var pos = this._startPos.add(this._offset.multiplyBy(progress));
		L.DomUtil.setPosition(this._el, pos);

		this.fire('step');
	},

	_complete: function () {
		L.Util.cancelAnimFrame(this._animId);

		this._inProgress = false;
		this.fire('end');
	},

	_easeOut: function (t) {
		return 1 - Math.pow(1 - t, this._easeOutPower);
	}
});


/*
 * Extends L.Map to handle zoom animations.
 */

L.Map.mergeOptions({
	zoomAnimation: true,
	zoomAnimationThreshold: 4
});

if (L.DomUtil.TRANSITION) {

	L.Map.addInitHook(function () {
		// don't animate on browsers without hardware-accelerated transitions or old Android/Opera
		this._zoomAnimated = this.options.zoomAnimation && L.DomUtil.TRANSITION &&
				L.Browser.any3d && !L.Browser.android23 && !L.Browser.mobileOpera;

		// zoom transitions run with the same duration for all layers, so if one of transitionend events
		// happens after starting zoom animation (propagating to the map pane), we know that it ended globally
		if (this._zoomAnimated) {
			L.DomEvent.on(this._mapPane, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);
		}
	});
}

L.Map.include(!L.DomUtil.TRANSITION ? {} : {

	_catchTransitionEnd: function (e) {
		if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
			this._onZoomTransitionEnd();
		}
	},

	_nothingToAnimate: function () {
		return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
	},

	_tryAnimatedZoom: function (center, zoom, options) {

		if (this._animatingZoom) { return true; }

		options = options || {};

		// don't animate if disabled, not supported or zoom difference is too large
		if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||
		        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }

		// offset is the pixel coords of the zoom origin relative to the current center
		var scale = this.getZoomScale(zoom),
		    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale),
			origin = this._getCenterLayerPoint()._add(offset);

		// don't animate if the zoom origin isn't within one screen from the current center, unless forced
		if (options.animate !== true && !this.getSize().contains(offset)) { return false; }

		this
		    .fire('movestart')
		    .fire('zoomstart');

		this._animateZoom(center, zoom, origin, scale, null, true);

		return true;
	},

	_animateZoom: function (center, zoom, origin, scale, delta, backwards, forTouchZoom) {

		if (!forTouchZoom) {
			this._animatingZoom = true;
		}

		// put transform transition on all layers with leaflet-zoom-animated class
		L.DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');

		// remember what center/zoom to set after animation
		this._animateToCenter = center;
		this._animateToZoom = zoom;

		// disable any dragging during animation
		if (L.Draggable) {
			L.Draggable._disabled = true;
		}

		L.Util.requestAnimFrame(function () {
			this.fire('zoomanim', {
				center: center,
				zoom: zoom,
				origin: origin,
				scale: scale,
				delta: delta,
				backwards: backwards
			});
			// horrible hack to work around a Chrome bug https://github.com/Leaflet/Leaflet/issues/3689
			setTimeout(L.bind(this._onZoomTransitionEnd, this), 250);
		}, this);
	},

	_onZoomTransitionEnd: function () {
		if (!this._animatingZoom) { return; }

		this._animatingZoom = false;

		L.DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');

		this._resetView(this._animateToCenter, this._animateToZoom, true, true);

		if (L.Draggable) {
			L.Draggable._disabled = false;
		}
	}
});


/*
	Zoom animation logic for L.TileLayer.
*/

L.TileLayer.include({
	_animateZoom: function (e) {
		if (!this._animating) {
			this._animating = true;
			this._prepareBgBuffer();
		}

		var bg = this._bgBuffer,
		    transform = L.DomUtil.TRANSFORM,
		    initialTransform = e.delta ? L.DomUtil.getTranslateString(e.delta) : bg.style[transform],
		    scaleStr = L.DomUtil.getScaleString(e.scale, e.origin);

		bg.style[transform] = e.backwards ?
				scaleStr + ' ' + initialTransform :
				initialTransform + ' ' + scaleStr;
	},

	_endZoomAnim: function () {
		var front = this._tileContainer,
		    bg = this._bgBuffer;

		front.style.visibility = '';
		front.parentNode.appendChild(front); // Bring to fore

		// force reflow
		L.Util.falseFn(bg.offsetWidth);

		var zoom = this._map.getZoom();
		if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
			this._clearBgBuffer();
		}

		this._animating = false;
	},

	_clearBgBuffer: function () {
		var map = this._map;

		if (map && !map._animatingZoom && !map.touchZoom._zooming) {
			this._bgBuffer.innerHTML = '';
			this._bgBuffer.style[L.DomUtil.TRANSFORM] = '';
		}
	},

	_prepareBgBuffer: function () {

		var front = this._tileContainer,
		    bg = this._bgBuffer;

		// if foreground layer doesn't have many tiles but bg layer does,
		// keep the existing bg layer and just zoom it some more

		var bgLoaded = this._getLoadedTilesPercentage(bg),
		    frontLoaded = this._getLoadedTilesPercentage(front);

		if (bg && bgLoaded > 0.5 && frontLoaded < 0.5) {

			front.style.visibility = 'hidden';
			this._stopLoadingImages(front);
			return;
		}

		// prepare the buffer to become the front tile pane
		bg.style.visibility = 'hidden';
		bg.style[L.DomUtil.TRANSFORM] = '';

		// switch out the current layer to be the new bg layer (and vice-versa)
		this._tileContainer = bg;
		bg = this._bgBuffer = front;

		this._stopLoadingImages(bg);

		//prevent bg buffer from clearing right after zoom
		clearTimeout(this._clearBgBufferTimer);
	},

	_getLoadedTilesPercentage: function (container) {
		var tiles = container.getElementsByTagName('img'),
		    i, len, count = 0;

		for (i = 0, len = tiles.length; i < len; i++) {
			if (tiles[i].complete) {
				count++;
			}
		}
		return count / len;
	},

	// stops loading all tiles in the background layer
	_stopLoadingImages: function (container) {
		var tiles = Array.prototype.slice.call(container.getElementsByTagName('img')),
		    i, len, tile;

		for (i = 0, len = tiles.length; i < len; i++) {
			tile = tiles[i];

			if (!tile.complete) {
				tile.onload = L.Util.falseFn;
				tile.onerror = L.Util.falseFn;
				tile.src = L.Util.emptyImageUrl;

				tile.parentNode.removeChild(tile);
			}
		}
	}
});


/*
 * Provides L.Map with convenient shortcuts for using browser geolocation features.
 */

L.Map.include({
	_defaultLocateOptions: {
		watch: false,
		setView: false,
		maxZoom: Infinity,
		timeout: 10000,
		maximumAge: 0,
		enableHighAccuracy: false
	},

	locate: function (/*Object*/ options) {

		options = this._locateOptions = L.extend(this._defaultLocateOptions, options);

		if (!navigator.geolocation) {
			this._handleGeolocationError({
				code: 0,
				message: 'Geolocation not supported.'
			});
			return this;
		}

		var onResponse = L.bind(this._handleGeolocationResponse, this),
			onError = L.bind(this._handleGeolocationError, this);

		if (options.watch) {
			this._locationWatchId =
			        navigator.geolocation.watchPosition(onResponse, onError, options);
		} else {
			navigator.geolocation.getCurrentPosition(onResponse, onError, options);
		}
		return this;
	},

	stopLocate: function () {
		if (navigator.geolocation) {
			navigator.geolocation.clearWatch(this._locationWatchId);
		}
		if (this._locateOptions) {
			this._locateOptions.setView = false;
		}
		return this;
	},

	_handleGeolocationError: function (error) {
		var c = error.code,
		    message = error.message ||
		            (c === 1 ? 'permission denied' :
		            (c === 2 ? 'position unavailable' : 'timeout'));

		if (this._locateOptions.setView && !this._loaded) {
			this.fitWorld();
		}

		this.fire('locationerror', {
			code: c,
			message: 'Geolocation error: ' + message + '.'
		});
	},

	_handleGeolocationResponse: function (pos) {
		var lat = pos.coords.latitude,
		    lng = pos.coords.longitude,
		    latlng = new L.LatLng(lat, lng),

		    latAccuracy = 180 * pos.coords.accuracy / 40075017,
		    lngAccuracy = latAccuracy / Math.cos(L.LatLng.DEG_TO_RAD * lat),

		    bounds = L.latLngBounds(
		            [lat - latAccuracy, lng - lngAccuracy],
		            [lat + latAccuracy, lng + lngAccuracy]),

		    options = this._locateOptions;

		if (options.setView) {
			var zoom = Math.min(this.getBoundsZoom(bounds), options.maxZoom);
			this.setView(latlng, zoom);
		}

		var data = {
			latlng: latlng,
			bounds: bounds,
			timestamp: pos.timestamp
		};

		for (var i in pos.coords) {
			if (typeof pos.coords[i] === 'number') {
				data[i] = pos.coords[i];
			}
		}

		this.fire('locationfound', data);
	}
});


}(window, document));
},{}],26:[function(require,module,exports){
(function (global){
'use strict';

var jsonp = require('jsonp');
var qs = require('query-string');

var prefix = 'nominatim_callback_';
var BASE_URL = 'https://nominatim.openstreetmap.org/';

var cbCounter = 0;

function noop() {}

function geocode(options, callback, context) {
  callback = callback || noop;
  options = options || { q: '' };

  options.format = 'json';
  options.addressdetails = 1;

  var url = BASE_URL + 'search?' + qs.stringify(options);
  var name = options.callback || prefix + cbCounter++;
  jsonp(url, { prefix: prefix, param: 'json_callback', name: name }, function () {
    callback.apply(context, arguments);
    if (name in global) global[name] = undefined;
  });
}

function reverse(options, callback, context) {
  callback = callback || noop;
  options = options || {};

  options.format = 'json';
  options.addressdetails = 1;

  var url = BASE_URL + 'reverse?' + qs.stringify(options);
  var name = options.callback || prefix + cbCounter++;
  jsonp(url, { prefix: prefix, param: 'json_callback', name: name }, function () {
    callback.apply(context, arguments);
    if (name in global) global[name] = undefined;
  });
}

module.exports = { geocode: geocode, reverse: reverse };

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"jsonp":15,"query-string":27}],27:[function(require,module,exports){
'use strict';
var strictUriEncode = require('strict-uri-encode');

exports.extract = function (str) {
	return str.split('?')[1] || '';
};

exports.parse = function (str) {
	if (typeof str !== 'string') {
		return {};
	}

	str = str.trim().replace(/^(\?|#|&)/, '');

	if (!str) {
		return {};
	}

	return str.split('&').reduce(function (ret, param) {
		var parts = param.replace(/\+/g, ' ').split('=');
		// Firefox (pre 40) decodes `%3D` to `=`
		// https://github.com/sindresorhus/query-string/pull/37
		var key = parts.shift();
		var val = parts.length > 0 ? parts.join('=') : undefined;

		key = decodeURIComponent(key);

		// missing `=` should be `null`:
		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
		val = val === undefined ? null : decodeURIComponent(val);

		if (!ret.hasOwnProperty(key)) {
			ret[key] = val;
		} else if (Array.isArray(ret[key])) {
			ret[key].push(val);
		} else {
			ret[key] = [ret[key], val];
		}

		return ret;
	}, {});
};

exports.stringify = function (obj) {
	return obj ? Object.keys(obj).sort().map(function (key) {
		var val = obj[key];

		if (val === undefined) {
			return '';
		}

		if (val === null) {
			return key;
		}

		if (Array.isArray(val)) {
			return val.sort().map(function (val2) {
				return strictUriEncode(key) + '=' + strictUriEncode(val2);
			}).join('&');
		}

		return strictUriEncode(key) + '=' + strictUriEncode(val);
	}).filter(function (x) {
		return x.length > 0;
	}).join('&') : '';
};

},{"strict-uri-encode":28}],28:[function(require,module,exports){
'use strict';
module.exports = function (str) {
	return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
		return '%' + c.charCodeAt(0).toString(16);
	});
};

},{}],29:[function(require,module,exports){
// Implementation of the Greiner-Hormann polygon clipping algorithm
//

var segseg = require('segseg');
var preprocessPolygon = require("point-in-big-polygon");
var area = require('2d-polygon-area');
var sign = require('signum');
var abs = Math.abs;

function copy(a) {
  var l = a.length;
  var out = new Array(l);
  for (var i = 0; i<l; i++) {
    out[i] = a[i].slice();
  }
  return out;
}

function Node(vec, alpha, intersection) {
  this.vec = vec;
  this.alpha = alpha || 0;
  this.intersect = !!intersection;
}

Node.prototype = {
  vec: null,
  next: null,
  next: null,
  prev: null,
  nextPoly: null,
  neighbor: null,
  intersect: null,
  entry: null,
  visited : false,
  alpha : 0,

  nextNonIntersection : function nodeNextNonIntersection() {
    var a = this;
    while(a && a.intersect) {
      a = a.next;
    }
    return a;
  },

  last : function nodeLast() {
    var a = this;
    while (a.next && a.next !== this) {
      a = a.next;
    }
    return a;
  },

  createLoop : function nodeCreateLoop() {
    var last = this.last();
    last.prev.next = this;
    this.prev = last.prev;
  },

  firstNodeOfInterest : function nodeFirstNodeOfInterest() {
    var a = this;

    if (a) {
      do {
        a=a.next;
      } while(a!==this && (!a.intersect || a.intersect && a.visited));
    }

    return a;
  },

  insertBetween : function nodeInsertBetween(first, last) {
    var a = first;
    while(a !== last && a.alpha < this.alpha) {
      a = a.next;
    }

    this.next = a;
    this.prev = a.prev;
    if (this.prev) {
      this.prev.next = this;
    }

    this.next.prev = this;
  }
};


function createLinkedList(vecs) {
  var l = vecs.length;
  var ret, where;
  for (var i=0; i<l; i++) {
    var current = vecs[i];
    if (!ret) {
      where = ret = new Node(current);
    } else {
      where.next = new Node(current);
      where.next.prev = where;
      where = where.next;
    }
  }

  return ret;
}

function distance(v1, v2) {
  var x = v1[0] - v2[0];
  var y = v1[1] - v2[1];
  return Math.sqrt(x*x + y*y);
}

function clean(array) {
  var seen = {};
  var cur = array.length - 1;
  while (cur--) {
    var c = array[cur];
    var p = array[cur+1];
    if (c[0] === p[0] && c[1] === p[1]) {
      array.splice(cur, 1);
    }
  }
  return array;
}


function identifyIntersections(subjectList, clipList) {
  var subject, clip;
  var auxs = subjectList.last();
  auxs.next = new Node(subjectList.vec, auxs);
  auxs.next.prev = auxs;

  var auxc = clipList.last();
  auxc.next = new Node(clipList.vec, auxc);
  auxc.next.prev = auxc;

  var found = false;
  for(subject = subjectList; subject.next; subject = subject.next) {
    if(!subject.intersect) {
      for(clip = clipList; clip.next; clip = clip.next) {
        if(!clip.intersect) {

          var a = subject.vec,
              b = subject.next.nextNonIntersection().vec,
              c = clip.vec,
              d = clip.next.nextNonIntersection().vec;

          var i = segseg(a, b, c, d);

          if(i && i !== true) {
            found = true;
            var intersectionSubject = new Node(i, distance(a, i) / distance(a, b), true);
            var intersectionClip = new Node(i, distance(c, i) / distance(c, d), true);
            intersectionSubject.neighbor = intersectionClip;
            intersectionClip.neighbor = intersectionSubject;
            intersectionSubject.insertBetween(subject, subject.next.nextNonIntersection());
            intersectionClip.insertBetween(clip, clip.next.nextNonIntersection());
          }
        }
      }
    }
  }

  return found;
};

function identifyIntersectionType(subjectList, clipList, clipTest, subjectTest, type) {
  var subject, clip;
  var se = clipTest(subjectList.vec) < 0;
  if (type === 'and') {
    se = !se;
  }

  for(subject = subjectList; subject.next; subject = subject.next) {
    if(subject.intersect) {
      subject.entry = se;
      se = !se;
    }
  }

  var ce = subjectTest(clipList.vec) > 0;
  if (type === 'or') {
    ce = !ce;
  }

  for(clip = clipList; clip.next; clip = clip.next) {
    if(clip.intersect) {
      clip.entry = ce;
      ce = !ce;
    }
  }
};

function collectClipResults(subjectList, clipList) {
  subjectList.createLoop();
  clipList.createLoop();

  var crt, results = [], result;

  while ((crt = subjectList.firstNodeOfInterest()) !== subjectList) {
    result = [];
    for (; !crt.visited; crt = crt.neighbor) {

      result.push(crt.vec);
      var forward = crt.entry
      while(true) {
        crt.visited = true;
        crt = forward ? crt.next : crt.prev;

        if(crt.intersect) {
          crt.visited = true;
          break;
        } else {
          result.push(crt.vec);
        }
      }
    }

    results.push(clean(result));
  }

  return results;
};

function polygonBoolean(subjectPoly, clipPoly, operation) {

  var subjectList = createLinkedList(subjectPoly);
  var clipList = createLinkedList(clipPoly);
  var clipContains = preprocessPolygon([clipPoly]);
  var subjectContains = preprocessPolygon([subjectPoly]);

  var subject, clip, res;

  // Phase 1: Identify and store intersections between the subject
  //          and clip polygons
  var isects = identifyIntersections(subjectList, clipList);

  if (isects) {
    // Phase 2: walk the resulting linked list and mark each intersection
    //          as entering or exiting
    identifyIntersectionType(
      subjectList,
      clipList,
      clipContains,
      subjectContains,
      operation
    );

    // Phase 3: collect resulting polygons
    res = collectClipResults(subjectList, clipList);
  } else {
    // No intersections

    var inner = clipContains(subjectPoly[0]) < 0;
    var outer = subjectContains(clipPoly[0]) < 0;

    // TODO: slice will not copy the vecs

    res = [];
    switch (operation) {
      case 'or':
        if (!inner && !outer) {
          res.push(copy(subjectPoly));
          res.push(copy(clipPoly));
        } else if (inner) {
          res.push(copy(clipPoly));
        } else if (outer) {
          res.push(copy(subjectPoly));
        }
      break;

      case 'and':
        if (inner) {
          res.push(copy(subjectPoly))
        } else if (outer) {
          res.push(copy(clipPoly));
        } else {
          throw new Error('woops')
        }
      break;

      case 'not':
        var sclone = copy(subjectPoly);
        var cclone = copy(clipPoly);

        var sarea = area(sclone);
        var carea = area(cclone);
        if (sign(sarea) === sign(carea)) {
          if (outer) {
            cclone.reverse();
          } else if (inner) {
            sclone.reverse();
          }
        }

        res.push(sclone);

        if (abs(sarea) > abs(carea)) {
          res.push(cclone);
        } else {
          res.unshift(cclone);
        }

      break
    }
  }

  return res;
};

module.exports = polygonBoolean;

},{"2d-polygon-area":30,"point-in-big-polygon":41,"segseg":56,"signum":42}],30:[function(require,module,exports){
module.exports = area;

var e0 = [0, 0];
var e1 = [0, 0];

function area(a) {
  var area = 0;
  var first = a[0];

  var l = a.length;
  for (var i=2; i<l; i++) {
    var p = a[i-1];
    var c = a[i];
    e0[0] = first[0] - c[0];
    e0[1] = first[1] - c[1];
    e1[0] = first[0] - p[0];
    e1[1] = first[1] - p[1];

    area += (e0[0] * e1[1]) - (e0[1] * e1[0]);
  }
  return area/2;
}

},{}],31:[function(require,module,exports){
"use strict"

module.exports = fastTwoSum

function fastTwoSum(a, b, result) {
	var x = a + b
	var bv = x - a
	var av = x - bv
	var br = b - bv
	var ar = a - av
	if(result) {
		result[0] = ar + br
		result[1] = x
		return result
	}
	return [ar+br, x]
}
},{}],32:[function(require,module,exports){
"use strict"

var twoProduct = require("two-product")
var twoSum = require("two-sum")

module.exports = scaleLinearExpansion

function scaleLinearExpansion(e, scale) {
  var n = e.length
  if(n === 1) {
    var ts = twoProduct(e[0], scale)
    if(ts[0]) {
      return ts
    }
    return [ ts[1] ]
  }
  var g = new Array(2 * n)
  var q = [0.1, 0.1]
  var t = [0.1, 0.1]
  var count = 0
  twoProduct(e[0], scale, q)
  if(q[0]) {
    g[count++] = q[0]
  }
  for(var i=1; i<n; ++i) {
    twoProduct(e[i], scale, t)
    var pq = q[1]
    twoSum(pq, t[0], q)
    if(q[0]) {
      g[count++] = q[0]
    }
    var a = t[1]
    var b = q[1]
    var x = a + b
    var bv = x - a
    var y = b - bv
    q[1] = x
    if(y) {
      g[count++] = y
    }
  }
  if(q[1]) {
    g[count++] = q[1]
  }
  if(count === 0) {
    g[count++] = 0.0
  }
  g.length = count
  return g
}
},{"two-product":35,"two-sum":31}],33:[function(require,module,exports){
"use strict"

module.exports = robustSubtract

//Easy case: Add two scalars
function scalarScalar(a, b) {
  var x = a + b
  var bv = x - a
  var av = x - bv
  var br = b - bv
  var ar = a - av
  var y = ar + br
  if(y) {
    return [y, x]
  }
  return [x]
}

function robustSubtract(e, f) {
  var ne = e.length|0
  var nf = f.length|0
  if(ne === 1 && nf === 1) {
    return scalarScalar(e[0], -f[0])
  }
  var n = ne + nf
  var g = new Array(n)
  var count = 0
  var eptr = 0
  var fptr = 0
  var abs = Math.abs
  var ei = e[eptr]
  var ea = abs(ei)
  var fi = -f[fptr]
  var fa = abs(fi)
  var a, b
  if(ea < fa) {
    b = ei
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
      ea = abs(ei)
    }
  } else {
    b = fi
    fptr += 1
    if(fptr < nf) {
      fi = -f[fptr]
      fa = abs(fi)
    }
  }
  if((eptr < ne && ea < fa) || (fptr >= nf)) {
    a = ei
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
      ea = abs(ei)
    }
  } else {
    a = fi
    fptr += 1
    if(fptr < nf) {
      fi = -f[fptr]
      fa = abs(fi)
    }
  }
  var x = a + b
  var bv = x - a
  var y = b - bv
  var q0 = y
  var q1 = x
  var _x, _bv, _av, _br, _ar
  while(eptr < ne && fptr < nf) {
    if(ea < fa) {
      a = ei
      eptr += 1
      if(eptr < ne) {
        ei = e[eptr]
        ea = abs(ei)
      }
    } else {
      a = fi
      fptr += 1
      if(fptr < nf) {
        fi = -f[fptr]
        fa = abs(fi)
      }
    }
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    }
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
  }
  while(eptr < ne) {
    a = ei
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    }
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
    }
  }
  while(fptr < nf) {
    a = fi
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    } 
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
    fptr += 1
    if(fptr < nf) {
      fi = -f[fptr]
    }
  }
  if(q0) {
    g[count++] = q0
  }
  if(q1) {
    g[count++] = q1
  }
  if(!count) {
    g[count++] = 0.0  
  }
  g.length = count
  return g
}
},{}],34:[function(require,module,exports){
"use strict"

module.exports = linearExpansionSum

//Easy case: Add two scalars
function scalarScalar(a, b) {
  var x = a + b
  var bv = x - a
  var av = x - bv
  var br = b - bv
  var ar = a - av
  var y = ar + br
  if(y) {
    return [y, x]
  }
  return [x]
}

function linearExpansionSum(e, f) {
  var ne = e.length|0
  var nf = f.length|0
  if(ne === 1 && nf === 1) {
    return scalarScalar(e[0], f[0])
  }
  var n = ne + nf
  var g = new Array(n)
  var count = 0
  var eptr = 0
  var fptr = 0
  var abs = Math.abs
  var ei = e[eptr]
  var ea = abs(ei)
  var fi = f[fptr]
  var fa = abs(fi)
  var a, b
  if(ea < fa) {
    b = ei
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
      ea = abs(ei)
    }
  } else {
    b = fi
    fptr += 1
    if(fptr < nf) {
      fi = f[fptr]
      fa = abs(fi)
    }
  }
  if((eptr < ne && ea < fa) || (fptr >= nf)) {
    a = ei
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
      ea = abs(ei)
    }
  } else {
    a = fi
    fptr += 1
    if(fptr < nf) {
      fi = f[fptr]
      fa = abs(fi)
    }
  }
  var x = a + b
  var bv = x - a
  var y = b - bv
  var q0 = y
  var q1 = x
  var _x, _bv, _av, _br, _ar
  while(eptr < ne && fptr < nf) {
    if(ea < fa) {
      a = ei
      eptr += 1
      if(eptr < ne) {
        ei = e[eptr]
        ea = abs(ei)
      }
    } else {
      a = fi
      fptr += 1
      if(fptr < nf) {
        fi = f[fptr]
        fa = abs(fi)
      }
    }
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    }
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
  }
  while(eptr < ne) {
    a = ei
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    }
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
    }
  }
  while(fptr < nf) {
    a = fi
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    } 
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
    fptr += 1
    if(fptr < nf) {
      fi = f[fptr]
    }
  }
  if(q0) {
    g[count++] = q0
  }
  if(q1) {
    g[count++] = q1
  }
  if(!count) {
    g[count++] = 0.0  
  }
  g.length = count
  return g
}
},{}],35:[function(require,module,exports){
"use strict"

module.exports = twoProduct

var SPLITTER = +(Math.pow(2, 27) + 1.0)

function twoProduct(a, b, result) {
  var x = a * b

  var c = SPLITTER * a
  var abig = c - a
  var ahi = c - abig
  var alo = a - ahi

  var d = SPLITTER * b
  var bbig = d - b
  var bhi = d - bbig
  var blo = b - bhi

  var err1 = x - (ahi * bhi)
  var err2 = err1 - (alo * bhi)
  var err3 = err2 - (ahi * blo)

  var y = alo * blo - err3

  if(result) {
    result[0] = y
    result[1] = x
    return result
  }

  return [ y, x ]
}
},{}],36:[function(require,module,exports){
"use strict"

var twoProduct = require("two-product")
var robustSum = require("robust-sum")
var robustScale = require("robust-scale")
var robustSubtract = require("robust-subtract")

var NUM_EXPAND = 5

var EPSILON     = 1.1102230246251565e-16
var ERRBOUND3   = (3.0 + 16.0 * EPSILON) * EPSILON
var ERRBOUND4   = (7.0 + 56.0 * EPSILON) * EPSILON

function cofactor(m, c) {
  var result = new Array(m.length-1)
  for(var i=1; i<m.length; ++i) {
    var r = result[i-1] = new Array(m.length-1)
    for(var j=0,k=0; j<m.length; ++j) {
      if(j === c) {
        continue
      }
      r[k++] = m[i][j]
    }
  }
  return result
}

function matrix(n) {
  var result = new Array(n)
  for(var i=0; i<n; ++i) {
    result[i] = new Array(n)
    for(var j=0; j<n; ++j) {
      result[i][j] = ["m", j, "[", (n-i-1), "]"].join("")
    }
  }
  return result
}

function sign(n) {
  if(n & 1) {
    return "-"
  }
  return ""
}

function generateSum(expr) {
  if(expr.length === 1) {
    return expr[0]
  } else if(expr.length === 2) {
    return ["sum(", expr[0], ",", expr[1], ")"].join("")
  } else {
    var m = expr.length>>1
    return ["sum(", generateSum(expr.slice(0, m)), ",", generateSum(expr.slice(m)), ")"].join("")
  }
}

function determinant(m) {
  if(m.length === 2) {
    return [["sum(prod(", m[0][0], ",", m[1][1], "),prod(-", m[0][1], ",", m[1][0], "))"].join("")]
  } else {
    var expr = []
    for(var i=0; i<m.length; ++i) {
      expr.push(["scale(", generateSum(determinant(cofactor(m, i))), ",", sign(i), m[0][i], ")"].join(""))
    }
    return expr
  }
}

function orientation(n) {
  var pos = []
  var neg = []
  var m = matrix(n)
  var args = []
  for(var i=0; i<n; ++i) {
    if((i&1)===0) {
      pos.push.apply(pos, determinant(cofactor(m, i)))
    } else {
      neg.push.apply(neg, determinant(cofactor(m, i)))
    }
    args.push("m" + i)
  }
  var posExpr = generateSum(pos)
  var negExpr = generateSum(neg)
  var funcName = "orientation" + n + "Exact"
  var code = ["function ", funcName, "(", args.join(), "){var p=", posExpr, ",n=", negExpr, ",d=sub(p,n);\
return d[d.length-1];};return ", funcName].join("")
  var proc = new Function("sum", "prod", "scale", "sub", code)
  return proc(robustSum, twoProduct, robustScale, robustSubtract)
}

var orientation3Exact = orientation(3)
var orientation4Exact = orientation(4)

var CACHED = [
  function orientation0() { return 0 },
  function orientation1() { return 0 },
  function orientation2(a, b) { 
    return b[0] - a[0]
  },
  function orientation3(a, b, c) {
    var l = (a[1] - c[1]) * (b[0] - c[0])
    var r = (a[0] - c[0]) * (b[1] - c[1])
    var det = l - r
    var s
    if(l > 0) {
      if(r <= 0) {
        return det
      } else {
        s = l + r
      }
    } else if(l < 0) {
      if(r >= 0) {
        return det
      } else {
        s = -(l + r)
      }
    } else {
      return det
    }
    var tol = ERRBOUND3 * s
    if(det >= tol || det <= -tol) {
      return det
    }
    return orientation3Exact(a, b, c)
  },
  function orientation4(a,b,c,d) {
    var adx = a[0] - d[0]
    var bdx = b[0] - d[0]
    var cdx = c[0] - d[0]
    var ady = a[1] - d[1]
    var bdy = b[1] - d[1]
    var cdy = c[1] - d[1]
    var adz = a[2] - d[2]
    var bdz = b[2] - d[2]
    var cdz = c[2] - d[2]
    var bdxcdy = bdx * cdy
    var cdxbdy = cdx * bdy
    var cdxady = cdx * ady
    var adxcdy = adx * cdy
    var adxbdy = adx * bdy
    var bdxady = bdx * ady
    var det = adz * (bdxcdy - cdxbdy) 
            + bdz * (cdxady - adxcdy)
            + cdz * (adxbdy - bdxady)
    var permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * Math.abs(adz)
                  + (Math.abs(cdxady) + Math.abs(adxcdy)) * Math.abs(bdz)
                  + (Math.abs(adxbdy) + Math.abs(bdxady)) * Math.abs(cdz)
    var tol = ERRBOUND4 * permanent
    if ((det > tol) || (-det > tol)) {
      return det
    }
    return orientation4Exact(a,b,c,d)
  }
]

function slowOrient(args) {
  var proc = CACHED[args.length]
  if(!proc) {
    proc = CACHED[args.length] = orientation(args.length)
  }
  return proc.apply(undefined, args)
}

function generateOrientationProc() {
  while(CACHED.length <= NUM_EXPAND) {
    CACHED.push(orientation(CACHED.length))
  }
  var args = []
  var procArgs = ["slow"]
  for(var i=0; i<=NUM_EXPAND; ++i) {
    args.push("a" + i)
    procArgs.push("o" + i)
  }
  var code = [
    "function getOrientation(", args.join(), "){switch(arguments.length){case 0:case 1:return 0;"
  ]
  for(var i=2; i<=NUM_EXPAND; ++i) {
    code.push("case ", i, ":return o", i, "(", args.slice(0, i).join(), ");")
  }
  code.push("}var s=new Array(arguments.length);for(var i=0;i<arguments.length;++i){s[i]=arguments[i]};return slow(s);}return getOrientation")
  procArgs.push(code.join(""))

  var proc = Function.apply(undefined, procArgs)
  module.exports = proc.apply(undefined, [slowOrient].concat(CACHED))
  for(var i=0; i<=NUM_EXPAND; ++i) {
    module.exports[i] = CACHED[i]
  }
}

generateOrientationProc()
},{"robust-scale":32,"robust-subtract":33,"robust-sum":34,"two-product":35}],37:[function(require,module,exports){
"use strict"

module.exports = orderSegments

var orient = require("robust-orientation")

function horizontalOrder(a, b) {
  var bl, br
  if(b[0][0] < b[1][0]) {
    bl = b[0]
    br = b[1]
  } else if(b[0][0] > b[1][0]) {
    bl = b[1]
    br = b[0]
  } else {
    var alo = Math.min(a[0][1], a[1][1])
    var ahi = Math.max(a[0][1], a[1][1])
    var blo = Math.min(b[0][1], b[1][1])
    var bhi = Math.max(b[0][1], b[1][1])
    if(ahi < blo) {
      return ahi - blo
    }
    if(alo > bhi) {
      return alo - bhi
    }
    return ahi - bhi
  }
  var al, ar
  if(a[0][1] < a[1][1]) {
    al = a[0]
    ar = a[1]
  } else {
    al = a[1]
    ar = a[0]
  }
  var d = orient(br, bl, al)
  if(d) {
    return d
  }
  d = orient(br, bl, ar)
  if(d) {
    return d
  }
  return ar - br
}

function orderSegments(b, a) {
  var al, ar
  if(a[0][0] < a[1][0]) {
    al = a[0]
    ar = a[1]
  } else if(a[0][0] > a[1][0]) {
    al = a[1]
    ar = a[0]
  } else {
    return horizontalOrder(a, b)
  }
  var bl, br
  if(b[0][0] < b[1][0]) {
    bl = b[0]
    br = b[1]
  } else if(b[0][0] > b[1][0]) {
    bl = b[1]
    br = b[0]
  } else {
    return -horizontalOrder(b, a)
  }
  var d1 = orient(al, ar, br)
  var d2 = orient(al, ar, bl)
  if(d1 < 0) {
    if(d2 <= 0) {
      return d1
    }
  } else if(d1 > 0) {
    if(d2 >= 0) {
      return d1
    }
  } else if(d2) {
    return d2
  }
  d1 = orient(br, bl, ar)
  d2 = orient(br, bl, al)
  if(d1 < 0) {
    if(d2 <= 0) {
      return d1
    }
  } else if(d1 > 0) {
    if(d2 >= 0) {
      return d1
    }
  } else if(d2) {
    return d2
  }
  return ar[0] - br[0]
}
},{"robust-orientation":36}],38:[function(require,module,exports){
"use strict"

function compileSearch(funcName, predicate, reversed, extraArgs, useNdarray, earlyOut) {
  var code = [
    "function ", funcName, "(a,l,h,", extraArgs.join(","),  "){",
earlyOut ? "" : "var i=", (reversed ? "l-1" : "h+1"),
";while(l<=h){\
var m=(l+h)>>>1,x=a", useNdarray ? ".get(m)" : "[m]"]
  if(earlyOut) {
    if(predicate.indexOf("c") < 0) {
      code.push(";if(x===y){return m}else if(x<=y){")
    } else {
      code.push(";var p=c(x,y);if(p===0){return m}else if(p<=0){")
    }
  } else {
    code.push(";if(", predicate, "){i=m;")
  }
  if(reversed) {
    code.push("l=m+1}else{h=m-1}")
  } else {
    code.push("h=m-1}else{l=m+1}")
  }
  code.push("}")
  if(earlyOut) {
    code.push("return -1};")
  } else {
    code.push("return i};")
  }
  return code.join("")
}

function compileBoundsSearch(predicate, reversed, suffix, earlyOut) {
  var result = new Function([
  compileSearch("A", "x" + predicate + "y", reversed, ["y"], false, earlyOut),
  compileSearch("B", "x" + predicate + "y", reversed, ["y"], true, earlyOut),
  compileSearch("P", "c(x,y)" + predicate + "0", reversed, ["y", "c"], false, earlyOut),
  compileSearch("Q", "c(x,y)" + predicate + "0", reversed, ["y", "c"], true, earlyOut),
"function dispatchBsearch", suffix, "(a,y,c,l,h){\
if(a.shape){\
if(typeof(c)==='function'){\
return Q(a,(l===undefined)?0:l|0,(h===undefined)?a.shape[0]-1:h|0,y,c)\
}else{\
return B(a,(c===undefined)?0:c|0,(l===undefined)?a.shape[0]-1:l|0,y)\
}}else{\
if(typeof(c)==='function'){\
return P(a,(l===undefined)?0:l|0,(h===undefined)?a.length-1:h|0,y,c)\
}else{\
return A(a,(c===undefined)?0:c|0,(l===undefined)?a.length-1:l|0,y)\
}}}\
return dispatchBsearch", suffix].join(""))
  return result()
}

module.exports = {
  ge: compileBoundsSearch(">=", false, "GE"),
  gt: compileBoundsSearch(">", false, "GT"),
  lt: compileBoundsSearch("<", true, "LT"),
  le: compileBoundsSearch("<=", true, "LE"),
  eq: compileBoundsSearch("-", true, "EQ", true)
}

},{}],39:[function(require,module,exports){
"use strict"

module.exports = createRBTree

var RED   = 0
var BLACK = 1

function RBNode(color, key, value, left, right, count) {
  this._color = color
  this.key = key
  this.value = value
  this.left = left
  this.right = right
  this._count = count
}

function cloneNode(node) {
  return new RBNode(node._color, node.key, node.value, node.left, node.right, node._count)
}

function repaint(color, node) {
  return new RBNode(color, node.key, node.value, node.left, node.right, node._count)
}

function recount(node) {
  node._count = 1 + (node.left ? node.left._count : 0) + (node.right ? node.right._count : 0)
}

function RedBlackTree(compare, root) {
  this._compare = compare
  this.root = root
}

var proto = RedBlackTree.prototype

Object.defineProperty(proto, "keys", {
  get: function() {
    var result = []
    this.forEach(function(k,v) {
      result.push(k)
    })
    return result
  }
})

Object.defineProperty(proto, "values", {
  get: function() {
    var result = []
    this.forEach(function(k,v) {
      result.push(v)
    })
    return result
  }
})

//Returns the number of nodes in the tree
Object.defineProperty(proto, "length", {
  get: function() {
    if(this.root) {
      return this.root._count
    }
    return 0
  }
})

//Insert a new item into the tree
proto.insert = function(key, value) {
  var cmp = this._compare
  //Find point to insert new node at
  var n = this.root
  var n_stack = []
  var d_stack = []
  while(n) {
    var d = cmp(key, n.key)
    n_stack.push(n)
    d_stack.push(d)
    if(d <= 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  //Rebuild path to leaf node
  n_stack.push(new RBNode(RED, key, value, null, null, 1))
  for(var s=n_stack.length-2; s>=0; --s) {
    var n = n_stack[s]
    if(d_stack[s] <= 0) {
      n_stack[s] = new RBNode(n._color, n.key, n.value, n_stack[s+1], n.right, n._count+1)
    } else {
      n_stack[s] = new RBNode(n._color, n.key, n.value, n.left, n_stack[s+1], n._count+1)
    }
  }
  //Rebalance tree using rotations
  //console.log("start insert", key, d_stack)
  for(var s=n_stack.length-1; s>1; --s) {
    var p = n_stack[s-1]
    var n = n_stack[s]
    if(p._color === BLACK || n._color === BLACK) {
      break
    }
    var pp = n_stack[s-2]
    if(pp.left === p) {
      if(p.left === n) {
        var y = pp.right
        if(y && y._color === RED) {
          //console.log("LLr")
          p._color = BLACK
          pp.right = repaint(BLACK, y)
          pp._color = RED
          s -= 1
        } else {
          //console.log("LLb")
          pp._color = RED
          pp.left = p.right
          p._color = BLACK
          p.right = pp
          n_stack[s-2] = p
          n_stack[s-1] = n
          recount(pp)
          recount(p)
          if(s >= 3) {
            var ppp = n_stack[s-3]
            if(ppp.left === pp) {
              ppp.left = p
            } else {
              ppp.right = p
            }
          }
          break
        }
      } else {
        var y = pp.right
        if(y && y._color === RED) {
          //console.log("LRr")
          p._color = BLACK
          pp.right = repaint(BLACK, y)
          pp._color = RED
          s -= 1
        } else {
          //console.log("LRb")
          p.right = n.left
          pp._color = RED
          pp.left = n.right
          n._color = BLACK
          n.left = p
          n.right = pp
          n_stack[s-2] = n
          n_stack[s-1] = p
          recount(pp)
          recount(p)
          recount(n)
          if(s >= 3) {
            var ppp = n_stack[s-3]
            if(ppp.left === pp) {
              ppp.left = n
            } else {
              ppp.right = n
            }
          }
          break
        }
      }
    } else {
      if(p.right === n) {
        var y = pp.left
        if(y && y._color === RED) {
          //console.log("RRr", y.key)
          p._color = BLACK
          pp.left = repaint(BLACK, y)
          pp._color = RED
          s -= 1
        } else {
          //console.log("RRb")
          pp._color = RED
          pp.right = p.left
          p._color = BLACK
          p.left = pp
          n_stack[s-2] = p
          n_stack[s-1] = n
          recount(pp)
          recount(p)
          if(s >= 3) {
            var ppp = n_stack[s-3]
            if(ppp.right === pp) {
              ppp.right = p
            } else {
              ppp.left = p
            }
          }
          break
        }
      } else {
        var y = pp.left
        if(y && y._color === RED) {
          //console.log("RLr")
          p._color = BLACK
          pp.left = repaint(BLACK, y)
          pp._color = RED
          s -= 1
        } else {
          //console.log("RLb")
          p.left = n.right
          pp._color = RED
          pp.right = n.left
          n._color = BLACK
          n.right = p
          n.left = pp
          n_stack[s-2] = n
          n_stack[s-1] = p
          recount(pp)
          recount(p)
          recount(n)
          if(s >= 3) {
            var ppp = n_stack[s-3]
            if(ppp.right === pp) {
              ppp.right = n
            } else {
              ppp.left = n
            }
          }
          break
        }
      }
    }
  }
  //Return new tree
  n_stack[0]._color = BLACK
  return new RedBlackTree(cmp, n_stack[0])
}


//Visit all nodes inorder
function doVisitFull(visit, node) {
  if(node.left) {
    var v = doVisitFull(visit, node.left)
    if(v) { return v }
  }
  var v = visit(node.key, node.value)
  if(v) { return v }
  if(node.right) {
    return doVisitFull(visit, node.right)
  }
}

//Visit half nodes in order
function doVisitHalf(lo, compare, visit, node) {
  var l = compare(lo, node.key)
  if(l <= 0) {
    if(node.left) {
      var v = doVisitHalf(lo, compare, visit, node.left)
      if(v) { return v }
    }
    var v = visit(node.key, node.value)
    if(v) { return v }
  }
  if(node.right) {
    return doVisitHalf(lo, compare, visit, node.right)
  }
}

//Visit all nodes within a range
function doVisit(lo, hi, compare, visit, node) {
  var l = compare(lo, node.key)
  var h = compare(hi, node.key)
  var v
  if(l <= 0) {
    if(node.left) {
      v = doVisit(lo, hi, compare, visit, node.left)
      if(v) { return v }
    }
    if(h > 0) {
      v = visit(node.key, node.value)
      if(v) { return v }
    }
  }
  if(h > 0 && node.right) {
    return doVisit(lo, hi, compare, visit, node.right)
  }
}


proto.forEach = function rbTreeForEach(visit, lo, hi) {
  if(!this.root) {
    return
  }
  switch(arguments.length) {
    case 1:
      return doVisitFull(visit, this.root)
    break

    case 2:
      return doVisitHalf(lo, this._compare, visit, this.root)
    break

    case 3:
      if(this._compare(lo, hi) >= 0) {
        return
      }
      return doVisit(lo, hi, this._compare, visit, this.root)
    break
  }
}

//First item in list
Object.defineProperty(proto, "begin", {
  get: function() {
    var stack = []
    var n = this.root
    while(n) {
      stack.push(n)
      n = n.left
    }
    return new RedBlackTreeIterator(this, stack)
  }
})

//Last item in list
Object.defineProperty(proto, "end", {
  get: function() {
    var stack = []
    var n = this.root
    while(n) {
      stack.push(n)
      n = n.right
    }
    return new RedBlackTreeIterator(this, stack)
  }
})

//Find the ith item in the tree
proto.at = function(idx) {
  if(idx < 0) {
    return new RedBlackTreeIterator(this, [])
  }
  var n = this.root
  var stack = []
  while(true) {
    stack.push(n)
    if(n.left) {
      if(idx < n.left._count) {
        n = n.left
        continue
      }
      idx -= n.left._count
    }
    if(!idx) {
      return new RedBlackTreeIterator(this, stack)
    }
    idx -= 1
    if(n.right) {
      if(idx >= n.right._count) {
        break
      }
      n = n.right
    } else {
      break
    }
  }
  return new RedBlackTreeIterator(this, [])
}

proto.ge = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  var last_ptr = 0
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d <= 0) {
      last_ptr = stack.length
    }
    if(d <= 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  stack.length = last_ptr
  return new RedBlackTreeIterator(this, stack)
}

proto.gt = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  var last_ptr = 0
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d < 0) {
      last_ptr = stack.length
    }
    if(d < 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  stack.length = last_ptr
  return new RedBlackTreeIterator(this, stack)
}

proto.lt = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  var last_ptr = 0
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d > 0) {
      last_ptr = stack.length
    }
    if(d <= 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  stack.length = last_ptr
  return new RedBlackTreeIterator(this, stack)
}

proto.le = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  var last_ptr = 0
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d >= 0) {
      last_ptr = stack.length
    }
    if(d < 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  stack.length = last_ptr
  return new RedBlackTreeIterator(this, stack)
}

//Finds the item with key if it exists
proto.find = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d === 0) {
      return new RedBlackTreeIterator(this, stack)
    }
    if(d <= 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  return new RedBlackTreeIterator(this, [])
}

//Removes item with key from tree
proto.remove = function(key) {
  var iter = this.find(key)
  if(iter) {
    return iter.remove()
  }
  return this
}

//Returns the item at `key`
proto.get = function(key) {
  var cmp = this._compare
  var n = this.root
  while(n) {
    var d = cmp(key, n.key)
    if(d === 0) {
      return n.value
    }
    if(d <= 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  return
}

//Iterator for red black tree
function RedBlackTreeIterator(tree, stack) {
  this.tree = tree
  this._stack = stack
}

var iproto = RedBlackTreeIterator.prototype

//Test if iterator is valid
Object.defineProperty(iproto, "valid", {
  get: function() {
    return this._stack.length > 0
  }
})

//Node of the iterator
Object.defineProperty(iproto, "node", {
  get: function() {
    if(this._stack.length > 0) {
      return this._stack[this._stack.length-1]
    }
    return null
  },
  enumerable: true
})

//Makes a copy of an iterator
iproto.clone = function() {
  return new RedBlackTreeIterator(this.tree, this._stack.slice())
}

//Swaps two nodes
function swapNode(n, v) {
  n.key = v.key
  n.value = v.value
  n.left = v.left
  n.right = v.right
  n._color = v._color
  n._count = v._count
}

//Fix up a double black node in a tree
function fixDoubleBlack(stack) {
  var n, p, s, z
  for(var i=stack.length-1; i>=0; --i) {
    n = stack[i]
    if(i === 0) {
      n._color = BLACK
      return
    }
    //console.log("visit node:", n.key, i, stack[i].key, stack[i-1].key)
    p = stack[i-1]
    if(p.left === n) {
      //console.log("left child")
      s = p.right
      if(s.right && s.right._color === RED) {
        //console.log("case 1: right sibling child red")
        s = p.right = cloneNode(s)
        z = s.right = cloneNode(s.right)
        p.right = s.left
        s.left = p
        s.right = z
        s._color = p._color
        n._color = BLACK
        p._color = BLACK
        z._color = BLACK
        recount(p)
        recount(s)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.left === p) {
            pp.left = s
          } else {
            pp.right = s
          }
        }
        stack[i-1] = s
        return
      } else if(s.left && s.left._color === RED) {
        //console.log("case 1: left sibling child red")
        s = p.right = cloneNode(s)
        z = s.left = cloneNode(s.left)
        p.right = z.left
        s.left = z.right
        z.left = p
        z.right = s
        z._color = p._color
        p._color = BLACK
        s._color = BLACK
        n._color = BLACK
        recount(p)
        recount(s)
        recount(z)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.left === p) {
            pp.left = z
          } else {
            pp.right = z
          }
        }
        stack[i-1] = z
        return
      }
      if(s._color === BLACK) {
        if(p._color === RED) {
          //console.log("case 2: black sibling, red parent", p.right.value)
          p._color = BLACK
          p.right = repaint(RED, s)
          return
        } else {
          //console.log("case 2: black sibling, black parent", p.right.value)
          p.right = repaint(RED, s)
          continue  
        }
      } else {
        //console.log("case 3: red sibling")
        s = cloneNode(s)
        p.right = s.left
        s.left = p
        s._color = p._color
        p._color = RED
        recount(p)
        recount(s)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.left === p) {
            pp.left = s
          } else {
            pp.right = s
          }
        }
        stack[i-1] = s
        stack[i] = p
        if(i+1 < stack.length) {
          stack[i+1] = n
        } else {
          stack.push(n)
        }
        i = i+2
      }
    } else {
      //console.log("right child")
      s = p.left
      if(s.left && s.left._color === RED) {
        //console.log("case 1: left sibling child red", p.value, p._color)
        s = p.left = cloneNode(s)
        z = s.left = cloneNode(s.left)
        p.left = s.right
        s.right = p
        s.left = z
        s._color = p._color
        n._color = BLACK
        p._color = BLACK
        z._color = BLACK
        recount(p)
        recount(s)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.right === p) {
            pp.right = s
          } else {
            pp.left = s
          }
        }
        stack[i-1] = s
        return
      } else if(s.right && s.right._color === RED) {
        //console.log("case 1: right sibling child red")
        s = p.left = cloneNode(s)
        z = s.right = cloneNode(s.right)
        p.left = z.right
        s.right = z.left
        z.right = p
        z.left = s
        z._color = p._color
        p._color = BLACK
        s._color = BLACK
        n._color = BLACK
        recount(p)
        recount(s)
        recount(z)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.right === p) {
            pp.right = z
          } else {
            pp.left = z
          }
        }
        stack[i-1] = z
        return
      }
      if(s._color === BLACK) {
        if(p._color === RED) {
          //console.log("case 2: black sibling, red parent")
          p._color = BLACK
          p.left = repaint(RED, s)
          return
        } else {
          //console.log("case 2: black sibling, black parent")
          p.left = repaint(RED, s)
          continue  
        }
      } else {
        //console.log("case 3: red sibling")
        s = cloneNode(s)
        p.left = s.right
        s.right = p
        s._color = p._color
        p._color = RED
        recount(p)
        recount(s)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.right === p) {
            pp.right = s
          } else {
            pp.left = s
          }
        }
        stack[i-1] = s
        stack[i] = p
        if(i+1 < stack.length) {
          stack[i+1] = n
        } else {
          stack.push(n)
        }
        i = i+2
      }
    }
  }
}

//Removes item at iterator from tree
iproto.remove = function() {
  var stack = this._stack
  if(stack.length === 0) {
    return this.tree
  }
  //First copy path to node
  var cstack = new Array(stack.length)
  var n = stack[stack.length-1]
  cstack[cstack.length-1] = new RBNode(n._color, n.key, n.value, n.left, n.right, n._count)
  for(var i=stack.length-2; i>=0; --i) {
    var n = stack[i]
    if(n.left === stack[i+1]) {
      cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i+1], n.right, n._count)
    } else {
      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count)
    }
  }

  //Get node
  n = cstack[cstack.length-1]
  //console.log("start remove: ", n.value)

  //If not leaf, then swap with previous node
  if(n.left && n.right) {
    //console.log("moving to leaf")

    //First walk to previous leaf
    var split = cstack.length
    n = n.left
    while(n.right) {
      cstack.push(n)
      n = n.right
    }
    //Copy path to leaf
    var v = cstack[split-1]
    cstack.push(new RBNode(n._color, v.key, v.value, n.left, n.right, n._count))
    cstack[split-1].key = n.key
    cstack[split-1].value = n.value

    //Fix up stack
    for(var i=cstack.length-2; i>=split; --i) {
      n = cstack[i]
      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count)
    }
    cstack[split-1].left = cstack[split]
  }
  //console.log("stack=", cstack.map(function(v) { return v.value }))

  //Remove leaf node
  n = cstack[cstack.length-1]
  if(n._color === RED) {
    //Easy case: removing red leaf
    //console.log("RED leaf")
    var p = cstack[cstack.length-2]
    if(p.left === n) {
      p.left = null
    } else if(p.right === n) {
      p.right = null
    }
    cstack.pop()
    for(var i=0; i<cstack.length; ++i) {
      cstack[i]._count--
    }
    return new RedBlackTree(this.tree._compare, cstack[0])
  } else {
    if(n.left || n.right) {
      //Second easy case:  Single child black parent
      //console.log("BLACK single child")
      if(n.left) {
        swapNode(n, n.left)
      } else if(n.right) {
        swapNode(n, n.right)
      }
      //Child must be red, so repaint it black to balance color
      n._color = BLACK
      for(var i=0; i<cstack.length-1; ++i) {
        cstack[i]._count--
      }
      return new RedBlackTree(this.tree._compare, cstack[0])
    } else if(cstack.length === 1) {
      //Third easy case: root
      //console.log("ROOT")
      return new RedBlackTree(this.tree._compare, null)
    } else {
      //Hard case: Repaint n, and then do some nasty stuff
      //console.log("BLACK leaf no children")
      for(var i=0; i<cstack.length; ++i) {
        cstack[i]._count--
      }
      var parent = cstack[cstack.length-2]
      fixDoubleBlack(cstack)
      //Fix up links
      if(parent.left === n) {
        parent.left = null
      } else {
        parent.right = null
      }
    }
  }
  return new RedBlackTree(this.tree._compare, cstack[0])
}

//Returns key
Object.defineProperty(iproto, "key", {
  get: function() {
    if(this._stack.length > 0) {
      return this._stack[this._stack.length-1].key
    }
    return
  },
  enumerable: true
})

//Returns value
Object.defineProperty(iproto, "value", {
  get: function() {
    if(this._stack.length > 0) {
      return this._stack[this._stack.length-1].value
    }
    return
  },
  enumerable: true
})


//Returns the position of this iterator in the sorted list
Object.defineProperty(iproto, "index", {
  get: function() {
    var idx = 0
    var stack = this._stack
    if(stack.length === 0) {
      var r = this.tree.root
      if(r) {
        return r._count
      }
      return 0
    } else if(stack[stack.length-1].left) {
      idx = stack[stack.length-1].left._count
    }
    for(var s=stack.length-2; s>=0; --s) {
      if(stack[s+1] === stack[s].right) {
        ++idx
        if(stack[s].left) {
          idx += stack[s].left._count
        }
      }
    }
    return idx
  },
  enumerable: true
})

//Advances iterator to next element in list
iproto.next = function() {
  var stack = this._stack
  if(stack.length === 0) {
    return
  }
  var n = stack[stack.length-1]
  if(n.right) {
    n = n.right
    while(n) {
      stack.push(n)
      n = n.left
    }
  } else {
    stack.pop()
    while(stack.length > 0 && stack[stack.length-1].right === n) {
      n = stack[stack.length-1]
      stack.pop()
    }
  }
}

//Checks if iterator is at end of tree
Object.defineProperty(iproto, "hasNext", {
  get: function() {
    var stack = this._stack
    if(stack.length === 0) {
      return false
    }
    if(stack[stack.length-1].right) {
      return true
    }
    for(var s=stack.length-1; s>0; --s) {
      if(stack[s-1].left === stack[s]) {
        return true
      }
    }
    return false
  }
})

//Update value
iproto.update = function(value) {
  var stack = this._stack
  if(stack.length === 0) {
    throw new Error("Can't update empty node!")
  }
  var cstack = new Array(stack.length)
  var n = stack[stack.length-1]
  cstack[cstack.length-1] = new RBNode(n._color, n.key, value, n.left, n.right, n._count)
  for(var i=stack.length-2; i>=0; --i) {
    n = stack[i]
    if(n.left === stack[i+1]) {
      cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i+1], n.right, n._count)
    } else {
      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count)
    }
  }
  return new RedBlackTree(this.tree._compare, cstack[0])
}

//Moves iterator backward one element
iproto.prev = function() {
  var stack = this._stack
  if(stack.length === 0) {
    return
  }
  var n = stack[stack.length-1]
  if(n.left) {
    n = n.left
    while(n) {
      stack.push(n)
      n = n.right
    }
  } else {
    stack.pop()
    while(stack.length > 0 && stack[stack.length-1].left === n) {
      n = stack[stack.length-1]
      stack.pop()
    }
  }
}

//Checks if iterator is at start of tree
Object.defineProperty(iproto, "hasPrev", {
  get: function() {
    var stack = this._stack
    if(stack.length === 0) {
      return false
    }
    if(stack[stack.length-1].left) {
      return true
    }
    for(var s=stack.length-1; s>0; --s) {
      if(stack[s-1].right === stack[s]) {
        return true
      }
    }
    return false
  }
})

//Default comparison function
function defaultCompare(a, b) {
  if(a < b) {
    return -1
  }
  if(a > b) {
    return 1
  }
  return 0
}

//Build a tree
function createRBTree(compare) {
  return new RedBlackTree(compare || defaultCompare, null)
}
},{}],40:[function(require,module,exports){
"use strict"

module.exports = createSlabDecomposition

var bounds = require("binary-search-bounds")
var createRBTree = require("functional-red-black-tree")
var orient = require("robust-orientation")
var orderSegments = require("./lib/order-segments")

function SlabDecomposition(slabs, coordinates, horizontal) {
  this.slabs = slabs
  this.coordinates = coordinates
  this.horizontal = horizontal
}

var proto = SlabDecomposition.prototype

function compareHorizontal(e, y) {
  return e.y - y
}

function searchBucket(root, p) {
  var lastNode = null
  while(root) {
    var seg = root.key
    var l, r
    if(seg[0][0] < seg[1][0]) {
      l = seg[0]
      r = seg[1]
    } else {
      l = seg[1]
      r = seg[0]
    }
    var o = orient(l, r, p)
    if(o < 0) {
      root = root.left
    } else if(o > 0) {
      if(p[0] !== seg[1][0]) {
        lastNode = root
        root = root.right
      } else {
        var val = searchBucket(root.right, p)
        if(val) {
          return val
        }
        root = root.left
      }
    } else {
      if(p[0] !== seg[1][0]) {
        return root
      } else {
        var val = searchBucket(root.right, p)
        if(val) {
          return val
        }
        root = root.left
      }
    }
  }
  return lastNode
}

proto.castUp = function(p) {
  var bucket = bounds.le(this.coordinates, p[0])
  if(bucket < 0) {
    return -1
  }
  var root = this.slabs[bucket]
  var hitNode = searchBucket(this.slabs[bucket], p)
  var lastHit = -1
  if(hitNode) {
    lastHit = hitNode.value
  }
  //Edge case: need to handle horizontal segments (sucks)
  if(this.coordinates[bucket] === p[0]) {
    var lastSegment = null
    if(hitNode) {
      lastSegment = hitNode.key
    }
    if(bucket > 0) {
      var otherHitNode = searchBucket(this.slabs[bucket-1], p)
      if(otherHitNode) {
        if(lastSegment) {
          if(orderSegments(otherHitNode.key, lastSegment) > 0) {
            lastSegment = otherHitNode.key
            lastHit = otherHitNode.value
          }
        } else {
          lastHit = otherHitNode.value
          lastSegment = otherHitNode.key
        }
      }
    }
    var horiz = this.horizontal[bucket]
    if(horiz.length > 0) {
      var hbucket = bounds.ge(horiz, p[1], compareHorizontal)
      if(hbucket < horiz.length) {
        var e = horiz[hbucket]
        if(p[1] === e.y) {
          if(e.closed) {
            return e.index
          } else {
            while(hbucket < horiz.length-1 && horiz[hbucket+1].y === p[1]) {
              hbucket = hbucket+1
              e = horiz[hbucket]
              if(e.closed) {
                return e.index
              }
            }
            if(e.y === p[1] && !e.start) {
              hbucket = hbucket+1
              if(hbucket >= horiz.length) {
                return lastHit
              }
              e = horiz[hbucket]
            }
          }
        }
        //Check if e is above/below last segment
        if(e.start) {
          if(lastSegment) {
            var o = orient(lastSegment[0], lastSegment[1], [p[0], e.y])
            if(lastSegment[0][0] > lastSegment[1][0]) {
              o = -o
            }
            if(o > 0) {
              lastHit = e.index
            }
          } else {
            lastHit = e.index
          }
        } else if(e.y !== p[1]) {
          lastHit = e.index
        }
      }
    }
  }
  return lastHit
}

function IntervalSegment(y, index, start, closed) {
  this.y = y
  this.index = index
  this.start = start
  this.closed = closed
}

function Event(x, segment, create, index) {
  this.x = x
  this.segment = segment
  this.create = create
  this.index = index
}


function createSlabDecomposition(segments) {
  var numSegments = segments.length
  var numEvents = 2 * numSegments
  var events = new Array(numEvents)
  for(var i=0; i<numSegments; ++i) {
    var s = segments[i]
    var f = s[0][0] < s[1][0]
    events[2*i] = new Event(s[0][0], s, f, i)
    events[2*i+1] = new Event(s[1][0], s, !f, i)
  }
  events.sort(function(a,b) {
    var d = a.x - b.x
    if(d) {
      return d
    }
    d = a.create - b.create
    if(d) {
      return d
    }
    return Math.min(a.segment[0][1], a.segment[1][1]) - Math.min(b.segment[0][1], b.segment[1][1])
  })
  var tree = createRBTree(orderSegments)
  var slabs = []
  var lines = []
  var horizontal = []
  var lastX = -Infinity
  for(var i=0; i<numEvents; ) {
    var x = events[i].x
    var horiz = []
    while(i < numEvents) {
      var e = events[i]
      if(e.x !== x) {
        break
      }
      i += 1
      if(e.segment[0][0] === e.x && e.segment[1][0] === e.x) {
        if(e.create) {
          if(e.segment[0][1] < e.segment[1][1]) {
            horiz.push(new IntervalSegment(
                e.segment[0][1],
                e.index,
                true,
                true))
            horiz.push(new IntervalSegment(
                e.segment[1][1],
                e.index,
                false,
                false))
          } else {
            horiz.push(new IntervalSegment(
                e.segment[1][1],
                e.index,
                true,
                false))
            horiz.push(new IntervalSegment(
                e.segment[0][1],
                e.index,
                false,
                true))
          }
        }
      } else {
        if(e.create) {
          tree = tree.insert(e.segment, e.index)
        } else {
          tree = tree.remove(e.segment)
        }
      }
    }
    slabs.push(tree.root)
    lines.push(x)
    horizontal.push(horiz)
  }
  return new SlabDecomposition(slabs, lines, horizontal)
}
},{"./lib/order-segments":37,"binary-search-bounds":38,"functional-red-black-tree":39,"robust-orientation":36}],41:[function(require,module,exports){
"use strict"

module.exports = preprocessPolygon

var orient = require("robust-orientation")
var makeSlabs = require("slab-decomposition")

function dummyFunction(p) {
  return -1
}

function createClassifyPoint(segments, slabs, outside, orientation) {
  function classifyPoint(p) {
    var index = slabs.castUp(p)
    if(index < 0) {
      return outside
    }
    var seg = segments[index]
    if(!orientation) {
      return orient(p, seg[0], seg[1])
    } else {
      return orient(p, seg[1], seg[0])
    }
  }
  return classifyPoint
}

function preprocessPolygon(loops, orientation) {
  orientation = !!orientation

  //Compute number of loops
  var numLoops = loops.length
  var numSegments = 0
  for(var i=0; i<numLoops; ++i) {
    numSegments += loops[i].length
  }

  //Degenerate case: All loops are empty
  if(numSegments === 0) {
    return dummyFunction
  }

  //Unpack segments
  var segments = new Array(numSegments)
  var ptr = 0
  for(var i=0; i<numLoops; ++i) {
    var loop = loops[i]
    var numVertices = loop.length
    for(var s=numVertices-1,t=0; t<numVertices; s=(t++)) {
      segments[ptr++] = [loop[s], loop[t]]
    }
  }

  //Build slab decomposition
  var slabs = makeSlabs(segments)

  //Find outer orientation
  var outside
  var root = slabs.slabs[0]
  if(root) {
    while(root.left) {
      root = root.left
    }
    var h = root.key
    if(h[0][0] < h[1][0]) {
      outside = -1
    } else {
      outside = 1
    }
  } else {
    var h = segments[slabs.horizontal[0][0].index]
    if(h[0][1] < h[1][1]) {
      outside = 1
    } else {
      outside = -1
    }
  }
  if(orientation) {
    outside = -outside
  }

  //Return classification function
  return createClassifyPoint(segments, slabs, outside, orientation)
}
},{"robust-orientation":36,"slab-decomposition":40}],42:[function(require,module,exports){
"use strict"

module.exports = function signum(x) {
  if(x < 0) { return -1 }
  if(x > 0) { return 1 }
  return 0.0
}
},{}],43:[function(require,module,exports){
var isect = require('exact-segment-intersect');
var float = require('robust-estimate-float');

module.exports = selfIntersections;

function cmp(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}

var pc = [0, 0];
var pn = [0, 0];
var oc = [0, 0];
var on = [0, 0];

function arrayOrObject(v, ret) {
  if (Array.isArray(v)) {
    ret[0] = v[0];
    ret[1] = v[1];
  } else {
    ret[0] = v.x;
    ret[1] = v.y;
  }
}

function selfIntersections(poly, filterFn) {
  var seen = {};
  var l = poly.length;
  var isects = [];
  for (var o=0; o<l; o++) {
    var s0 = poly[o];
    var e0 = poly[(o+1) % l];
    arrayOrObject(s0, oc);
    arrayOrObject(e0, on);
    for (var p=0; p<l; p++) {
      if (o === p) { continue; }

      var s1 = poly[p]
      var e1 = poly[(p+1) % l];
      arrayOrObject(s1, pc);
      arrayOrObject(e1, pn);

      if (cmp(pc, oc) || cmp(pc, on) || cmp(pn, oc) || cmp(pn, on)) {
        continue;
      }

      var r = isect(oc, on, pc, pn);
      // since these are homogeneous vectors, if the last component `w` is 0
      // then we've done something wrong
      var wraw = r[2];
      if (wraw.length === 1 && !wraw[0]) {
        continue;
      }

      var w = float(r[2]);
      r[0] = float(r[0]) / w;
      r[1] = float(r[1]) / w;
      r.pop();

      if (cmp(r, oc) || cmp(r, on) || cmp(r, pc) || cmp(r, pn)) {
        continue;
      }

      var key = r+'';
      var unique = !seen[key];
      if (unique) {
        seen[key] = true;
      }

      var collect = unique;
      if (filterFn) {
        collect = filterFn(r, o, s0, e0, p, s1, e1, unique);
      }

      if (collect) {
        isects.push(r);
      }
    }
  }

  return isects;
}

},{"exact-segment-intersect":44,"robust-estimate-float":53}],44:[function(require,module,exports){
"use strict"

module.exports = exactIntersect

var twoProduct = require("two-product")
var robustSum = require("robust-sum")
var robustScale = require("robust-scale")
var compress = require("robust-compress")
var robustIntersect = require("robust-segment-intersect")

// Find solution to system of two linear equations
//
//  | a[0]  a[1]   1 |
//  | b[0]  b[1]   1 |  =  0
//  |  x      y    1 |
//
//  | c[0]  c[1]   1 |
//  | d[0]  d[1]   1 |  =  0
//  |  x      y    1 |
//
function exactIntersect(a, b, c, d) {
  
  if(!robustIntersect(a, b, c, d)) {
    return [ [0], [0], [0] ]
  }

  var x1 = robustSum([c[1]], [-d[1]])
  var y1 = robustSum([-c[0]], [d[0]])
  var denom = robustSum(
      robustSum(
        robustScale(y1, a[1]),
        robustScale(y1, -b[1])),
      robustSum(
        robustScale(x1, a[0]),
        robustScale(x1, -b[0])))

  var w0 = robustSum(twoProduct(-a[0], b[1]), twoProduct(a[1], b[0]))
  var w1 = robustSum(twoProduct(-c[0], d[1]), twoProduct(c[1], d[0]))

  //Calculate nX, nY
  var nX = robustSum(
    robustSum(
      robustScale(w1, a[0]),
      robustScale(w1, -b[0])),
    robustSum(
      robustScale(w0, -c[0]),
      robustScale(w0, d[0])))

  var nY = robustSum(
    robustSum(
      robustScale(w1, a[1]),
      robustScale(w1, -b[1])),
    robustSum(
      robustScale(w0, -c[1]),
      robustScale(w0, d[1])))

  return [ compress(nX), compress(nY), compress(denom) ]
}

},{"robust-compress":45,"robust-scale":47,"robust-segment-intersect":50,"robust-sum":51,"two-product":52}],45:[function(require,module,exports){
"use strict"

module.exports = compressExpansion

function compressExpansion(e) {
  var m = e.length
  var Q = e[e.length-1]
  var bottom = m
  for(var i=m-2; i>=0; --i) {
    var a = Q
    var b = e[i]
    Q = a + b
    var bv = Q - a
    var q = b - bv
    if(q) {
      e[--bottom] = Q
      Q = q
    }
  }
  var top = 0
  for(var i=bottom; i<m; ++i) {
    var a = e[i]
    var b = Q
    Q = a + b
    var bv = Q - a
    var q = b - bv
    if(q) {
      e[top++] = q
    }
  }
  e[top++] = Q
  e.length = top
  return e
}
},{}],46:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"dup":31}],47:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32,"two-product":52,"two-sum":46}],48:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],49:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"dup":36,"robust-scale":47,"robust-subtract":48,"robust-sum":51,"two-product":52}],50:[function(require,module,exports){
"use strict"

module.exports = segmentsIntersect

var orient = require("robust-orientation")[3]

function checkCollinear(a0, a1, b0, b1) {

  for(var d=0; d<2; ++d) {
    var x0 = a0[d]
    var y0 = a1[d]
    var l0 = Math.min(x0, y0)
    var h0 = Math.max(x0, y0)    

    var x1 = b0[d]
    var y1 = b1[d]
    var l1 = Math.min(x1, y1)
    var h1 = Math.max(x1, y1)    

    if(h1 < l0 || h0 < l1) {
      return false
    }
  }

  return true
}

function segmentsIntersect(a0, a1, b0, b1) {
  var x0 = orient(a0, b0, b1)
  var y0 = orient(a1, b0, b1)
  if((x0 > 0 && y0 > 0) || (x0 < 0 && y0 < 0)) {
    return false
  }

  var x1 = orient(b0, a0, a1)
  var y1 = orient(b1, a0, a1)
  if((x1 > 0 && y1 > 0) || (x1 < 0 && y1 < 0)) {
    return false
  }

  //Check for degenerate collinear case
  if(x0 === 0 && y0 === 0 && x1 === 0 && y1 === 0) {
    return checkCollinear(a0, a1, b0, b1)
  }

  return true
}
},{"robust-orientation":49}],51:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],52:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],53:[function(require,module,exports){
module.exports = estimateFloat;

function estimateFloat(predicate) {
  var r = 0, l = predicate.length;

  switch (l) {
    case 1:
      r = predicate[0];
    break;

    case 2:
      r = predicate[0] + predicate[1];
    break;

    case 3:
      r = predicate[0] + predicate[1] + predicate[2];
    break;

    case 4:
      r = predicate[0] + predicate[1] + predicate[2] + predicate[3];
    break;

    default:
      for (var i=0; i<l; i++) {
        r+=predicate[i];
      }
  }

  return r;
}

},{}],54:[function(require,module,exports){
if (typeof require !== 'undefined') {
  var Vec2 = require('vec2');
  var segseg = require('segseg');
}

var isArray = function (a) {
  return Object.prototype.toString.call(a) === "[object Array]";
};

var defined = function(a) {
  return typeof a !== 'undefined';
};

var definedOr = function(a, defaultValue) {
  return defined(a) ? a : defaultValue;
};

var finite = function(a) {
  return a !== Infinity && a !== -Infinity;
};

var det = function(x1, y1, x2, y2) {
  return x1*y2 - y1*x2;
};

function Line2(slope, yintercept, x2, y2) {

  this._listeners = [];

  if (!(this instanceof Line2)) {
    return new Line2(slope, yintercept, x2, y2);
  }

  if (defined(x2) && defined(y2)) {
    return Line2.fromPoints(slope, yintercept, x2, y2);

  } else {
    if (defined(slope)) {
      this.slope(slope);
    }

    if (defined(yintercept)) {
      this.yintercept(yintercept);
    }
  }


}

Line2.prototype._yintercept = null;
Line2.prototype._xintercept = null;
Line2.prototype._slope = null;

Line2.prototype.change = function(fn) {
  if (typeof fn === 'function') {
    this._listeners.push(fn);
    return fn;
  }
};

Line2.prototype.ignore = function(fn) {
  if (!fn) {
    this._listeners = [];
  } else {
    this._listeners = this._listeners.filter(function(a) {
      return a !== fn;
    });
  }
};

Line2.prototype.notify = function(fn) {
  var fns = this._listeners, l = fns.length;
  for (var i = 0; i<l; i++) {
    fns[i](this);
  }
};

Line2.prototype.yintercept = function(val) {

  if (defined(val)) {
    if (finite(val)) {
      val = Vec2.clean(val);
    }

    if (this._yintercept !== val) {
      this._yintercept = val;

      if (!this.isHorizontal()) {
        this._xintercept = this.solveForX(0);
      }

      this.notify();
    }
  }
  return definedOr(this._yintercept, null);
};

Line2.prototype.xintercept = function(val) {

  if (defined(val)) {
    if (finite(val)) {
      val = Vec2.clean(val);
    }

    if (this._xintercept !== val) {
      if (!this.isVertical()) {

        var diff =  this._xintercept - val;
        this._yintercept -= (diff * -this._slope);
      }

      this._xintercept = val;
      this.notify();
    }
  }
  return definedOr(this._xintercept, null);
};

Line2.prototype.slope = function(val) {
  if (defined(val)) {
    if (finite(val)) {
      val = Vec2.clean(val);
    }

    if (this._slope !== val) {
      var old = this._slope;
      this._slope = val;

      if (old !== null) {
        var x = this.solveForX(0);
        if (!finite(x)) {
          x = null;
        }

        this._xintercept = x;
      }
      this.notify();
    }
  }
  return definedOr(this._slope, null);
};

Line2.prototype.intersectSegment = function(x1, y1, x2, y2) {

  var dx = x2 - x1;
  var dy = y2 - y1;
  var lx1, ly1, lx2, ly2;
  var horizontal = this.isHorizontal();
  var vertical = this.isVertical();

  // vertical
  if (dx === 0) {
    if (vertical) {
      return x1 === this.xintercept();
    }

  // horizontal
  } else if (dy === 0) {
    // parallel
    if (horizontal) {
      return y1 === this.yintercept();
    }

  // diagonal
  } else {
    if (dy/dx === this.slope()) {
      return y1 === this.solveForY(x1);
    }
  }

  if (x1 > x2) {
    lx1 = x2-10;
    lx2 = x1+10;
  } else {
    lx1 = x1-10;
    lx2 = x2+10;
  }

  var isect;
  if (this.isHorizontal()) {
    y = this.yintercept();
    isect = segseg(lx1, y, lx2, y, x1, y1, x2, y2);
  } else if (this.isVertical()) {
    if (y1 > y2) {
      ly1 = y2-10;
      ly2 = y1+10;
    } else {
      ly1 = y1-10;
      ly2 = y2+10;
    }
    var x = this.xintercept();

    isect = segseg(x, ly1, x, ly2, x1, y1, x2, y2);
  } else {
    ly1 = this.solveForY(lx1);
    ly2 = this.solveForY(lx2);
    isect = segseg(lx1, ly1, lx2, ly2, x1, y1, x2, y2);
  }

  if (isect && isect !== true) {
    return Vec2.fromArray(isect);
  }

  return isect;
};

Line2.prototype.createPerpendicular = function(vec) {
  if (this.isVertical()) {
    return new Line2(0, vec.y);
  } else if (this.isHorizontal()) {
    var l = new Line2();
    l.xintercept(vec.x);
    l.slope(Infinity);
    return l;
  } else {
    var perpSlope = -1/this.slope();
    return new Line2(perpSlope, vec.y - perpSlope * vec.x);
  }
};

Line2.prototype.intersectCircle = function(vec, radius) {

  var r2 = radius*radius,
      slope = this.slope(),
      yintercept = this.yintercept(),
      f, g, v1, v2;

  if (this.isHorizontal()) {
    f = 1;
    g = 0;
  } else if (this.isVertical()) {
    slope = radius;
    yintercept = r2;
    f = 0;
    g = slope;
  } else {
    f = 1/slope;
    g = 1;
  }

  var x0 = (this.isVertical()) ? this.xintercept() : 1;
  var y0 = yintercept + slope;
  var f2 = f*f;
  var g2 = g*g;

  var tmp = f * (vec.y - y0) - g * (vec.x - x0);
  tmp *= tmp;
  var den = f2 + g2;
  var discriminant = Math.sqrt(r2 * (f2 + g2) - tmp);

  // no intersection
  if (isNaN(discriminant)) {
    return [];
  }

  discriminant /= den;

  var num = f * (vec.x - x0) + g * (vec.y - y0);
  var t1 = num/den + discriminant;
  var t2 = num/den - discriminant;

  v1 = new Vec2(x0 + t1*f, y0 + t1*g);
  v2 = new Vec2(x0 + t2*f, y0 + t2*g);

  var ret = [v1];
  if (!v1.equal(v2)) {
    ret.push(v2);
  }

  return ret;
};

Line2.prototype.solveForX = function(y) {
  if (this.isVertical()) {
    return this.xintercept();
  } else {
    return (y - this.yintercept()) / this.slope();
  }
};

Line2.prototype.solveForY = function(x) {
  if (this.isHorizontal()) {
    return this.yintercept();
  } else {
    return this.slope() * x + this.yintercept();
  }
};

Line2.prototype.intersect = function(line, y1, x2, y2) {

  if ((defined(y1) && defined(y2)) || defined(line.end)) {
    return this.intersectSegment(line, y1, x2, y2);
  }

  var s1 = this.slope();
  var s2 = line.slope();

  // Parallel lines
  if (s1 === s2) {
    return (this.yintercept() === line.yintercept() &&
            this.xintercept() === line.xintercept());
  }

  if (finite(s1) && finite(s2)) {
    if (this.isHorizontal()) {
      return new Vec2(line.solveForX(this.yintercept()), this.yintercept())
    } if (line.isHorizontal()) {
      return new Vec2(this.solveForX(line.yintercept()), line.yintercept())
    }

    var x1 = line.solveForX(-1);
    y1 = line.solveForY(x1);
    x2 = line.solveForX(1);
    y2 = line.solveForY(x2);

    var x3 = this.solveForX(-1);
    var y3 = this.solveForY(x3);
    var x4 = this.solveForX(1);
    var y4 = this.solveForY(x4);

    var a = det(x1, y1, x2, y2);
    var b = det(x3, y3, x4, y4);

    var xnum = det(a, x1 - x2, b, x3 - x4);
    var ynum = det(a, y1 - y2, b, y3 - y4);

    var den = det(
      x1 - x2, y1 - y2,
      x3 - x4, y3 - y4
    );

    return Vec2(xnum/den, ynum/den);
  } else {
    var slope, yi, x = this.xintercept() || line.xintercept();
    if (!finite(s1)) {
      slope = s2;
      yi = line.yintercept();
    } else {
      slope = s1;
      yi = this.yintercept();
    }

    // Diagonal line
    if (slope !== 0) {
      return Vec2(x, x*slope + yi);

    // Horizonal line
    } else {
      return Vec2(x, yi);
    }
  }
};

Line2.fromPoints = function(x1, y1, x2, y2) {

  if (isArray(y1)) {
    y2 = y1[1];
    x2 = y1[0];
  } else if (defined(y1) && defined(y1.x) && defined(y1.y)) {
    y2 = y1.y;
    x2 = y1.x;
  }

  if (isArray(x1)) {
    y1 = x1[1];
    x1 = x1[0];
  } else if (defined(x1) && defined(x1.x) && defined(x1.y)) {
    y1 = x1.y;
    x1 = x1.x;
  }

  var line = new Line2();
  var slope = (y2 - y1) / (x2 - x1);
  line.slope(slope);

  if (line.isHorizontal()) {
    line.yintercept(y1);
  } else if (line.isVertical()) {
    line.xintercept(x2);
  } else {
    line.yintercept(y1 - slope * x1);
  }

  return line;
};

Line2.prototype.isHorizontal = function() {
  return !this.slope();
};

Line2.prototype.isVertical = function() {
  return !finite(this.slope());
};

Line2.prototype.closestPointTo = function(vec) {
  var yi = this.yintercept();
  var xi = this.xintercept();
  var s = this.slope();

  if (this.isHorizontal()) {
    return Vec2(vec.x, yi);
  } else if (this.isVertical()) {
    return Vec2(xi, vec.y);
  } else {
    return this.intersect(this.createPerpendicular(vec));
  }
};

Line2.prototype.containsPoint = function(vec, y) {
  var x = vec;
  if (!defined(y)) {
    y = vec.y;
    x = vec.x;
  }

  if (this.isHorizontal()) {
    return y === this.yintercept();
  } else if (this.isVertical()) {
    return x === this.xintercept();
  } else {
    return y === this.solveForY(x);
  }
};


if (typeof module !== "undefined" && typeof module.exports == "object") {
  module.exports = Line2;
}

if (typeof window !== "undefined") {
  window.Line2 = window.Line2 || Line2;
}

},{"segseg":56,"vec2":55}],55:[function(require,module,exports){
;(function inject(clean, precision, undef) {

  function Vec2(x, y) {
    if (!(this instanceof Vec2)) {
      return new Vec2(x, y);
    }

    if('object' === typeof x && x) {
      this.y = x.y || 0;
      this.x = x.x || 0;
      return;
    }

    this.x = Vec2.clean(x || 0);
    this.y = Vec2.clean(y || 0);
  }

  Vec2.prototype = {
    change : function(fn) {
      if (fn) {
        if (this.observers) {
          this.observers.push(fn);
        } else {
          this.observers = [fn];
        }
      } else if (this.observers) {
        for (var i=this.observers.length-1; i>=0; i--) {
          this.observers[i](this);
        }
      }

      return this;
    },

    ignore : function(fn) {
      if (this.observers) {
        var o = this.observers, l = o.length;
        while(l--) {
          o[l] === fn && o.splice(l, 1);
        }
      }
      return this;
    },

    // set x and y
    set: function(x, y, silent) {
      if('number' != typeof x) {
        silent = y;
        y = x.y;
        x = x.x;
      }
      if(this.x === x && this.y === y)
        return this;

      this.x = Vec2.clean(x);
      this.y = Vec2.clean(y);

      if(silent !== false)
        return this.change();
    },

    // reset x and y to zero
    zero : function() {
      return this.set(0, 0);
    },

    // return a new vector with the same component values
    // as this one
    clone : function() {
      return new Vec2(this.x, this.y);
    },

    // negate the values of this vector
    negate : function(returnNew) {
      if (returnNew) {
        return new Vec2(-this.x, -this.y);
      } else {
        return this.set(-this.x, -this.y);
      }
    },

    // Add the incoming `vec2` vector to this vector
    add : function(vec2, returnNew) {
      if (!returnNew) {
        this.x += vec2.x; this.y += vec2.y;
        return this.change();
      } else {
        // Return a new vector if `returnNew` is truthy
        return new Vec2(
          this.x + vec2.x,
          this.y + vec2.y
        );
      }
    },

    // Subtract the incoming `vec2` from this vector
    subtract : function(vec2, returnNew) {
      if (!returnNew) {
        this.x -= vec2.x; this.y -= vec2.y;
        return this.change();
      } else {
        // Return a new vector if `returnNew` is truthy
        return new Vec2(
          this.x - vec2.x,
          this.y - vec2.y
        );
      }
    },

    // Multiply this vector by the incoming `vec2`
    multiply : function(vec2, returnNew) {
      var x,y;
      if ('number' !== typeof vec2) { //.x !== undef) {
        x = vec2.x;
        y = vec2.y;

      // Handle incoming scalars
      } else {
        x = y = vec2;
      }

      if (!returnNew) {
        return this.set(this.x * x, this.y * y);
      } else {
        return new Vec2(
          this.x * x,
          this.y * y
        );
      }
    },

    // Rotate this vector. Accepts a `Rotation` or angle in radians.
    //
    // Passing a truthy `inverse` will cause the rotation to
    // be reversed.
    //
    // If `returnNew` is truthy, a new
    // `Vec2` will be created with the values resulting from
    // the rotation. Otherwise the rotation will be applied
    // to this vector directly, and this vector will be returned.
    rotate : function(r, inverse, returnNew) {
      var
      x = this.x,
      y = this.y,
      cos = Math.cos(r),
      sin = Math.sin(r),
      rx, ry;

      inverse = (inverse) ? -1 : 1;

      rx = cos * x - (inverse * sin) * y;
      ry = (inverse * sin) * x + cos * y;

      if (returnNew) {
        return new Vec2(rx, ry);
      } else {
        return this.set(rx, ry);
      }
    },

    // Calculate the length of this vector
    length : function() {
      var x = this.x, y = this.y;
      return Math.sqrt(x * x + y * y);
    },

    // Get the length squared. For performance, use this instead of `Vec2#length` (if possible).
    lengthSquared : function() {
      var x = this.x, y = this.y;
      return x*x+y*y;
    },

    // Return the distance betwen this `Vec2` and the incoming vec2 vector
    // and return a scalar
    distance : function(vec2) {
      var x = this.x - vec2.x;
      var y = this.y - vec2.y;
      return Math.sqrt(x*x + y*y);
    },

    // Convert this vector into a unit vector.
    // Returns the length.
    normalize : function(returnNew) {
      var length = this.length();

      // Collect a ratio to shrink the x and y coords
      var invertedLength = (length < Number.MIN_VALUE) ? 0 : 1/length;

      if (!returnNew) {
        // Convert the coords to be greater than zero
        // but smaller than or equal to 1.0
        return this.set(this.x * invertedLength, this.y * invertedLength);
      } else {
        return new Vec2(this.x * invertedLength, this.y * invertedLength);
      }
    },

    // Determine if another `Vec2`'s components match this one's
    // also accepts 2 scalars
    equal : function(v, w) {
      if (w === undef) {
        w = v.y;
        v = v.x;
      }

      return (Vec2.clean(v) === this.x && Vec2.clean(w) === this.y);
    },

    // Return a new `Vec2` that contains the absolute value of
    // each of this vector's parts
    abs : function(returnNew) {
      var x = Math.abs(this.x), y = Math.abs(this.y);

      if (returnNew) {
        return new Vec2(x, y);
      } else {
        return this.set(x, y);
      }
    },

    // Return a new `Vec2` consisting of the smallest values
    // from this vector and the incoming
    //
    // When returnNew is truthy, a new `Vec2` will be returned
    // otherwise the minimum values in either this or `v` will
    // be applied to this vector.
    min : function(v, returnNew) {
      var
      tx = this.x,
      ty = this.y,
      vx = v.x,
      vy = v.y,
      x = tx < vx ? tx : vx,
      y = ty < vy ? ty : vy;

      if (returnNew) {
        return new Vec2(x, y);
      } else {
        return this.set(x, y);
      }
    },

    // Return a new `Vec2` consisting of the largest values
    // from this vector and the incoming
    //
    // When returnNew is truthy, a new `Vec2` will be returned
    // otherwise the minimum values in either this or `v` will
    // be applied to this vector.
    max : function(v, returnNew) {
      var
      tx = this.x,
      ty = this.y,
      vx = v.x,
      vy = v.y,
      x = tx > vx ? tx : vx,
      y = ty > vy ? ty : vy;

      if (returnNew) {
        return new Vec2(x, y);
      } else {
        return this.set(x, y);
      }
    },

    // Clamp values into a range.
    // If this vector's values are lower than the `low`'s
    // values, then raise them.  If they are higher than
    // `high`'s then lower them.
    //
    // Passing returnNew as true will cause a new Vec2 to be
    // returned.  Otherwise, this vector's values will be clamped
    clamp : function(low, high, returnNew) {
      var ret = this.min(high, true).max(low);
      if (returnNew) {
        return ret;
      } else {
        return this.set(ret.x, ret.y);
      }
    },

    // Perform linear interpolation between two vectors
    // amount is a decimal between 0 and 1
    lerp : function(vec, amount) {
      return this.add(vec.subtract(this, true).multiply(amount), true);
    },

    // Get the skew vector such that dot(skew_vec, other) == cross(vec, other)
    skew : function() {
      // Returns a new vector.
      return new Vec2(-this.y, this.x);
    },

    // calculate the dot product between
    // this vector and the incoming
    dot : function(b) {
      return Vec2.clean(this.x * b.x + b.y * this.y);
    },

    // calculate the perpendicular dot product between
    // this vector and the incoming
    perpDot : function(b) {
      return Vec2.clean(this.x * b.y - this.y * b.x);
    },

    // Determine the angle between two vec2s
    angleTo : function(vec) {
      return Math.atan2(this.perpDot(vec), this.dot(vec));
    },

    // Divide this vector's components by a scalar
    divide : function(vec2, returnNew) {
      var x,y;
      if ('number' !== typeof vec2) {
        x = vec2.x;
        y = vec2.y;

      // Handle incoming scalars
      } else {
        x = y = vec2;
      }

      if (x === 0 || y === 0) {
        throw new Error('division by zero')
      }

      if (isNaN(x) || isNaN(y)) {
        throw new Error('NaN detected');
      }

      if (returnNew) {
        return new Vec2(this.x / x, this.y / y);
      }

      return this.set(this.x / x, this.y / y);
    },

    isPointOnLine : function(start, end) {
      return (start.y - this.y) * (start.x - end.x) ===
             (start.y - end.y) * (start.x - this.x);
    },

    toArray: function() {
      return [this.x, this.y];
    },

    fromArray: function(array) {
      return this.set(array[0], array[1]);
    },
    toJSON: function () {
      return {x: this.x, y: this.y};
    },
    toString: function() {
      return '(' + this.x + ', ' + this.y + ')';
    }
  };

  Vec2.fromArray = function(array) {
    return new Vec2(array[0], array[1]);
  };

  // Floating point stability
  Vec2.precision = precision || 8;
  var p = Math.pow(10, Vec2.precision);

  Vec2.clean = clean || function(val) {
    if (isNaN(val)) {
      throw new Error('NaN detected');
    }

    if (!isFinite(val)) {
      throw new Error('Infinity detected');
    }

    if(Math.round(val) === val) {
      return val;
    }

    return Math.round(val * p)/p;
  };

  Vec2.inject = inject;

  if(!clean) {
    Vec2.fast = inject(function (k) { return k; });

    // Expose, but also allow creating a fresh Vec2 subclass.
    if (typeof module !== 'undefined' && typeof module.exports == 'object') {
      module.exports = Vec2;
    } else {
      window.Vec2 = window.Vec2 || Vec2;
    }
  }
  return Vec2;
})();



},{}],56:[function(require,module,exports){
/*  Ported from Mukesh Prasad's public domain code:
 *    http://tog.acm.org/resources/GraphicsGems/gemsii/xlines.c
 *
 *   This function computes whether two line segments,
 *   respectively joining the input points (x1,y1) -- (x2,y2)
 *   and the input points (x3,y3) -- (x4,y4) intersect.
 *   If the lines intersect, the return value is an array
 *   containing coordinates of the point of intersection.
 *
 *   Params
 *        x1, y1,  x2, y2   Coordinates of endpoints of one segment.
 *        x3, y3,  x4, y4   Coordinates of endpoints of other segment.
 *
 *   Also Accepts:
 *    4 objects with the minimal object structure { x: .., y: ..}
 *    4 arrays where [0] is x and [1] is y
 *
 *   The value returned by the function is one of:
 *
 *        undefined - no intersection
 *        array     - intersection
 *        true      - colinear
 */

function segseg(x1, y1, x2, y2, x3, y3, x4, y4) {

  if (arguments.length === 4) {
    var p1 = x1;
    var p2 = y1;
    var p3 = x2;
    var p4 = y2;

    // assume array [x, y]
    if (p1.length && p1.length === 2) {
      x1 = p1[0];
      y1 = p1[1];
      x2 = p2[0];
      y2 = p2[1];
      x3 = p3[0];
      y3 = p3[1];
      x4 = p4[0];
      y4 = p4[1];

    // assume object with obj.x and obj.y
    } else {
      x1 = p1.x;
      y1 = p1.y;
      x2 = p2.x;
      y2 = p2.y;
      x3 = p3.x;
      y3 = p3.y;
      x4 = p4.x;
      y4 = p4.y;
    }
  }


  var a1, a2, b1, b2, c1, c2; // Coefficients of line eqns.
  var r1, r2, r3, r4;         // 'Sign' values
  var denom, offset;          // Intermediate values
  var x, y;                   // Intermediate return values

  // Compute a1, b1, c1, where line joining points 1 and 2
  // is "a1 x  +  b1 y  +  c1  =  0".
  a1 = y2 - y1;
  b1 = x1 - x2;
  c1 = x2 * y1 - x1 * y2;

  // Compute r3 and r4.
  r3 = a1 * x3 + b1 * y3 + c1;
  r4 = a1 * x4 + b1 * y4 + c1;

  // Check signs of r3 and r4.  If both point 3 and point 4 lie on
  // same side of line 1, the line segments do not intersect.
  if ( r3 !== 0 && r4 !== 0 && ((r3 >= 0 && r4 >= 0) || (r3 < 0 && r4 < 0))) {
    return; // no intersection
  }


  // Compute a2, b2, c2
  a2 = y4 - y3;
  b2 = x3 - x4;
  c2 = x4 * y3 - x3 * y4;

  // Compute r1 and r2
  r1 = a2 * x1 + b2 * y1 + c2;
  r2 = a2 * x2 + b2 * y2 + c2;

  // Check signs of r1 and r2.  If both point 1 and point 2 lie
  // on same side of second line segment, the line segments do
  // not intersect.
  if (r1 !== 0 && r2 !== 0 && ((r1 >= 0 && r2 >= 0) || (r1 < 0 && r2 < 0))) {
    return; // no intersections
  }

  // Line segments intersect: compute intersection point.
  denom = a1 * b2 - a2 * b1;

  if ( denom === 0 ) {
    return true;
  }

  offset = denom < 0 ? - denom / 2 : denom / 2;

  x = b1 * c2 - b2 * c1;
  y = a2 * c1 - a1 * c2;

  return [
    ( x < 0 ? x : x ) / denom,
    ( y < 0 ? y : y ) / denom,
  ];
};

if (typeof module !== 'undefined' && module.exports) {
  module.exports = segseg;
}

if (typeof window !== 'undefined') {
  window.segseg = window.segseg || segseg;
}

},{}],57:[function(require,module,exports){

if (typeof require !== 'undefined') {
  var Vec2 = require('vec2');
  var segseg = require('segseg');
  var Line2 = require('line2');
  var polygonBoolean = require('2d-polygon-boolean');
  var selfIntersections = require('2d-polygon-self-intersections');
}

var PI = Math.PI;
var TAU = PI*2;
var toTAU = function(rads) {
  if (rads<0) {
    rads += TAU;
  }

  return rads;
};

var isArray = function (a) {
  return Object.prototype.toString.call(a) === "[object Array]";
}

var isFunction = function(a) {
  return typeof a === 'function';
}

var defined = function(a) {
  return typeof a !== 'undefined';
}


function Polygon(points) {
  if (points instanceof Polygon) {
    return points;
  }

  if (!(this instanceof Polygon)) {
    return new Polygon(points);
  }

  if (!Array.isArray(points)) {
    points = (points) ? [points] : [];
  }

  this.points = points.map(function(point) {
    if (Array.isArray(point)) {
      return Vec2.fromArray(point);
    } else if (!(point instanceof Vec2)) {
      if (typeof point.x !== 'undefined' &&
          typeof point.y !== 'undefined')
      {
        return Vec2(point.x, point.y);
      }
    } else {
      return point;
    }
  });
}

Polygon.prototype = {
  each : function(fn) {
    for (var i = 0; i<this.points.length; i++) {
      if (fn.call(this, this.point(i-1), this.point(i), this.point(i+1), i) === false) {
        break;
      }
    }
    return this;
  },

  insert : function (vec, index) {
    this.points.splice(index, 0, vec);
  },

  point : function(idx) {
    var el = idx%(this.points.length);
    if (el<0) {
      el = this.points.length + el;
    }

    return this.points[el];
  },

  dedupe : function(returnNew) {
    var seen = {};
    // TODO: make this a tree
    var points = this.points.filter(function(a) {
      var key = a.x + ':' + a.y;
      if (!seen[key]) {
        seen[key] = true;
        return true;
      }
    });

    if (returnNew) {
      return new Polygon(points);
    } else {
      this.points = points;
      return this;
    }
  },

  remove : function(vec) {
    if (typeof vec === 'number') {
      this.points.splice(vec, 1);
    } else {
      this.points = this.points.filter(function(point) {
        return point!==vec;
      });
    }
    return this;
  },

  // Remove identical points occurring one after the other
  clean : function(returnNew) {
    var last = this.point(-1);

    var points = this.points.filter(function(a) {
      var ret = false;
      if (!last.equal(a)) {
        ret = true;
      }

      last = a;
      return ret;
    });

    if (returnNew) {
      return new Polygon(points);
    } else {
      this.points = points
      return this;
    }
  },

  simplify : function() {
    var clean = function(v) {
      return Math.round(v * 10000)/10000;
    }

    var collinear = function(a, b, c) {
      var r = a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y);
      return clean(r) === 0;
    };

    this.points = this.points.filter(Boolean);

    var newPoly = [];
    for (var i = 0; i<this.points.length; i++) {
      var p = this.point(i-1);
      var n = this.point(i+1);
      var c = this.point(i);

      var angle = c.subtract(p, true).angleTo(c.subtract(n, true));

      if (!collinear(p, c, n) && clean(angle)) {
        newPoly.push(c);
      }
    }

    this.points = newPoly;
    return this;
  },

  winding : function() {
    return this.area() > 0;
  },

  rewind : function(cw) {
    cw = !!cw;
    var winding = this.winding();
    if (winding !== cw) {
      this.points.reverse();
    }
    return this;
  },

  area : function() {
    var area = 0;
    var first = this.point(0);

    this.each(function(prev, current, next, idx) {
      if (idx<2) { return; }

      var edge1 = first.subtract(current, true);
      var edge2 = first.subtract(prev, true);
      area += ((edge1.x * edge2.y) - (edge1.y * edge2.x));
    });

    return area/2;
  },

  closestPointTo : function(vec) {
    var points = [],
        l = this.points.length,
        dist = Infinity,
        found = null,
        foundIndex = 0,
        foundOnPoint = false,
        i;

    for (i=0; i<l; i++) {

      var a = this.point(i-1);
      var b = this.point(i);

      // handle closed loops
      if (a.equal(b)) {
        continue;
      }

      var ab = b.subtract(a, true);
      var veca = vec.subtract(a, true);
      var vecadot = veca.dot(ab);
      var abdot = ab.dot(ab);

      var t = Math.min(Math.max(vecadot/abdot, 0), 1);

      var point = ab.multiply(t).add(a);
      var length = vec.subtract(point, true).lengthSquared();

      if (length < dist) {
        found = point;
        foundIndex = i;
        foundOnPoint = t===0 || t===1;
        dist = length;
      }
    }

    found.prev = this.point(foundIndex-1);
    found.next = this.point(foundIndex+1);

    if (foundOnPoint) {
      found.current = this.point(foundIndex);
    }

    return found;
  },

  center : function() {
    // TODO: the center of a polygon is not the center of it's aabb.
    var aabb = this.aabb();
    return Vec2(aabb.x + aabb.w/2, aabb.y + aabb.h/2);
  },

  scale : function(amount, origin, returnTrue) {
    var obj = this;
    if (returnTrue) {
      obj = this.clone();
    }

    if (!origin) {
      origin = obj.center();
    }

    obj.each(function(p, c) {
      c.multiply(amount);
    });

    var originDiff = origin.multiply(amount, true).subtract(origin);

    obj.each(function(p, c) {
      c.subtract(originDiff);
    });

    return obj;
  },

  containsPoint : function(point) {
    var c = false;

    this.each(function(prev, current, next) {
      ((prev.y <= point.y && point.y < current.y) || (current.y <= point.y && point.y < prev.y))
        && (point.x < (current.x - prev.x) * (point.y - prev.y) / (current.y - prev.y) + prev.x)
        && (c = !c);
    });

    return c;
  },

  containsPolygon : function(subject) {
    if (isArray(subject)) {
      subject = new Polygon(subject);
    }

    for (var i=0; i<subject.points.length; i++) {
      if (!this.containsPoint(subject.points[i])) {
        return false;
      }
    }

    for (var i=0; i<this.points.length; i++) {
      var outer = this.line(i);
      for (var j=0; j<subject.points.length; j++) {
        var inner = subject.line(j);

        var isect = segseg(outer[0], outer[1], inner[0], inner[1]);
        if (isect && isect !== true) {
          return false;
        }
      }
    }

    return true;
  },


  aabb : function() {
    if (this.points.length<2) {
      return { x: 0, y : 0, w: 0, h: 0};
    }

    var xmin, xmax, ymax, ymin, point1 = this.point(1);

    xmax = xmin = point1.x;
    ymax = ymin = point1.y;

    this.each(function(p, c) {
      if (c.x > xmax) {
        xmax = c.x;
      }

      if (c.x < xmin) {
        xmin = c.x;
      }

      if (c.y > ymax) {
        ymax = c.y;
      }

      if (c.y < ymin) {
        ymin = c.y;
      }
    });

    return {
      x : xmin,
      y : ymin,
      w : xmax - xmin,
      h : ymax - ymin
    };
  },

  offset : function(delta, prune) {

    var res = [];
    this.rewind(false).simplify().each(function(p, c, n, i) {
      var e1 = c.subtract(p, true).normalize();
      var e2 = c.subtract(n, true).normalize();

      var r = delta / Math.sin(Math.acos(e1.dot(e2))/2);
      var d = e1.add(e2, true).normalize().multiply(r, true);

      var angle = toTAU(e1.angleTo(e2));
      var o = e1.perpDot(e2) < 0 ? c.add(d, true) : c.subtract(d, true);

      if (angle > TAU * .75 || angle < TAU * .25) {

        o.computeSegments = angle;
        c.color = "white"
        c.radius = 3;
      }

      o.point = c;
      res.push(o);
    });


    var parline = function(a, b) {
      var normal = a.subtract(b, true);

      var angle = Vec2(1, 0).angleTo(normal);
      var bisector = Vec2(delta, 0).rotate(angle + Math.PI/2);

      bisector.add(b);

      var cperp = bisector.add(normal, true);

      var l = new Line2(bisector.x, bisector.y, cperp.x, cperp.y);
      var n = a.add(normal, true);
      var l2 = new Line2(a.x, a.y, n.x, n.y);
      return l;
    }

    var offsetPolygon = Polygon(res);
    var ret = [];


    offsetPolygon.each(function(p, c, n, i) {

      var isect = segseg(c, c.point, n, n.point);
      if (isect) {

        var pp = offsetPolygon.point(i-2);
        var nn = offsetPolygon.point(i+2);

        var ppline = parline(pp.point, p.point);
        var pline = parline(p.point, c.point);
        var nline = parline(c.point, n.point);
        var nnline = parline(n.point, nn.point);

        // ret.push(ppline.intersect(nline));
        // ret.push(pline.intersect(nline));
        // ret.push(ppline.intersect(pline));
        // ret.push(nline.intersect(nnline));

        var computed = pline.intersect(nnline);
        computed.color = "yellow";
        computed.point = c.point;

        ret.push(computed);

      } else {
        ret.push(c);
      }
    });

    return ret.length ? Polygon(ret) : offsetPolygon;
  },

  line : function(idx) {
    return [this.point(idx), this.point(idx+1)];
  },

  lines : function(fn) {
    var idx = 0;
    this.each(function(p, start, end) {
      fn(start, end, idx++);
    });

    return this;
  },

  selfIntersections : function() {
    var points = [];

    selfIntersections(this.points, function(isect, i, s, e, i2, s2, e2, unique) {
      if (!unique) return;
      var v = Vec2.fromArray(isect);
      points.push(v);

      v.s = i + (s.subtract(v, true).length() / s.subtract(e, true).length())
      v.b = i2 + (s2.subtract(v, true).length() / s2.subtract(e2, true).length())
      v.si = i;
      v.bi = i2;

      // don't create extra garbage for no reason
      return false;
    });

    return Polygon(points);
  },

  pruneSelfIntersections : function() {
    var selfIntersections = this.selfIntersections();

    var belongTo = function(s1, b1, s2, b2) {
      return s1 > s2 && b1 < b2
    }

    var contain = function(s1, b1, s2, b2) {
      return s1 < s2 && b1 > b2;
    }

    var interfere = function(s1, b1, s2, b2) {
      return (s1 < s2 && s2 < b1 && b2 > b1) || (s2 < b1 && b1 < b2 && s1 < s2);
    }

    function Node(value, depth) {
      this.value = value;
      this.depth = this.depth;
      this.children = [];
    }

    // TODO: create tree based on relationship operations
    // TODO: ensure the root node is valid
    var rootVec = this.point(0).clone();
    rootVec.s = 0;
    rootVec.b = (this.points.length-1) + 0.99;
    var root = new Node(rootVec);
    var last = root;
    var tree = [rootVec];
    selfIntersections.each(function(p, c, n) {
      console.log(
        'belongTo:', belongTo(last.s, last.b, c.s, c.b),
        'contain:', contain(last.s, last.b, c.s, c.b),
        'interfere:', interfere(last.s, last.b, c.s, c.b)
      );

      //if (!contain(1-last.s, 1-last.b, 1-c.s, 1-c.b)) {
        tree.push(c);
        last = c;
      //}
    });

    var ret = [];
    if (tree.length < 2) {
      return [this];
    }

    tree.sort(function(a, b) {
      return a.s - b.s;
    });

    for (var i=0; i<tree.length; i+=2) {
      var poly = [];
      var next = (i<tree.length-1) ? tree[i+1] : null;

     if (next) {

        // collect up to the next isect
        for (var j = Math.floor(tree[i].s); j<=Math.floor(next.s); j++) {
          poly.push(this.point(j));
        }

        poly.push(next);

        // collect up to the next isect
        for (var j = Math.floor(next.b+1); j<=Math.floor(tree[i].b); j++) {
          poly.push(this.point(j));
        }
      } else {
        poly.push(tree[i])
        for (var k = Math.floor(tree[i].s+1); k<=Math.floor(tree[i].b); k++) {
          poly.push(this.point(k));
        }
      }

      ret.push(new Polygon(poly));
    }


    return ret;
  },

  get length() {
    return this.points.length
  },

  clone : function() {
    var points = [];
    this.each(function(p, c) {
      points.push(c.clone());
    });
    return new Polygon(points);
  },

  rotate: function(rads, origin, returnNew) {
    origin = origin || this.center();

    var obj = (returnNew) ? this.clone() : this;

    return obj.each(function(p, c) {
      c.subtract(origin).rotate(rads).add(origin);
    });
  },

  translate : function(vec2, returnNew) {
    var obj = (returnNew) ? this.clone() : this;

    obj.each(function(p, c) {
      c.add(vec2);
    });

    return obj;
  },

  equal : function(poly) {
    var current = poly.length;

    while(current--) {
      if (!this.point(current).equal(poly.point(current))) {
        return false;
      }
    }
    return true;
  },


  containsCircle : function(x, y, radius) {
    var position = new Vec2(x, y);

    // Confirm that the x,y is inside of our bounds
    if (!this.containsPoint(position)) {
      return false;
    }

    var closestPoint = this.closestPointTo(position);

    if (closestPoint.distance(position) >= radius) {
      return true;
    }
  },

  contains : function(thing) {

    if (!thing) {
      return false;
    }

    // Other circles
    if (defined(thing.radius) && thing.position) {
      var radius;
      if (isFunction(thing.radius)) {
        radius = thing.radius();
      } else {
        radius = thing.radius;
      }

      return this.containsCircle(thing.position.x, thing.position.y, radius);

    } else if (typeof thing.points !== 'undefined') {

      var points, l;
      if (isFunction(thing.containsPolygon)) {
        points = thing.points;
      } else if (isArray(thing.points)) {
        points = thing.points;
      }

      return this.containsPolygon(points);

    } else if (
      defined(thing.x1) &&
      defined(thing.x2) &&
      defined(thing.y1) &&
      defined(thing.y2)
    ) {
      return this.containsPolygon([
        new Vec2(thing.x1, thing.y1),
        new Vec2(thing.x2, thing.y1),
        new Vec2(thing.x2, thing.y2),
        new Vec2(thing.x1, thing.y2)
      ]);

    } else if (defined(thing.x) && defined(thing.y)) {

      var x2, y2;

      if (defined(thing.w) && defined(thing.h)) {
        x2 = thing.x+thing.w;
        y2 = thing.y+thing.h;
      }

      if (defined(thing.width) && defined(thing.height)) {
        x2 = thing.x+thing.width;
        y2 = thing.y+thing.height;
      }

      return this.containsPolygon([
        new Vec2(thing.x, thing.y),
        new Vec2(x2, thing.y),
        new Vec2(x2, y2),
        new Vec2(thing.x, y2)
      ]);
    }

    return false;
  },

  union: function(other) {
    return Polygon(
      polygonBoolean(
        this.toArray(),
        other.toArray(),
        'or'
      )[0]
    );
  },

  cut: function(other) {
    return polygonBoolean(
      this.toArray(),
      other.toArray(),
      'not'
    ).map(function(r) {
      return new Polygon(r);
    });
  },

  intersect: function(other) {
    return polygonBoolean(
      this.toArray(),
      other.toArray(),
      'and'
    ).map(function(r) {
      return new Polygon(r);
    });
  },

  toArray: function() {
    var l = this.length;
    var ret = Array(l);
    for (var i=0; i<l; i++) {
      ret[i] = this.points[i].toArray();
    }
    return ret;
  },

  toString : function() {
    return this.points.join(',');
  }

};

if (typeof module !== 'undefined' && module.exports) {
  module.exports = Polygon;
}

if (typeof window !== 'undefined') {
  window.Polygon = Polygon;
}

},{"2d-polygon-boolean":29,"2d-polygon-self-intersections":43,"line2":54,"segseg":56,"vec2":182}],58:[function(require,module,exports){
/**
 * Copyright (c) 2011-2014 Felix Gnass
 * Licensed under the MIT license
 * http://spin.js.org/
 *
 * Example:
    var opts = {
      lines: 12             // The number of lines to draw
    , length: 7             // The length of each line
    , width: 5              // The line thickness
    , radius: 10            // The radius of the inner circle
    , scale: 1.0            // Scales overall size of the spinner
    , corners: 1            // Roundness (0..1)
    , color: '#000'         // #rgb or #rrggbb
    , opacity: 1/4          // Opacity of the lines
    , rotate: 0             // Rotation offset
    , direction: 1          // 1: clockwise, -1: counterclockwise
    , speed: 1              // Rounds per second
    , trail: 100            // Afterglow percentage
    , fps: 20               // Frames per second when using setTimeout()
    , zIndex: 2e9           // Use a high z-index by default
    , className: 'spinner'  // CSS class to assign to the element
    , top: '50%'            // center vertically
    , left: '50%'           // center horizontally
    , shadow: false         // Whether to render a shadow
    , hwaccel: false        // Whether to use hardware acceleration (might be buggy)
    , position: 'absolute'  // Element positioning
    }
    var target = document.getElementById('foo')
    var spinner = new Spinner(opts).spin(target)
 */
;(function (root, factory) {

  /* CommonJS */
  if (typeof module == 'object' && module.exports) module.exports = factory()

  /* AMD module */
  else if (typeof define == 'function' && define.amd) define(factory)

  /* Browser global */
  else root.Spinner = factory()
}(this, function () {
  "use strict"

  var prefixes = ['webkit', 'Moz', 'ms', 'O'] /* Vendor prefixes */
    , animations = {} /* Animation rules keyed by their name */
    , useCssAnimations /* Whether to use CSS animations or setTimeout */
    , sheet /* A stylesheet to hold the @keyframe or VML rules. */

  /**
   * Utility function to create elements. If no tag name is given,
   * a DIV is created. Optionally properties can be passed.
   */
  function createEl (tag, prop) {
    var el = document.createElement(tag || 'div')
      , n

    for (n in prop) el[n] = prop[n]
    return el
  }

  /**
   * Appends children and returns the parent.
   */
  function ins (parent /* child1, child2, ...*/) {
    for (var i = 1, n = arguments.length; i < n; i++) {
      parent.appendChild(arguments[i])
    }

    return parent
  }

  /**
   * Creates an opacity keyframe animation rule and returns its name.
   * Since most mobile Webkits have timing issues with animation-delay,
   * we create separate rules for each line/segment.
   */
  function addAnimation (alpha, trail, i, lines) {
    var name = ['opacity', trail, ~~(alpha * 100), i, lines].join('-')
      , start = 0.01 + i/lines * 100
      , z = Math.max(1 - (1-alpha) / trail * (100-start), alpha)
      , prefix = useCssAnimations.substring(0, useCssAnimations.indexOf('Animation')).toLowerCase()
      , pre = prefix && '-' + prefix + '-' || ''

    if (!animations[name]) {
      sheet.insertRule(
        '@' + pre + 'keyframes ' + name + '{' +
        '0%{opacity:' + z + '}' +
        start + '%{opacity:' + alpha + '}' +
        (start+0.01) + '%{opacity:1}' +
        (start+trail) % 100 + '%{opacity:' + alpha + '}' +
        '100%{opacity:' + z + '}' +
        '}', sheet.cssRules.length)

      animations[name] = 1
    }

    return name
  }

  /**
   * Tries various vendor prefixes and returns the first supported property.
   */
  function vendor (el, prop) {
    var s = el.style
      , pp
      , i

    prop = prop.charAt(0).toUpperCase() + prop.slice(1)
    if (s[prop] !== undefined) return prop
    for (i = 0; i < prefixes.length; i++) {
      pp = prefixes[i]+prop
      if (s[pp] !== undefined) return pp
    }
  }

  /**
   * Sets multiple style properties at once.
   */
  function css (el, prop) {
    for (var n in prop) {
      el.style[vendor(el, n) || n] = prop[n]
    }

    return el
  }

  /**
   * Fills in default values.
   */
  function merge (obj) {
    for (var i = 1; i < arguments.length; i++) {
      var def = arguments[i]
      for (var n in def) {
        if (obj[n] === undefined) obj[n] = def[n]
      }
    }
    return obj
  }

  /**
   * Returns the line color from the given string or array.
   */
  function getColor (color, idx) {
    return typeof color == 'string' ? color : color[idx % color.length]
  }

  // Built-in defaults

  var defaults = {
    lines: 12             // The number of lines to draw
  , length: 7             // The length of each line
  , width: 5              // The line thickness
  , radius: 10            // The radius of the inner circle
  , scale: 1.0            // Scales overall size of the spinner
  , corners: 1            // Roundness (0..1)
  , color: '#000'         // #rgb or #rrggbb
  , opacity: 1/4          // Opacity of the lines
  , rotate: 0             // Rotation offset
  , direction: 1          // 1: clockwise, -1: counterclockwise
  , speed: 1              // Rounds per second
  , trail: 100            // Afterglow percentage
  , fps: 20               // Frames per second when using setTimeout()
  , zIndex: 2e9           // Use a high z-index by default
  , className: 'spinner'  // CSS class to assign to the element
  , top: '50%'            // center vertically
  , left: '50%'           // center horizontally
  , shadow: false         // Whether to render a shadow
  , hwaccel: false        // Whether to use hardware acceleration (might be buggy)
  , position: 'absolute'  // Element positioning
  }

  /** The constructor */
  function Spinner (o) {
    this.opts = merge(o || {}, Spinner.defaults, defaults)
  }

  // Global defaults that override the built-ins:
  Spinner.defaults = {}

  merge(Spinner.prototype, {
    /**
     * Adds the spinner to the given target element. If this instance is already
     * spinning, it is automatically removed from its previous target b calling
     * stop() internally.
     */
    spin: function (target) {
      this.stop()

      var self = this
        , o = self.opts
        , el = self.el = createEl(null, {className: o.className})

      css(el, {
        position: o.position
      , width: 0
      , zIndex: o.zIndex
      , left: o.left
      , top: o.top
      })

      if (target) {
        target.insertBefore(el, target.firstChild || null)
      }

      el.setAttribute('role', 'progressbar')
      self.lines(el, self.opts)

      if (!useCssAnimations) {
        // No CSS animation support, use setTimeout() instead
        var i = 0
          , start = (o.lines - 1) * (1 - o.direction) / 2
          , alpha
          , fps = o.fps
          , f = fps / o.speed
          , ostep = (1 - o.opacity) / (f * o.trail / 100)
          , astep = f / o.lines

        ;(function anim () {
          i++
          for (var j = 0; j < o.lines; j++) {
            alpha = Math.max(1 - (i + (o.lines - j) * astep) % f * ostep, o.opacity)

            self.opacity(el, j * o.direction + start, alpha, o)
          }
          self.timeout = self.el && setTimeout(anim, ~~(1000 / fps))
        })()
      }
      return self
    }

    /**
     * Stops and removes the Spinner.
     */
  , stop: function () {
      var el = this.el
      if (el) {
        clearTimeout(this.timeout)
        if (el.parentNode) el.parentNode.removeChild(el)
        this.el = undefined
      }
      return this
    }

    /**
     * Internal method that draws the individual lines. Will be overwritten
     * in VML fallback mode below.
     */
  , lines: function (el, o) {
      var i = 0
        , start = (o.lines - 1) * (1 - o.direction) / 2
        , seg

      function fill (color, shadow) {
        return css(createEl(), {
          position: 'absolute'
        , width: o.scale * (o.length + o.width) + 'px'
        , height: o.scale * o.width + 'px'
        , background: color
        , boxShadow: shadow
        , transformOrigin: 'left'
        , transform: 'rotate(' + ~~(360/o.lines*i + o.rotate) + 'deg) translate(' + o.scale*o.radius + 'px' + ',0)'
        , borderRadius: (o.corners * o.scale * o.width >> 1) + 'px'
        })
      }

      for (; i < o.lines; i++) {
        seg = css(createEl(), {
          position: 'absolute'
        , top: 1 + ~(o.scale * o.width / 2) + 'px'
        , transform: o.hwaccel ? 'translate3d(0,0,0)' : ''
        , opacity: o.opacity
        , animation: useCssAnimations && addAnimation(o.opacity, o.trail, start + i * o.direction, o.lines) + ' ' + 1 / o.speed + 's linear infinite'
        })

        if (o.shadow) ins(seg, css(fill('#000', '0 0 4px #000'), {top: '2px'}))
        ins(el, ins(seg, fill(getColor(o.color, i), '0 0 1px rgba(0,0,0,.1)')))
      }
      return el
    }

    /**
     * Internal method that adjusts the opacity of a single line.
     * Will be overwritten in VML fallback mode below.
     */
  , opacity: function (el, i, val) {
      if (i < el.childNodes.length) el.childNodes[i].style.opacity = val
    }

  })


  function initVML () {

    /* Utility function to create a VML tag */
    function vml (tag, attr) {
      return createEl('<' + tag + ' xmlns="urn:schemas-microsoft.com:vml" class="spin-vml">', attr)
    }

    // No CSS transforms but VML support, add a CSS rule for VML elements:
    sheet.addRule('.spin-vml', 'behavior:url(#default#VML)')

    Spinner.prototype.lines = function (el, o) {
      var r = o.scale * (o.length + o.width)
        , s = o.scale * 2 * r

      function grp () {
        return css(
          vml('group', {
            coordsize: s + ' ' + s
          , coordorigin: -r + ' ' + -r
          })
        , { width: s, height: s }
        )
      }

      var margin = -(o.width + o.length) * o.scale * 2 + 'px'
        , g = css(grp(), {position: 'absolute', top: margin, left: margin})
        , i

      function seg (i, dx, filter) {
        ins(
          g
        , ins(
            css(grp(), {rotation: 360 / o.lines * i + 'deg', left: ~~dx})
          , ins(
              css(
                vml('roundrect', {arcsize: o.corners})
              , { width: r
                , height: o.scale * o.width
                , left: o.scale * o.radius
                , top: -o.scale * o.width >> 1
                , filter: filter
                }
              )
            , vml('fill', {color: getColor(o.color, i), opacity: o.opacity})
            , vml('stroke', {opacity: 0}) // transparent stroke to fix color bleeding upon opacity change
            )
          )
        )
      }

      if (o.shadow)
        for (i = 1; i <= o.lines; i++) {
          seg(i, -2, 'progid:DXImageTransform.Microsoft.Blur(pixelradius=2,makeshadow=1,shadowopacity=.3)')
        }

      for (i = 1; i <= o.lines; i++) seg(i)
      return ins(el, g)
    }

    Spinner.prototype.opacity = function (el, i, val, o) {
      var c = el.firstChild
      o = o.shadow && o.lines || 0
      if (c && i + o < c.childNodes.length) {
        c = c.childNodes[i + o]; c = c && c.firstChild; c = c && c.firstChild
        if (c) c.opacity = val
      }
    }
  }

  if (typeof document !== 'undefined') {
    sheet = (function () {
      var el = createEl('style', {type : 'text/css'})
      ins(document.getElementsByTagName('head')[0], el)
      return el.sheet || el.styleSheet
    }())

    var probe = css(createEl('group'), {behavior: 'url(#default#VML)'})

    if (!vendor(probe, 'transform') && probe.adj) initVML()
    else useCssAnimations = vendor(probe, 'animation')
  }

  return Spinner

}));

},{}],59:[function(require,module,exports){
/**
 * Turf is a modular GIS engine written in JavaScript. It performs geospatial
 * processing tasks with GeoJSON data and can be run on a server or in a browser.
 *
 * @module turf
 * @summary GIS For Web Maps
 */
module.exports = {
  isolines: require('turf-isolines'),
  merge: require('turf-merge'),
  convex: require('turf-convex'),
  within: require('turf-within'),
  concave: require('turf-concave'),
  count: require('turf-count'),
  erase: require('turf-erase'),
  variance: require('turf-variance'),
  deviation: require('turf-deviation'),
  median: require('turf-median'),
  min: require('turf-min'),
  max: require('turf-max'),
  aggregate: require('turf-aggregate'),
  flip: require('turf-flip'),
  simplify: require('turf-simplify'),
  sum: require('turf-sum'),
  average: require('turf-average'),
  bezier: require('turf-bezier'),
  tag: require('turf-tag'),
  size: require('turf-size'),
  sample: require('turf-sample'),
  jenks: require('turf-jenks'),
  quantile: require('turf-quantile'),
  envelope: require('turf-envelope'),
  square: require('turf-square'),
  midpoint: require('turf-midpoint'),
  buffer: require('turf-buffer'),
  center: require('turf-center'),
  centroid: require('turf-centroid'),
  combine: require('turf-combine'),
  distance: require('turf-distance'),
  explode: require('turf-explode'),
  extent: require('turf-extent'),
  bboxPolygon: require('turf-bbox-polygon'),
  featurecollection: require('turf-featurecollection'),
  filter: require('turf-filter'),
  inside: require('turf-inside'),
  intersect: require('turf-intersect'),
  linestring: require('turf-linestring'),
  nearest: require('turf-nearest'),
  planepoint: require('turf-planepoint'),
  point: require('turf-point'),
  polygon: require('turf-polygon'),
  random: require('turf-random'),
  reclass: require('turf-reclass'),
  remove: require('turf-remove'),
  tin: require('turf-tin'),
  union: require('turf-union'),
  bearing: require('turf-bearing'),
  destination: require('turf-destination'),
  kinks: require('turf-kinks'),
  pointOnSurface: require('turf-point-on-surface'),
  area: require('turf-area'),
  along: require('turf-along'),
  lineDistance: require('turf-line-distance'),
  lineSlice: require('turf-line-slice'),
  pointOnLine: require('turf-point-on-line'),
  pointGrid: require('turf-point-grid'),
  squareGrid: require('turf-square-grid'),
  triangleGrid: require('turf-triangle-grid'),
  hexGrid: require('turf-hex-grid')
};

},{"turf-aggregate":60,"turf-along":61,"turf-area":62,"turf-average":65,"turf-bbox-polygon":66,"turf-bearing":67,"turf-bezier":68,"turf-buffer":70,"turf-center":75,"turf-centroid":76,"turf-combine":78,"turf-concave":79,"turf-convex":80,"turf-count":110,"turf-destination":111,"turf-deviation":112,"turf-distance":114,"turf-envelope":116,"turf-erase":117,"turf-explode":122,"turf-extent":124,"turf-featurecollection":126,"turf-filter":127,"turf-flip":128,"turf-hex-grid":129,"turf-inside":130,"turf-intersect":131,"turf-isolines":137,"turf-jenks":139,"turf-kinks":141,"turf-line-distance":142,"turf-line-slice":143,"turf-linestring":144,"turf-max":145,"turf-median":146,"turf-merge":147,"turf-midpoint":149,"turf-min":150,"turf-nearest":151,"turf-planepoint":152,"turf-point":156,"turf-point-grid":153,"turf-point-on-line":154,"turf-point-on-surface":155,"turf-polygon":157,"turf-quantile":158,"turf-random":160,"turf-reclass":162,"turf-remove":163,"turf-sample":164,"turf-simplify":165,"turf-size":167,"turf-square":169,"turf-square-grid":168,"turf-sum":170,"turf-tag":171,"turf-tin":172,"turf-triangle-grid":173,"turf-union":174,"turf-variance":179,"turf-within":181}],60:[function(require,module,exports){
var average = require('turf-average');
var sum = require('turf-sum');
var median = require('turf-median');
var min = require('turf-min');
var max = require('turf-max');
var deviation = require('turf-deviation');
var variance = require('turf-variance');
var count = require('turf-count');
var operations = {};
operations.average = average;
operations.sum = sum;
operations.median = median;
operations.min = min;
operations.max = max;
operations.deviation = deviation;
operations.variance = variance;
operations.count = count;

/**
* Calculates a series of aggregations for a set of {@link Point} features within a set of {@link Polygon} features. Sum, average, count, min, max, and deviation are supported.
*
* @module turf/aggregate
* @category aggregation
* @param {FeatureCollection} polygons a FeatureCollection of {@link Polygon} features
* @param {FeatureCollection} points a FeatureCollection of {@link Point} features
* @param {Array} aggregations an array of aggregation objects
* @return {FeatureCollection} a FeatureCollection of {@link Polygon} features with properties listed as `outField` values in `aggregations`
* @example
* var polygons = {
*   "type": "FeatureCollection",
*   "features": [
*     {
*       "type": "Feature",
*       "properties": {},
*       "geometry": {
*         "type": "Polygon",
*         "coordinates": [[
*           [1.669921, 48.632908],
*           [1.669921, 49.382372],
*           [3.636474, 49.382372],
*           [3.636474, 48.632908],
*           [1.669921, 48.632908]
*         ]]
*       }
*     }, {
*       "type": "Feature",
*       "properties": {},
*       "geometry": {
*         "type": "Polygon",
*         "coordinates": [[
*           [2.230224, 47.85003],
*           [2.230224, 48.611121],
*           [4.361572, 48.611121],
*           [4.361572, 47.85003],
*           [2.230224, 47.85003]
*         ]]
*       }
*     }
*   ]
* };
* var points = {
*   "type": "FeatureCollection",
*   "features": [
*     {
*       "type": "Feature",
*       "properties": {
*         "population": 200
*       },
*       "geometry": {
*         "type": "Point",
*         "coordinates": [2.054443,49.138596]
*       }
*     },
*     {
*       "type": "Feature",
*       "properties": {
*         "population": 600
*       },
*       "geometry": {
*         "type": "Point",
*         "coordinates": [3.065185,48.850258]
*       }
*     },
*     {
*       "type": "Feature",
*       "properties": {
*         "population": 100
*       },
*       "geometry": {
*         "type": "Point",
*         "coordinates": [2.329101,48.79239]
*       }
*     },
*     {
*       "type": "Feature",
*       "properties": {
*         "population": 200
*       },
*       "geometry": {
*         "type": "Point",
*         "coordinates": [2.614746,48.334343]
*       }
*     },
*     {
*       "type": "Feature",
*       "properties": {
*         "population": 300
*       },
*       "geometry": {
*         "type": "Point",
*         "coordinates": [3.416748,48.056053]
*       }
*     }
*   ]
* };
* var aggregations = [
*   {
*     aggregation: 'sum',
*     inField: 'population',
*     outField: 'pop_sum'
*   },
*   {
*     aggregation: 'average',
*     inField: 'population',
*     outField: 'pop_avg'
*   },
*   {
*     aggregation: 'median',
*     inField: 'population',
*     outField: 'pop_median'
*   },
*   {
*     aggregation: 'min',
*     inField: 'population',
*     outField: 'pop_min'
*   },
*   {
*     aggregation: 'max',
*     inField: 'population',
*     outField: 'pop_max'
*   },
*   {
*     aggregation: 'deviation',
*     inField: 'population',
*     outField: 'pop_deviation'
*   },
*   {
*     aggregation: 'variance',
*     inField: 'population',
*     outField: 'pop_variance'
*   },
*   {
*     aggregation: 'count',
*     inField: '',
*     outField: 'point_count'
*   }
* ];
*
* var aggregated = turf.aggregate(
*   polygons, points, aggregations);
*
* var result = turf.featurecollection(
*   points.features.concat(aggregated.features));
*
* //=result
*/

module.exports = function(polygons, points, aggregations){
  for (var i = 0, len = aggregations.length; i < len; i++) {
    var agg = aggregations[i],
      operation = agg.aggregation,
      unrecognizedError;

    if (isAggregationOperation(operation)) {
      if (operation === 'count') {
        polygons = operations[operation](polygons, points, agg.outField);
      } else {
        polygons = operations[operation](polygons, points, agg.inField, agg.outField);
      }
    } else {
      throw new Error('"'+ operation +'" is not a recognized aggregation operation.');
    }
  }

  return polygons;
};

function isAggregationOperation(operation) {
  return operation === 'average' ||
    operation === 'sum' ||
    operation === 'median' ||
    operation === 'min' ||
    operation === 'max' ||
    operation === 'deviation' ||
    operation === 'variance' ||
    operation === 'count';
}

},{"turf-average":65,"turf-count":110,"turf-deviation":112,"turf-max":145,"turf-median":146,"turf-min":150,"turf-sum":170,"turf-variance":179}],61:[function(require,module,exports){
var distance = require('turf-distance');
var point = require('turf-point');
var bearing = require('turf-bearing');
var destination = require('turf-destination');

/**
 * Takes a {@link LineString} feature and returns a {@link Point} feature at a specified distance along a line.
 *
 * @module turf/along
 * @category measurement
 * @param {LineString} line a LineString feature
 * @param {Number} distance distance along the line
 * @param {String} [units=miles] can be degrees, radians, miles, or kilometers
 * @return {Point} Point along the line at `distance` distance
 * @example
 * var line = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "LineString",
 *     "coordinates": [
 *       [-77.031669, 38.878605],
 *       [-77.029609, 38.881946],
 *       [-77.020339, 38.884084],
 *       [-77.025661, 38.885821],
 *       [-77.021884, 38.889563],
 *       [-77.019824, 38.892368]
 *     ]
 *   }
 * };
 *
 * var along = turf.along(line, 1, 'miles');
 *
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": [line, along]
 * };
 *
 * //=result
 */
module.exports = function (line, dist, units) {
  var coords;
  if(line.type === 'Feature') coords = line.geometry.coordinates;
  else if(line.type === 'LineString') coords = line.geometry.coordinates;
  else throw new Error('input must be a LineString Feature or Geometry');

  var travelled = 0;
  for(var i = 0; i < coords.length; i++) {
    if (dist >= travelled && i === coords.length - 1) break;
    else if(travelled >= dist) {
      var overshot = dist - travelled;
      if(!overshot) return point(coords[i]);
      else {
        var direction = bearing(point(coords[i]), point(coords[i-1])) - 180;
        var interpolated = destination(point(coords[i]), overshot, direction, units);
        return interpolated;
      }
    }
    else {
      travelled += distance(point(coords[i]), point(coords[i+1]), units);
    }
  }
  return point(coords[coords.length - 1]);
}

},{"turf-bearing":67,"turf-destination":111,"turf-distance":114,"turf-point":156}],62:[function(require,module,exports){
var geometryArea = require('geojson-area').geometry;

/**
 * Takes a {@link GeoJSON} feature or {@link FeatureCollection} of any type and returns the area of that feature
 * in square meters.
 *
 * @module turf/area
 * @category measurement
 * @param {GeoJSON} input a {@link Feature} or {@link FeatureCollection} of any type
 * @return {Number} area in square meters
 * @example
 * var polygons = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [[
 *           [-67.031021, 10.458102],
 *           [-67.031021, 10.53372],
 *           [-66.929397, 10.53372],
 *           [-66.929397, 10.458102],
 *           [-67.031021, 10.458102]
 *         ]]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [[
 *           [-66.919784, 10.397325],
 *           [-66.919784, 10.513467],
 *           [-66.805114, 10.513467],
 *           [-66.805114, 10.397325],
 *           [-66.919784, 10.397325]
 *         ]]
 *       }
 *     }
 *   ]
 * };
 *
 * var area = turf.area(polygons);
 *
 * //=area
 */
module.exports = function(_) {
    if (_.type === 'FeatureCollection') {
        for (var i = 0, sum = 0; i < _.features.length; i++) {
            if (_.features[i].geometry) {
                sum += geometryArea(_.features[i].geometry);
            }
        }
        return sum;
    } else if (_.type === 'Feature') {
        return geometryArea(_.geometry);
    } else {
        return geometryArea(_);
    }
};

},{"geojson-area":63}],63:[function(require,module,exports){
var wgs84 = require('wgs84');

module.exports.geometry = geometry;
module.exports.ring = ringArea;

function geometry(_) {
    var area = 0, i;
    switch (_.type) {
        case 'Polygon':
            return polygonArea(_.coordinates);
        case 'MultiPolygon':
            for (i = 0; i < _.coordinates.length; i++) {
                area += polygonArea(_.coordinates[i]);
            }
            return area;
        case 'Point':
        case 'MultiPoint':
        case 'LineString':
        case 'MultiLineString':
            return 0;
        case 'GeometryCollection':
            for (i = 0; i < _.geometries.length; i++) {
                area += geometry(_.geometries[i]);
            }
            return area;
    }
}

function polygonArea(coords) {
    var area = 0;
    if (coords && coords.length > 0) {
        area += Math.abs(ringArea(coords[0]));
        for (var i = 1; i < coords.length; i++) {
            area -= Math.abs(ringArea(coords[i]));
        }
    }
    return area;
}

/**
 * Calculate the approximate area of the polygon were it projected onto
 *     the earth.  Note that this area will be positive if ring is oriented
 *     clockwise, otherwise it will be negative.
 *
 * Reference:
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
 *
 * Returns:
 * {float} The approximate signed geodesic area of the polygon in square
 *     meters.
 */

function ringArea(coords) {
    var area = 0;

    if (coords.length > 2) {
        var p1, p2;
        for (var i = 0; i < coords.length - 1; i++) {
            p1 = coords[i];
            p2 = coords[i + 1];
            area += rad(p2[0] - p1[0]) * (2 + Math.sin(rad(p1[1])) + Math.sin(rad(p2[1])));
        }

        area = area * wgs84.RADIUS * wgs84.RADIUS / 2;
    }

    return area;
}

function rad(_) {
    return _ * Math.PI / 180;
}

},{"wgs84":64}],64:[function(require,module,exports){
module.exports.RADIUS = 6378137;
module.exports.FLATTENING = 1/298.257223563;
module.exports.POLAR_RADIUS = 6356752.3142;

},{}],65:[function(require,module,exports){
var inside = require('turf-inside');

/**
 * Calculates the average value of a field for a set of {@link Point} features within a set of {@link Polygon} features.
 *
 * @module turf/average
 * @category aggregation
 * @param {FeatureCollection} polygons a FeatureCollection of {@link Polygon} features
 * @param {FeatureCollection} points a FeatureCollection of {@link Point} features
 * @param {string} field the field in the `points` features from which to pull values to average
 * @param {string} outputField the field in the `polygons` FeatureCollection to put results of the averages
 * @return {FeatureCollection} a FeatureCollection of {@link Polygon} features with the value of `outField` set to the calculated average
 * @example
* var polygons = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [[
 *           [10.666351, 59.890659],
 *           [10.666351, 59.936784],
 *           [10.762481, 59.936784],
 *           [10.762481, 59.890659],
 *           [10.666351, 59.890659]
 *         ]]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [[
 *           [10.764541, 59.889281],
 *           [10.764541, 59.937128],
 *           [10.866165, 59.937128],
 *           [10.866165, 59.889281],
 *           [10.764541, 59.889281]
 *         ]]
 *       }
 *     }
 *   ]
 * };
 * var points = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "population": 200
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [10.724029, 59.926807]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "population": 600
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [10.715789, 59.904778]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "population": 100
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [10.746002, 59.908566]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "population": 200
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [10.806427, 59.908910]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "population": 300
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [10.79544, 59.931624]
 *       }
 *     }
 *   ]
 * };
 *
 * var averaged = turf.average(
 *  polygons, points, 'population', 'pop_avg');
 *
 * var resultFeatures = points.features.concat(
 *   averaged.features);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */
module.exports = function(polyFC, ptFC, inField, outField, done){
  polyFC.features.forEach(function(poly){
    if(!poly.properties) poly.properties = {};
    var values = [];
    ptFC.features.forEach(function(pt){
      if (inside(pt, poly)) values.push(pt.properties[inField]);
    });
    poly.properties[outField] = average(values);
  });

  return polyFC;
}

function average(values) {
  var sum = 0;
  for (var i = 0; i < values.length; i++) {
    sum += values[i];
  }
  return sum / values.length;
}

},{"turf-inside":130}],66:[function(require,module,exports){
var polygon = require('turf-polygon');

/**
 * Takes a bbox and returns the equivalent {@link Polygon} feature.
 *
 * @module turf/bbox-polygon
 * @category measurement
 * @param {Array<number>} bbox an Array of bounding box coordinates in the form: ```[xLow, yLow, xHigh, yHigh]```
 * @return {Polygon} a Polygon representation of the bounding box
 * @example
 * var bbox = [0, 0, 10, 10];
 *
 * var poly = turf.bboxPolygon(bbox);
 *
 * //=poly
 */

module.exports = function(bbox){
  var lowLeft = [bbox[0], bbox[1]];
  var topLeft = [bbox[0], bbox[3]];
  var topRight = [bbox[2], bbox[3]];
  var lowRight = [bbox[2], bbox[1]];

  var poly = polygon([[
    lowLeft,
    lowRight,
    topRight,
    topLeft,
    lowLeft
  ]]);
  return poly;
}

},{"turf-polygon":157}],67:[function(require,module,exports){
//http://en.wikipedia.org/wiki/Haversine_formula
//http://www.movable-type.co.uk/scripts/latlong.html

/**
 * Takes two {@link Point} features and finds the bearing between them.
 *
 * @module turf/bearing
 * @category measurement
 * @param {Point} start starting Point
 * @param {Point} end ending Point
 * @category measurement
 * @returns {Number} bearing in decimal degrees
 * @example
 * var point1 = {
 *   "type": "Feature",
 *   "properties": {
 *     "marker-color": '#f00'
 *   },
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-75.343, 39.984]
 *   }
 * };
 * var point2 = {
 *   "type": "Feature",
 *   "properties": {
 *     "marker-color": '#0f0'
 *   },
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-75.534, 39.123]
 *   }
 * };
 *
 * var points = {
 *   "type": "FeatureCollection",
 *   "features": [point1, point2]
 * };
 *
 * //=points
 *
 * var bearing = turf.bearing(point1, point2);
 *
 * //=bearing
 */
module.exports = function (point1, point2) {
    var coordinates1 = point1.geometry.coordinates;
    var coordinates2 = point2.geometry.coordinates;

    var lon1 = toRad(coordinates1[0]);
    var lon2 = toRad(coordinates2[0]);
    var lat1 = toRad(coordinates1[1]);
    var lat2 = toRad(coordinates2[1]);
    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);
    var b = Math.cos(lat1) * Math.sin(lat2) -
        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);

    var bearing = toDeg(Math.atan2(a, b));

    return bearing;
};

function toRad(degree) {
    return degree * Math.PI / 180;
}

function toDeg(radian) {
    return radian * 180 / Math.PI;
}

},{}],68:[function(require,module,exports){
var linestring = require('turf-linestring');
var Spline = require('./spline.js');

/**
 * Takes a {@link LineString} feature and returns a curved version of the line
 * by applying a [Bezier spline](http://en.wikipedia.org/wiki/B%C3%A9zier_spline)
 * algorithm.
 *
 * The bezier spline implementation is by [Leszek Rybicki](http://leszek.rybicki.cc/).
 *
 * @module turf/bezier
 * @category transformation
 * @param {LineString} line the input LineString
 * @param {number} [resolution=10000] time in milliseconds between points
 * @param {number} [sharpness=0.85] a measure of how curvy the path should be between splines
 * @returns {LineString} curved line
 * @example
 * var line = {
 *   "type": "Feature",
 *   "properties": {
 *     "stroke": "#f00"
 *   },
 *   "geometry": {
 *     "type": "LineString",
 *     "coordinates": [
 *       [-76.091308, 18.427501],
 *       [-76.695556, 18.729501],
 *       [-76.552734, 19.40443],
 *       [-74.61914, 19.134789],
 *       [-73.652343, 20.07657],
 *       [-73.157958, 20.210656]
 *     ]
 *   }
 * };
 *
 * var curved = turf.bezier(line);
 * curved.properties = { stroke: '#0f0' };
 *
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": [line, curved]
 * };
 *
 * //=result
 */
module.exports = function(line, resolution, sharpness){
  var lineOut = linestring([]);

  lineOut.properties = line.properties;
  var pts = line.geometry.coordinates.map(function(pt){
    return {x: pt[0], y: pt[1]};
  });

  var spline = new Spline({
    points: pts,
    duration: resolution,
    sharpness: sharpness
  });
  for (var i=0; i<spline.duration; i+=10) {
    var pos = spline.pos(i);
    if (Math.floor(i/100)%2===0) {
        lineOut.geometry.coordinates.push([pos.x, pos.y]);
    }
  }

  return lineOut;
};

},{"./spline.js":69,"turf-linestring":144}],69:[function(require,module,exports){
 /**
   * BezierSpline
   * http://leszekr.github.com/
   *
   * @copyright
   * Copyright (C) 2012 Leszek Rybicki.
   *
   * @license
   * This file is part of BezierSpline
   *
   * BezierSpline is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * BezierSpline is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with BezierSpline.  If not, see <http://www.gnu.org/copyleft/lesser.html>.
   */

  /*
  Usage:

    var spline = new Spline({
      points: array_of_control_points,
      duration: time_in_miliseconds,
      sharpness: how_curvy,
      stepLength: distance_between_points_to_cache
    });

  */
var Spline = function(options){
    this.points = options.points || [];
    this.duration = options.duration || 10000;
    this.sharpness = options.sharpness || 0.85;
    this.centers = [];
    this.controls = [];
    this.stepLength = options.stepLength || 60;
    this.length = this.points.length;
    this.delay = 0;
    // this is to ensure compatibility with the 2d version
    for(var i=0; i<this.length; i++) this.points[i].z = this.points[i].z || 0;
    for(var i=0; i<this.length-1; i++){
      var p1 = this.points[i];
      var p2 = this.points[i+1];
      this.centers.push({x:(p1.x+p2.x)/2, y:(p1.y+p2.y)/2, z:(p1.z+p2.z)/2});
    }
    this.controls.push([this.points[0],this.points[0]]);
    for(var i=0; i<this.centers.length-1; i++){
      var p1 = this.centers[i];
      var p2 = this.centers[i+1];
      var dx = this.points[i+1].x-(this.centers[i].x+this.centers[i+1].x)/2;
      var dy = this.points[i+1].y-(this.centers[i].y+this.centers[i+1].y)/2;
      var dz = this.points[i+1].z-(this.centers[i].y+this.centers[i+1].z)/2;
      this.controls.push([{
        x:(1.0-this.sharpness)*this.points[i+1].x+this.sharpness*(this.centers[i].x+dx),
        y:(1.0-this.sharpness)*this.points[i+1].y+this.sharpness*(this.centers[i].y+dy),
        z:(1.0-this.sharpness)*this.points[i+1].z+this.sharpness*(this.centers[i].z+dz)},
      {
        x:(1.0-this.sharpness)*this.points[i+1].x+this.sharpness*(this.centers[i+1].x+dx),
        y:(1.0-this.sharpness)*this.points[i+1].y+this.sharpness*(this.centers[i+1].y+dy),
        z:(1.0-this.sharpness)*this.points[i+1].z+this.sharpness*(this.centers[i+1].z+dz)}]);
    }
    this.controls.push([this.points[this.length-1],this.points[this.length-1]]);
    this.steps = this.cacheSteps(this.stepLength);
    return this;
  };

  /*
    Caches an array of equidistant (more or less) points on the curve.
  */
  Spline.prototype.cacheSteps = function(mindist){
    var steps = [];
    var laststep = this.pos(0);
    steps.push(0);
    for(var t=0; t<this.duration; t+=10){
      var step = this.pos(t);
      var dist = Math.sqrt((step.x-laststep.x)*(step.x-laststep.x)+(step.y-laststep.y)*(step.y-laststep.y)+(step.z-laststep.z)*(step.z-laststep.z));
      if(dist>mindist){
        steps.push(t);
        laststep = step;
      }
    }
    return steps;
  };

  /*
    returns angle and speed in the given point in the curve
  */
  Spline.prototype.vector = function(t){
    var p1 = this.pos(t+10);
    var p2 = this.pos(t-10);
    return {
      angle:180*Math.atan2(p1.y-p2.y, p1.x-p2.x)/3.14,
      speed:Math.sqrt((p2.x-p1.x)*(p2.x-p1.x)+(p2.y-p1.y)*(p2.y-p1.y)+(p2.z-p1.z)*(p2.z-p1.z))
    };
  };

  /*
    Gets the position of the point, given time.

    WARNING: The speed is not constant. The time it takes between control points is constant.

    For constant speed, use Spline.steps[i];
  */
  Spline.prototype.pos = function(time){

    function bezier(t, p1, c1, c2, p2){
      var B = function(t) {
        var t2=t*t, t3=t2*t;
        return [(t3),(3*t2*(1-t)),(3*t*(1-t)*(1-t)),((1-t)*(1-t)*(1-t))]
      }
      var b = B(t)
      var pos = {
        x : p2.x * b[0] + c2.x * b[1] +c1.x * b[2] + p1.x * b[3],
        y : p2.y * b[0] + c2.y * b[1] +c1.y * b[2] + p1.y * b[3],
        z : p2.z * b[0] + c2.z * b[1] +c1.z * b[2] + p1.z * b[3]
      }
      return pos;
    }
    var t = time-this.delay;
    if(t<0) t=0;
    if(t>this.duration) t=this.duration-1;
    //t = t-this.delay;
    var t2 = (t)/this.duration;
    if(t2>=1) return this.points[this.length-1];

    var n = Math.floor((this.points.length-1)*t2);
    var t1 = (this.length-1)*t2-n;
    return bezier(t1,this.points[n],this.controls[n][1],this.controls[n+1][0],this.points[n+1]);
  }

  module.exports = Spline;

},{}],70:[function(require,module,exports){
// http://stackoverflow.com/questions/839899/how-do-i-calculate-a-point-on-a-circles-circumference
// radians = degrees * (pi/180)
// https://github.com/bjornharrtell/jsts/blob/master/examples/buffer.html

var featurecollection = require('turf-featurecollection');
var polygon = require('turf-polygon');
var combine = require('turf-combine');
var jsts = require('jsts');

/**
* Calculates a buffer for a {@link Point}, {@link LineString}, or {@link Polygon} {@link Feature}/{@link FeatureCollection} for a given radius. Units supported are miles, kilometers, and degrees.
*
* @module turf/buffer
* @category transformation
* @param {FeatureCollection} feature a Feature or FeatureCollection of any type
* @param {Number} distance distance to draw the buffer
* @param {String} unit 'miles' or 'kilometers'
* @return {FeatureCollection} a FeatureCollection containing {@link Polygon} features representing buffers
*
* @example
* var pt = {
*   "type": "Feature",
*   "properties": {},
*   "geometry": {
*     "type": "Point",
*     "coordinates": [-90.548630, 14.616599]
*   }
* };
* var unit = 'miles';
*
* var buffered = turf.buffer(pt, 500, unit);
*
* var resultFeatures = buffered.features.concat(pt);
* var result = {
*   "type": "FeatureCollection",
*   "features": resultFeatures
* };
*
* //=result
*/

module.exports = function(feature, radius, units){
  var buffered;

  switch(units){
    case 'miles':
      radius = radius / 69.047;
      break
    case 'feet':
      radius = radius / 364568.0;
      break
    case 'kilometers':
      radius = radius / 111.12;
      break
    case 'meters':
      radius = radius / 111120.0;
      break
    case 'degrees':
      break
  }

  if(feature.type === 'FeatureCollection'){
    var multi = combine(feature);
    multi.properties = {};
    buffered = bufferOp(multi, radius);
    return buffered;
  }
  else{
    buffered = bufferOp(feature, radius);
    return buffered;
  }
}

var bufferOp = function(feature, radius){
  var reader = new jsts.io.GeoJSONReader();
  var geom = reader.read(JSON.stringify(feature.geometry));
  var buffered = geom.buffer(radius);
  var parser = new jsts.io.GeoJSONParser();
  buffered = parser.write(buffered);

  if(buffered.type === 'MultiPolygon'){
    buffered = {
      type: 'Feature',
      geometry: buffered,
      properties: {}
    };
    buffered = featurecollection([buffered]);
  }
  else{
    buffered = featurecollection([polygon(buffered.coordinates)]);
  }

  return buffered;
}

},{"jsts":71,"turf-combine":78,"turf-featurecollection":126,"turf-polygon":157}],71:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"./lib/jsts":72,"dup":19,"javascript.util":74}],72:[function(require,module,exports){
/* The JSTS Topology Suite is a collection of JavaScript classes that
implement the fundamental operations required to validate a given
geo-spatial data set to a known topological specification.

Copyright (C) 2011 The Authors

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
jsts={version:'0.15.0',algorithm:{distance:{},locate:{}},error:{},geom:{util:{}},geomgraph:{index:{}},index:{bintree:{},chain:{},kdtree:{},quadtree:{},strtree:{}},io:{},noding:{snapround:{}},operation:{buffer:{},distance:{},overlay:{snap:{}},polygonize:{},predicate:{},relate:{},union:{},valid:{}},planargraph:{},simplify:{},triangulate:{quadedge:{}},util:{}};if(typeof String.prototype.trim!=='function'){String.prototype.trim=function(){return this.replace(/^\s+|\s+$/g,'');};}
jsts.abstractFunc=function(){throw new jsts.error.AbstractMethodInvocationError();};jsts.error={};jsts.error.IllegalArgumentError=function(message){this.name='IllegalArgumentError';this.message=message;};jsts.error.IllegalArgumentError.prototype=new Error();jsts.error.TopologyError=function(message,pt){this.name='TopologyError';this.message=pt?message+' [ '+pt+' ]':message;};jsts.error.TopologyError.prototype=new Error();jsts.error.AbstractMethodInvocationError=function(){this.name='AbstractMethodInvocationError';this.message='Abstract method called, should be implemented in subclass.';};jsts.error.AbstractMethodInvocationError.prototype=new Error();jsts.error.NotImplementedError=function(){this.name='NotImplementedError';this.message='This method has not yet been implemented.';};jsts.error.NotImplementedError.prototype=new Error();jsts.error.NotRepresentableError=function(message){this.name='NotRepresentableError';this.message=message;};jsts.error.NotRepresentableError.prototype=new Error();jsts.error.LocateFailureError=function(message){this.name='LocateFailureError';this.message=message;};jsts.error.LocateFailureError.prototype=new Error();if(typeof module!=="undefined")module.exports=jsts;jsts.geom.GeometryFilter=function(){};jsts.geom.GeometryFilter.prototype.filter=function(geom){throw new jsts.error.AbstractMethodInvocationError();};jsts.geom.util.PolygonExtracter=function(comps){this.comps=comps;};jsts.geom.util.PolygonExtracter.prototype=new jsts.geom.GeometryFilter();jsts.geom.util.PolygonExtracter.prototype.comps=null;jsts.geom.util.PolygonExtracter.getPolygons=function(geom,list){if(list===undefined){list=[];}
if(geom instanceof jsts.geom.Polygon){list.push(geom);}else if(geom instanceof jsts.geom.GeometryCollection){geom.apply(new jsts.geom.util.PolygonExtracter(list));}
return list;};jsts.geom.util.PolygonExtracter.prototype.filter=function(geom){if(geom instanceof jsts.geom.Polygon)
this.comps.push(geom);};jsts.io.WKTParser=function(geometryFactory){this.geometryFactory=geometryFactory||new jsts.geom.GeometryFactory();this.regExes={'typeStr':/^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,'emptyTypeStr':/^\s*(\w+)\s*EMPTY\s*$/,'spaces':/\s+/,'parenComma':/\)\s*,\s*\(/,'doubleParenComma':/\)\s*\)\s*,\s*\(\s*\(/,'trimParens':/^\s*\(?(.*?)\)?\s*$/};};jsts.io.WKTParser.prototype.read=function(wkt){var geometry,type,str;wkt=wkt.replace(/[\n\r]/g,' ');var matches=this.regExes.typeStr.exec(wkt);if(wkt.search('EMPTY')!==-1){matches=this.regExes.emptyTypeStr.exec(wkt);matches[2]=undefined;}
if(matches){type=matches[1].toLowerCase();str=matches[2];if(this.parse[type]){geometry=this.parse[type].apply(this,[str]);}}
if(geometry===undefined)
throw new Error('Could not parse WKT '+wkt);return geometry;};jsts.io.WKTParser.prototype.write=function(geometry){return this.extractGeometry(geometry);};jsts.io.WKTParser.prototype.extractGeometry=function(geometry){var type=geometry.CLASS_NAME.split('.')[2].toLowerCase();if(!this.extract[type]){return null;}
var wktType=type.toUpperCase();var data;if(geometry.isEmpty()){data=wktType+' EMPTY';}else{data=wktType+'('+this.extract[type].apply(this,[geometry])+')';}
return data;};jsts.io.WKTParser.prototype.extract={'coordinate':function(coordinate){return coordinate.x+' '+coordinate.y;},'point':function(point){return point.coordinate.x+' '+point.coordinate.y;},'multipoint':function(multipoint){var array=[];for(var i=0,len=multipoint.geometries.length;i<len;++i){array.push('('+
this.extract.point.apply(this,[multipoint.geometries[i]])+')');}
return array.join(',');},'linestring':function(linestring){var array=[];for(var i=0,len=linestring.points.length;i<len;++i){array.push(this.extract.coordinate.apply(this,[linestring.points[i]]));}
return array.join(',');},'multilinestring':function(multilinestring){var array=[];for(var i=0,len=multilinestring.geometries.length;i<len;++i){array.push('('+
this.extract.linestring.apply(this,[multilinestring.geometries[i]])+')');}
return array.join(',');},'polygon':function(polygon){var array=[];array.push('('+this.extract.linestring.apply(this,[polygon.shell])+')');for(var i=0,len=polygon.holes.length;i<len;++i){array.push('('+this.extract.linestring.apply(this,[polygon.holes[i]])+')');}
return array.join(',');},'multipolygon':function(multipolygon){var array=[];for(var i=0,len=multipolygon.geometries.length;i<len;++i){array.push('('+this.extract.polygon.apply(this,[multipolygon.geometries[i]])+')');}
return array.join(',');},'geometrycollection':function(collection){var array=[];for(var i=0,len=collection.geometries.length;i<len;++i){array.push(this.extractGeometry.apply(this,[collection.geometries[i]]));}
return array.join(',');}};jsts.io.WKTParser.prototype.parse={'point':function(str){if(str===undefined){return this.geometryFactory.createPoint(null);}
var coords=str.trim().split(this.regExes.spaces);return this.geometryFactory.createPoint(new jsts.geom.Coordinate(coords[0],coords[1]));},'multipoint':function(str){if(str===undefined){return this.geometryFactory.createMultiPoint(null);}
var point;var points=str.trim().split(',');var components=[];for(var i=0,len=points.length;i<len;++i){point=points[i].replace(this.regExes.trimParens,'$1');components.push(this.parse.point.apply(this,[point]));}
return this.geometryFactory.createMultiPoint(components);},'linestring':function(str){if(str===undefined){return this.geometryFactory.createLineString(null);}
var points=str.trim().split(',');var components=[];var coords;for(var i=0,len=points.length;i<len;++i){coords=points[i].trim().split(this.regExes.spaces);components.push(new jsts.geom.Coordinate(coords[0],coords[1]));}
return this.geometryFactory.createLineString(components);},'linearring':function(str){if(str===undefined){return this.geometryFactory.createLinearRing(null);}
var points=str.trim().split(',');var components=[];var coords;for(var i=0,len=points.length;i<len;++i){coords=points[i].trim().split(this.regExes.spaces);components.push(new jsts.geom.Coordinate(coords[0],coords[1]));}
return this.geometryFactory.createLinearRing(components);},'multilinestring':function(str){if(str===undefined){return this.geometryFactory.createMultiLineString(null);}
var line;var lines=str.trim().split(this.regExes.parenComma);var components=[];for(var i=0,len=lines.length;i<len;++i){line=lines[i].replace(this.regExes.trimParens,'$1');components.push(this.parse.linestring.apply(this,[line]));}
return this.geometryFactory.createMultiLineString(components);},'polygon':function(str){if(str===undefined){return this.geometryFactory.createPolygon(null);}
var ring,linestring,linearring;var rings=str.trim().split(this.regExes.parenComma);var shell;var holes=[];for(var i=0,len=rings.length;i<len;++i){ring=rings[i].replace(this.regExes.trimParens,'$1');linestring=this.parse.linestring.apply(this,[ring]);linearring=this.geometryFactory.createLinearRing(linestring.points);if(i===0){shell=linearring;}else{holes.push(linearring);}}
return this.geometryFactory.createPolygon(shell,holes);},'multipolygon':function(str){if(str===undefined){return this.geometryFactory.createMultiPolygon(null);}
var polygon;var polygons=str.trim().split(this.regExes.doubleParenComma);var components=[];for(var i=0,len=polygons.length;i<len;++i){polygon=polygons[i].replace(this.regExes.trimParens,'$1');components.push(this.parse.polygon.apply(this,[polygon]));}
return this.geometryFactory.createMultiPolygon(components);},'geometrycollection':function(str){if(str===undefined){return this.geometryFactory.createGeometryCollection(null);}
str=str.replace(/,\s*([A-Za-z])/g,'|$1');var wktArray=str.trim().split('|');var components=[];for(var i=0,len=wktArray.length;i<len;++i){components.push(jsts.io.WKTParser.prototype.read.apply(this,[wktArray[i]]));}
return this.geometryFactory.createGeometryCollection(components);}};jsts.index.ItemVisitor=function(){};jsts.index.ItemVisitor.prototype.visitItem=function(){throw new jsts.error.AbstractMethodInvocationError();};jsts.algorithm.CGAlgorithms=function(){};jsts.algorithm.CGAlgorithms.CLOCKWISE=-1;jsts.algorithm.CGAlgorithms.RIGHT=jsts.algorithm.CGAlgorithms.CLOCKWISE;jsts.algorithm.CGAlgorithms.COUNTERCLOCKWISE=1;jsts.algorithm.CGAlgorithms.LEFT=jsts.algorithm.CGAlgorithms.COUNTERCLOCKWISE;jsts.algorithm.CGAlgorithms.COLLINEAR=0;jsts.algorithm.CGAlgorithms.STRAIGHT=jsts.algorithm.CGAlgorithms.COLLINEAR;jsts.algorithm.CGAlgorithms.orientationIndex=function(p1,p2,q){var dx1,dy1,dx2,dy2;dx1=p2.x-p1.x;dy1=p2.y-p1.y;dx2=q.x-p2.x;dy2=q.y-p2.y;return jsts.algorithm.RobustDeterminant.signOfDet2x2(dx1,dy1,dx2,dy2);};jsts.algorithm.CGAlgorithms.isPointInRing=function(p,ring){return jsts.algorithm.CGAlgorithms.locatePointInRing(p,ring)!==jsts.geom.Location.EXTERIOR;};jsts.algorithm.CGAlgorithms.locatePointInRing=function(p,ring){return jsts.algorithm.RayCrossingCounter.locatePointInRing(p,ring);};jsts.algorithm.CGAlgorithms.isOnLine=function(p,pt){var lineIntersector,i,il,p0,p1;lineIntersector=new jsts.algorithm.RobustLineIntersector();for(i=1,il=pt.length;i<il;i++){p0=pt[i-1];p1=pt[i];lineIntersector.computeIntersection(p,p0,p1);if(lineIntersector.hasIntersection()){return true;}}
return false;};jsts.algorithm.CGAlgorithms.isCCW=function(ring){var nPts,hiPt,hiIndex,p,iPrev,iNext,prev,next,i,disc,isCCW;nPts=ring.length-1;if(nPts<3){throw new jsts.IllegalArgumentError('Ring has fewer than 3 points, so orientation cannot be determined');}
hiPt=ring[0];hiIndex=0;i=1;for(i;i<=nPts;i++){p=ring[i];if(p.y>hiPt.y){hiPt=p;hiIndex=i;}}
iPrev=hiIndex;do{iPrev=iPrev-1;if(iPrev<0){iPrev=nPts;}}while(ring[iPrev].equals2D(hiPt)&&iPrev!==hiIndex);iNext=hiIndex;do{iNext=(iNext+1)%nPts;}while(ring[iNext].equals2D(hiPt)&&iNext!==hiIndex);prev=ring[iPrev];next=ring[iNext];if(prev.equals2D(hiPt)||next.equals2D(hiPt)||prev.equals2D(next)){return false;}
disc=jsts.algorithm.CGAlgorithms.computeOrientation(prev,hiPt,next);isCCW=false;if(disc===0){isCCW=(prev.x>next.x);}else{isCCW=(disc>0);}
return isCCW;};jsts.algorithm.CGAlgorithms.computeOrientation=function(p1,p2,q){return jsts.algorithm.CGAlgorithms.orientationIndex(p1,p2,q);};jsts.algorithm.CGAlgorithms.distancePointLine=function(p,A,B){if(!(A instanceof jsts.geom.Coordinate)){jsts.algorithm.CGAlgorithms.distancePointLine2.apply(this,arguments);}
if(A.x===B.x&&A.y===B.y){return p.distance(A);}
var r,s;r=((p.x-A.x)*(B.x-A.x)+(p.y-A.y)*(B.y-A.y))/((B.x-A.x)*(B.x-A.x)+(B.y-A.y)*(B.y-A.y));if(r<=0.0){return p.distance(A);}
if(r>=1.0){return p.distance(B);}
s=((A.y-p.y)*(B.x-A.x)-(A.x-p.x)*(B.y-A.y))/((B.x-A.x)*(B.x-A.x)+(B.y-A.y)*(B.y-A.y));return Math.abs(s)*Math.sqrt(((B.x-A.x)*(B.x-A.x)+(B.y-A.y)*(B.y-A.y)));};jsts.algorithm.CGAlgorithms.distancePointLinePerpendicular=function(p,A,B){var s=((A.y-p.y)*(B.x-A.x)-(A.x-p.x)*(B.y-A.y))/((B.x-A.x)*(B.x-A.x)+(B.y-A.y)*(B.y-A.y));return Math.abs(s)*Math.sqrt(((B.x-A.x)*(B.x-A.x)+(B.y-A.y)*(B.y-A.y)));};jsts.algorithm.CGAlgorithms.distancePointLine2=function(p,line){var minDistance,i,il,dist;if(line.length===0){throw new jsts.error.IllegalArgumentError('Line array must contain at least one vertex');}
minDistance=p.distance(line[0]);for(i=0,il=line.length-1;i<il;i++){dist=jsts.algorithm.CGAlgorithms.distancePointLine(p,line[i],line[i+1]);if(dist<minDistance){minDistance=dist;}}
return minDistance;};jsts.algorithm.CGAlgorithms.distanceLineLine=function(A,B,C,D){if(A.equals(B)){return jsts.algorithm.CGAlgorithms.distancePointLine(A,C,D);}
if(C.equals(D)){return jsts.algorithm.CGAlgorithms.distancePointLine(D,A,B);}
var r_top,r_bot,s_top,s_bot,s,r;r_top=(A.y-C.y)*(D.x-C.x)-(A.x-C.x)*(D.y-C.y);r_bot=(B.x-A.x)*(D.y-C.y)-(B.y-A.y)*(D.x-C.x);s_top=(A.y-C.y)*(B.x-A.x)-(A.x-C.x)*(B.y-A.y);s_bot=(B.x-A.x)*(D.y-C.y)-(B.y-A.y)*(D.x-C.x);if((r_bot===0)||(s_bot===0)){return Math.min(jsts.algorithm.CGAlgorithms.distancePointLine(A,C,D),Math.min(jsts.algorithm.CGAlgorithms.distancePointLine(B,C,D),Math.min(jsts.algorithm.CGAlgorithms.distancePointLine(C,A,B),jsts.algorithm.CGAlgorithms.distancePointLine(D,A,B))));}
s=s_top/s_bot;r=r_top/r_bot;if((r<0)||(r>1)||(s<0)||(s>1)){return Math.min(jsts.algorithm.CGAlgorithms.distancePointLine(A,C,D),Math.min(jsts.algorithm.CGAlgorithms.distancePointLine(B,C,D),Math.min(jsts.algorithm.CGAlgorithms.distancePointLine(C,A,B),jsts.algorithm.CGAlgorithms.distancePointLine(D,A,B))));}
return 0.0;};jsts.algorithm.CGAlgorithms.signedArea=function(ring){if(ring.length<3){return 0.0;}
var sum,i,il,bx,by,cx,cy;sum=0.0;for(i=0,il=ring.length-1;i<il;i++){bx=ring[i].x;by=ring[i].y;cx=ring[i+1].x;cy=ring[i+1].y;sum+=(bx+cx)*(cy-by);}
return-sum/2.0;};jsts.algorithm.CGAlgorithms.signedArea=function(ring){var n,sum,p,bx,by,i,cx,cy;n=ring.length;if(n<3){return 0.0;}
sum=0.0;p=ring[0];bx=p.x;by=p.y;for(i=1;i<n;i++){p=ring[i];cx=p.x;cy=p.y;sum+=(bx+cx)*(cy-by);bx=cx;by=cy;}
return-sum/2.0;};jsts.algorithm.CGAlgorithms.computeLength=function(pts){var n=pts.length,len,x0,y0,x1,y1,dx,dy,p,i,il;if(n<=1){return 0.0;}
len=0.0;p=pts[0];x0=p.x;y0=p.y;i=1,il=n;for(i;i<n;i++){p=pts[i];x1=p.x;y1=p.y;dx=x1-x0;dy=y1-y0;len+=Math.sqrt(dx*dx+dy*dy);x0=x1;y0=y1;}
return len;};jsts.algorithm.CGAlgorithms.length=function(){};jsts.algorithm.Angle=function(){};jsts.algorithm.Angle.PI_TIMES_2=2.0*Math.PI;jsts.algorithm.Angle.PI_OVER_2=Math.PI/2.0;jsts.algorithm.Angle.PI_OVER_4=Math.PI/4.0;jsts.algorithm.Angle.COUNTERCLOCKWISE=jsts.algorithm.CGAlgorithms.COUNTERCLOCKWISE;jsts.algorithm.Angle.CLOCKWISE=jsts.algorithm.CGAlgorithms.CLOCKWISE;jsts.algorithm.Angle.NONE=jsts.algorithm.CGAlgorithms.COLLINEAR;jsts.algorithm.Angle.toDegrees=function(radians){return(radians*180)/Math.PI;};jsts.algorithm.Angle.toRadians=function(angleDegrees){return(angleDegrees*Math.PI)/180.0;};jsts.algorithm.Angle.angle=function(){if(arguments.length===1){return jsts.algorithm.Angle.angleFromOrigo(arguments[0]);}else{return jsts.algorithm.Angle.angleBetweenCoords(arguments[0],arguments[1]);}};jsts.algorithm.Angle.angleBetweenCoords=function(p0,p1){var dx,dy;dx=p1.x-p0.x;dy=p1.y-p0.y;return Math.atan2(dy,dx);};jsts.algorithm.Angle.angleFromOrigo=function(p){return Math.atan2(p.y,p.x);};jsts.algorithm.Angle.isAcute=function(p0,p1,p2){var dx0,dy0,dx1,dy1,dotprod;dx0=p0.x-p1.x;dy0=p0.y-p1.y;dx1=p2.x-p1.x;dy1=p2.y-p1.y;dotprod=dx0*dx1+dy0*dy1;return dotprod>0;};jsts.algorithm.Angle.isObtuse=function(p0,p1,p2){var dx0,dy0,dx1,dy1,dotprod;dx0=p0.x-p1.x;dy0=p0.y-p1.y;dx1=p2.x-p1.x;dy1=p2.y-p1.y;dotprod=dx0*dx1+dy0*dy1;return dotprod<0;};jsts.algorithm.Angle.angleBetween=function(tip1,tail,tip2){var a1,a2;a1=jsts.algorithm.Angle.angle(tail,tip1);a2=jsts.algorithm.Angle.angle(tail,tip2);return jsts.algorithm.Angle.diff(a1,a2);};jsts.algorithm.Angle.angleBetweenOriented=function(tip1,tail,tip2){var a1,a2,angDel;a1=jsts.algorithm.Angle.angle(tail,tip1);a2=jsts.algorithm.Angle.angle(tail,tip2);angDel=a2-a1;if(angDel<=-Math.PI){return angDel+jsts.algorithm.Angle.PI_TIMES_2;}
if(angDel>Math.PI){return angDel-jsts.algorithm.Angle.PI_TIMES_2;}
return angDel;};jsts.algorithm.Angle.interiorAngle=function(p0,p1,p2){var anglePrev,angleNext;anglePrev=jsts.algorithm.Angle.angle(p1,p0);angleNext=jsts.algorithm.Angle.angle(p1,p2);return Math.abs(angleNext-anglePrev);};jsts.algorithm.Angle.getTurn=function(ang1,ang2){var crossproduct=Math.sin(ang2-ang1);if(crossproduct>0){return jsts.algorithm.Angle.COUNTERCLOCKWISE;}
if(crossproduct<0){return jsts.algorithm.Angle.CLOCKWISE;}
return jsts.algorithm.Angle.NONE;};jsts.algorithm.Angle.normalize=function(angle){while(angle>Math.PI){angle-=jsts.algorithm.Angle.PI_TIMES_2;}
while(angle<=-Math.PI){angle+=jsts.algorithm.Angle.PI_TIMES_2;}
return angle;};jsts.algorithm.Angle.normalizePositive=function(angle){if(angle<0.0){while(angle<0.0){angle+=jsts.algorithm.Angle.PI_TIMES_2;}
if(angle>=jsts.algorithm.Angle.PI_TIMES_2){angle=0.0;}}
else{while(angle>=jsts.algorithm.Angle.PI_TIMES_2){angle-=jsts.algorithm.Angle.PI_TIMES_2;}
if(angle<0.0){angle=0.0;}}
return angle;};jsts.algorithm.Angle.diff=function(ang1,ang2){var delAngle;if(ang1<ang2){delAngle=ang2-ang1;}else{delAngle=ang1-ang2;}
if(delAngle>Math.PI){delAngle=(2*Math.PI)-delAngle;}
return delAngle;};jsts.geom.GeometryComponentFilter=function(){};jsts.geom.GeometryComponentFilter.prototype.filter=function(geom){throw new jsts.error.AbstractMethodInvocationError();};jsts.geom.util.LinearComponentExtracter=function(lines,isForcedToLineString){this.lines=lines;this.isForcedToLineString=isForcedToLineString;};jsts.geom.util.LinearComponentExtracter.prototype=new jsts.geom.GeometryComponentFilter();jsts.geom.util.LinearComponentExtracter.prototype.lines=null;jsts.geom.util.LinearComponentExtracter.prototype.isForcedToLineString=false;jsts.geom.util.LinearComponentExtracter.getLines=function(geoms,lines){if(arguments.length==1){return jsts.geom.util.LinearComponentExtracter.getLines5.apply(this,arguments);}
else if(arguments.length==2&&typeof lines==='boolean'){return jsts.geom.util.LinearComponentExtracter.getLines6.apply(this,arguments);}
else if(arguments.length==2&&geoms instanceof jsts.geom.Geometry){return jsts.geom.util.LinearComponentExtracter.getLines3.apply(this,arguments);}
else if(arguments.length==3&&geoms instanceof jsts.geom.Geometry){return jsts.geom.util.LinearComponentExtracter.getLines4.apply(this,arguments);}
else if(arguments.length==3){return jsts.geom.util.LinearComponentExtracter.getLines2.apply(this,arguments);}
for(var i=0;i<geoms.length;i++){var g=geoms[i];jsts.geom.util.LinearComponentExtracter.getLines3(g,lines);}
return lines;};jsts.geom.util.LinearComponentExtracter.getLines2=function(geoms,lines,forceToLineString){for(var i=0;i<geoms.length;i++){var g=geoms[i];jsts.geom.util.LinearComponentExtracter.getLines4(g,lines,forceToLineString);}
return lines;};jsts.geom.util.LinearComponentExtracter.getLines3=function(geom,lines){if(geom instanceof LineString){lines.add(geom);}else{geom.apply(new jsts.geom.util.LinearComponentExtracter(lines));}
return lines;};jsts.geom.util.LinearComponentExtracter.getLines4=function(geom,lines,forceToLineString){geom.apply(new jsts.geom.util.LinearComponentExtracter(lines,forceToLineString));return lines;};jsts.geom.util.LinearComponentExtracter.getLines5=function(geom){return jsts.geom.util.LinearComponentExtracter.getLines6(geom,false);};jsts.geom.util.LinearComponentExtracter.getLines6=function(geom,forceToLineString){var lines=[];geom.apply(new jsts.geom.util.LinearComponentExtracter(lines,forceToLineString));return lines;};jsts.geom.util.LinearComponentExtracter.prototype.setForceToLineString=function(isForcedToLineString){this.isForcedToLineString=isForcedToLineString;};jsts.geom.util.LinearComponentExtracter.prototype.filter=function(geom){if(this.isForcedToLineString&&geom instanceof jsts.geom.LinearRing){var line=geom.getFactory().createLineString(geom.getCoordinateSequence());this.lines.push(line);return;}
if(geom instanceof jsts.geom.LineString||geom instanceof jsts.geom.LinearRing)
this.lines.push(geom);};jsts.geom.Location=function(){};jsts.geom.Location.INTERIOR=0;jsts.geom.Location.BOUNDARY=1;jsts.geom.Location.EXTERIOR=2;jsts.geom.Location.NONE=-1;jsts.geom.Location.toLocationSymbol=function(locationValue){switch(locationValue){case jsts.geom.Location.EXTERIOR:return'e';case jsts.geom.Location.BOUNDARY:return'b';case jsts.geom.Location.INTERIOR:return'i';case jsts.geom.Location.NONE:return'-';}
throw new jsts.IllegalArgumentError('Unknown location value: '+
locationValue);};(function(){jsts.io.GeoJSONReader=function(geometryFactory){this.geometryFactory=geometryFactory||new jsts.geom.GeometryFactory();this.precisionModel=this.geometryFactory.getPrecisionModel();this.parser=new jsts.io.GeoJSONParser(this.geometryFactory);};jsts.io.GeoJSONReader.prototype.read=function(geoJson){var geometry=this.parser.read(geoJson);if(this.precisionModel.getType()===jsts.geom.PrecisionModel.FIXED){this.reducePrecision(geometry);}
return geometry;};jsts.io.GeoJSONReader.prototype.reducePrecision=function(geometry){var i,len;if(geometry.coordinate){this.precisionModel.makePrecise(geometry.coordinate);}else if(geometry.points){for(i=0,len=geometry.points.length;i<len;i++){this.precisionModel.makePrecise(geometry.points[i]);}}else if(geometry.geometries){for(i=0,len=geometry.geometries.length;i<len;i++){this.reducePrecision(geometry.geometries[i]);}}};})();jsts.geom.Geometry=function(factory){this.factory=factory;};jsts.geom.Geometry.prototype.envelope=null;jsts.geom.Geometry.prototype.factory=null;jsts.geom.Geometry.prototype.getGeometryType=function(){return'Geometry';};jsts.geom.Geometry.hasNonEmptyElements=function(geometries){var i;for(i=0;i<geometries.length;i++){if(!geometries[i].isEmpty()){return true;}}
return false;};jsts.geom.Geometry.hasNullElements=function(array){var i;for(i=0;i<array.length;i++){if(array[i]===null){return true;}}
return false;};jsts.geom.Geometry.prototype.getFactory=function(){if(this.factory===null||this.factory===undefined){this.factory=new jsts.geom.GeometryFactory();}
return this.factory;};jsts.geom.Geometry.prototype.getNumGeometries=function(){return 1;};jsts.geom.Geometry.prototype.getGeometryN=function(n){return this;};jsts.geom.Geometry.prototype.getPrecisionModel=function(){return this.getFactory().getPrecisionModel();};jsts.geom.Geometry.prototype.getCoordinate=function(){throw new jsts.error.AbstractMethodInvocationError();};jsts.geom.Geometry.prototype.getCoordinates=function(){throw new jsts.error.AbstractMethodInvocationError();};jsts.geom.Geometry.prototype.getNumPoints=function(){throw new jsts.error.AbstractMethodInvocationError();};jsts.geom.Geometry.prototype.isSimple=function(){this.checkNotGeometryCollection(this);var op=new jsts.operation.IsSimpleOp(this);return op.isSimple();};jsts.geom.Geometry.prototype.isValid=function(){var isValidOp=new jsts.operation.valid.IsValidOp(this);return isValidOp.isValid();};jsts.geom.Geometry.prototype.isEmpty=function(){throw new jsts.error.AbstractMethodInvocationError();};jsts.geom.Geometry.prototype.distance=function(g){return jsts.operation.distance.DistanceOp.distance(this,g);};jsts.geom.Geometry.prototype.isWithinDistance=function(geom,distance){var envDist=this.getEnvelopeInternal().distance(geom.getEnvelopeInternal());if(envDist>distance){return false;}
return DistanceOp.isWithinDistance(this,geom,distance);};jsts.geom.Geometry.prototype.isRectangle=function(){return false;};jsts.geom.Geometry.prototype.getArea=function(){return 0.0;};jsts.geom.Geometry.prototype.getLength=function(){return 0.0;};jsts.geom.Geometry.prototype.getCentroid=function(){if(this.isEmpty()){return null;}
var cent;var centPt=null;var dim=this.getDimension();if(dim===0){cent=new jsts.algorithm.CentroidPoint();cent.add(this);centPt=cent.getCentroid();}else if(dim===1){cent=new jsts.algorithm.CentroidLine();cent.add(this);centPt=cent.getCentroid();}else{cent=new jsts.algorithm.CentroidArea();cent.add(this);centPt=cent.getCentroid();}
return this.createPointFromInternalCoord(centPt,this);};jsts.geom.Geometry.prototype.getInteriorPoint=function(){var intPt;var interiorPt=null;var dim=this.getDimension();if(dim===0){intPt=new jsts.algorithm.InteriorPointPoint(this);interiorPt=intPt.getInteriorPoint();}else if(dim===1){intPt=new jsts.algorithm.InteriorPointLine(this);interiorPt=intPt.getInteriorPoint();}else{intPt=new jsts.algorithm.InteriorPointArea(this);interiorPt=intPt.getInteriorPoint();}
return this.createPointFromInternalCoord(interiorPt,this);};jsts.geom.Geometry.prototype.getDimension=function(){throw new jsts.error.AbstractMethodInvocationError();};jsts.geom.Geometry.prototype.getBoundary=function(){throw new jsts.error.AbstractMethodInvocationError();};jsts.geom.Geometry.prototype.getBoundaryDimension=function(){throw new jsts.error.AbstractMethodInvocationError();};jsts.geom.Geometry.prototype.getEnvelope=function(){return this.getFactory().toGeometry(this.getEnvelopeInternal());};jsts.geom.Geometry.prototype.getEnvelopeInternal=function(){if(this.envelope===null){this.envelope=this.computeEnvelopeInternal();}
return this.envelope;};jsts.geom.Geometry.prototype.disjoint=function(g){return!this.intersects(g);};jsts.geom.Geometry.prototype.touches=function(g){if(!this.getEnvelopeInternal().intersects(g.getEnvelopeInternal())){return false;}
return this.relate(g).isTouches(this.getDimension(),g.getDimension());};jsts.geom.Geometry.prototype.intersects=function(g){if(!this.getEnvelopeInternal().intersects(g.getEnvelopeInternal())){return false;}
if(this.isRectangle()){return jsts.operation.predicate.RectangleIntersects.intersects(this,g);}
if(g.isRectangle()){return jsts.operation.predicate.RectangleIntersects.intersects(g,this);}
return this.relate(g).isIntersects();};jsts.geom.Geometry.prototype.crosses=function(g){if(!this.getEnvelopeInternal().intersects(g.getEnvelopeInternal())){return false;}
return this.relate(g).isCrosses(this.getDimension(),g.getDimension());};jsts.geom.Geometry.prototype.within=function(g){return g.contains(this);};jsts.geom.Geometry.prototype.contains=function(g){if(!this.getEnvelopeInternal().contains(g.getEnvelopeInternal())){return false;}
if(this.isRectangle()){return jsts.operation.predicate.RectangleContains.contains(this,g);}
return this.relate(g).isContains();};jsts.geom.Geometry.prototype.overlaps=function(g){if(!this.getEnvelopeInternal().intersects(g.getEnvelopeInternal())){return false;}
return this.relate(g).isOverlaps(this.getDimension(),g.getDimension());};jsts.geom.Geometry.prototype.covers=function(g){if(!this.getEnvelopeInternal().covers(g.getEnvelopeInternal())){return false;}
if(this.isRectangle()){return true;}
return this.relate(g).isCovers();};jsts.geom.Geometry.prototype.coveredBy=function(g){return g.covers(this);};jsts.geom.Geometry.prototype.relate=function(g,intersectionPattern){if(arguments.length===1){return this.relate2.apply(this,arguments);}
return this.relate2(g).matches(intersectionPattern);};jsts.geom.Geometry.prototype.relate2=function(g){this.checkNotGeometryCollection(this);this.checkNotGeometryCollection(g);return jsts.operation.relate.RelateOp.relate(this,g);};jsts.geom.Geometry.prototype.equalsTopo=function(g){if(!this.getEnvelopeInternal().equals(g.getEnvelopeInternal())){return false;}
return this.relate(g).isEquals(this.getDimension(),g.getDimension());};jsts.geom.Geometry.prototype.equals=function(o){if(o instanceof jsts.geom.Geometry||o instanceof jsts.geom.LinearRing||o instanceof jsts.geom.Polygon||o instanceof jsts.geom.GeometryCollection||o instanceof jsts.geom.MultiPoint||o instanceof jsts.geom.MultiLineString||o instanceof jsts.geom.MultiPolygon){return this.equalsExact(o);}
return false;};jsts.geom.Geometry.prototype.buffer=function(distance,quadrantSegments,endCapStyle){var params=new jsts.operation.buffer.BufferParameters(quadrantSegments,endCapStyle)
return jsts.operation.buffer.BufferOp.bufferOp2(this,distance,params);};jsts.geom.Geometry.prototype.convexHull=function(){return new jsts.algorithm.ConvexHull(this).getConvexHull();};jsts.geom.Geometry.prototype.intersection=function(other){if(this.isEmpty()){return this.getFactory().createGeometryCollection(null);}
if(other.isEmpty()){return this.getFactory().createGeometryCollection(null);}
if(this.isGeometryCollection(this)){var g2=other;}
this.checkNotGeometryCollection(this);this.checkNotGeometryCollection(other);return jsts.operation.overlay.snap.SnapIfNeededOverlayOp.overlayOp(this,other,jsts.operation.overlay.OverlayOp.INTERSECTION);};jsts.geom.Geometry.prototype.union=function(other){if(arguments.length===0){return jsts.operation.union.UnaryUnionOp.union(this);}
if(this.isEmpty()){return other.clone();}
if(other.isEmpty()){return this.clone();}
this.checkNotGeometryCollection(this);this.checkNotGeometryCollection(other);return jsts.operation.overlay.snap.SnapIfNeededOverlayOp.overlayOp(this,other,jsts.operation.overlay.OverlayOp.UNION);};jsts.geom.Geometry.prototype.difference=function(other){if(this.isEmpty()){return this.getFactory().createGeometryCollection(null);}
if(other.isEmpty()){return this.clone();}
this.checkNotGeometryCollection(this);this.checkNotGeometryCollection(other);return jsts.operation.overlay.snap.SnapIfNeededOverlayOp.overlayOp(this,other,jsts.operation.overlay.OverlayOp.DIFFERENCE);};jsts.geom.Geometry.prototype.symDifference=function(other){if(this.isEmpty()){return other.clone();}
if(other.isEmpty()){return this.clone();}
this.checkNotGeometryCollection(this);this.checkNotGeometryCollection(other);return jsts.operation.overlay.snap.SnapIfNeededOverlayOp.overlayOp(this,other,jsts.operation.overlay.OverlayOp.SYMDIFFERENCE);};jsts.geom.Geometry.prototype.equalsExact=function(other,tolerance){throw new jsts.error.AbstractMethodInvocationError();};jsts.geom.Geometry.prototype.equalsNorm=function(g){if(g===null||g===undefined)
return false;return this.norm().equalsExact(g.norm());};jsts.geom.Geometry.prototype.apply=function(filter){throw new jsts.error.AbstractMethodInvocationError();};jsts.geom.Geometry.prototype.clone=function(){throw new jsts.error.AbstractMethodInvocationError();};jsts.geom.Geometry.prototype.normalize=function(){throw new jsts.error.AbstractMethodInvocationError();};jsts.geom.Geometry.prototype.norm=function(){var copy=this.clone();copy.normalize();return copy;};jsts.geom.Geometry.prototype.compareTo=function(o){var other=o;if(this.getClassSortIndex()!==other.getClassSortIndex()){return this.getClassSortIndex()-other.getClassSortIndex();}
if(this.isEmpty()&&other.isEmpty()){return 0;}
if(this.isEmpty()){return-1;}
if(other.isEmpty()){return 1;}
return this.compareToSameClass(o);};jsts.geom.Geometry.prototype.isEquivalentClass=function(other){if(this instanceof jsts.geom.Point&&other instanceof jsts.geom.Point){return true;}else if(this instanceof jsts.geom.LineString&&(other instanceof jsts.geom.LineString|other instanceof jsts.geom.LinearRing)){return true;}else if(this instanceof jsts.geom.LinearRing&&(other instanceof jsts.geom.LineString|other instanceof jsts.geom.LinearRing)){return true;}else if(this instanceof jsts.geom.Polygon&&(other instanceof jsts.geom.Polygon)){return true;}else if(this instanceof jsts.geom.MultiPoint&&(other instanceof jsts.geom.MultiPoint)){return true;}else if(this instanceof jsts.geom.MultiLineString&&(other instanceof jsts.geom.MultiLineString)){return true;}else if(this instanceof jsts.geom.MultiPolygon&&(other instanceof jsts.geom.MultiPolygon)){return true;}else if(this instanceof jsts.geom.GeometryCollection&&(other instanceof jsts.geom.GeometryCollection)){return true;}
return false;};jsts.geom.Geometry.prototype.checkNotGeometryCollection=function(g){if(g.isGeometryCollectionBase()){throw new jsts.error.IllegalArgumentError('This method does not support GeometryCollection');}};jsts.geom.Geometry.prototype.isGeometryCollection=function(){return(this instanceof jsts.geom.GeometryCollection);};jsts.geom.Geometry.prototype.isGeometryCollectionBase=function(){return(this.CLASS_NAME==='jsts.geom.GeometryCollection');};jsts.geom.Geometry.prototype.computeEnvelopeInternal=function(){throw new jsts.error.AbstractMethodInvocationError();};jsts.geom.Geometry.prototype.compareToSameClass=function(o){throw new jsts.error.AbstractMethodInvocationError();};jsts.geom.Geometry.prototype.compare=function(a,b){var i=a.iterator();var j=b.iterator();while(i.hasNext()&&j.hasNext()){var aElement=i.next();var bElement=j.next();var comparison=aElement.compareTo(bElement);if(comparison!==0){return comparison;}}
if(i.hasNext()){return 1;}
if(j.hasNext()){return-1;}
return 0;};jsts.geom.Geometry.prototype.equal=function(a,b,tolerance){if(tolerance===undefined||tolerance===null||tolerance===0){return a.equals(b);}
return a.distance(b)<=tolerance;};jsts.geom.Geometry.prototype.getClassSortIndex=function(){var sortedClasses=[jsts.geom.Point,jsts.geom.MultiPoint,jsts.geom.LineString,jsts.geom.LinearRing,jsts.geom.MultiLineString,jsts.geom.Polygon,jsts.geom.MultiPolygon,jsts.geom.GeometryCollection];for(var i=0;i<sortedClasses.length;i++){if(this instanceof sortedClasses[i])
return i;}
jsts.util.Assert.shouldNeverReachHere('Class not supported: '+this);return-1;};jsts.geom.Geometry.prototype.toString=function(){return new jsts.io.WKTWriter().write(this);};jsts.geom.Geometry.prototype.createPointFromInternalCoord=function(coord,exemplar){exemplar.getPrecisionModel().makePrecise(coord);return exemplar.getFactory().createPoint(coord);};(function(){jsts.geom.Coordinate=function(x,y){if(typeof x==='number'){this.x=x;this.y=y;}else if(x instanceof jsts.geom.Coordinate){this.x=parseFloat(x.x);this.y=parseFloat(x.y);}else if(x===undefined||x===null){this.x=0;this.y=0;}else if(typeof x==='string'){this.x=parseFloat(x);this.y=parseFloat(y);}};jsts.geom.Coordinate.prototype.setCoordinate=function(other){this.x=other.x;this.y=other.y;};jsts.geom.Coordinate.prototype.clone=function(){return new jsts.geom.Coordinate(this.x,this.y);};jsts.geom.Coordinate.prototype.distance=function(p){var dx=this.x-p.x;var dy=this.y-p.y;return Math.sqrt(dx*dx+dy*dy);};jsts.geom.Coordinate.prototype.equals2D=function(other){if(this.x!==other.x){return false;}
if(this.y!==other.y){return false;}
return true;};jsts.geom.Coordinate.prototype.equals=function(other){if(!other instanceof jsts.geom.Coordinate||other===undefined){return false;}
return this.equals2D(other);};jsts.geom.Coordinate.prototype.compareTo=function(other){if(this.x<other.x){return-1;}
if(this.x>other.x){return 1;}
if(this.y<other.y){return-1;}
if(this.y>other.y){return 1;}
return 0;};jsts.geom.Coordinate.prototype.toString=function(){return'('+this.x+', '+this.y+')';};})();jsts.geom.Envelope=function(){jsts.geom.Envelope.prototype.init.apply(this,arguments);};jsts.geom.Envelope.prototype.minx=null;jsts.geom.Envelope.prototype.maxx=null;jsts.geom.Envelope.prototype.miny=null;jsts.geom.Envelope.prototype.maxy=null;jsts.geom.Envelope.prototype.init=function(){if(typeof arguments[0]==='number'&&arguments.length===4){this.initFromValues(arguments[0],arguments[1],arguments[2],arguments[3]);}else if(arguments[0]instanceof jsts.geom.Coordinate&&arguments.length===1){this.initFromCoordinate(arguments[0]);}else if(arguments[0]instanceof jsts.geom.Coordinate&&arguments.length===2){this.initFromCoordinates(arguments[0],arguments[1]);}else if(arguments[0]instanceof jsts.geom.Envelope&&arguments.length===1){this.initFromEnvelope(arguments[0]);}else{this.setToNull();}};jsts.geom.Envelope.prototype.initFromValues=function(x1,x2,y1,y2){if(x1<x2){this.minx=x1;this.maxx=x2;}else{this.minx=x2;this.maxx=x1;}
if(y1<y2){this.miny=y1;this.maxy=y2;}else{this.miny=y2;this.maxy=y1;}};jsts.geom.Envelope.prototype.initFromCoordinates=function(p1,p2){this.initFromValues(p1.x,p2.x,p1.y,p2.y);};jsts.geom.Envelope.prototype.initFromCoordinate=function(p){this.initFromValues(p.x,p.x,p.y,p.y);};jsts.geom.Envelope.prototype.initFromEnvelope=function(env){this.minx=env.minx;this.maxx=env.maxx;this.miny=env.miny;this.maxy=env.maxy;};jsts.geom.Envelope.prototype.setToNull=function(){this.minx=0;this.maxx=-1;this.miny=0;this.maxy=-1;};jsts.geom.Envelope.prototype.isNull=function(){return this.maxx<this.minx;};jsts.geom.Envelope.prototype.getHeight=function(){if(this.isNull()){return 0;}
return this.maxy-this.miny;};jsts.geom.Envelope.prototype.getWidth=function(){if(this.isNull()){return 0;}
return this.maxx-this.minx;};jsts.geom.Envelope.prototype.getMinX=function(){return this.minx;};jsts.geom.Envelope.prototype.getMaxX=function(){return this.maxx;};jsts.geom.Envelope.prototype.getMinY=function(){return this.miny;};jsts.geom.Envelope.prototype.getMaxY=function(){return this.maxy;};jsts.geom.Envelope.prototype.getArea=function(){return this.getWidth()*this.getHeight();};jsts.geom.Envelope.prototype.expandToInclude=function(){if(arguments[0]instanceof jsts.geom.Coordinate){this.expandToIncludeCoordinate(arguments[0]);}else if(arguments[0]instanceof jsts.geom.Envelope){this.expandToIncludeEnvelope(arguments[0]);}else{this.expandToIncludeValues(arguments[0],arguments[1]);}};jsts.geom.Envelope.prototype.expandToIncludeCoordinate=function(p){this.expandToIncludeValues(p.x,p.y);};jsts.geom.Envelope.prototype.expandToIncludeValues=function(x,y){if(this.isNull()){this.minx=x;this.maxx=x;this.miny=y;this.maxy=y;}else{if(x<this.minx){this.minx=x;}
if(x>this.maxx){this.maxx=x;}
if(y<this.miny){this.miny=y;}
if(y>this.maxy){this.maxy=y;}}};jsts.geom.Envelope.prototype.expandToIncludeEnvelope=function(other){if(other.isNull()){return;}
if(this.isNull()){this.minx=other.getMinX();this.maxx=other.getMaxX();this.miny=other.getMinY();this.maxy=other.getMaxY();}else{if(other.minx<this.minx){this.minx=other.minx;}
if(other.maxx>this.maxx){this.maxx=other.maxx;}
if(other.miny<this.miny){this.miny=other.miny;}
if(other.maxy>this.maxy){this.maxy=other.maxy;}}};jsts.geom.Envelope.prototype.expandBy=function(){if(arguments.length===1){this.expandByDistance(arguments[0]);}else{this.expandByDistances(arguments[0],arguments[1]);}};jsts.geom.Envelope.prototype.expandByDistance=function(distance){this.expandByDistances(distance,distance);};jsts.geom.Envelope.prototype.expandByDistances=function(deltaX,deltaY){if(this.isNull()){return;}
this.minx-=deltaX;this.maxx+=deltaX;this.miny-=deltaY;this.maxy+=deltaY;if(this.minx>this.maxx||this.miny>this.maxy){this.setToNull();}};jsts.geom.Envelope.prototype.translate=function(transX,transY){if(this.isNull()){return;}
this.init(this.minx+transX,this.maxx+transX,this.miny+transY,this.maxy+transY);};jsts.geom.Envelope.prototype.centre=function(){if(this.isNull()){return null;}
return new jsts.geom.Coordinate((this.minx+this.maxx)/2.0,(this.miny+this.maxy)/2.0);};jsts.geom.Envelope.prototype.intersection=function(env){if(this.isNull()||env.isNull()||!this.intersects(env)){return new jsts.geom.Envelope();}
var intMinX=this.minx>env.minx?this.minx:env.minx;var intMinY=this.miny>env.miny?this.miny:env.miny;var intMaxX=this.maxx<env.maxx?this.maxx:env.maxx;var intMaxY=this.maxy<env.maxy?this.maxy:env.maxy;return new jsts.geom.Envelope(intMinX,intMaxX,intMinY,intMaxY);};jsts.geom.Envelope.prototype.intersects=function(){if(arguments[0]instanceof jsts.geom.Envelope){return this.intersectsEnvelope(arguments[0]);}else if(arguments[0]instanceof jsts.geom.Coordinate){return this.intersectsCoordinate(arguments[0]);}else{return this.intersectsValues(arguments[0],arguments[1]);}};jsts.geom.Envelope.prototype.intersectsEnvelope=function(other){if(this.isNull()||other.isNull()){return false;}
var result=!(other.minx>this.maxx||other.maxx<this.minx||other.miny>this.maxy||other.maxy<this.miny);return result;};jsts.geom.Envelope.prototype.intersectsCoordinate=function(p){return this.intersectsValues(p.x,p.y);};jsts.geom.Envelope.prototype.intersectsValues=function(x,y){if(this.isNull()){return false;}
return!(x>this.maxx||x<this.minx||y>this.maxy||y<this.miny);};jsts.geom.Envelope.prototype.contains=function(){if(arguments[0]instanceof jsts.geom.Envelope){return this.containsEnvelope(arguments[0]);}else if(arguments[0]instanceof jsts.geom.Coordinate){return this.containsCoordinate(arguments[0]);}else{return this.containsValues(arguments[0],arguments[1]);}};jsts.geom.Envelope.prototype.containsEnvelope=function(other){return this.coversEnvelope(other);};jsts.geom.Envelope.prototype.containsCoordinate=function(p){return this.coversCoordinate(p);};jsts.geom.Envelope.prototype.containsValues=function(x,y){return this.coversValues(x,y);};jsts.geom.Envelope.prototype.covers=function(){if(arguments[0]instanceof jsts.geom.Envelope){return this.coversEnvelope(arguments[0]);}else if(arguments[0]instanceof jsts.geom.Coordinate){return this.coversCoordinate(arguments[0]);}else{return this.coversValues(arguments[0],arguments[1]);}};jsts.geom.Envelope.prototype.coversValues=function(x,y){if(this.isNull()){return false;}
return x>=this.minx&&x<=this.maxx&&y>=this.miny&&y<=this.maxy;};jsts.geom.Envelope.prototype.coversCoordinate=function(p){return this.coversValues(p.x,p.y);};jsts.geom.Envelope.prototype.coversEnvelope=function(other){if(this.isNull()||other.isNull()){return false;}
return other.minx>=this.minx&&other.maxx<=this.maxx&&other.miny>=this.miny&&other.maxy<=this.maxy;};jsts.geom.Envelope.prototype.distance=function(env){if(this.intersects(env)){return 0;}
var dx=0.0;if(this.maxx<env.minx){dx=env.minx-this.maxx;}
if(this.minx>env.maxx){dx=this.minx-env.maxx;}
var dy=0.0;if(this.maxy<env.miny){dy=env.miny-this.maxy;}
if(this.miny>env.maxy){dy=this.miny-env.maxy;}
if(dx===0.0){return dy;}
if(dy===0.0){return dx;}
return Math.sqrt(dx*dx+dy*dy);};jsts.geom.Envelope.prototype.equals=function(other){if(this.isNull()){return other.isNull();}
return this.maxx===other.maxx&&this.maxy===other.maxy&&this.minx===other.minx&&this.miny===other.miny;};jsts.geom.Envelope.prototype.toString=function(){return'Env['+this.minx+' : '+this.maxx+', '+this.miny+' : '+
this.maxy+']';};jsts.geom.Envelope.intersects=function(p1,p2,q){if(arguments.length===4){return jsts.geom.Envelope.intersectsEnvelope(arguments[0],arguments[1],arguments[2],arguments[3]);}
var xc1=p1.x<p2.x?p1.x:p2.x;var xc2=p1.x>p2.x?p1.x:p2.x;var yc1=p1.y<p2.y?p1.y:p2.y;var yc2=p1.y>p2.y?p1.y:p2.y;if(((q.x>=xc1)&&(q.x<=xc2))&&((q.y>=yc1)&&(q.y<=yc2))){return true;}
return false;};jsts.geom.Envelope.intersectsEnvelope=function(p1,p2,q1,q2){var minq=Math.min(q1.x,q2.x);var maxq=Math.max(q1.x,q2.x);var minp=Math.min(p1.x,p2.x);var maxp=Math.max(p1.x,p2.x);if(minp>maxq){return false;}
if(maxp<minq){return false;}
minq=Math.min(q1.y,q2.y);maxq=Math.max(q1.y,q2.y);minp=Math.min(p1.y,p2.y);maxp=Math.max(p1.y,p2.y);if(minp>maxq){return false;}
if(maxp<minq){return false;}
return true;};jsts.geom.Envelope.prototype.clone=function(){return new jsts.geom.Envelope(this.minx,this.maxx,this.miny,this.maxy);};jsts.geom.util.GeometryCombiner=function(geoms){this.geomFactory=jsts.geom.util.GeometryCombiner.extractFactory(geoms);this.inputGeoms=geoms;};jsts.geom.util.GeometryCombiner.combine=function(geoms){if(arguments.length>1)return this.combine2.apply(this,arguments);var combiner=new jsts.geom.util.GeometryCombiner(geoms);return combiner.combine();};jsts.geom.util.GeometryCombiner.combine2=function(){var arrayList=new javascript.util.ArrayList();Array.prototype.slice.call(arguments).forEach(function(a){arrayList.add(a);});var combiner=new jsts.geom.util.GeometryCombiner(arrayList);return combiner.combine();};jsts.geom.util.GeometryCombiner.prototype.geomFactory=null;jsts.geom.util.GeometryCombiner.prototype.skipEmpty=false;jsts.geom.util.GeometryCombiner.prototype.inputGeoms;jsts.geom.util.GeometryCombiner.extractFactory=function(geoms){if(geoms.isEmpty())return null;return geoms.iterator().next().getFactory();};jsts.geom.util.GeometryCombiner.prototype.combine=function(){var elems=new javascript.util.ArrayList(),i;for(i=this.inputGeoms.iterator();i.hasNext();){var g=i.next();this.extractElements(g,elems);}
if(elems.size()===0){if(this.geomFactory!==null){return this.geomFactory.createGeometryCollection(null);}
return null;}
return this.geomFactory.buildGeometry(elems);};jsts.geom.util.GeometryCombiner.prototype.extractElements=function(geom,elems){if(geom===null){return;}
for(var i=0;i<geom.getNumGeometries();i++){var elemGeom=geom.getGeometryN(i);if(this.skipEmpty&&elemGeom.isEmpty()){continue;}
elems.add(elemGeom);}};jsts.geom.PrecisionModel=function(modelType){if(typeof modelType==='number'){this.modelType=jsts.geom.PrecisionModel.FIXED;this.scale=modelType;return;}
this.modelType=modelType||jsts.geom.PrecisionModel.FLOATING;if(this.modelType===jsts.geom.PrecisionModel.FIXED){this.scale=1.0;}};jsts.geom.PrecisionModel.FLOATING='FLOATING';jsts.geom.PrecisionModel.FIXED='FIXED';jsts.geom.PrecisionModel.FLOATING_SINGLE='FLOATING_SINGLE';jsts.geom.PrecisionModel.prototype.scale=null;jsts.geom.PrecisionModel.prototype.modelType=null;jsts.geom.PrecisionModel.prototype.isFloating=function(){return this.modelType===jsts.geom.PrecisionModel.FLOATING||this.modelType===jsts.geom.PrecisionModel.FLOATING_SINLGE;};jsts.geom.PrecisionModel.prototype.getScale=function(){return this.scale;};jsts.geom.PrecisionModel.prototype.getType=function(){return this.modelType;};jsts.geom.PrecisionModel.prototype.equals=function(other){return true;if(!(other instanceof jsts.geom.PrecisionModel)){return false;}
var otherPrecisionModel=other;return this.modelType===otherPrecisionModel.modelType&&this.scale===otherPrecisionModel.scale;};jsts.geom.PrecisionModel.prototype.makePrecise=function(val){if(val instanceof jsts.geom.Coordinate){this.makePrecise2(val);return;}
if(isNaN(val))
return val;if(this.modelType===jsts.geom.PrecisionModel.FIXED){return Math.round(val*this.scale)/this.scale;}
return val;};jsts.geom.PrecisionModel.prototype.makePrecise2=function(coord){if(this.modelType===jsts.geom.PrecisionModel.FLOATING)
return;coord.x=this.makePrecise(coord.x);coord.y=this.makePrecise(coord.y);};jsts.geom.PrecisionModel.prototype.compareTo=function(o){var other=o;return 0;};jsts.geom.CoordinateFilter=function(){};jsts.geom.CoordinateFilter.prototype.filter=function(coord){throw new jsts.error.AbstractMethodInvocationError();};jsts.simplify.DouglasPeuckerLineSimplifier=function(pts){this.pts=pts;this.seg=new jsts.geom.LineSegment();};jsts.simplify.DouglasPeuckerLineSimplifier.prototype.pts=null;jsts.simplify.DouglasPeuckerLineSimplifier.prototype.usePt=null;jsts.simplify.DouglasPeuckerLineSimplifier.prototype.distanceTolerance=null;jsts.simplify.DouglasPeuckerLineSimplifier.simplify=function(pts,distanceTolerance){var simp=new jsts.simplify.DouglasPeuckerLineSimplifier(pts);simp.setDistanceTolerance(distanceTolerance);return simp.simplify();};jsts.simplify.DouglasPeuckerLineSimplifier.prototype.setDistanceTolerance=function(distanceTolerance){this.distanceTolerance=distanceTolerance;};jsts.simplify.DouglasPeuckerLineSimplifier.prototype.simplify=function(){this.usePt=[];for(var i=0;i<this.pts.length;i++){this.usePt[i]=true;}
this.simplifySection(0,this.pts.length-1);var coordList=new jsts.geom.CoordinateList();for(var j=0;j<this.pts.length;j++){if(this.usePt[j]){coordList.add(new jsts.geom.Coordinate(this.pts[j]));}}
return coordList.toCoordinateArray();};jsts.simplify.DouglasPeuckerLineSimplifier.prototype.seg=null;jsts.simplify.DouglasPeuckerLineSimplifier.prototype.simplifySection=function(i,j){if(i+1==j){return;}
this.seg.p0=this.pts[i];this.seg.p1=this.pts[j];var maxDistance=-1.0;var maxIndex=i;for(var k=i+1;k<j;k++){var distance=this.seg.distance(this.pts[k]);if(distance>maxDistance){maxDistance=distance;maxIndex=k;}}
if(maxDistance<=this.distanceTolerance){for(var l=i+1;l<j;l++){this.usePt[l]=false;}}else{this.simplifySection(i,maxIndex);this.simplifySection(maxIndex,j);}};jsts.geomgraph.EdgeIntersection=function(coord,segmentIndex,dist){this.coord=new jsts.geom.Coordinate(coord);this.segmentIndex=segmentIndex;this.dist=dist;};jsts.geomgraph.EdgeIntersection.prototype.coord=null;jsts.geomgraph.EdgeIntersection.prototype.segmentIndex=null;jsts.geomgraph.EdgeIntersection.prototype.dist=null;jsts.geomgraph.EdgeIntersection.prototype.getCoordinate=function(){return this.coord;};jsts.geomgraph.EdgeIntersection.prototype.getSegmentIndex=function(){return this.segmentIndex;};jsts.geomgraph.EdgeIntersection.prototype.getDistance=function(){return this.dist;};jsts.geomgraph.EdgeIntersection.prototype.compareTo=function(other){return this.compare(other.segmentIndex,other.dist);};jsts.geomgraph.EdgeIntersection.prototype.compare=function(segmentIndex,dist){if(this.segmentIndex<segmentIndex)
return-1;if(this.segmentIndex>segmentIndex)
return 1;if(this.dist<dist)
return-1;if(this.dist>dist)
return 1;return 0;};jsts.geomgraph.EdgeIntersection.prototype.isEndPoint=function(maxSegmentIndex){if(this.segmentIndex===0&&this.dist===0.0)
return true;if(this.segmentIndex===maxSegmentIndex)
return true;return false;};jsts.geomgraph.EdgeIntersection.prototype.toString=function(){return''+this.segmentIndex+this.dist;};(function(){var EdgeIntersection=jsts.geomgraph.EdgeIntersection;var TreeMap=javascript.util.TreeMap;jsts.geomgraph.EdgeIntersectionList=function(edge){this.nodeMap=new TreeMap();this.edge=edge;};jsts.geomgraph.EdgeIntersectionList.prototype.nodeMap=null;jsts.geomgraph.EdgeIntersectionList.prototype.edge=null;jsts.geomgraph.EdgeIntersectionList.prototype.isIntersection=function(pt){for(var it=this.iterator();it.hasNext();){var ei=it.next();if(ei.coord.equals(pt)){return true;}}
return false;};jsts.geomgraph.EdgeIntersectionList.prototype.add=function(intPt,segmentIndex,dist){var eiNew=new EdgeIntersection(intPt,segmentIndex,dist);var ei=this.nodeMap.get(eiNew);if(ei!==null){return ei;}
this.nodeMap.put(eiNew,eiNew);return eiNew;};jsts.geomgraph.EdgeIntersectionList.prototype.iterator=function(){return this.nodeMap.values().iterator();};jsts.geomgraph.EdgeIntersectionList.prototype.addEndpoints=function(){var maxSegIndex=this.edge.pts.length-1;this.add(this.edge.pts[0],0,0.0);this.add(this.edge.pts[maxSegIndex],maxSegIndex,0.0);};jsts.geomgraph.EdgeIntersectionList.prototype.addSplitEdges=function(edgeList)
{this.addEndpoints();var it=this.iterator();var eiPrev=it.next();while(it.hasNext()){var ei=it.next();var newEdge=this.createSplitEdge(eiPrev,ei);edgeList.add(newEdge);eiPrev=ei;}};jsts.geomgraph.EdgeIntersectionList.prototype.createSplitEdge=function(ei0,ei1){var npts=ei1.segmentIndex-ei0.segmentIndex+2;var lastSegStartPt=this.edge.pts[ei1.segmentIndex];var useIntPt1=ei1.dist>0.0||!ei1.coord.equals2D(lastSegStartPt);if(!useIntPt1){npts--;}
var pts=[];var ipt=0;pts[ipt++]=new jsts.geom.Coordinate(ei0.coord);for(var i=ei0.segmentIndex+1;i<=ei1.segmentIndex;i++){pts[ipt++]=this.edge.pts[i];}
if(useIntPt1)pts[ipt]=ei1.coord;return new jsts.geomgraph.Edge(pts,new jsts.geomgraph.Label(this.edge.label));};})();(function(){var AssertionFailedException=function(message){this.message=message;};AssertionFailedException.prototype=new Error();AssertionFailedException.prototype.name='AssertionFailedException';jsts.util.AssertionFailedException=AssertionFailedException;})();(function(){var AssertionFailedException=jsts.util.AssertionFailedException;jsts.util.Assert=function(){};jsts.util.Assert.isTrue=function(assertion,message){if(!assertion){if(message===null){throw new AssertionFailedException();}else{throw new AssertionFailedException(message);}}};jsts.util.Assert.equals=function(expectedValue,actualValue,message){if(!actualValue.equals(expectedValue)){throw new AssertionFailedException('Expected '+expectedValue+' but encountered '+actualValue+
(message!=null?': '+message:''));}};jsts.util.Assert.shouldNeverReachHere=function(message){throw new AssertionFailedException('Should never reach here'+
(message!=null?': '+message:''));};})();(function(){var Location=jsts.geom.Location;var Assert=jsts.util.Assert;var ArrayList=javascript.util.ArrayList;jsts.operation.relate.RelateComputer=function(arg){this.li=new jsts.algorithm.RobustLineIntersector();this.ptLocator=new jsts.algorithm.PointLocator();this.nodes=new jsts.geomgraph.NodeMap(new jsts.operation.relate.RelateNodeFactory());this.isolatedEdges=new ArrayList();this.arg=arg;};jsts.operation.relate.RelateComputer.prototype.li=null;jsts.operation.relate.RelateComputer.prototype.ptLocator=null;jsts.operation.relate.RelateComputer.prototype.arg=null;jsts.operation.relate.RelateComputer.prototype.nodes=null;jsts.operation.relate.RelateComputer.prototype.im=null;jsts.operation.relate.RelateComputer.prototype.isolatedEdges=null;jsts.operation.relate.RelateComputer.prototype.invalidPoint=null;jsts.operation.relate.RelateComputer.prototype.computeIM=function(){var im=new jsts.geom.IntersectionMatrix();im.set(Location.EXTERIOR,Location.EXTERIOR,2);if(!this.arg[0].getGeometry().getEnvelopeInternal().intersects(this.arg[1].getGeometry().getEnvelopeInternal())){this.computeDisjointIM(im);return im;}
this.arg[0].computeSelfNodes(this.li,false);this.arg[1].computeSelfNodes(this.li,false);var intersector=this.arg[0].computeEdgeIntersections(this.arg[1],this.li,false);this.computeIntersectionNodes(0);this.computeIntersectionNodes(1);this.copyNodesAndLabels(0);this.copyNodesAndLabels(1);this.labelIsolatedNodes();this.computeProperIntersectionIM(intersector,im);var eeBuilder=new jsts.operation.relate.EdgeEndBuilder();var ee0=eeBuilder.computeEdgeEnds(this.arg[0].getEdgeIterator());this.insertEdgeEnds(ee0);var ee1=eeBuilder.computeEdgeEnds(this.arg[1].getEdgeIterator());this.insertEdgeEnds(ee1);this.labelNodeEdges();this.labelIsolatedEdges(0,1);this.labelIsolatedEdges(1,0);this.updateIM(im);return im;};jsts.operation.relate.RelateComputer.prototype.insertEdgeEnds=function(ee){for(var i=ee.iterator();i.hasNext();){var e=i.next();this.nodes.add(e);}};jsts.operation.relate.RelateComputer.prototype.computeProperIntersectionIM=function(intersector,im){var dimA=this.arg[0].getGeometry().getDimension();var dimB=this.arg[1].getGeometry().getDimension();var hasProper=intersector.hasProperIntersection();var hasProperInterior=intersector.hasProperInteriorIntersection();if(dimA===2&&dimB===2){if(hasProper)
im.setAtLeast('212101212');}
else if(dimA===2&&dimB===1){if(hasProper)
im.setAtLeast('FFF0FFFF2');if(hasProperInterior)
im.setAtLeast('1FFFFF1FF');}else if(dimA===1&&dimB===2){if(hasProper)
im.setAtLeast('F0FFFFFF2');if(hasProperInterior)
im.setAtLeast('1F1FFFFFF');}
else if(dimA===1&&dimB===1){if(hasProperInterior)
im.setAtLeast('0FFFFFFFF');}};jsts.operation.relate.RelateComputer.prototype.copyNodesAndLabels=function(argIndex){for(var i=this.arg[argIndex].getNodeIterator();i.hasNext();){var graphNode=i.next();var newNode=this.nodes.addNode(graphNode.getCoordinate());newNode.setLabel(argIndex,graphNode.getLabel().getLocation(argIndex));}};jsts.operation.relate.RelateComputer.prototype.computeIntersectionNodes=function(argIndex){for(var i=this.arg[argIndex].getEdgeIterator();i.hasNext();){var e=i.next();var eLoc=e.getLabel().getLocation(argIndex);for(var eiIt=e.getEdgeIntersectionList().iterator();eiIt.hasNext();){var ei=eiIt.next();var n=this.nodes.addNode(ei.coord);if(eLoc===Location.BOUNDARY)
n.setLabelBoundary(argIndex);else{if(n.getLabel().isNull(argIndex))
n.setLabel(argIndex,Location.INTERIOR);}}}};jsts.operation.relate.RelateComputer.prototype.labelIntersectionNodes=function(argIndex){for(var i=this.arg[argIndex].getEdgeIterator();i.hasNext();){var e=i.next();var eLoc=e.getLabel().getLocation(argIndex);for(var eiIt=e.getEdgeIntersectionList().iterator();eiIt.hasNext();){var ei=eiIt.next();var n=this.nodes.find(ei.coord);if(n.getLabel().isNull(argIndex)){if(eLoc===Location.BOUNDARY)
n.setLabelBoundary(argIndex);else
n.setLabel(argIndex,Location.INTERIOR);}}}};jsts.operation.relate.RelateComputer.prototype.computeDisjointIM=function(im){var ga=this.arg[0].getGeometry();if(!ga.isEmpty()){im.set(Location.INTERIOR,Location.EXTERIOR,ga.getDimension());im.set(Location.BOUNDARY,Location.EXTERIOR,ga.getBoundaryDimension());}
var gb=this.arg[1].getGeometry();if(!gb.isEmpty()){im.set(Location.EXTERIOR,Location.INTERIOR,gb.getDimension());im.set(Location.EXTERIOR,Location.BOUNDARY,gb.getBoundaryDimension());}};jsts.operation.relate.RelateComputer.prototype.labelNodeEdges=function(){for(var ni=this.nodes.iterator();ni.hasNext();){var node=ni.next();node.getEdges().computeLabelling(this.arg);}};jsts.operation.relate.RelateComputer.prototype.updateIM=function(im){for(var ei=this.isolatedEdges.iterator();ei.hasNext();){var e=ei.next();e.updateIM(im);}
for(var ni=this.nodes.iterator();ni.hasNext();){var node=ni.next();node.updateIM(im);node.updateIMFromEdges(im);}};jsts.operation.relate.RelateComputer.prototype.labelIsolatedEdges=function(thisIndex,targetIndex){for(var ei=this.arg[thisIndex].getEdgeIterator();ei.hasNext();){var e=ei.next();if(e.isIsolated()){this.labelIsolatedEdge(e,targetIndex,this.arg[targetIndex].getGeometry());this.isolatedEdges.add(e);}}};jsts.operation.relate.RelateComputer.prototype.labelIsolatedEdge=function(e,targetIndex,target){if(target.getDimension()>0){var loc=this.ptLocator.locate(e.getCoordinate(),target);e.getLabel().setAllLocations(targetIndex,loc);}else{e.getLabel().setAllLocations(targetIndex,Location.EXTERIOR);}};jsts.operation.relate.RelateComputer.prototype.labelIsolatedNodes=function(){for(var ni=this.nodes.iterator();ni.hasNext();){var n=ni.next();var label=n.getLabel();Assert.isTrue(label.getGeometryCount()>0,'node with empty label found');if(n.isIsolated()){if(label.isNull(0))
this.labelIsolatedNode(n,0);else
this.labelIsolatedNode(n,1);}}};jsts.operation.relate.RelateComputer.prototype.labelIsolatedNode=function(n,targetIndex){var loc=this.ptLocator.locate(n.getCoordinate(),this.arg[targetIndex].getGeometry());n.getLabel().setAllLocations(targetIndex,loc);};})();(function(){var Assert=jsts.util.Assert;jsts.geomgraph.GraphComponent=function(label){this.label=label;};jsts.geomgraph.GraphComponent.prototype.label=null;jsts.geomgraph.GraphComponent.prototype._isInResult=false;jsts.geomgraph.GraphComponent.prototype._isCovered=false;jsts.geomgraph.GraphComponent.prototype._isCoveredSet=false;jsts.geomgraph.GraphComponent.prototype._isVisited=false;jsts.geomgraph.GraphComponent.prototype.getLabel=function(){return this.label;};jsts.geomgraph.GraphComponent.prototype.setLabel=function(label){if(arguments.length===2){this.setLabel2.apply(this,arguments);return;}
this.label=label;};jsts.geomgraph.GraphComponent.prototype.setInResult=function(isInResult){this._isInResult=isInResult;};jsts.geomgraph.GraphComponent.prototype.isInResult=function(){return this._isInResult;};jsts.geomgraph.GraphComponent.prototype.setCovered=function(isCovered){this._isCovered=isCovered;this._isCoveredSet=true;};jsts.geomgraph.GraphComponent.prototype.isCovered=function(){return this._isCovered;};jsts.geomgraph.GraphComponent.prototype.isCoveredSet=function(){return this._isCoveredSet;};jsts.geomgraph.GraphComponent.prototype.isVisited=function(){return this._isVisited;};jsts.geomgraph.GraphComponent.prototype.setVisited=function(isVisited){this._isVisited=isVisited;};jsts.geomgraph.GraphComponent.prototype.getCoordinate=function(){throw new jsts.error.AbstractMethodInvocationError();};jsts.geomgraph.GraphComponent.prototype.computeIM=function(im){throw new jsts.error.AbstractMethodInvocationError();};jsts.geomgraph.GraphComponent.prototype.isIsolated=function(){throw new jsts.error.AbstractMethodInvocationError();};jsts.geomgraph.GraphComponent.prototype.updateIM=function(im){Assert.isTrue(this.label.getGeometryCount()>=2,'found partial label');this.computeIM(im);};})();jsts.geomgraph.Node=function(coord,edges){this.coord=coord;this.edges=edges;this.label=new jsts.geomgraph.Label(0,jsts.geom.Location.NONE);};jsts.geomgraph.Node.prototype=new jsts.geomgraph.GraphComponent();jsts.geomgraph.Node.prototype.coord=null;jsts.geomgraph.Node.prototype.edges=null;jsts.geomgraph.Node.prototype.isIsolated=function(){return(this.label.getGeometryCount()==1);};jsts.geomgraph.Node.prototype.setLabel2=function(argIndex,onLocation){if(this.label===null){this.label=new jsts.geomgraph.Label(argIndex,onLocation);}else
this.label.setLocation(argIndex,onLocation);};jsts.geomgraph.Node.prototype.setLabelBoundary=function(argIndex){var loc=jsts.geom.Location.NONE;if(this.label!==null)
loc=this.label.getLocation(argIndex);var newLoc;switch(loc){case jsts.geom.Location.BOUNDARY:newLoc=jsts.geom.Location.INTERIOR;break;case jsts.geom.Location.INTERIOR:newLoc=jsts.geom.Location.BOUNDARY;break;default:newLoc=jsts.geom.Location.BOUNDARY;break;}
this.label.setLocation(argIndex,newLoc);};jsts.geomgraph.Node.prototype.add=function(e){this.edges.insert(e);e.setNode(this);};jsts.geomgraph.Node.prototype.getCoordinate=function(){return this.coord;};jsts.geomgraph.Node.prototype.getEdges=function(){return this.edges;};jsts.geomgraph.Node.prototype.isIncidentEdgeInResult=function(){for(var it=this.getEdges().getEdges().iterator();it.hasNext();){var de=it.next();if(de.getEdge().isInResult())
return true;}
return false;};jsts.geom.Point=function(coordinate,factory){this.factory=factory;if(coordinate===undefined)
return;this.coordinate=coordinate;};jsts.geom.Point.prototype=new jsts.geom.Geometry();jsts.geom.Point.constructor=jsts.geom.Point;jsts.geom.Point.CLASS_NAME='jsts.geom.Point';jsts.geom.Point.prototype.coordinate=null;jsts.geom.Point.prototype.getX=function(){return this.coordinate.x;};jsts.geom.Point.prototype.getY=function(){return this.coordinate.y;};jsts.geom.Point.prototype.getCoordinate=function(){return this.coordinate;};jsts.geom.Point.prototype.getCoordinates=function(){return this.isEmpty()?[]:[this.coordinate];};jsts.geom.Point.prototype.getCoordinateSequence=function(){return this.isEmpty()?[]:[this.coordinate];};jsts.geom.Point.prototype.isEmpty=function(){return this.coordinate===null;};jsts.geom.Point.prototype.equalsExact=function(other,tolerance){if(!this.isEquivalentClass(other)){return false;}
if(this.isEmpty()&&other.isEmpty()){return true;}
return this.equal(other.getCoordinate(),this.getCoordinate(),tolerance);};jsts.geom.Point.prototype.getNumPoints=function(){return this.isEmpty()?0:1;};jsts.geom.Point.prototype.isSimple=function(){return true;};jsts.geom.Point.prototype.getBoundary=function(){return new jsts.geom.GeometryCollection(null);};jsts.geom.Point.prototype.computeEnvelopeInternal=function(){if(this.isEmpty()){return new jsts.geom.Envelope();}
return new jsts.geom.Envelope(this.coordinate);};jsts.geom.Point.prototype.apply=function(filter){if(filter instanceof jsts.geom.GeometryFilter||filter instanceof jsts.geom.GeometryComponentFilter){filter.filter(this);}else if(filter instanceof jsts.geom.CoordinateFilter){if(this.isEmpty()){return;}
filter.filter(this.getCoordinate());}};jsts.geom.Point.prototype.clone=function(){return new jsts.geom.Point(this.coordinate.clone(),this.factory);};jsts.geom.Point.prototype.getDimension=function(){return 0;};jsts.geom.Point.prototype.getBoundaryDimension=function(){return jsts.geom.Dimension.FALSE;};jsts.geom.Point.prototype.reverse=function(){return this.clone();};jsts.geom.Point.prototype.isValid=function(){if(!jsts.operation.valid.IsValidOp.isValid(this.getCoordinate())){return false;}
return true;};jsts.geom.Point.prototype.normalize=function(){};jsts.geom.Point.prototype.compareToSameClass=function(other){var point=other;return this.getCoordinate().compareTo(point.getCoordinate());};jsts.geom.Point.prototype.getGeometryType=function(){return'Point';};jsts.geom.Point.prototype.hashCode=function(){return'Point_'+this.coordinate.hashCode();};jsts.geom.Point.prototype.CLASS_NAME='jsts.geom.Point';jsts.geom.Dimension=function(){};jsts.geom.Dimension.P=0;jsts.geom.Dimension.L=1;jsts.geom.Dimension.A=2;jsts.geom.Dimension.FALSE=-1;jsts.geom.Dimension.TRUE=-2;jsts.geom.Dimension.DONTCARE=-3;jsts.geom.Dimension.toDimensionSymbol=function(dimensionValue){switch(dimensionValue){case jsts.geom.Dimension.FALSE:return'F';case jsts.geom.Dimension.TRUE:return'T';case jsts.geom.Dimension.DONTCARE:return'*';case jsts.geom.Dimension.P:return'0';case jsts.geom.Dimension.L:return'1';case jsts.geom.Dimension.A:return'2';}
throw new jsts.IllegalArgumentError('Unknown dimension value: '+
dimensionValue);};jsts.geom.Dimension.toDimensionValue=function(dimensionSymbol){switch(dimensionSymbol.toUpperCase()){case'F':return jsts.geom.Dimension.FALSE;case'T':return jsts.geom.Dimension.TRUE;case'*':return jsts.geom.Dimension.DONTCARE;case'0':return jsts.geom.Dimension.P;case'1':return jsts.geom.Dimension.L;case'2':return jsts.geom.Dimension.A;}
throw new jsts.error.IllegalArgumentError('Unknown dimension symbol: '+
dimensionSymbol);};(function(){var Dimension=jsts.geom.Dimension;jsts.geom.LineString=function(points,factory){this.factory=factory;this.points=points||[];};jsts.geom.LineString.prototype=new jsts.geom.Geometry();jsts.geom.LineString.constructor=jsts.geom.LineString;jsts.geom.LineString.prototype.points=null;jsts.geom.LineString.prototype.getCoordinates=function(){return this.points;};jsts.geom.LineString.prototype.getCoordinateSequence=function(){return this.points;};jsts.geom.LineString.prototype.getCoordinateN=function(n){return this.points[n];};jsts.geom.LineString.prototype.getCoordinate=function(){if(this.isEmpty()){return null;}
return this.getCoordinateN(0);};jsts.geom.LineString.prototype.getDimension=function(){return 1;};jsts.geom.LineString.prototype.getBoundaryDimension=function(){if(this.isClosed()){return Dimension.FALSE;}
return 0;};jsts.geom.LineString.prototype.isEmpty=function(){return this.points.length===0;};jsts.geom.LineString.prototype.getNumPoints=function(){return this.points.length;};jsts.geom.LineString.prototype.getPointN=function(n){return this.getFactory().createPoint(this.points[n]);};jsts.geom.LineString.prototype.getStartPoint=function(){if(this.isEmpty()){return null;}
return this.getPointN(0);};jsts.geom.LineString.prototype.getEndPoint=function(){if(this.isEmpty()){return null;}
return this.getPointN(this.getNumPoints()-1);};jsts.geom.LineString.prototype.isClosed=function(){if(this.isEmpty()){return false;}
return this.getCoordinateN(0).equals2D(this.getCoordinateN(this.points.length-1));};jsts.geom.LineString.prototype.isRing=function(){return this.isClosed()&&this.isSimple();};jsts.geom.LineString.prototype.getGeometryType=function(){return'LineString';};jsts.geom.LineString.prototype.getLength=function(){return jsts.algorithm.CGAlgorithms.computeLength(this.points);};jsts.geom.LineString.prototype.getBoundary=function(){return(new jsts.operation.BoundaryOp(this)).getBoundary();};jsts.geom.LineString.prototype.computeEnvelopeInternal=function(){if(this.isEmpty()){return new jsts.geom.Envelope();}
var env=new jsts.geom.Envelope();this.points.forEach(function(component){env.expandToInclude(component);});return env;};jsts.geom.LineString.prototype.equalsExact=function(other,tolerance){if(!this.isEquivalentClass(other)){return false;}
if(this.points.length!==other.points.length){return false;}
if(this.isEmpty()&&other.isEmpty()){return true;}
return this.points.reduce(function(equal,point,i){return equal&&jsts.geom.Geometry.prototype.equal(point,other.points[i],tolerance);});};jsts.geom.LineString.prototype.isEquivalentClass=function(other){return other instanceof jsts.geom.LineString;};jsts.geom.LineString.prototype.compareToSameClass=function(o){var line=o;var i=0,il=this.points.length;var j=0,jl=line.points.length;while(i<il&&j<jl){var comparison=this.points[i].compareTo(line.points[j]);if(comparison!==0){return comparison;}
i++;j++;}
if(i<il){return 1;}
if(j<jl){return-1;}
return 0;};jsts.geom.LineString.prototype.apply=function(filter){if(filter instanceof jsts.geom.GeometryFilter||filter instanceof jsts.geom.GeometryComponentFilter){filter.filter(this);}else if(filter instanceof jsts.geom.CoordinateFilter){for(var i=0,len=this.points.length;i<len;i++){filter.filter(this.points[i]);}}else if(filter instanceof jsts.geom.CoordinateSequenceFilter){this.apply2.apply(this,arguments);}};jsts.geom.LineString.prototype.apply2=function(filter){if(this.points.length===0)
return;for(var i=0;i<this.points.length;i++){filter.filter(this.points,i);if(filter.isDone())
break;}
if(filter.isGeometryChanged()){}};jsts.geom.LineString.prototype.clone=function(){var points=[];for(var i=0,len=this.points.length;i<len;i++){points.push(this.points[i].clone());}
return this.factory.createLineString(points);};jsts.geom.LineString.prototype.normalize=function(){var i,il,j,ci,cj,len;len=this.points.length;il=parseInt(len/2);for(i=0;i<il;i++){j=len-1-i;ci=this.points[i];cj=this.points[j];if(!ci.equals(cj)){if(ci.compareTo(cj)>0){this.points.reverse();}
return;}}};jsts.geom.LineString.prototype.CLASS_NAME='jsts.geom.LineString';})();(function(){jsts.geom.Polygon=function(shell,holes,factory){this.shell=shell||factory.createLinearRing(null);this.holes=holes||[];this.factory=factory;};jsts.geom.Polygon.prototype=new jsts.geom.Geometry();jsts.geom.Polygon.constructor=jsts.geom.Polygon;jsts.geom.Polygon.prototype.getCoordinate=function(){return this.shell.getCoordinate();};jsts.geom.Polygon.prototype.getCoordinates=function(){if(this.isEmpty()){return[];}
var coordinates=[];var k=-1;var shellCoordinates=this.shell.getCoordinates();for(var x=0;x<shellCoordinates.length;x++){k++;coordinates[k]=shellCoordinates[x];}
for(var i=0;i<this.holes.length;i++){var childCoordinates=this.holes[i].getCoordinates();for(var j=0;j<childCoordinates.length;j++){k++;coordinates[k]=childCoordinates[j];}}
return coordinates;};jsts.geom.Polygon.prototype.getNumPoints=function(){var numPoints=this.shell.getNumPoints();for(var i=0;i<this.holes.length;i++){numPoints+=this.holes[i].getNumPoints();}
return numPoints;};jsts.geom.Polygon.prototype.isEmpty=function(){return this.shell.isEmpty();};jsts.geom.Polygon.prototype.isRectangle=function(){if(this.getNumInteriorRing()!=0)return false;if(this.shell==null)return false;if(this.shell.getNumPoints()!=5)return false;var seq=this.shell.getCoordinateSequence();var env=this.getEnvelopeInternal();for(var i=0;i<5;i++){var x=seq[i].x;if(!(x==env.getMinX()||x==env.getMaxX()))return false;var y=seq[i].y;if(!(y==env.getMinY()||y==env.getMaxY()))return false;}
var prevX=seq[0].x;var prevY=seq[0].y;for(var i=1;i<=4;i++){var x=seq[i].x;var y=seq[i].y;var xChanged=x!=prevX;var yChanged=y!=prevY;if(xChanged==yChanged)
return false;prevX=x;prevY=y;}
return true;};jsts.geom.Polygon.prototype.getExteriorRing=function(){return this.shell;};jsts.geom.Polygon.prototype.getInteriorRingN=function(n){return this.holes[n];};jsts.geom.Polygon.prototype.getNumInteriorRing=function(){return this.holes.length;};jsts.geom.Polygon.prototype.getArea=function(){var area=0.0;area+=Math.abs(jsts.algorithm.CGAlgorithms.signedArea(this.shell.getCoordinateSequence()));for(var i=0;i<this.holes.length;i++){area-=Math.abs(jsts.algorithm.CGAlgorithms.signedArea(this.holes[i].getCoordinateSequence()));}
return area;};jsts.geom.Polygon.prototype.getLength=function(){var len=0.0;len+=this.shell.getLength();for(var i=0;i<this.holes.length;i++){len+=this.holes[i].getLength();}
return len;};jsts.geom.Polygon.prototype.getBoundary=function(){if(this.isEmpty()){return this.getFactory().createMultiLineString(null);}
var rings=[];rings[0]=this.shell.clone();for(var i=0,len=this.holes.length;i<len;i++){rings[i+1]=this.holes[i].clone();}
if(rings.length<=1)
return rings[0];return this.getFactory().createMultiLineString(rings);};jsts.geom.Polygon.prototype.computeEnvelopeInternal=function(){return this.shell.getEnvelopeInternal();};jsts.geom.Polygon.prototype.getDimension=function(){return 2;};jsts.geom.Polygon.prototype.getBoundaryDimension=function(){return 1;};jsts.geom.Polygon.prototype.equalsExact=function(other,tolerance){if(!this.isEquivalentClass(other)){return false;}
if(this.isEmpty()&&other.isEmpty()){return true;}
if(this.isEmpty()!==other.isEmpty()){return false;}
if(!this.shell.equalsExact(other.shell,tolerance)){return false;}
if(this.holes.length!==other.holes.length){return false;}
if(this.holes.length!==other.holes.length){return false;}
for(var i=0;i<this.holes.length;i++){if(!(this.holes[i]).equalsExact(other.holes[i],tolerance)){return false;}}
return true;};jsts.geom.Polygon.prototype.compareToSameClass=function(o){return this.shell.compareToSameClass(o.shell);};jsts.geom.Polygon.prototype.apply=function(filter){if(filter instanceof jsts.geom.GeometryComponentFilter){filter.filter(this);this.shell.apply(filter);for(var i=0,len=this.holes.length;i<len;i++){this.holes[i].apply(filter);}}else if(filter instanceof jsts.geom.GeometryFilter){filter.filter(this);}else if(filter instanceof jsts.geom.CoordinateFilter){this.shell.apply(filter);for(var i=0,len=this.holes.length;i<len;i++){this.holes[i].apply(filter);}}else if(filter instanceof jsts.geom.CoordinateSequenceFilter){this.apply2.apply(this,arguments);}};jsts.geom.Polygon.prototype.apply2=function(filter){this.shell.apply(filter);if(!filter.isDone()){for(var i=0;i<this.holes.length;i++){this.holes[i].apply(filter);if(filter.isDone())
break;}}
if(filter.isGeometryChanged()){}};jsts.geom.Polygon.prototype.clone=function(){var holes=[];for(var i=0,len=this.holes.length;i<len;i++){holes.push(this.holes[i].clone());}
return this.factory.createPolygon(this.shell.clone(),holes);};jsts.geom.Polygon.prototype.normalize=function(){this.normalize2(this.shell,true);for(var i=0,len=this.holes.length;i<len;i++){this.normalize2(this.holes[i],false);}
this.holes.sort();};jsts.geom.Polygon.prototype.normalize2=function(ring,clockwise){if(ring.isEmpty()){return;}
var uniqueCoordinates=ring.points.slice(0,ring.points.length-1);var minCoordinate=jsts.geom.CoordinateArrays.minCoordinate(ring.points);jsts.geom.CoordinateArrays.scroll(uniqueCoordinates,minCoordinate);ring.points=uniqueCoordinates.concat();ring.points[uniqueCoordinates.length]=uniqueCoordinates[0];if(jsts.algorithm.CGAlgorithms.isCCW(ring.points)===clockwise){ring.points.reverse();}};jsts.geom.Polygon.prototype.getGeometryType=function(){return'Polygon';};jsts.geom.Polygon.prototype.CLASS_NAME='jsts.geom.Polygon';})();(function(){var Geometry=jsts.geom.Geometry;var TreeSet=javascript.util.TreeSet;var Arrays=javascript.util.Arrays;jsts.geom.GeometryCollection=function(geometries,factory){this.geometries=geometries||[];this.factory=factory;};jsts.geom.GeometryCollection.prototype=new Geometry();jsts.geom.GeometryCollection.constructor=jsts.geom.GeometryCollection;jsts.geom.GeometryCollection.prototype.isEmpty=function(){for(var i=0,len=this.geometries.length;i<len;i++){var geometry=this.getGeometryN(i);if(!geometry.isEmpty()){return false;}}
return true;};jsts.geom.GeometryCollection.prototype.getArea=function(){var area=0.0;for(var i=0,len=this.geometries.length;i<len;i++){area+=this.getGeometryN(i).getArea();}
return area;};jsts.geom.GeometryCollection.prototype.getLength=function(){var length=0.0;for(var i=0,len=this.geometries.length;i<len;i++){length+=this.getGeometryN(i).getLength();}
return length;};jsts.geom.GeometryCollection.prototype.getCoordinate=function(){if(this.isEmpty())
return null;return this.getGeometryN(0).getCoordinate();};jsts.geom.GeometryCollection.prototype.getCoordinates=function(){var coordinates=[];var k=-1;for(var i=0,len=this.geometries.length;i<len;i++){var geometry=this.getGeometryN(i);var childCoordinates=geometry.getCoordinates();for(var j=0;j<childCoordinates.length;j++){k++;coordinates[k]=childCoordinates[j];}}
return coordinates;};jsts.geom.GeometryCollection.prototype.getNumGeometries=function(){return this.geometries.length;};jsts.geom.GeometryCollection.prototype.getGeometryN=function(n){var geometry=this.geometries[n];if(geometry instanceof jsts.geom.Coordinate){geometry=new jsts.geom.Point(geometry);}
return geometry;};jsts.geom.GeometryCollection.prototype.getNumPoints=function(n){var numPoints=0;for(var i=0;i<this.geometries.length;i++){numPoints+=this.geometries[i].getNumPoints();}
return numPoints;}
jsts.geom.GeometryCollection.prototype.equalsExact=function(other,tolerance){if(!this.isEquivalentClass(other)){return false;}
if(this.geometries.length!==other.geometries.length){return false;}
for(var i=0,len=this.geometries.length;i<len;i++){var geometry=this.getGeometryN(i);if(!geometry.equalsExact(other.getGeometryN(i),tolerance)){return false;}}
return true;};jsts.geom.GeometryCollection.prototype.clone=function(){var geometries=[];for(var i=0,len=this.geometries.length;i<len;i++){geometries.push(this.geometries[i].clone());}
return this.factory.createGeometryCollection(geometries);};jsts.geom.GeometryCollection.prototype.normalize=function(){for(var i=0,len=this.geometries.length;i<len;i++){this.getGeometryN(i).normalize();}
this.geometries.sort();};jsts.geom.GeometryCollection.prototype.compareToSameClass=function(o){var theseElements=new TreeSet(Arrays.asList(this.geometries));var otherElements=new TreeSet(Arrays.asList(o.geometries));return this.compare(theseElements,otherElements);};jsts.geom.GeometryCollection.prototype.apply=function(filter){if(filter instanceof jsts.geom.GeometryFilter||filter instanceof jsts.geom.GeometryComponentFilter){filter.filter(this);for(var i=0,len=this.geometries.length;i<len;i++){this.getGeometryN(i).apply(filter);}}else if(filter instanceof jsts.geom.CoordinateFilter){for(var i=0,len=this.geometries.length;i<len;i++){this.getGeometryN(i).apply(filter);}}else if(filter instanceof jsts.geom.CoordinateSequenceFilter){this.apply2.apply(this,arguments);}};jsts.geom.GeometryCollection.prototype.apply2=function(filter){if(this.geometries.length==0)
return;for(var i=0;i<this.geometries.length;i++){this.geometries[i].apply(filter);if(filter.isDone()){break;}}
if(filter.isGeometryChanged()){}};jsts.geom.GeometryCollection.prototype.getDimension=function(){var dimension=jsts.geom.Dimension.FALSE;for(var i=0,len=this.geometries.length;i<len;i++){var geometry=this.getGeometryN(i);dimension=Math.max(dimension,geometry.getDimension());}
return dimension;};jsts.geom.GeometryCollection.prototype.computeEnvelopeInternal=function(){var envelope=new jsts.geom.Envelope();for(var i=0,len=this.geometries.length;i<len;i++){var geometry=this.getGeometryN(i);envelope.expandToInclude(geometry.getEnvelopeInternal());}
return envelope;};jsts.geom.GeometryCollection.prototype.CLASS_NAME='jsts.geom.GeometryCollection';})();jsts.algorithm.Centroid=function(geometry){this.areaBasePt=null;this.triangleCent3=new jsts.geom.Coordinate();this.areasum2=0;this.cg3=new jsts.geom.Coordinate();this.lineCentSum=new jsts.geom.Coordinate();this.totalLength=0;this.ptCount=0;this.ptCentSum=new jsts.geom.Coordinate();this.add(geometry);};jsts.algorithm.Centroid.getCentroid=function(geometry){var cent=new jsts.algorithm.Centroid(geometry);return cent.getCentroid();};jsts.algorithm.Centroid.centroid3=function(p1,p2,p3,c){c.x=p1.x+p2.x+p3.x;c.y=p1.y+p2.y+p3.y;};jsts.algorithm.Centroid.area2=function(p1,p2,p3){return(p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y);};jsts.algorithm.Centroid.prototype.add=function(geom){if(geom.isEmpty()){return;}
if(geom instanceof jsts.geom.Point){this.addPoint(geom.getCoordinate());}else if(geom instanceof jsts.geom.LineString){this.addLineSegments(geom.getCoordinates());}else if(geom instanceof jsts.geom.Polygon){this.addPolygon(geom);}else if(geom instanceof jsts.geom.GeometryCollection){for(var i=0;i<geom.getNumGeometries();i++){this.add(geom.getGeometryN(i));}}};jsts.algorithm.Centroid.prototype.getCentroid=function(){var cent=new jsts.geom.Coordinate();if(Math.abs(this.areasum2)>0){cent.x=this.cg3.x/3/this.areasum2;cent.y=this.cg3.y/3/this.areasum2;}else if(this.totalLength>0){cent.x=this.lineCentSum.x/this.totalLength;cent.y=this.lineCentSum.y/this.totalLength;}else if(this.ptCount>0){cent.x=this.ptCentSum.x/this.ptCount;cent.y=this.ptCentSum.y/this.ptCount;}else{return null;}
return cent;};jsts.algorithm.Centroid.prototype.setBasePoint=function(basePt){if(this.areaBasePt===null){this.areaBasePt=basePt;}};jsts.algorithm.Centroid.prototype.addPolygon=function(poly){this.addShell(poly.getExteriorRing().getCoordinates());for(var i=0;i<poly.getNumInteriorRing();i++){this.addHole(poly.getInteriorRingN(i).getCoordinates());}};jsts.algorithm.Centroid.prototype.addShell=function(pts){if(pts.length>0){this.setBasePoint(pts[0]);}
var isPositiveArea=!jsts.algorithm.CGAlgorithms.isCCW(pts);for(var i=0;i<pts.length-1;i++){this.addTriangle(this.areaBasePt,pts[i],pts[i+1],isPositiveArea);}
this.addLineSegments(pts);};jsts.algorithm.Centroid.prototype.addHole=function(pts){var isPositiveArea=jsts.algorithm.CGAlgorithms.isCCW(pts);for(var i=0;i<pts.length-1;i++){this.addTriangle(this.areaBasePt,pts[i],pts[i+1],isPositiveArea);}
this.addLineSegments(pts);};jsts.algorithm.Centroid.prototype.addTriangle=function(p0,p1,p2,isPositiveArea){var sign=(isPositiveArea)?1:-1;jsts.algorithm.Centroid.centroid3(p0,p1,p2,this.triangleCent3);var area2=jsts.algorithm.Centroid.area2(p0,p1,p2);this.cg3.x+=sign*area2*this.triangleCent3.x;this.cg3.y+=sign*area2*this.triangleCent3.y;this.areasum2+=sign*area2;};jsts.algorithm.Centroid.prototype.addLineSegments=function(pts){var lineLen=0;for(var i=0;i<pts.length-1;i++){var segmentLen=pts[i].distance(pts[i+1]);if(segmentLen===0){continue;}
lineLen+=segmentLen;var midx=(pts[i].x+pts[i+1].x)/2;this.lineCentSum.x+=segmentLen*midx;var midy=(pts[i].y+pts[i+1].y)/2;this.lineCentSum.y+=segmentLen*midy;}
this.totalLength+=lineLen;if(lineLen===0&&pts.length>0){this.addPoint(pts[0]);}};jsts.algorithm.Centroid.prototype.addPoint=function(pt){this.ptCount+=1;this.ptCentSum.x+=pt.x;this.ptCentSum.y+=pt.y;};(function(){var EdgeRing=function(factory){this.deList=new javascript.util.ArrayList();this.factory=factory;};EdgeRing.findEdgeRingContaining=function(testEr,shellList){var testRing=testEr.getRing();var testEnv=testRing.getEnvelopeInternal();var testPt=testRing.getCoordinateN(0);var minShell=null;var minEnv=null;for(var it=shellList.iterator();it.hasNext();){var tryShell=it.next();var tryRing=tryShell.getRing();var tryEnv=tryRing.getEnvelopeInternal();if(minShell!=null)
minEnv=minShell.getRing().getEnvelopeInternal();var isContained=false;if(tryEnv.equals(testEnv))
continue;testPt=jsts.geom.CoordinateArrays.ptNotInList(testRing.getCoordinates(),tryRing.getCoordinates());if(tryEnv.contains(testEnv)&&jsts.algorithm.CGAlgorithms.isPointInRing(testPt,tryRing.getCoordinates()))
isContained=true;if(isContained){if(minShell==null||minEnv.contains(tryEnv)){minShell=tryShell;}}}
return minShell;};EdgeRing.ptNotInList=function(testPts,pts){for(var i=0;i<testPts.length;i++){var testPt=testPts[i];if(!isInList(testPt,pts))
return testPt;}
return null;};EdgeRing.isInList=function(pt,pts){for(var i=0;i<pts.length;i++){if(pt.equals(pts[i]))
return true;}
return false;}
EdgeRing.prototype.factory=null;EdgeRing.prototype.deList=null;EdgeRing.prototype.ring=null;EdgeRing.prototype.ringPts=null;EdgeRing.prototype.holes=null;EdgeRing.prototype.add=function(de){this.deList.add(de);};EdgeRing.prototype.isHole=function(){var ring=this.getRing();return jsts.algorithm.CGAlgorithms.isCCW(ring.getCoordinates());};EdgeRing.prototype.addHole=function(hole){if(this.holes==null)
this.holes=new javascript.util.ArrayList();this.holes.add(hole);};EdgeRing.prototype.getPolygon=function(){var holeLR=null;if(this.holes!=null){holeLR=[];for(var i=0;i<this.holes.size();i++){holeLR[i]=this.holes.get(i);}}
var poly=this.factory.createPolygon(this.ring,holeLR);return poly;};EdgeRing.prototype.isValid=function(){this.getCoordinates();if(this.ringPts.length<=3)
return false;this.getRing();return this.ring.isValid();};EdgeRing.prototype.getCoordinates=function(){if(this.ringPts==null){var coordList=new jsts.geom.CoordinateList();for(var i=this.deList.iterator();i.hasNext();){var de=i.next();var edge=de.getEdge();EdgeRing.addEdge(edge.getLine().getCoordinates(),de.getEdgeDirection(),coordList);}
this.ringPts=coordList.toCoordinateArray();}
return this.ringPts;};EdgeRing.prototype.getLineString=function(){this.getCoordinates();return this.factory.createLineString(this.ringPts);};EdgeRing.prototype.getRing=function(){if(this.ring!=null)
return this.ring;this.getCoordinates();if(this.ringPts.length<3)
console.log(this.ringPts);try{this.ring=this.factory.createLinearRing(this.ringPts);}catch(ex){console.log(this.ringPts);}
return this.ring;};EdgeRing.addEdge=function(coords,isForward,coordList){if(isForward){for(var i=0;i<coords.length;i++){coordList.add(coords[i],false);}}else{for(var i=coords.length-1;i>=0;i--){coordList.add(coords[i],false);}}};jsts.operation.polygonize.EdgeRing=EdgeRing;})();(function(){var GraphComponent=function(){};GraphComponent.setVisited=function(i,visited){while(i.hasNext()){var comp=i.next();comp.setVisited(visited);}};GraphComponent.setMarked=function(i,marked){while(i.hasNext()){var comp=i.next();comp.setMarked(marked);}};GraphComponent.getComponentWithVisitedState=function(i,visitedState){while(i.hasNext()){var comp=i.next();if(comp.isVisited()==visitedState)
return comp;}
return null;};GraphComponent.prototype._isMarked=false;GraphComponent.prototype._isVisited=false;GraphComponent.prototype.data;GraphComponent.prototype.isVisited=function(){return this._isVisited;};GraphComponent.prototype.setVisited=function(isVisited){this._isVisited=isVisited;};GraphComponent.prototype.isMarked=function(){return this._isMarked;};GraphComponent.prototype.setMarked=function(isMarked){this._isMarked=isMarked;};GraphComponent.prototype.setContext=function(data){this.data=data;};GraphComponent.prototype.getContext=function(){return data;};GraphComponent.prototype.setData=function(data){this.data=data;};GraphComponent.prototype.getData=function(){return data;};GraphComponent.prototype.isRemoved=function(){throw new jsts.error.AbstractMethodInvocationError();};jsts.planargraph.GraphComponent=GraphComponent;})();(function(){var GraphComponent=jsts.planargraph.GraphComponent;var Edge=function(de0,de1){if(de0===undefined){return;}
this.setDirectedEdges(de0,de1);};Edge.prototype=new GraphComponent();Edge.prototype.dirEdge=null;Edge.prototype.setDirectedEdges=function(de0,de1){this.dirEdge=[de0,de1];de0.setEdge(this);de1.setEdge(this);de0.setSym(de1);de1.setSym(de0);de0.getFromNode().addOutEdge(de0);de1.getFromNode().addOutEdge(de1);};Edge.prototype.getDirEdge=function(i){if(i instanceof jsts.planargraph.Node){this.getDirEdge2(i);}
return this.dirEdge[i];};Edge.prototype.getDirEdge2=function(fromNode){if(this.dirEdge[0].getFromNode()==fromNode)
return this.dirEdge[0];if(this.dirEdge[1].getFromNode()==fromNode)
return this.dirEdge[1];return null;};Edge.prototype.getOppositeNode=function(node){if(this.dirEdge[0].getFromNode()==node)
return this.dirEdge[0].getToNode();if(this.dirEdge[1].getFromNode()==node)
return this.dirEdge[1].getToNode();return null;};Edge.prototype.remove=function(){this.dirEdge=null;};Edge.prototype.isRemoved=function(){return dirEdge==null;};jsts.planargraph.Edge=Edge;})();jsts.operation.polygonize.PolygonizeEdge=function(line){this.line=line;};jsts.operation.polygonize.PolygonizeEdge.prototype=new jsts.planargraph.Edge();jsts.operation.polygonize.PolygonizeEdge.prototype.line=null;jsts.operation.polygonize.PolygonizeEdge.prototype.getLine=function(){return this.line;};(function(){var ArrayList=javascript.util.ArrayList;var GraphComponent=jsts.planargraph.GraphComponent;var DirectedEdge=function(from,to,directionPt,edgeDirection){if(from===undefined){return;}
this.from=from;this.to=to;this.edgeDirection=edgeDirection;this.p0=from.getCoordinate();this.p1=directionPt;var dx=this.p1.x-this.p0.x;var dy=this.p1.y-this.p0.y;this.quadrant=jsts.geomgraph.Quadrant.quadrant(dx,dy);this.angle=Math.atan2(dy,dx);};DirectedEdge.prototype=new GraphComponent();DirectedEdge.toEdges=function(dirEdges){var edges=new ArrayList();for(var i=dirEdges.iterator();i.hasNext();){edges.add((i.next()).parentEdge);}
return edges;};DirectedEdge.prototype.parentEdge=null;DirectedEdge.prototype.from=null;DirectedEdge.prototype.to=null;DirectedEdge.prototype.p0=null;DirectedEdge.prototype.p1=null;DirectedEdge.prototype.sym=null;DirectedEdge.prototype.edgeDirection=null;DirectedEdge.prototype.quadrant=null;DirectedEdge.prototype.angle=null;DirectedEdge.prototype.getEdge=function(){return this.parentEdge;};DirectedEdge.prototype.setEdge=function(parentEdge){this.parentEdge=parentEdge;};DirectedEdge.prototype.getQuadrant=function(){return this.quadrant;};DirectedEdge.prototype.getDirectionPt=function(){return this.p1;};DirectedEdge.prototype.getEdgeDirection=function(){return this.edgeDirection;};DirectedEdge.prototype.getFromNode=function(){return this.from;};DirectedEdge.prototype.getToNode=function(){return this.to;};DirectedEdge.prototype.getCoordinate=function(){return this.from.getCoordinate();};DirectedEdge.prototype.getAngle=function(){return this.angle;};DirectedEdge.prototype.getSym=function(){return this.sym;};DirectedEdge.prototype.setSym=function(sym){this.sym=sym;};DirectedEdge.prototype.remove=function(){this.sym=null;this.parentEdge=null;};DirectedEdge.prototype.isRemoved=function(){return this.parentEdge==null;};DirectedEdge.prototype.compareTo=function(obj){var de=obj;return this.compareDirection(de);};DirectedEdge.prototype.compareDirection=function(e){if(this.quadrant>e.quadrant)
return 1;if(this.quadrant<e.quadrant)
return-1;return jsts.algorithm.CGAlgorithms.computeOrientation(e.p0,e.p1,this.p1);};jsts.planargraph.DirectedEdge=DirectedEdge;})();(function(){var DirectedEdge=jsts.planargraph.DirectedEdge;var PolygonizeDirectedEdge=function(from,to,directionPt,edgeDirection){DirectedEdge.apply(this,arguments);};PolygonizeDirectedEdge.prototype=new DirectedEdge();PolygonizeDirectedEdge.prototype.edgeRing=null;PolygonizeDirectedEdge.prototype.next=null;PolygonizeDirectedEdge.prototype.label=-1;PolygonizeDirectedEdge.prototype.getLabel=function(){return this.label;};PolygonizeDirectedEdge.prototype.setLabel=function(label){this.label=label;};PolygonizeDirectedEdge.prototype.getNext=function(){return this.next;};PolygonizeDirectedEdge.prototype.setNext=function(next){this.next=next;};PolygonizeDirectedEdge.prototype.isInRing=function(){return this.edgeRing!=null;};PolygonizeDirectedEdge.prototype.setRing=function(edgeRing){this.edgeRing=edgeRing;};jsts.operation.polygonize.PolygonizeDirectedEdge=PolygonizeDirectedEdge;})();(function(){var ArrayList=javascript.util.ArrayList;var DirectedEdgeStar=function(){this.outEdges=new ArrayList();};DirectedEdgeStar.prototype.outEdges=null;DirectedEdgeStar.prototype.sorted=false;DirectedEdgeStar.prototype.add=function(de){this.outEdges.add(de);this.sorted=false;};DirectedEdgeStar.prototype.remove=function(de){this.outEdges.remove(de);};DirectedEdgeStar.prototype.iterator=function(){this.sortEdges();return this.outEdges.iterator();};DirectedEdgeStar.prototype.getDegree=function(){return this.outEdges.size();};DirectedEdgeStar.prototype.getCoordinate=function(){var it=iterator();if(!it.hasNext())
return null;var e=it.next();return e.getCoordinate();};DirectedEdgeStar.prototype.getEdges=function(){this.sortEdges();return this.outEdges;};DirectedEdgeStar.prototype.sortEdges=function(){if(!this.sorted){var array=this.outEdges.toArray();array.sort(function(a,b){return a.compareTo(b);});this.outEdges=javascript.util.Arrays.asList(array);this.sorted=true;}};DirectedEdgeStar.prototype.getIndex=function(edge){if(edge instanceof jsts.planargraph.DirectedEdge){return this.getIndex2(edge);}else if(typeof(edge)==='number'){return this.getIndex3(edge);}
this.sortEdges();for(var i=0;i<this.outEdges.size();i++){var de=this.outEdges.get(i);if(de.getEdge()==edge)
return i;}
return-1;};DirectedEdgeStar.prototype.getIndex2=function(dirEdge){this.sortEdges();for(var i=0;i<this.outEdges.size();i++){var de=this.outEdges.get(i);if(de==dirEdge)
return i;}
return-1;};DirectedEdgeStar.prototype.getIndex3=function(i){var modi=toInt(i%this.outEdges.size());if(modi<0)
modi+=this.outEdges.size();return modi;};DirectedEdgeStar.prototype.getNextEdge=function(dirEdge){var i=this.getIndex(dirEdge);return this.outEdges.get(getIndex(i+1));};DirectedEdgeStar.prototype.getNextCWEdge=function(dirEdge){var i=this.getIndex(dirEdge);return this.outEdges.get(getIndex(i-1));};jsts.planargraph.DirectedEdgeStar=DirectedEdgeStar;})();(function(){var GraphComponent=jsts.planargraph.GraphComponent;var DirectedEdgeStar=jsts.planargraph.DirectedEdgeStar;var Node=function(pt,deStar){this.pt=pt;this.deStar=deStar||new DirectedEdgeStar();};Node.prototype=new GraphComponent();Node.getEdgesBetween=function(node0,node1){var edges0=DirectedEdge.toEdges(node0.getOutEdges().getEdges());var commonEdges=new javascript.util.HashSet(edges0);var edges1=DirectedEdge.toEdges(node1.getOutEdges().getEdges());commonEdges.retainAll(edges1);return commonEdges;};Node.prototype.pt=null;Node.prototype.deStar=null;Node.prototype.getCoordinate=function(){return this.pt;};Node.prototype.addOutEdge=function(de){this.deStar.add(de);};Node.prototype.getOutEdges=function(){return this.deStar;};Node.prototype.getDegree=function(){return this.deStar.getDegree();};Node.prototype.getIndex=function(edge){return this.deStar.getIndex(edge);};Node.prototype.remove=function(de){if(de===undefined){return this.remove2();}
this.deStar.remove(de);};Node.prototype.remove2=function(){this.pt=null;};Node.prototype.isRemoved=function(){return this.pt==null;};jsts.planargraph.Node=Node;})();(function(){var NodeMap=function(){this.nodeMap=new javascript.util.TreeMap();};NodeMap.prototype.nodeMap=null;NodeMap.prototype.add=function(n){this.nodeMap.put(n.getCoordinate(),n);return n;};NodeMap.prototype.remove=function(pt){return this.nodeMap.remove(pt);};NodeMap.prototype.find=function(coord){return this.nodeMap.get(coord);};NodeMap.prototype.iterator=function(){return this.nodeMap.values().iterator();};NodeMap.prototype.values=function(){return this.nodeMap.values();};jsts.planargraph.NodeMap=NodeMap;})();(function(){var ArrayList=javascript.util.ArrayList;var PlanarGraph=function(){this.edges=new javascript.util.HashSet();this.dirEdges=new javascript.util.HashSet();this.nodeMap=new jsts.planargraph.NodeMap();};PlanarGraph.prototype.edges=null;PlanarGraph.prototype.dirEdges=null;PlanarGraph.prototype.nodeMap=null;PlanarGraph.prototype.findNode=function(pt){return this.nodeMap.find(pt);};PlanarGraph.prototype.add=function(node){if(node instanceof jsts.planargraph.Edge){return this.add2(node);}else if(node instanceof jsts.planargraph.DirectedEdge){return this.add3(node);}
this.nodeMap.add(node);};PlanarGraph.prototype.add2=function(edge){this.edges.add(edge);this.add(edge.getDirEdge(0));this.add(edge.getDirEdge(1));};PlanarGraph.prototype.add3=function(dirEdge){this.dirEdges.add(dirEdge);};PlanarGraph.prototype.nodeIterator=function(){return this.nodeMap.iterator();};PlanarGraph.prototype.contains=function(e){if(e instanceof jsts.planargraph.DirectedEdge){return this.contains2(e);}
return this.edges.contains(e);};PlanarGraph.prototype.contains2=function(de){return this.dirEdges.contains(de);};PlanarGraph.prototype.getNodes=function(){return this.nodeMap.values();};PlanarGraph.prototype.dirEdgeIterator=function(){return this.dirEdges.iterator();};PlanarGraph.prototype.edgeIterator=function(){return this.edges.iterator();};PlanarGraph.prototype.getEdges=function(){return this.edges;};PlanarGraph.prototype.remove=function(edge){if(edge instanceof jsts.planargraph.DirectedEdge){return this.remove2(edge);}
this.remove(edge.getDirEdge(0));this.remove(edge.getDirEdge(1));this.edges.remove(edge);this.edge.remove();};PlanarGraph.prototype.remove2=function(de){if(de instanceof jsts.planargraph.Node){return this.remove3(de);}
var sym=de.getSym();if(sym!=null)
sym.setSym(null);de.getFromNode().remove(de);de.remove();this.dirEdges.remove(de);};PlanarGraph.prototype.remove3=function(node){var outEdges=node.getOutEdges().getEdges();for(var i=outEdges.iterator();i.hasNext();){var de=i.next();var sym=de.getSym();if(sym!=null)
this.remove(sym);this.dirEdges.remove(de);var edge=de.getEdge();if(edge!=null){this.edges.remove(edge);}}
this.nodeMap.remove(node.getCoordinate());node.remove();};PlanarGraph.prototype.findNodesOfDegree=function(degree){var nodesFound=new ArrayList();for(var i=this.nodeIterator();i.hasNext();){var node=i.next();if(node.getDegree()==degree)
nodesFound.add(node);}
return nodesFound;};jsts.planargraph.PlanarGraph=PlanarGraph;})();(function(){var ArrayList=javascript.util.ArrayList;var Stack=javascript.util.Stack;var HashSet=javascript.util.HashSet;var Assert=jsts.util.Assert;var EdgeRing=jsts.operation.polygonize.EdgeRing;var PolygonizeEdge=jsts.operation.polygonize.PolygonizeEdge;var PolygonizeDirectedEdge=jsts.operation.polygonize.PolygonizeDirectedEdge;var PlanarGraph=jsts.planargraph.PlanarGraph;var Node=jsts.planargraph.Node;var PolygonizeGraph=function(factory){PlanarGraph.apply(this);this.factory=factory;};PolygonizeGraph.prototype=new PlanarGraph();PolygonizeGraph.getDegreeNonDeleted=function(node){var edges=node.getOutEdges().getEdges();var degree=0;for(var i=edges.iterator();i.hasNext();){var de=i.next();if(!de.isMarked())
degree++;}
return degree;};PolygonizeGraph.getDegree=function(node,label){var edges=node.getOutEdges().getEdges();var degree=0;for(var i=edges.iterator();i.hasNext();){var de=i.next();if(de.getLabel()==label)
degree++;}
return degree;};PolygonizeGraph.deleteAllEdges=function(node){var edges=node.getOutEdges().getEdges();for(var i=edges.iterator();i.hasNext();){var de=i.next();de.setMarked(true);var sym=de.getSym();if(sym!=null)
sym.setMarked(true);}};PolygonizeGraph.prototype.factory=null;PolygonizeGraph.prototype.addEdge=function(line){if(line.isEmpty()){return;}
var linePts=jsts.geom.CoordinateArrays.removeRepeatedPoints(line.getCoordinates());if(linePts.length<2){return;}
var startPt=linePts[0];var endPt=linePts[linePts.length-1];var nStart=this.getNode(startPt);var nEnd=this.getNode(endPt);var de0=new PolygonizeDirectedEdge(nStart,nEnd,linePts[1],true);var de1=new PolygonizeDirectedEdge(nEnd,nStart,linePts[linePts.length-2],false);var edge=new PolygonizeEdge(line);edge.setDirectedEdges(de0,de1);this.add(edge);};PolygonizeGraph.prototype.getNode=function(pt){var node=this.findNode(pt);if(node==null){node=new Node(pt);this.add(node);}
return node;};PolygonizeGraph.prototype.computeNextCWEdges=function(){for(var iNode=this.nodeIterator();iNode.hasNext();){var node=iNode.next();PolygonizeGraph.computeNextCWEdges(node);}};PolygonizeGraph.prototype.convertMaximalToMinimalEdgeRings=function(ringEdges){for(var i=ringEdges.iterator();i.hasNext();){var de=i.next();var label=de.getLabel();var intNodes=PolygonizeGraph.findIntersectionNodes(de,label);if(intNodes==null)
continue;for(var iNode=intNodes.iterator();iNode.hasNext();){var node=iNode.next();PolygonizeGraph.computeNextCCWEdges(node,label);}}};PolygonizeGraph.findIntersectionNodes=function(startDE,label){var de=startDE;var intNodes=null;do{var node=de.getFromNode();if(PolygonizeGraph.getDegree(node,label)>1){if(intNodes==null)
intNodes=new ArrayList();intNodes.add(node);}
de=de.getNext();Assert.isTrue(de!=null,'found null DE in ring');Assert.isTrue(de==startDE||!de.isInRing(),'found DE already in ring');}while(de!=startDE);return intNodes;};PolygonizeGraph.prototype.getEdgeRings=function(){this.computeNextCWEdges();PolygonizeGraph.label(this.dirEdges,-1);var maximalRings=PolygonizeGraph.findLabeledEdgeRings(this.dirEdges);this.convertMaximalToMinimalEdgeRings(maximalRings);var edgeRingList=new ArrayList();for(var i=this.dirEdges.iterator();i.hasNext();){var de=i.next();if(de.isMarked())
continue;if(de.isInRing())
continue;var er=this.findEdgeRing(de);edgeRingList.add(er);}
return edgeRingList;};PolygonizeGraph.findLabeledEdgeRings=function(dirEdges){var edgeRingStarts=new ArrayList();var currLabel=1;for(var i=dirEdges.iterator();i.hasNext();){var de=i.next();if(de.isMarked())
continue;if(de.getLabel()>=0)
continue;edgeRingStarts.add(de);var edges=PolygonizeGraph.findDirEdgesInRing(de);PolygonizeGraph.label(edges,currLabel);currLabel++;}
return edgeRingStarts;};PolygonizeGraph.prototype.deleteCutEdges=function(){this.computeNextCWEdges();PolygonizeGraph.findLabeledEdgeRings(this.dirEdges);var cutLines=new ArrayList();for(var i=this.dirEdges.iterator();i.hasNext();){var de=i.next();if(de.isMarked())
continue;var sym=de.getSym();if(de.getLabel()==sym.getLabel()){de.setMarked(true);sym.setMarked(true);var e=de.getEdge();cutLines.add(e.getLine());}}
return cutLines;};PolygonizeGraph.label=function(dirEdges,label){for(var i=dirEdges.iterator();i.hasNext();){var de=i.next();de.setLabel(label);}};PolygonizeGraph.computeNextCWEdges=function(node){var deStar=node.getOutEdges();var startDE=null;var prevDE=null;for(var i=deStar.getEdges().iterator();i.hasNext();){var outDE=i.next();if(outDE.isMarked())
continue;if(startDE==null)
startDE=outDE;if(prevDE!=null){var sym=prevDE.getSym();sym.setNext(outDE);}
prevDE=outDE;}
if(prevDE!=null){var sym=prevDE.getSym();sym.setNext(startDE);}};PolygonizeGraph.computeNextCCWEdges=function(node,label){var deStar=node.getOutEdges();var firstOutDE=null;var prevInDE=null;var edges=deStar.getEdges();for(var i=edges.size()-1;i>=0;i--){var de=edges.get(i);var sym=de.getSym();var outDE=null;if(de.getLabel()==label)
outDE=de;var inDE=null;if(sym.getLabel()==label)
inDE=sym;if(outDE==null&&inDE==null)
continue;if(inDE!=null){prevInDE=inDE;}
if(outDE!=null){if(prevInDE!=null){prevInDE.setNext(outDE);prevInDE=null;}
if(firstOutDE==null)
firstOutDE=outDE;}}
if(prevInDE!=null){Assert.isTrue(firstOutDE!=null);prevInDE.setNext(firstOutDE);}};PolygonizeGraph.findDirEdgesInRing=function(startDE){var de=startDE;var edges=new ArrayList();do{edges.add(de);de=de.getNext();Assert.isTrue(de!=null,'found null DE in ring');Assert.isTrue(de==startDE||!de.isInRing(),'found DE already in ring');}while(de!=startDE);return edges;};PolygonizeGraph.prototype.findEdgeRing=function(startDE){var de=startDE;var er=new EdgeRing(this.factory);do{er.add(de);de.setRing(er);de=de.getNext();Assert.isTrue(de!=null,'found null DE in ring');Assert.isTrue(de==startDE||!de.isInRing(),'found DE already in ring');}while(de!=startDE);return er;};PolygonizeGraph.prototype.deleteDangles=function(){var nodesToRemove=this.findNodesOfDegree(1);var dangleLines=new HashSet();var nodeStack=new Stack();for(var i=nodesToRemove.iterator();i.hasNext();){nodeStack.push(i.next());}
while(!nodeStack.isEmpty()){var node=nodeStack.pop();PolygonizeGraph.deleteAllEdges(node);var nodeOutEdges=node.getOutEdges().getEdges();for(var i=nodeOutEdges.iterator();i.hasNext();){var de=i.next();de.setMarked(true);var sym=de.getSym();if(sym!=null)
sym.setMarked(true);var e=de.getEdge();dangleLines.add(e.getLine());var toNode=de.getToNode();if(PolygonizeGraph.getDegreeNonDeleted(toNode)==1)
nodeStack.push(toNode);}}
return dangleLines;};PolygonizeGraph.prototype.computeDepthParity=function(){while(true){var de=null;if(de==null)
return;this.computeDepthParity(de);}};PolygonizeGraph.prototype.computeDepthParity=function(de){};jsts.operation.polygonize.PolygonizeGraph=PolygonizeGraph;})();jsts.index.strtree.Interval=function(){var other;if(arguments.length===1){other=arguments[0];return jsts.index.strtree.Interval(other.min,other.max);}else if(arguments.length===2){jsts.util.Assert.isTrue(this.min<=this.max);this.min=arguments[0];this.max=arguments[1];}};jsts.index.strtree.Interval.prototype.min=null;jsts.index.strtree.Interval.prototype.max=null;jsts.index.strtree.Interval.prototype.getCentre=function(){return(this.min+this.max)/2;};jsts.index.strtree.Interval.prototype.expandToInclude=function(other){this.max=Math.max(this.max,other.max);this.min=Math.min(this.min,other.min);return this;};jsts.index.strtree.Interval.prototype.intersects=function(other){return!(other.min>this.max||other.max<this.min);};jsts.index.strtree.Interval.prototype.equals=function(o){if(!(o instanceof jsts.index.strtree.Interval)){return false;}
other=o;return this.min===other.min&&this.max===other.max;};jsts.geom.GeometryFactory=function(precisionModel){this.precisionModel=precisionModel||new jsts.geom.PrecisionModel();};jsts.geom.GeometryFactory.prototype.precisionModel=null;jsts.geom.GeometryFactory.prototype.getPrecisionModel=function(){return this.precisionModel;};jsts.geom.GeometryFactory.prototype.createPoint=function(coordinate){var point=new jsts.geom.Point(coordinate,this);return point;};jsts.geom.GeometryFactory.prototype.createLineString=function(coordinates){var lineString=new jsts.geom.LineString(coordinates,this);return lineString;};jsts.geom.GeometryFactory.prototype.createLinearRing=function(coordinates){var linearRing=new jsts.geom.LinearRing(coordinates,this);return linearRing;};jsts.geom.GeometryFactory.prototype.createPolygon=function(shell,holes){var polygon=new jsts.geom.Polygon(shell,holes,this);return polygon;};jsts.geom.GeometryFactory.prototype.createMultiPoint=function(points){if(points&&points[0]instanceof jsts.geom.Coordinate){var converted=[];var i;for(i=0;i<points.length;i++){converted.push(this.createPoint(points[i]));}
points=converted;}
return new jsts.geom.MultiPoint(points,this);};jsts.geom.GeometryFactory.prototype.createMultiLineString=function(lineStrings){return new jsts.geom.MultiLineString(lineStrings,this);};jsts.geom.GeometryFactory.prototype.createMultiPolygon=function(polygons){return new jsts.geom.MultiPolygon(polygons,this);};jsts.geom.GeometryFactory.prototype.buildGeometry=function(geomList){var geomClass=null;var isHeterogeneous=false;var hasGeometryCollection=false;for(var i=geomList.iterator();i.hasNext();){var geom=i.next();var partClass=geom.CLASS_NAME;if(geomClass===null){geomClass=partClass;}
if(!(partClass===geomClass)){isHeterogeneous=true;}
if(geom.isGeometryCollectionBase())
hasGeometryCollection=true;}
if(geomClass===null){return this.createGeometryCollection(null);}
if(isHeterogeneous||hasGeometryCollection){return this.createGeometryCollection(geomList.toArray());}
var geom0=geomList.get(0);var isCollection=geomList.size()>1;if(isCollection){if(geom0 instanceof jsts.geom.Polygon){return this.createMultiPolygon(geomList.toArray());}else if(geom0 instanceof jsts.geom.LineString){return this.createMultiLineString(geomList.toArray());}else if(geom0 instanceof jsts.geom.Point){return this.createMultiPoint(geomList.toArray());}
jsts.util.Assert.shouldNeverReachHere('Unhandled class: '+geom0);}
return geom0;};jsts.geom.GeometryFactory.prototype.createGeometryCollection=function(geometries){return new jsts.geom.GeometryCollection(geometries,this);};jsts.geom.GeometryFactory.prototype.toGeometry=function(envelope){if(envelope.isNull()){return this.createPoint(null);}
if(envelope.getMinX()===envelope.getMaxX()&&envelope.getMinY()===envelope.getMaxY()){return this.createPoint(new jsts.geom.Coordinate(envelope.getMinX(),envelope.getMinY()));}
if(envelope.getMinX()===envelope.getMaxX()||envelope.getMinY()===envelope.getMaxY()){return this.createLineString([new jsts.geom.Coordinate(envelope.getMinX(),envelope.getMinY()),new jsts.geom.Coordinate(envelope.getMaxX(),envelope.getMaxY())]);}
return this.createPolygon(this.createLinearRing([new jsts.geom.Coordinate(envelope.getMinX(),envelope.getMinY()),new jsts.geom.Coordinate(envelope.getMinX(),envelope.getMaxY()),new jsts.geom.Coordinate(envelope.getMaxX(),envelope.getMaxY()),new jsts.geom.Coordinate(envelope.getMaxX(),envelope.getMinY()),new jsts.geom.Coordinate(envelope.getMinX(),envelope.getMinY())]),null);};jsts.geomgraph.NodeFactory=function(){};jsts.geomgraph.NodeFactory.prototype.createNode=function(coord){return new jsts.geomgraph.Node(coord,null);};(function(){jsts.geomgraph.Position=function(){};jsts.geomgraph.Position.ON=0;jsts.geomgraph.Position.LEFT=1;jsts.geomgraph.Position.RIGHT=2;jsts.geomgraph.Position.opposite=function(position){if(position===jsts.geomgraph.Position.LEFT){return jsts.geomgraph.Position.RIGHT;}
if(position===jsts.geomgraph.Position.RIGHT){return jsts.geomgraph.Position.LEFT;}
return position;};})();jsts.geomgraph.TopologyLocation=function(){this.location=[];if(arguments.length===3){var on=arguments[0];var left=arguments[1];var right=arguments[2];this.init(3);this.location[jsts.geomgraph.Position.ON]=on;this.location[jsts.geomgraph.Position.LEFT]=left;this.location[jsts.geomgraph.Position.RIGHT]=right;}else if(arguments[0]instanceof jsts.geomgraph.TopologyLocation){var gl=arguments[0];this.init(gl.location.length);if(gl!=null){for(var i=0;i<this.location.length;i++){this.location[i]=gl.location[i];}}}else if(typeof arguments[0]==='number'){var on=arguments[0];this.init(1);this.location[jsts.geomgraph.Position.ON]=on;}else if(arguments[0]instanceof Array){var location=arguments[0];this.init(location.length);}};jsts.geomgraph.TopologyLocation.prototype.location=null;jsts.geomgraph.TopologyLocation.prototype.init=function(size){this.location[size-1]=null;this.setAllLocations(jsts.geom.Location.NONE);};jsts.geomgraph.TopologyLocation.prototype.get=function(posIndex){if(posIndex<this.location.length)
return this.location[posIndex];return jsts.geom.Location.NONE;};jsts.geomgraph.TopologyLocation.prototype.isNull=function(){for(var i=0;i<this.location.length;i++){if(this.location[i]!==jsts.geom.Location.NONE)
return false;}
return true;};jsts.geomgraph.TopologyLocation.prototype.isAnyNull=function(){for(var i=0;i<this.location.length;i++){if(this.location[i]===jsts.geom.Location.NONE)
return true;}
return false;};jsts.geomgraph.TopologyLocation.prototype.isEqualOnSide=function(le,locIndex){return this.location[locIndex]==le.location[locIndex];};jsts.geomgraph.TopologyLocation.prototype.isArea=function(){return this.location.length>1;};jsts.geomgraph.TopologyLocation.prototype.isLine=function(){return this.location.length===1;};jsts.geomgraph.TopologyLocation.prototype.flip=function(){if(this.location.length<=1)
return;var temp=this.location[jsts.geomgraph.Position.LEFT];this.location[jsts.geomgraph.Position.LEFT]=this.location[jsts.geomgraph.Position.RIGHT];this.location[jsts.geomgraph.Position.RIGHT]=temp;};jsts.geomgraph.TopologyLocation.prototype.setAllLocations=function(locValue){for(var i=0;i<this.location.length;i++){this.location[i]=locValue;}};jsts.geomgraph.TopologyLocation.prototype.setAllLocationsIfNull=function(locValue){for(var i=0;i<this.location.length;i++){if(this.location[i]===jsts.geom.Location.NONE)
this.location[i]=locValue;}};jsts.geomgraph.TopologyLocation.prototype.setLocation=function(locIndex,locValue){if(locValue!==undefined){this.location[locIndex]=locValue;}else{this.setLocation(jsts.geomgraph.Position.ON,locIndex);}};jsts.geomgraph.TopologyLocation.prototype.getLocations=function(){return location;};jsts.geomgraph.TopologyLocation.prototype.setLocations=function(on,left,right){this.location[jsts.geomgraph.Position.ON]=on;this.location[jsts.geomgraph.Position.LEFT]=left;this.location[jsts.geomgraph.Position.RIGHT]=right;};jsts.geomgraph.TopologyLocation.prototype.allPositionsEqual=function(loc){for(var i=0;i<this.location.length;i++){if(this.location[i]!==loc)
return false;}
return true;};jsts.geomgraph.TopologyLocation.prototype.merge=function(gl){if(gl.location.length>this.location.length){var newLoc=[];newLoc[jsts.geomgraph.Position.ON]=this.location[jsts.geomgraph.Position.ON];newLoc[jsts.geomgraph.Position.LEFT]=jsts.geom.Location.NONE;newLoc[jsts.geomgraph.Position.RIGHT]=jsts.geom.Location.NONE;this.location=newLoc;}
for(var i=0;i<this.location.length;i++){if(this.location[i]===jsts.geom.Location.NONE&&i<gl.location.length)
this.location[i]=gl.location[i];}};jsts.geomgraph.Label=function(){this.elt=[];var geomIndex,onLoc,leftLoc,lbl,rightLoc;if(arguments.length===4){geomIndex=arguments[0];onLoc=arguments[1];leftLoc=arguments[2];rightLoc=arguments[3];this.elt[0]=new jsts.geomgraph.TopologyLocation(jsts.geom.Location.NONE,jsts.geom.Location.NONE,jsts.geom.Location.NONE);this.elt[1]=new jsts.geomgraph.TopologyLocation(jsts.geom.Location.NONE,jsts.geom.Location.NONE,jsts.geom.Location.NONE);this.elt[geomIndex].setLocations(onLoc,leftLoc,rightLoc);}else if(arguments.length===3){onLoc=arguments[0];leftLoc=arguments[1];rightLoc=arguments[2];this.elt[0]=new jsts.geomgraph.TopologyLocation(onLoc,leftLoc,rightLoc);this.elt[1]=new jsts.geomgraph.TopologyLocation(onLoc,leftLoc,rightLoc);}else if(arguments.length===2){geomIndex=arguments[0];onLoc=arguments[1];this.elt[0]=new jsts.geomgraph.TopologyLocation(jsts.geom.Location.NONE);this.elt[1]=new jsts.geomgraph.TopologyLocation(jsts.geom.Location.NONE);this.elt[geomIndex].setLocation(onLoc);}else if(arguments[0]instanceof jsts.geomgraph.Label){lbl=arguments[0];this.elt[0]=new jsts.geomgraph.TopologyLocation(lbl.elt[0]);this.elt[1]=new jsts.geomgraph.TopologyLocation(lbl.elt[1]);}else if(typeof arguments[0]==='number'){onLoc=arguments[0];this.elt[0]=new jsts.geomgraph.TopologyLocation(onLoc);this.elt[1]=new jsts.geomgraph.TopologyLocation(onLoc);}};jsts.geomgraph.Label.toLineLabel=function(label){var i,lineLabel=new jsts.geomgraph.Label(jsts.geom.Location.NONE);for(i=0;i<2;i++){lineLabel.setLocation(i,label.getLocation(i));}
return lineLabel;};jsts.geomgraph.Label.prototype.elt=null;jsts.geomgraph.Label.prototype.flip=function(){this.elt[0].flip();this.elt[1].flip();};jsts.geomgraph.Label.prototype.getLocation=function(geomIndex,posIndex){if(arguments.length==1){return this.getLocation2.apply(this,arguments);}
return this.elt[geomIndex].get(posIndex);};jsts.geomgraph.Label.prototype.getLocation2=function(geomIndex){return this.elt[geomIndex].get(jsts.geomgraph.Position.ON);};jsts.geomgraph.Label.prototype.setLocation=function(geomIndex,posIndex,location){if(arguments.length==2){this.setLocation2.apply(this,arguments);return;}
this.elt[geomIndex].setLocation(posIndex,location);};jsts.geomgraph.Label.prototype.setLocation2=function(geomIndex,location){this.elt[geomIndex].setLocation(jsts.geomgraph.Position.ON,location);};jsts.geomgraph.Label.prototype.setAllLocations=function(geomIndex,location){this.elt[geomIndex].setAllLocations(location);};jsts.geomgraph.Label.prototype.setAllLocationsIfNull=function(geomIndex,location){if(arguments.length==1){this.setAllLocationsIfNull2.apply(this,arguments);return;}
this.elt[geomIndex].setAllLocationsIfNull(location);};jsts.geomgraph.Label.prototype.setAllLocationsIfNull2=function(location){this.setAllLocationsIfNull(0,location);this.setAllLocationsIfNull(1,location);};jsts.geomgraph.Label.prototype.merge=function(lbl){var i;for(i=0;i<2;i++){if(this.elt[i]===null&&lbl.elt[i]!==null){this.elt[i]=new jsts.geomgraph.TopologyLocation(lbl.elt[i]);}else{this.elt[i].merge(lbl.elt[i]);}}};jsts.geomgraph.Label.prototype.getGeometryCount=function(){var count=0;if(!this.elt[0].isNull()){count++;}
if(!this.elt[1].isNull()){count++;}
return count;};jsts.geomgraph.Label.prototype.isNull=function(geomIndex){return this.elt[geomIndex].isNull();};jsts.geomgraph.Label.prototype.isAnyNull=function(geomIndex){return this.elt[geomIndex].isAnyNull();};jsts.geomgraph.Label.prototype.isArea=function(){if(arguments.length==1){return this.isArea2(arguments[0]);}
return this.elt[0].isArea()||this.elt[1].isArea();};jsts.geomgraph.Label.prototype.isArea2=function(geomIndex){return this.elt[geomIndex].isArea();};jsts.geomgraph.Label.prototype.isLine=function(geomIndex){return this.elt[geomIndex].isLine();};jsts.geomgraph.Label.prototype.isEqualOnSide=function(lbl,side){return this.elt[0].isEqualOnSide(lbl.elt[0],side)&&this.elt[1].isEqualOnSide(lbl.elt[1],side);};jsts.geomgraph.Label.prototype.allPositionsEqual=function(geomIndex,loc){return this.elt[geomIndex].allPositionsEqual(loc);};jsts.geomgraph.Label.prototype.toLine=function(geomIndex){if(this.elt[geomIndex].isArea()){this.elt[geomIndex]=new jsts.geomgraph.TopologyLocation(this.elt[geomIndex].location[0]);}};jsts.geomgraph.EdgeRing=function(start,geometryFactory){this.edges=[];this.pts=[];this.holes=[];this.label=new jsts.geomgraph.Label(jsts.geom.Location.NONE);this.geometryFactory=geometryFactory;if(start){this.computePoints(start);this.computeRing();}};jsts.geomgraph.EdgeRing.prototype.startDe=null;jsts.geomgraph.EdgeRing.prototype.maxNodeDegree=-1;jsts.geomgraph.EdgeRing.prototype.edges=null;jsts.geomgraph.EdgeRing.prototype.pts=null;jsts.geomgraph.EdgeRing.prototype.label=null;jsts.geomgraph.EdgeRing.prototype.ring=null;jsts.geomgraph.EdgeRing.prototype._isHole=null;jsts.geomgraph.EdgeRing.prototype.shell=null;jsts.geomgraph.EdgeRing.prototype.holes=null;jsts.geomgraph.EdgeRing.prototype.geometryFactory=null;jsts.geomgraph.EdgeRing.prototype.isIsolated=function(){return(this.label.getGeometryCount()==1);};jsts.geomgraph.EdgeRing.prototype.isHole=function(){return this._isHole;};jsts.geomgraph.EdgeRing.prototype.getCoordinate=function(i){return this.pts[i];};jsts.geomgraph.EdgeRing.prototype.getLinearRing=function(){return this.ring;};jsts.geomgraph.EdgeRing.prototype.getLabel=function(){return this.label;};jsts.geomgraph.EdgeRing.prototype.isShell=function(){return this.shell===null;};jsts.geomgraph.EdgeRing.prototype.getShell=function(){return this.shell;};jsts.geomgraph.EdgeRing.prototype.setShell=function(shell){this.shell=shell;if(shell!==null)
shell.addHole(this);};jsts.geomgraph.EdgeRing.prototype.addHole=function(ring){this.holes.push(ring);};jsts.geomgraph.EdgeRing.prototype.toPolygon=function(geometryFactory){var holeLR=[];for(var i=0;i<this.holes.length;i++){holeLR[i]=this.holes[i].getLinearRing();}
var poly=this.geometryFactory.createPolygon(this.getLinearRing(),holeLR);return poly;};jsts.geomgraph.EdgeRing.prototype.computeRing=function(){if(this.ring!==null)
return;var coord=[];for(var i=0;i<this.pts.length;i++){coord[i]=this.pts[i];}
this.ring=this.geometryFactory.createLinearRing(coord);this._isHole=jsts.algorithm.CGAlgorithms.isCCW(this.ring.getCoordinates());};jsts.geomgraph.EdgeRing.prototype.getNext=function(de){throw new jsts.error.AbstractInvocationError();};jsts.geomgraph.EdgeRing.prototype.setEdgeRing=function(de,er){throw new jsts.error.AbstractInvocationError();};jsts.geomgraph.EdgeRing.prototype.getEdges=function(){return this.edges;};jsts.geomgraph.EdgeRing.prototype.computePoints=function(start){this.startDe=start;var de=start;var isFirstEdge=true;do{if(de===null)
throw new jsts.error.TopologyError('Found null DirectedEdge');if(de.getEdgeRing()===this)
throw new jsts.error.TopologyError('Directed Edge visited twice during ring-building at '+
de.getCoordinate());this.edges.push(de);var label=de.getLabel();jsts.util.Assert.isTrue(label.isArea());this.mergeLabel(label);this.addPoints(de.getEdge(),de.isForward(),isFirstEdge);isFirstEdge=false;this.setEdgeRing(de,this);de=this.getNext(de);}while(de!==this.startDe);};jsts.geomgraph.EdgeRing.prototype.getMaxNodeDegree=function(){if(this.maxNodeDegree<0)
this.computeMaxNodeDegree();return this.maxNodeDegree;};jsts.geomgraph.EdgeRing.prototype.computeMaxNodeDegree=function(){this.maxNodeDegree=0;var de=this.startDe;do{var node=de.getNode();var degree=node.getEdges().getOutgoingDegree(this);if(degree>this.maxNodeDegree)
this.maxNodeDegree=degree;de=this.getNext(de);}while(de!==this.startDe);this.maxNodeDegree*=2;};jsts.geomgraph.EdgeRing.prototype.setInResult=function(){var de=this.startDe;do{de.getEdge().setInResult(true);de=de.getNext();}while(de!=this.startDe);};jsts.geomgraph.EdgeRing.prototype.mergeLabel=function(deLabel){this.mergeLabel2(deLabel,0);this.mergeLabel2(deLabel,1);};jsts.geomgraph.EdgeRing.prototype.mergeLabel2=function(deLabel,geomIndex){var loc=deLabel.getLocation(geomIndex,jsts.geomgraph.Position.RIGHT);if(loc==jsts.geom.Location.NONE)
return;if(this.label.getLocation(geomIndex)===jsts.geom.Location.NONE){this.label.setLocation(geomIndex,loc);return;}};jsts.geomgraph.EdgeRing.prototype.addPoints=function(edge,isForward,isFirstEdge){var edgePts=edge.getCoordinates();if(isForward){var startIndex=1;if(isFirstEdge)
startIndex=0;for(var i=startIndex;i<edgePts.length;i++){this.pts.push(edgePts[i]);}}else{var startIndex=edgePts.length-2;if(isFirstEdge)
startIndex=edgePts.length-1;for(var i=startIndex;i>=0;i--){this.pts.push(edgePts[i]);}}};jsts.geomgraph.EdgeRing.prototype.containsPoint=function(p){var shell=this.getLinearRing();var env=shell.getEnvelopeInternal();if(!env.contains(p))
return false;if(!jsts.algorithm.CGAlgorithms.isPointInRing(p,shell.getCoordinates()))
return false;for(var i=0;i<this.holes.length;i++){var hole=this.holes[i];if(hole.containsPoint(p))
return false;}
return true;};(function(){jsts.geom.LinearRing=function(points,factory){jsts.geom.LineString.apply(this,arguments);};jsts.geom.LinearRing.prototype=new jsts.geom.LineString();jsts.geom.LinearRing.constructor=jsts.geom.LinearRing;jsts.geom.LinearRing.prototype.getBoundaryDimension=function(){return jsts.geom.Dimension.FALSE;};jsts.geom.LinearRing.prototype.isSimple=function(){return true;};jsts.geom.LinearRing.prototype.getGeometryType=function(){return'LinearRing';};jsts.geom.LinearRing.MINIMUM_VALID_SIZE=4;jsts.geom.LinearRing.prototype.CLASS_NAME='jsts.geom.LinearRing';})();jsts.index.strtree.Boundable=function(){};jsts.index.strtree.Boundable.prototype.getBounds=function(){throw new jsts.error.AbstractMethodInvocationError();};jsts.index.strtree.AbstractNode=function(level){this.level=level;this.childBoundables=[];};jsts.index.strtree.AbstractNode.prototype=new jsts.index.strtree.Boundable();jsts.index.strtree.AbstractNode.constructor=jsts.index.strtree.AbstractNode;jsts.index.strtree.AbstractNode.prototype.childBoundables=null;jsts.index.strtree.AbstractNode.prototype.bounds=null;jsts.index.strtree.AbstractNode.prototype.level=null;jsts.index.strtree.AbstractNode.prototype.getChildBoundables=function(){return this.childBoundables;};jsts.index.strtree.AbstractNode.prototype.computeBounds=function(){throw new jsts.error.AbstractMethodInvocationError();};jsts.index.strtree.AbstractNode.prototype.getBounds=function(){if(this.bounds===null){this.bounds=this.computeBounds();}
return this.bounds;};jsts.index.strtree.AbstractNode.prototype.getLevel=function(){return this.level;};jsts.index.strtree.AbstractNode.prototype.addChildBoundable=function(childBoundable){this.childBoundables.push(childBoundable);};(function(){jsts.noding.Noder=function(){};jsts.noding.Noder.prototype.computeNodes=jsts.abstractFunc;jsts.noding.Noder.prototype.getNodedSubstrings=jsts.abstractFunc;})();(function(){var Noder=jsts.noding.Noder;jsts.noding.SinglePassNoder=function(){};jsts.noding.SinglePassNoder.prototype=new Noder();jsts.noding.SinglePassNoder.constructor=jsts.noding.SinglePassNoder;jsts.noding.SinglePassNoder.prototype.segInt=null;jsts.noding.SinglePassNoder.prototype.setSegmentIntersector=function(segInt){this.segInt=segInt;};})();jsts.index.SpatialIndex=function(){};jsts.index.SpatialIndex.prototype.insert=function(itemEnv,item){throw new jsts.error.AbstractMethodInvocationError();};jsts.index.SpatialIndex.prototype.query=function(searchEnv,visitor){throw new jsts.error.AbstractMethodInvocationError();};jsts.index.SpatialIndex.prototype.remove=function(itemEnv,item){throw new jsts.error.AbstractMethodInvocationError();};jsts.index.strtree.AbstractSTRtree=function(nodeCapacity){if(nodeCapacity===undefined)
return;this.itemBoundables=[];jsts.util.Assert.isTrue(nodeCapacity>1,'Node capacity must be greater than 1');this.nodeCapacity=nodeCapacity;};jsts.index.strtree.AbstractSTRtree.IntersectsOp=function(){};jsts.index.strtree.AbstractSTRtree.IntersectsOp.prototype.intersects=function(aBounds,bBounds){throw new jsts.error.AbstractMethodInvocationError();};jsts.index.strtree.AbstractSTRtree.prototype.root=null;jsts.index.strtree.AbstractSTRtree.prototype.built=false;jsts.index.strtree.AbstractSTRtree.prototype.itemBoundables=null;jsts.index.strtree.AbstractSTRtree.prototype.nodeCapacity=null;jsts.index.strtree.AbstractSTRtree.prototype.build=function(){jsts.util.Assert.isTrue(!this.built);this.root=this.itemBoundables.length===0?this.createNode(0):this.createHigherLevels(this.itemBoundables,-1);this.built=true;};jsts.index.strtree.AbstractSTRtree.prototype.createNode=function(level){throw new jsts.error.AbstractMethodInvocationError();};jsts.index.strtree.AbstractSTRtree.prototype.createParentBoundables=function(childBoundables,newLevel){jsts.util.Assert.isTrue(!(childBoundables.length===0));var parentBoundables=[];parentBoundables.push(this.createNode(newLevel));var sortedChildBoundables=[];for(var i=0;i<childBoundables.length;i++){sortedChildBoundables.push(childBoundables[i]);}
sortedChildBoundables.sort(this.getComparator());for(var i=0;i<sortedChildBoundables.length;i++){var childBoundable=sortedChildBoundables[i];if(this.lastNode(parentBoundables).getChildBoundables().length===this.getNodeCapacity()){parentBoundables.push(this.createNode(newLevel));}
this.lastNode(parentBoundables).addChildBoundable(childBoundable);}
return parentBoundables;};jsts.index.strtree.AbstractSTRtree.prototype.lastNode=function(nodes){return nodes[nodes.length-1];};jsts.index.strtree.AbstractSTRtree.prototype.compareDoubles=function(a,b){return a>b?1:a<b?-1:0;};jsts.index.strtree.AbstractSTRtree.prototype.createHigherLevels=function(boundablesOfALevel,level){jsts.util.Assert.isTrue(!(boundablesOfALevel.length===0));var parentBoundables=this.createParentBoundables(boundablesOfALevel,level+1);if(parentBoundables.length===1){return parentBoundables[0];}
return this.createHigherLevels(parentBoundables,level+1);};jsts.index.strtree.AbstractSTRtree.prototype.getRoot=function(){if(!this.built)
this.build();return this.root;};jsts.index.strtree.AbstractSTRtree.prototype.getNodeCapacity=function(){return this.nodeCapacity;};jsts.index.strtree.AbstractSTRtree.prototype.size=function(){if(arguments.length===1){return this.size2(arguments[0]);}
if(!this.built){this.build();}
if(this.itemBoundables.length===0){return 0;}
return this.size2(root);};jsts.index.strtree.AbstractSTRtree.prototype.size2=function(node){var size=0;var childBoundables=node.getChildBoundables();for(var i=0;i<childBoundables.length;i++){var childBoundable=childBoundables[i];if(childBoundable instanceof jsts.index.strtree.AbstractNode){size+=this.size(childBoundable);}else if(childBoundable instanceof jsts.index.strtree.ItemBoundable){size+=1;}}
return size;};jsts.index.strtree.AbstractSTRtree.prototype.depth=function(){if(arguments.length===1){return this.depth2(arguments[0]);}
if(!this.built){this.build();}
if(this.itemBoundables.length===0){return 0;}
return this.depth2(root);};jsts.index.strtree.AbstractSTRtree.prototype.depth2=function(){var maxChildDepth=0;var childBoundables=node.getChildBoundables();for(var i=0;i<childBoundables.length;i++){var childBoundable=childBoundables[i];if(childBoundable instanceof jsts.index.strtree.AbstractNode){var childDepth=this.depth(childBoundable);if(childDepth>maxChildDepth)
maxChildDepth=childDepth;}}
return maxChildDepth+1;};jsts.index.strtree.AbstractSTRtree.prototype.insert=function(bounds,item){jsts.util.Assert.isTrue(!this.built,'Cannot insert items into an STR packed R-tree after it has been built.');this.itemBoundables.push(new jsts.index.strtree.ItemBoundable(bounds,item));};jsts.index.strtree.AbstractSTRtree.prototype.query=function(searchBounds){if(arguments.length>1){this.query2.apply(this,arguments);}
if(!this.built){this.build();}
var matches=[];if(this.itemBoundables.length===0){jsts.util.Assert.isTrue(this.root.getBounds()===null);return matches;}
if(this.getIntersectsOp().intersects(this.root.getBounds(),searchBounds)){this.query3(searchBounds,this.root,matches);}
return matches;};jsts.index.strtree.AbstractSTRtree.prototype.query2=function(searchBounds,visitor){if(arguments.length>2){this.query3.apply(this,arguments);}
if(!this.built){this.build();}
if(this.itemBoundables.length===0){jsts.util.Assert.isTrue(this.root.getBounds()===null);}
if(this.getIntersectsOp().intersects(this.root.getBounds(),searchBounds)){this.query4(searchBounds,this.root,visitor);}};jsts.index.strtree.AbstractSTRtree.prototype.query3=function(searchBounds,node,matches){if(!(arguments[2]instanceof Array)){this.query4.apply(this,arguments);}
var childBoundables=node.getChildBoundables();for(var i=0;i<childBoundables.length;i++){var childBoundable=childBoundables[i];if(!this.getIntersectsOp().intersects(childBoundable.getBounds(),searchBounds)){continue;}
if(childBoundable instanceof jsts.index.strtree.AbstractNode){this.query3(searchBounds,childBoundable,matches);}else if(childBoundable instanceof jsts.index.strtree.ItemBoundable){matches.push(childBoundable.getItem());}else{jsts.util.Assert.shouldNeverReachHere();}}};jsts.index.strtree.AbstractSTRtree.prototype.query4=function(searchBounds,node,visitor){var childBoundables=node.getChildBoundables();for(var i=0;i<childBoundables.length;i++){var childBoundable=childBoundables[i];if(!this.getIntersectsOp().intersects(childBoundable.getBounds(),searchBounds)){continue;}
if(childBoundable instanceof jsts.index.strtree.AbstractNode){this.query4(searchBounds,childBoundable,visitor);}else if(childBoundable instanceof jsts.index.strtree.ItemBoundable){visitor.visitItem(childBoundable.getItem());}else{jsts.util.Assert.shouldNeverReachHere();}}};jsts.index.strtree.AbstractSTRtree.prototype.getIntersectsOp=function(){throw new jsts.error.AbstractMethodInvocationError();};jsts.index.strtree.AbstractSTRtree.prototype.itemsTree=function(){if(arguments.length===1){return this.itemsTree2.apply(this,arguments);}
if(!this.built){this.build();}
var valuesTree=this.itemsTree2(this.root);if(valuesTree===null)
return[];return valuesTree;};jsts.index.strtree.AbstractSTRtree.prototype.itemsTree2=function(node){var valuesTreeForNode=[];var childBoundables=node.getChildBoundables();for(var i=0;i<childBoundables.length;i++){var childBoundable=childBoundables[i];if(childBoundable instanceof jsts.index.strtree.AbstractNode){var valuesTreeForChild=this.itemsTree(childBoundable);if(valuesTreeForChild!=null)
valuesTreeForNode.push(valuesTreeForChild);}else if(childBoundable instanceof jsts.index.strtree.ItemBoundable){valuesTreeForNode.push(childBoundable.getItem());}else{jsts.util.Assert.shouldNeverReachHere();}}
if(valuesTreeForNode.length<=0)
return null;return valuesTreeForNode;};jsts.index.strtree.AbstractSTRtree.prototype.remove=function(searchBounds,item){if(!this.built){this.build();}
if(this.itemBoundables.length===0){jsts.util.Assert.isTrue(this.root.getBounds()==null);}
if(this.getIntersectsOp().intersects(this.root.getBounds(),searchBounds)){return this.remove2(searchBounds,this.root,item);}
return false;};jsts.index.strtree.AbstractSTRtree.prototype.remove2=function(searchBounds,node,item){var found=this.removeItem(node,item);if(found)
return true;var childToPrune=null;var childBoundables=node.getChildBoundables();for(var i=0;i<childBoundables.length;i++){var childBoundable=childBoundables[i];if(!this.getIntersectsOp().intersects(childBoundable.getBounds(),searchBounds)){continue;}
if(childBoundable instanceof jsts.index.strtree.AbstractNode){found=this.remove(searchBounds,childBoundable,item);if(found){childToPrune=childBoundable;break;}}}
if(childToPrune!=null){if(childToPrune.getChildBoundables().length===0){childBoundables.splice(childBoundables.indexOf(childToPrune),1);}}
return found;};jsts.index.strtree.AbstractSTRtree.prototype.removeItem=function(node,item){var childToRemove=null;var childBoundables=node.getChildBoundables();for(var i=0;i<childBoundables.length;i++){var childBoundable=childBoundables[i];if(childBoundable instanceof jsts.index.strtree.ItemBoundable){if(childBoundable.getItem()===item)
childToRemove=childBoundable;}}
if(childToRemove!==null){childBoundables.splice(childBoundables.indexOf(childToRemove),1);return true;}
return false;};jsts.index.strtree.AbstractSTRtree.prototype.boundablesAtLevel=function(level){if(arguments.length>1){this.boundablesAtLevel2.apply(this,arguments);return;}
var boundables=[];this.boundablesAtLevel2(level,this.root,boundables);return boundables;};jsts.index.strtree.AbstractSTRtree.prototype.boundablesAtLevel2=function(level,top,boundables){jsts.util.Assert.isTrue(level>-2);if(top.getLevel()===level){boundables.add(top);return;}
var childBoundables=node.getChildBoundables();for(var i=0;i<childBoundables.length;i++){var boundable=childBoundables[i];if(boundable instanceof jsts.index.strtree.AbstractNode){this.boundablesAtLevel(level,boundable,boundables);}else{jsts.util.Assert.isTrue(boundable instanceof jsts.index.strtree.ItemBoundable);if(level===-1){boundables.add(boundable);}}}
return;};jsts.index.strtree.AbstractSTRtree.prototype.getComparator=function(){throw new jsts.error.AbstractMethodInvocationError();};jsts.index.strtree.STRtree=function(nodeCapacity){nodeCapacity=nodeCapacity||jsts.index.strtree.STRtree.DEFAULT_NODE_CAPACITY;jsts.index.strtree.AbstractSTRtree.call(this,nodeCapacity);};jsts.index.strtree.STRtree.prototype=new jsts.index.strtree.AbstractSTRtree();jsts.index.strtree.STRtree.constructor=jsts.index.strtree.STRtree;jsts.index.strtree.STRtree.prototype.xComparator=function(o1,o2){return jsts.index.strtree.AbstractSTRtree.prototype.compareDoubles(jsts.index.strtree.STRtree.prototype.centreX(o1.getBounds()),jsts.index.strtree.STRtree.prototype.centreX(o2.getBounds()));};jsts.index.strtree.STRtree.prototype.yComparator=function(o1,o2){return jsts.index.strtree.AbstractSTRtree.prototype.compareDoubles(jsts.index.strtree.STRtree.prototype.centreY(o1.getBounds()),jsts.index.strtree.STRtree.prototype.centreY(o2.getBounds()));};jsts.index.strtree.STRtree.prototype.centreX=function(e){return jsts.index.strtree.STRtree.prototype.avg(e.getMinX(),e.getMaxX());};jsts.index.strtree.STRtree.prototype.centreY=function(e){return jsts.index.strtree.STRtree.prototype.avg(e.getMinY(),e.getMaxY());};jsts.index.strtree.STRtree.prototype.avg=function(a,b){return(a+b)/2.0;};jsts.index.strtree.STRtree.prototype.intersectsOp={intersects:function(aBounds,bBounds){return aBounds.intersects(bBounds);}};jsts.index.strtree.STRtree.prototype.createParentBoundables=function(childBoundables,newLevel){jsts.util.Assert.isTrue(!(childBoundables.length===0));var minLeafCount=Math.ceil(childBoundables.length/this.getNodeCapacity());var sortedChildBoundables=[];for(var i=0;i<childBoundables.length;i++){sortedChildBoundables.push(childBoundables[i]);}
sortedChildBoundables.sort(this.xComparator);var verticalSlices=this.verticalSlices(sortedChildBoundables,Math.ceil(Math.sqrt(minLeafCount)));return this.createParentBoundablesFromVerticalSlices(verticalSlices,newLevel);};jsts.index.strtree.STRtree.prototype.createParentBoundablesFromVerticalSlices=function(verticalSlices,newLevel){jsts.util.Assert.isTrue(verticalSlices.length>0);var parentBoundables=[];for(var i=0;i<verticalSlices.length;i++){parentBoundables=parentBoundables.concat(this.createParentBoundablesFromVerticalSlice(verticalSlices[i],newLevel));}
return parentBoundables;};jsts.index.strtree.STRtree.prototype.createParentBoundablesFromVerticalSlice=function(childBoundables,newLevel){return jsts.index.strtree.AbstractSTRtree.prototype.createParentBoundables.call(this,childBoundables,newLevel);};jsts.index.strtree.STRtree.prototype.verticalSlices=function(childBoundables,sliceCount){var sliceCapacity=Math.ceil(childBoundables.length/sliceCount);var slices=[];var i=0,boundablesAddedToSlice,childBoundable;for(var j=0;j<sliceCount;j++){slices[j]=[];boundablesAddedToSlice=0;while(i<childBoundables.length&&boundablesAddedToSlice<sliceCapacity){childBoundable=childBoundables[i++];slices[j].push(childBoundable);boundablesAddedToSlice++;}}
return slices;};jsts.index.strtree.STRtree.DEFAULT_NODE_CAPACITY=10;jsts.index.strtree.STRtree.prototype.createNode=function(level){var abstractNode=new jsts.index.strtree.AbstractNode(level);abstractNode.computeBounds=function(){var bounds=null;var childBoundables=this.getChildBoundables();for(var i=0;i<childBoundables.length;i++){var childBoundable=childBoundables[i];if(bounds===null){bounds=new jsts.geom.Envelope(childBoundable.getBounds());}else{bounds.expandToInclude(childBoundable.getBounds());}}
return bounds;};return abstractNode;};jsts.index.strtree.STRtree.prototype.getIntersectsOp=function(){return this.intersectsOp;};jsts.index.strtree.STRtree.prototype.insert=function(itemEnv,item){if(itemEnv.isNull()){return;}
jsts.index.strtree.AbstractSTRtree.prototype.insert.call(this,itemEnv,item);};jsts.index.strtree.STRtree.prototype.query=function(searchEnv,visitor){return jsts.index.strtree.AbstractSTRtree.prototype.query.apply(this,arguments);};jsts.index.strtree.STRtree.prototype.remove=function(itemEnv,item){return jsts.index.strtree.AbstractSTRtree.prototype.remove.call(this,itemEnv,item);};jsts.index.strtree.STRtree.prototype.size=function(){return jsts.index.strtree.AbstractSTRtree.prototype.size.call(this);};jsts.index.strtree.STRtree.prototype.depth=function(){return jsts.index.strtree.AbstractSTRtree.prototype.depth.call(this);};jsts.index.strtree.STRtree.prototype.getComparator=function(){return this.yComparator;};jsts.index.strtree.STRtree.prototype.nearestNeighbour=function(itemDist){var bp=new jsts.index.strtree.BoundablePair(this.getRoot(),this.getRoot(),itemDist);return this.nearestNeighbour4(bp);};jsts.index.strtree.STRtree.prototype.nearestNeighbour2=function(env,item,itemDist){var bnd=new jsts.index.strtree.ItemBoundable(env,item);var bp=new jsts.index.strtree.BoundablePair(this.getRoot(),bnd,itemDist);return this.nearestNeighbour4(bp)[0];};jsts.index.strtree.STRtree.prototype.nearestNeighbour3=function(tree,itemDist){var bp=new jsts.index.strtree.BoundablePair(this.getRoot(),tree.getRoot(),itemDist);return this.nearestNeighbour4(bp);};jsts.index.strtree.STRtree.prototype.nearestNeighbour4=function(initBndPair){return this.nearestNeighbour5(initBndPair,Double.POSITIVE_INFINITY);};jsts.index.strtree.STRtree.prototype.nearestNeighbour5=function(initBndPair,maxDistance){var distanceLowerBound=maxDistance;var minPair=null;var priQ=[];priQ.push(initBndPair);while(!priQ.isEmpty()&&distanceLowerBound>0.0){var bndPair=priQ.pop();var currentDistance=bndPair.getDistance();if(currentDistance>=distanceLowerBound)
break;if(bndPair.isLeaves()){distanceLowerBound=currentDistance;minPair=bndPair;}else{bndPair.expandToQueue(priQ,distanceLowerBound);}}
return[minPair.getBoundable(0).getItem(),minPair.getBoundable(1).getItem()];};jsts.noding.SegmentString=function(){};jsts.noding.SegmentString.prototype.getData=jsts.abstractFunc;jsts.noding.SegmentString.prototype.setData=jsts.abstractFunc;jsts.noding.SegmentString.prototype.size=jsts.abstractFunc;jsts.noding.SegmentString.prototype.getCoordinate=jsts.abstractFunc;jsts.noding.SegmentString.prototype.getCoordinates=jsts.abstractFunc;jsts.noding.SegmentString.prototype.isClosed=jsts.abstractFunc;jsts.noding.NodableSegmentString=function(){};jsts.noding.NodableSegmentString.prototype=new jsts.noding.SegmentString();jsts.noding.NodableSegmentString.prototype.addIntersection=jsts.abstractFunc;jsts.noding.NodedSegmentString=function(pts,data){this.nodeList=new jsts.noding.SegmentNodeList(this);this.pts=pts;this.data=data;};jsts.noding.NodedSegmentString.prototype=new jsts.noding.NodableSegmentString();jsts.noding.NodedSegmentString.constructor=jsts.noding.NodedSegmentString;jsts.noding.NodedSegmentString.getNodedSubstrings=function(segStrings){if(arguments.length===2){jsts.noding.NodedSegmentString.getNodedSubstrings2.apply(this,arguments);return;}
var resultEdgelist=new javascript.util.ArrayList();jsts.noding.NodedSegmentString.getNodedSubstrings2(segStrings,resultEdgelist);return resultEdgelist;};jsts.noding.NodedSegmentString.getNodedSubstrings2=function(segStrings,resultEdgelist){for(var i=segStrings.iterator();i.hasNext();){var ss=i.next();ss.getNodeList().addSplitEdges(resultEdgelist);}};jsts.noding.NodedSegmentString.prototype.nodeList=null;jsts.noding.NodedSegmentString.prototype.pts=null;jsts.noding.NodedSegmentString.prototype.data=null;jsts.noding.NodedSegmentString.prototype.getData=function(){return this.data;};jsts.noding.NodedSegmentString.prototype.setData=function(data){this.data=data;};jsts.noding.NodedSegmentString.prototype.getNodeList=function(){return this.nodeList;};jsts.noding.NodedSegmentString.prototype.size=function(){return this.pts.length;};jsts.noding.NodedSegmentString.prototype.getCoordinate=function(i){return this.pts[i];};jsts.noding.NodedSegmentString.prototype.getCoordinates=function(){return this.pts;};jsts.noding.NodedSegmentString.prototype.isClosed=function(){return this.pts[0].equals(this.pts[this.pts.length-1]);};jsts.noding.NodedSegmentString.prototype.getSegmentOctant=function(index){if(index===this.pts.length-1)
return-1;return this.safeOctant(this.getCoordinate(index),this.getCoordinate(index+1));};jsts.noding.NodedSegmentString.prototype.safeOctant=function(p0,p1){if(p0.equals2D(p1))
return 0;return jsts.noding.Octant.octant(p0,p1);};jsts.noding.NodedSegmentString.prototype.addIntersections=function(li,segmentIndex,geomIndex){for(var i=0;i<li.getIntersectionNum();i++){this.addIntersection(li,segmentIndex,geomIndex,i);}};jsts.noding.NodedSegmentString.prototype.addIntersection=function(li,segmentIndex,geomIndex,intIndex){if(li instanceof jsts.geom.Coordinate){this.addIntersection2.apply(this,arguments);return;}
var intPt=new jsts.geom.Coordinate(li.getIntersection(intIndex));this.addIntersection2(intPt,segmentIndex);};jsts.noding.NodedSegmentString.prototype.addIntersection2=function(intPt,segmentIndex){this.addIntersectionNode(intPt,segmentIndex);};jsts.noding.NodedSegmentString.prototype.addIntersectionNode=function(intPt,segmentIndex){var normalizedSegmentIndex=segmentIndex;var nextSegIndex=normalizedSegmentIndex+1;if(nextSegIndex<this.pts.length){var nextPt=this.pts[nextSegIndex];if(intPt.equals2D(nextPt)){normalizedSegmentIndex=nextSegIndex;}}
var ei=this.nodeList.add(intPt,normalizedSegmentIndex);return ei;};jsts.noding.NodedSegmentString.prototype.toString=function(){var geometryFactory=new jsts.geom.GeometryFactory();return new jsts.io.WKTWriter().write(geometryFactory.createLineString(this.pts));};jsts.index.chain.MonotoneChainBuilder=function(){};jsts.index.chain.MonotoneChainBuilder.toIntArray=function(list){var array=[];for(var i=0;i<list.length;i++){array[i]=list[i];}
return array;};jsts.index.chain.MonotoneChainBuilder.getChains=function(pts){if(arguments.length===2){return jsts.index.chain.MonotoneChainBuilder.getChains2.apply(this,arguments);}
return jsts.index.chain.MonotoneChainBuilder.getChains2(pts,null);};jsts.index.chain.MonotoneChainBuilder.getChains2=function(pts,context){var mcList=[];var startIndex=jsts.index.chain.MonotoneChainBuilder.getChainStartIndices(pts);for(var i=0;i<startIndex.length-1;i++){var mc=new jsts.index.chain.MonotoneChain(pts,startIndex[i],startIndex[i+1],context);mcList.push(mc);}
return mcList;};jsts.index.chain.MonotoneChainBuilder.getChainStartIndices=function(pts){var start=0;var startIndexList=[];startIndexList.push(start);do{var last=jsts.index.chain.MonotoneChainBuilder.findChainEnd(pts,start);startIndexList.push(last);start=last;}while(start<pts.length-1);var startIndex=jsts.index.chain.MonotoneChainBuilder.toIntArray(startIndexList);return startIndex;};jsts.index.chain.MonotoneChainBuilder.findChainEnd=function(pts,start){var safeStart=start;while(safeStart<pts.length-1&&pts[safeStart].equals2D(pts[safeStart+1])){safeStart++;}
if(safeStart>=pts.length-1){return pts.length-1;}
var chainQuad=jsts.geomgraph.Quadrant.quadrant(pts[safeStart],pts[safeStart+1]);var last=start+1;while(last<pts.length){if(!pts[last-1].equals2D(pts[last])){var quad=jsts.geomgraph.Quadrant.quadrant(pts[last-1],pts[last]);if(quad!==chainQuad)
break;}
last++;}
return last-1;};jsts.algorithm.LineIntersector=function(){this.inputLines=[[],[]];this.intPt=[null,null];this.pa=this.intPt[0];this.pb=this.intPt[1];this.result=jsts.algorithm.LineIntersector.NO_INTERSECTION;};jsts.algorithm.LineIntersector.NO_INTERSECTION=0;jsts.algorithm.LineIntersector.POINT_INTERSECTION=1;jsts.algorithm.LineIntersector.COLLINEAR_INTERSECTION=2;jsts.algorithm.LineIntersector.prototype.setPrecisionModel=function(precisionModel){this.precisionModel=precisionModel;};jsts.algorithm.LineIntersector.prototype.getEndpoint=function(segmentIndex,ptIndex){return this.inputLines[segmentIndex][ptIndex];};jsts.algorithm.LineIntersector.computeEdgeDistance=function(p,p0,p1){var dx=Math.abs(p1.x-p0.x);var dy=Math.abs(p1.y-p0.y);var dist=-1.0;if(p.equals(p0)){dist=0.0;}else if(p.equals(p1)){if(dx>dy){dist=dx;}else{dist=dy;}}else{var pdx=Math.abs(p.x-p0.x);var pdy=Math.abs(p.y-p0.y);if(dx>dy){dist=pdx;}else{dist=pdy;}
if(dist===0.0&&!p.equals(p0)){dist=Math.max(pdx,pdy);}}
if(dist===0.0&&!p.equals(p0)){throw new jsts.error.IllegalArgumentError('Bad distance calculation');}
return dist;};jsts.algorithm.LineIntersector.nonRobustComputeEdgeDistance=function(p,p1,p2){var dx=p.x-p1.x;var dy=p.y-p1.y;var dist=Math.sqrt(dx*dx+dy*dy);if(!(dist===0.0&&!p.equals(p1))){throw new jsts.error.IllegalArgumentError('Invalid distance calculation');}
return dist;};jsts.algorithm.LineIntersector.prototype.result=null;jsts.algorithm.LineIntersector.prototype.inputLines=null;jsts.algorithm.LineIntersector.prototype.intPt=null;jsts.algorithm.LineIntersector.prototype.intLineIndex=null;jsts.algorithm.LineIntersector.prototype._isProper=null;jsts.algorithm.LineIntersector.prototype.pa=null;jsts.algorithm.LineIntersector.prototype.pb=null;jsts.algorithm.LineIntersector.prototype.precisionModel=null;jsts.algorithm.LineIntersector.prototype.computeIntersection=function(p,p1,p2){throw new jsts.error.AbstractMethodInvocationError();};jsts.algorithm.LineIntersector.prototype.isCollinear=function(){return this.result===jsts.algorithm.LineIntersector.COLLINEAR_INTERSECTION;};jsts.algorithm.LineIntersector.prototype.computeIntersection=function(p1,p2,p3,p4){this.inputLines[0][0]=p1;this.inputLines[0][1]=p2;this.inputLines[1][0]=p3;this.inputLines[1][1]=p4;this.result=this.computeIntersect(p1,p2,p3,p4);};jsts.algorithm.LineIntersector.prototype.computeIntersect=function(p1,p2,q1,q2){throw new jsts.error.AbstractMethodInvocationError();};jsts.algorithm.LineIntersector.prototype.isEndPoint=function(){return this.hasIntersection()&&!this._isProper;};jsts.algorithm.LineIntersector.prototype.hasIntersection=function(){return this.result!==jsts.algorithm.LineIntersector.NO_INTERSECTION;};jsts.algorithm.LineIntersector.prototype.getIntersectionNum=function(){return this.result;};jsts.algorithm.LineIntersector.prototype.getIntersection=function(intIndex){return this.intPt[intIndex];};jsts.algorithm.LineIntersector.prototype.computeIntLineIndex=function(){if(this.intLineIndex===null){this.intLineIndex=[[],[]];this.computeIntLineIndex(0);this.computeIntLineIndex(1);}};jsts.algorithm.LineIntersector.prototype.isIntersection=function(pt){var i;for(i=0;i<this.result;i++){if(this.intPt[i].equals2D(pt)){return true;}}
return false;};jsts.algorithm.LineIntersector.prototype.isInteriorIntersection=function(){if(arguments.length===1){return this.isInteriorIntersection2.apply(this,arguments);}
if(this.isInteriorIntersection(0)){return true;}
if(this.isInteriorIntersection(1)){return true;}
return false;};jsts.algorithm.LineIntersector.prototype.isInteriorIntersection2=function(inputLineIndex){var i;for(i=0;i<this.result;i++){if(!(this.intPt[i].equals2D(this.inputLines[inputLineIndex][0])||this.intPt[i].equals2D(this.inputLines[inputLineIndex][1]))){return true;}}
return false;};jsts.algorithm.LineIntersector.prototype.isProper=function(){return this.hasIntersection()&&this._isProper;};jsts.algorithm.LineIntersector.prototype.getIntersectionAlongSegment=function(segmentIndex,intIndex){this.computeIntLineIndex();return this.intPt[intLineIndex[segmentIndex][intIndex]];};jsts.algorithm.LineIntersector.prototype.getIndexAlongSegment=function(segmentIndex,intIndex){this.computeIntLineIndex();return this.intLineIndex[segmentIndex][intIndex];};jsts.algorithm.LineIntersector.prototype.computeIntLineIndex=function(segmentIndex){var dist0=this.getEdgeDistance(segmentIndex,0);var dist1=this.getEdgeDistance(segmentIndex,1);if(dist0>dist1){this.intLineIndex[segmentIndex][0]=0;this.intLineIndex[segmentIndex][1]=1;}else{this.intLineIndex[segmentIndex][0]=1;this.intLineIndex[segmentIndex][1]=0;}};jsts.algorithm.LineIntersector.prototype.getEdgeDistance=function(segmentIndex,intIndex){var dist=jsts.algorithm.LineIntersector.computeEdgeDistance(this.intPt[intIndex],this.inputLines[segmentIndex][0],this.inputLines[segmentIndex][1]);return dist;};jsts.algorithm.RobustLineIntersector=function(){jsts.algorithm.RobustLineIntersector.prototype.constructor.call(this);};jsts.algorithm.RobustLineIntersector.prototype=new jsts.algorithm.LineIntersector();jsts.algorithm.RobustLineIntersector.prototype.computeIntersection=function(p,p1,p2){if(arguments.length===4){jsts.algorithm.LineIntersector.prototype.computeIntersection.apply(this,arguments);return;}
this._isProper=false;if(jsts.geom.Envelope.intersects(p1,p2,p)){if((jsts.algorithm.CGAlgorithms.orientationIndex(p1,p2,p)===0)&&(jsts.algorithm.CGAlgorithms.orientationIndex(p2,p1,p)===0)){this._isProper=true;if(p.equals(p1)||p.equals(p2)){this._isProper=false;}
this.result=jsts.algorithm.LineIntersector.POINT_INTERSECTION;return;}}
this.result=jsts.algorithm.LineIntersector.NO_INTERSECTION;};jsts.algorithm.RobustLineIntersector.prototype.computeIntersect=function(p1,p2,q1,q2){this._isProper=false;if(!jsts.geom.Envelope.intersects(p1,p2,q1,q2)){return jsts.algorithm.LineIntersector.NO_INTERSECTION;}
var Pq1=jsts.algorithm.CGAlgorithms.orientationIndex(p1,p2,q1);var Pq2=jsts.algorithm.CGAlgorithms.orientationIndex(p1,p2,q2);if((Pq1>0&&Pq2>0)||(Pq1<0&&Pq2<0)){return jsts.algorithm.LineIntersector.NO_INTERSECTION;}
var Qp1=jsts.algorithm.CGAlgorithms.orientationIndex(q1,q2,p1);var Qp2=jsts.algorithm.CGAlgorithms.orientationIndex(q1,q2,p2);if((Qp1>0&&Qp2>0)||(Qp1<0&&Qp2<0)){return jsts.algorithm.LineIntersector.NO_INTERSECTION;}
var collinear=Pq1===0&&Pq2===0&&Qp1===0&&Qp2===0;if(collinear){return this.computeCollinearIntersection(p1,p2,q1,q2);}
if(Pq1===0||Pq2===0||Qp1===0||Qp2===0){this._isProper=false;if(p1.equals2D(q1)||p1.equals2D(q2)){this.intPt[0]=p1;}else if(p2.equals2D(q1)||p2.equals2D(q2)){this.intPt[0]=p2;}
else if(Pq1===0){this.intPt[0]=new jsts.geom.Coordinate(q1);}else if(Pq2===0){this.intPt[0]=new jsts.geom.Coordinate(q2);}else if(Qp1===0){this.intPt[0]=new jsts.geom.Coordinate(p1);}else if(Qp2===0){this.intPt[0]=new jsts.geom.Coordinate(p2);}}else{this._isProper=true;this.intPt[0]=this.intersection(p1,p2,q1,q2);}
return jsts.algorithm.LineIntersector.POINT_INTERSECTION;};jsts.algorithm.RobustLineIntersector.prototype.computeCollinearIntersection=function(p1,p2,q1,q2){var p1q1p2=jsts.geom.Envelope.intersects(p1,p2,q1);var p1q2p2=jsts.geom.Envelope.intersects(p1,p2,q2);var q1p1q2=jsts.geom.Envelope.intersects(q1,q2,p1);var q1p2q2=jsts.geom.Envelope.intersects(q1,q2,p2);if(p1q1p2&&p1q2p2){this.intPt[0]=q1;this.intPt[1]=q2;return jsts.algorithm.LineIntersector.COLLINEAR_INTERSECTION;}
if(q1p1q2&&q1p2q2){this.intPt[0]=p1;this.intPt[1]=p2;return jsts.algorithm.LineIntersector.COLLINEAR_INTERSECTION;}
if(p1q1p2&&q1p1q2){this.intPt[0]=q1;this.intPt[1]=p1;return q1.equals(p1)&&!p1q2p2&&!q1p2q2?jsts.algorithm.LineIntersector.POINT_INTERSECTION:jsts.algorithm.LineIntersector.COLLINEAR_INTERSECTION;}
if(p1q1p2&&q1p2q2){this.intPt[0]=q1;this.intPt[1]=p2;return q1.equals(p2)&&!p1q2p2&&!q1p1q2?jsts.algorithm.LineIntersector.POINT_INTERSECTION:jsts.algorithm.LineIntersector.COLLINEAR_INTERSECTION;}
if(p1q2p2&&q1p1q2){this.intPt[0]=q2;this.intPt[1]=p1;return q2.equals(p1)&&!p1q1p2&&!q1p2q2?jsts.algorithm.LineIntersector.POINT_INTERSECTION:jsts.algorithm.LineIntersector.COLLINEAR_INTERSECTION;}
if(p1q2p2&&q1p2q2){this.intPt[0]=q2;this.intPt[1]=p2;return q2.equals(p2)&&!p1q1p2&&!q1p1q2?jsts.algorithm.LineIntersector.POINT_INTERSECTION:jsts.algorithm.LineIntersector.COLLINEAR_INTERSECTION;}
return jsts.algorithm.LineIntersector.NO_INTERSECTION;};jsts.algorithm.RobustLineIntersector.prototype.intersection=function(p1,p2,q1,q2){var intPt=this.intersectionWithNormalization(p1,p2,q1,q2);if(!this.isInSegmentEnvelopes(intPt)){intPt=jsts.algorithm.CentralEndpointIntersector.getIntersection(p1,p2,q1,q2);}
if(this.precisionModel!==null){this.precisionModel.makePrecise(intPt);}
return intPt;};jsts.algorithm.RobustLineIntersector.prototype.intersectionWithNormalization=function(p1,p2,q1,q2){var n1=new jsts.geom.Coordinate(p1);var n2=new jsts.geom.Coordinate(p2);var n3=new jsts.geom.Coordinate(q1);var n4=new jsts.geom.Coordinate(q2);var normPt=new jsts.geom.Coordinate();this.normalizeToEnvCentre(n1,n2,n3,n4,normPt);var intPt=this.safeHCoordinateIntersection(n1,n2,n3,n4);intPt.x+=normPt.x;intPt.y+=normPt.y;return intPt;};jsts.algorithm.RobustLineIntersector.prototype.safeHCoordinateIntersection=function(p1,p2,q1,q2){var intPt=null;try{intPt=jsts.algorithm.HCoordinate.intersection(p1,p2,q1,q2);}catch(e){if(e instanceof jsts.error.NotRepresentableError){intPt=jsts.algorithm.CentralEndpointIntersector.getIntersection(p1,p2,q1,q2);}else{throw e;}}
return intPt;};jsts.algorithm.RobustLineIntersector.prototype.normalizeToMinimum=function(n1,n2,n3,n4,normPt){normPt.x=this.smallestInAbsValue(n1.x,n2.x,n3.x,n4.x);normPt.y=this.smallestInAbsValue(n1.y,n2.y,n3.y,n4.y);n1.x-=normPt.x;n1.y-=normPt.y;n2.x-=normPt.x;n2.y-=normPt.y;n3.x-=normPt.x;n3.y-=normPt.y;n4.x-=normPt.x;n4.y-=normPt.y;};jsts.algorithm.RobustLineIntersector.prototype.normalizeToEnvCentre=function(n00,n01,n10,n11,normPt){var minX0=n00.x<n01.x?n00.x:n01.x;var minY0=n00.y<n01.y?n00.y:n01.y;var maxX0=n00.x>n01.x?n00.x:n01.x;var maxY0=n00.y>n01.y?n00.y:n01.y;var minX1=n10.x<n11.x?n10.x:n11.x;var minY1=n10.y<n11.y?n10.y:n11.y;var maxX1=n10.x>n11.x?n10.x:n11.x;var maxY1=n10.y>n11.y?n10.y:n11.y;var intMinX=minX0>minX1?minX0:minX1;var intMaxX=maxX0<maxX1?maxX0:maxX1;var intMinY=minY0>minY1?minY0:minY1;var intMaxY=maxY0<maxY1?maxY0:maxY1;var intMidX=(intMinX+intMaxX)/2.0;var intMidY=(intMinY+intMaxY)/2.0;normPt.x=intMidX;normPt.y=intMidY;n00.x-=normPt.x;n00.y-=normPt.y;n01.x-=normPt.x;n01.y-=normPt.y;n10.x-=normPt.x;n10.y-=normPt.y;n11.x-=normPt.x;n11.y-=normPt.y;};jsts.algorithm.RobustLineIntersector.prototype.smallestInAbsValue=function(x1,x2,x3,x4){var x=x1;var xabs=Math.abs(x);if(Math.abs(x2)<xabs){x=x2;xabs=Math.abs(x2);}
if(Math.abs(x3)<xabs){x=x3;xabs=Math.abs(x3);}
if(Math.abs(x4)<xabs){x=x4;}
return x;};jsts.algorithm.RobustLineIntersector.prototype.isInSegmentEnvelopes=function(intPt){var env0=new jsts.geom.Envelope(this.inputLines[0][0],this.inputLines[0][1]);var env1=new jsts.geom.Envelope(this.inputLines[1][0],this.inputLines[1][1]);return env0.contains(intPt)&&env1.contains(intPt);};jsts.algorithm.HCoordinate=function(){this.x=0.0;this.y=0.0;this.w=1.0;if(arguments.length===1){this.initFrom1Coordinate(arguments[0]);}else if(arguments.length===2&&arguments[0]instanceof jsts.geom.Coordinate){this.initFrom2Coordinates(arguments[0],arguments[1]);}else if(arguments.length===2&&arguments[0]instanceof jsts.algorithm.HCoordinate){this.initFrom2HCoordinates(arguments[0],arguments[1]);}else if(arguments.length===2){this.initFromXY(arguments[0],arguments[1]);}else if(arguments.length===3){this.initFromXYW(arguments[0],arguments[1],arguments[2]);}else if(arguments.length===4){this.initFromXYW(arguments[0],arguments[1],arguments[2],arguments[3]);}};jsts.algorithm.HCoordinate.intersection=function(p1,p2,q1,q2){var px,py,pw,qx,qy,qw,x,y,w,xInt,yInt;px=p1.y-p2.y;py=p2.x-p1.x;pw=p1.x*p2.y-p2.x*p1.y;qx=q1.y-q2.y;qy=q2.x-q1.x;qw=q1.x*q2.y-q2.x*q1.y;x=py*qw-qy*pw;y=qx*pw-px*qw;w=px*qy-qx*py;xInt=x/w;yInt=y/w;if(!isFinite(xInt)||!isFinite(yInt)){throw new jsts.error.NotRepresentableError();}
return new jsts.geom.Coordinate(xInt,yInt);};jsts.algorithm.HCoordinate.prototype.initFrom1Coordinate=function(p){this.x=p.x;this.y=p.y;this.w=1.0;};jsts.algorithm.HCoordinate.prototype.initFrom2Coordinates=function(p1,p2){this.x=p1.y-p2.y;this.y=p2.x-p1.x;this.w=p1.x*p2.y-p2.x*p1.y;};jsts.algorithm.HCoordinate.prototype.initFrom2HCoordinates=function(p1,p2){this.x=p1.y*p2.w-p2.y*p1.w;this.y=p2.x*p1.w-p1.x*p2.w;this.w=p1.x*p2.y-p2.x*p1.y;};jsts.algorithm.HCoordinate.prototype.initFromXYW=function(x,y,w){this.x=x;this.y=y;this.w=w;};jsts.algorithm.HCoordinate.prototype.initFromXY=function(x,y){this.x=x;this.y=y;this.w=1.0;};jsts.algorithm.HCoordinate.prototype.initFrom4Coordinates=function(p1,p2,q1,q2){var px,py,pw,qx,qy,qw;px=p1.y-p2.y;py=p2.x-p1.x;pw=p1.x*p2.y-p2.x*p1.y;qx=q1.y-q2.y;qy=q2.x-q1.x;qw=q1.x*q2.y-q2.x*q1.y;this.x=py*qw-qy*pw;this.y=qx*pw-px*qw;this.w=px*qy-qx*py;};jsts.algorithm.HCoordinate.prototype.getX=function(){var a=this.x/this.w;if(!isFinite(a)){throw new jsts.error.NotRepresentableError();}
return a;};jsts.algorithm.HCoordinate.prototype.getY=function(){var a=this.y/this.w;if(!isFinite(a)){throw new jsts.error.NotRepresentableError();}
return a;};jsts.algorithm.HCoordinate.prototype.getCoordinate=function(){var p=new jsts.geom.Coordinate();p.x=this.getX();p.y=this.getY();return p;};jsts.geom.LineSegment=function(){if(arguments.length===0){this.p0=new jsts.geom.Coordinate();this.p1=new jsts.geom.Coordinate();}else if(arguments.length===1){this.p0=arguments[0].p0;this.p1=arguments[0].p1;}else if(arguments.length===2){this.p0=arguments[0];this.p1=arguments[1];}else if(arguments.length===4){this.p0=new jsts.geom.Coordinate(arguments[0],arguments[1]);this.p1=new jsts.geom.Coordinate(arguments[2],arguments[3]);}};jsts.geom.LineSegment.prototype.p0=null;jsts.geom.LineSegment.prototype.p1=null;jsts.geom.LineSegment.midPoint=function(p0,p1){return new jsts.geom.Coordinate((p0.x+p1.x)/2,(p0.y+p1.y)/2);};jsts.geom.LineSegment.prototype.getCoordinate=function(i){if(i===0)return this.p0;return this.p1;};jsts.geom.LineSegment.prototype.getLength=function(){return this.p0.distance(this.p1);};jsts.geom.LineSegment.prototype.isHorizontal=function(){return this.p0.y===this.p1.y;};jsts.geom.LineSegment.prototype.isVertical=function(){return this.p0.x===this.p1.x;};jsts.geom.LineSegment.prototype.orientationIndex=function(arg){if(arg instanceof jsts.geom.LineSegment){return this.orientationIndex1(arg);}else if(arg instanceof jsts.geom.Coordinate){return this.orientationIndex2(arg);}};jsts.geom.LineSegment.prototype.orientationIndex1=function(seg){var orient0=jsts.algorithm.CGAlgorithms.orientationIndex(this.p0,this.p1,seg.p0);var orient1=jsts.algorithm.CGAlgorithms.orientationIndex(this.p0,this.p1,seg.p1);if(orient0>=0&&orient1>=0){return Math.max(orient0,orient1);}
if(orient0<=0&&orient1<=0){return Math.max(orient0,orient1);}
return 0;};jsts.geom.LineSegment.prototype.orientationIndex2=function(p){return jsts.algorithm.CGAlgorithms.orientationIndex(this.p0,this.p1,p);};jsts.geom.LineSegment.prototype.reverse=function(){var temp=this.p0;this.p0=this.p1;this.p1=temp;};jsts.geom.LineSegment.prototype.normalize=function(){if(this.p1.compareTo(this.p0)<0)this.reverse();};jsts.geom.LineSegment.prototype.angle=function(){return Math.atan2(this.p1.y-this.p0.y,this.p1.x-this.p0.x);};jsts.geom.LineSegment.prototype.midPoint=function(){return jsts.geom.LineSegment.midPoint(this.p0,this.p1);};jsts.geom.LineSegment.prototype.distance=function(arg){if(arg instanceof jsts.geom.LineSegment){return this.distance1(arg);}else if(arg instanceof jsts.geom.Coordinate){return this.distance2(arg);}};jsts.geom.LineSegment.prototype.distance1=function(ls){return jsts.algorithm.CGAlgorithms.distanceLineLine(this.p0,this.p1,ls.p0,ls.p1);};jsts.geom.LineSegment.prototype.distance2=function(p){return jsts.algorithm.CGAlgorithms.distancePointLine(p,this.p0,this.p1);};jsts.geom.LineSegment.prototype.pointAlong=function(segmentLengthFraction){var coord=new jsts.geom.Coordinate();coord.x=this.p0.x+segmentLengthFraction*(this.p1.x-this.p0.x);coord.y=this.p0.y+segmentLengthFraction*(this.p1.y-this.p0.y);return coord;};jsts.geom.LineSegment.prototype.pointAlongOffset=function(segmentLengthFraction,offsetDistance){var segx=this.p0.x+segmentLengthFraction*(this.p1.x-this.p0.x);var segy=this.p0.y+segmentLengthFraction*(this.p1.y-this.p0.y);var dx=this.p1.x-this.p0.x;var dy=this.p1.y-this.p0.y;var len=Math.sqrt(dx*dx+dy*dy);var ux=0;var uy=0;if(offsetDistance!==0){if(len<=0){throw"Cannot compute offset from zero-length line segment";}
ux=offsetDistance*dx/len;uy=offsetDistance*dy/len;}
var offsetx=segx-uy;var offsety=segy+ux;var coord=new jsts.geom.Coordinate(offsetx,offsety);return coord;};jsts.geom.LineSegment.prototype.projectionFactor=function(p){if(p.equals(this.p0))
return 0.0;if(p.equals(this.p1))
return 1.0;var dx=this.p1.x-this.p0.x;var dy=this.p1.y-this.p0.y;var len2=dx*dx+dy*dy;var r=((p.x-this.p0.x)*dx+(p.y-this.p0.y)*dy)/len2;return r;};jsts.geom.LineSegment.prototype.segmentFraction=function(inputPt){var segFrac=this.projectionFactor(inputPt);if(segFrac<0){segFrac=0;}else if(segFrac>1||isNaN(segFrac)){segFrac=1;}
return segFrac;};jsts.geom.LineSegment.prototype.project=function(arg){if(arg instanceof jsts.geom.Coordinate){return this.project1(arg);}else if(arg instanceof jsts.geom.LineSegment){return this.project2(arg);}};jsts.geom.LineSegment.prototype.project1=function(p){if(p.equals(this.p0)||p.equals(this.p1)){return new jsts.geom.Coordinate(p);}
var r=this.projectionFactor(p);var coord=new jsts.geom.Coordinate();coord.x=this.p0.x+r*(this.p1.x-this.p0.x);coord.y=this.p0.y+r*(this.p1.y-this.p0.y);return coord;};jsts.geom.LineSegment.prototype.project2=function(seg){var pf0=this.projectionFactor(seg.p0);var pf1=this.projectionFactor(seg.p1);if(pf0>=1&&pf1>=1)return null;if(pf0<=0&&pf1<=0)return null;var newp0=this.project(seg.p0);if(pf0<0)newp0=p0;if(pf0>1)newp0=p1;var newp1=this.project(seg.p1);if(pf1<0.0)newp1=p0;if(pf1>1.0)newp1=p1;return new jsts.geom.LineSegment(newp0,newp1);};jsts.geom.LineSegment.prototype.closestPoint=function(p){var factor=this.projectionFactor(p);if(factor>0&&factor<1){return this.project(p);}
var dist0=this.p0.distance(p);var dist1=this.p1.distance(p);if(dist0<dist1)
return this.p0;return this.p1;};jsts.geom.LineSegment.prototype.closestPoints=function(line){var intPt=this.intersection(line);if(intPt!==null){return[intPt,intPt];}
var closestPt=[];var minDistance=Number.MAX_VALUE;var dist;var close00=this.closestPoint(line.p0);minDistance=close00.distance(line.p0);closestPt[0]=close00;closestPt[1]=line.p0;var close01=this.closestPoint(line.p1);dist=close01.distance(line.p1);if(dist<minDistance){minDistance=dist;closestPt[0]=close01;closestPt[1]=line.p1;}
var close10=line.closestPoint(this.p0);dist=close10.distance(this.p0);if(dist<minDistance){minDistance=dist;closestPt[0]=this.p0;closestPt[1]=close10;}
var close11=line.closestPoint(this.p1);dist=close11.distance(this.p1);if(dist<minDistance){minDistance=dist;closestPt[0]=this.p1;closestPt[1]=close11;}
return closestPt;};jsts.geom.LineSegment.prototype.intersection=function(line){var li=new jsts.algorithm.RobustLineIntersector();li.computeIntersection(this.p0,this.p1,line.p0,line.p1);if(li.hasIntersection())
return li.getIntersection(0);return null;};jsts.geom.LineSegment.prototype.setCoordinates=function(ls){if(ls instanceof jsts.geom.Coordinate){this.setCoordinates2.apply(this,arguments);return;}
this.setCoordinates2(ls.p0,ls.p1);};jsts.geom.LineSegment.prototype.setCoordinates2=function(p0,p1){this.p0.x=p0.x;this.p0.y=p0.y;this.p1.x=p1.x;this.p1.y=p1.y;};jsts.geom.LineSegment.prototype.distancePerpendicular=function(p){return jsts.algorithm.CGAlgorithms.distancePointLinePerpendicular(p,this.p0,this.p1);};jsts.geom.LineSegment.prototype.lineIntersection=function(line){try{var intPt=jsts.algorithm.HCoordinate.intersection(this.p0,this.p1,line.p0,line.p1);return intPt;}catch(ex){}
return null;};jsts.geom.LineSegment.prototype.toGeometry=function(geomFactory){return geomFactory.createLineString([this.p0,this.p1]);};jsts.geom.LineSegment.prototype.equals=function(o){if(!(o instanceof jsts.geom.LineSegment)){return false;}
return this.p0.equals(o.p0)&&this.p1.equals(o.p1);};jsts.geom.LineSegment.prototype.compareTo=function(o){var comp0=this.p0.compareTo(o.p0);if(comp0!==0)return comp0;return this.p1.compareTo(o.p1);};jsts.geom.LineSegment.prototype.equalsTopo=function(other){return this.p0.equals(other.p0)&&this.p1.equals(other.p1)||this.p0.equals(other.p1)&&this.p1.equals(other.p0);};jsts.geom.LineSegment.prototype.toString=function(){return"LINESTRING("+
this.p0.x+" "+this.p0.y
+", "+
this.p1.x+" "+this.p1.y+")";};jsts.index.chain.MonotoneChainOverlapAction=function(){this.tempEnv1=new jsts.geom.Envelope();this.tempEnv2=new jsts.geom.Envelope();this.overlapSeg1=new jsts.geom.LineSegment();this.overlapSeg2=new jsts.geom.LineSegment();};jsts.index.chain.MonotoneChainOverlapAction.prototype.tempEnv1=null;jsts.index.chain.MonotoneChainOverlapAction.prototype.tempEnv2=null;jsts.index.chain.MonotoneChainOverlapAction.prototype.overlapSeg1=null;jsts.index.chain.MonotoneChainOverlapAction.prototype.overlapSeg2=null;jsts.index.chain.MonotoneChainOverlapAction.prototype.overlap=function(mc1,start1,mc2,start2){this.mc1.getLineSegment(start1,this.overlapSeg1);this.mc2.getLineSegment(start2,this.overlapSeg2);this.overlap2(this.overlapSeg1,this.overlapSeg2);};jsts.index.chain.MonotoneChainOverlapAction.prototype.overlap2=function(seg1,seg2){};(function(){var MonotoneChainOverlapAction=jsts.index.chain.MonotoneChainOverlapAction;var SinglePassNoder=jsts.noding.SinglePassNoder;var STRtree=jsts.index.strtree.STRtree;var NodedSegmentString=jsts.noding.NodedSegmentString;var MonotoneChainBuilder=jsts.index.chain.MonotoneChainBuilder;var SegmentOverlapAction=function(si){this.si=si;};SegmentOverlapAction.prototype=new MonotoneChainOverlapAction();SegmentOverlapAction.constructor=SegmentOverlapAction;SegmentOverlapAction.prototype.si=null;SegmentOverlapAction.prototype.overlap=function(mc1,start1,mc2,start2){var ss1=mc1.getContext();var ss2=mc2.getContext();this.si.processIntersections(ss1,start1,ss2,start2);};jsts.noding.MCIndexNoder=function(){this.monoChains=[];this.index=new STRtree();};jsts.noding.MCIndexNoder.prototype=new SinglePassNoder();jsts.noding.MCIndexNoder.constructor=jsts.noding.MCIndexNoder;jsts.noding.MCIndexNoder.prototype.monoChains=null;jsts.noding.MCIndexNoder.prototype.index=null;jsts.noding.MCIndexNoder.prototype.idCounter=0;jsts.noding.MCIndexNoder.prototype.nodedSegStrings=null;jsts.noding.MCIndexNoder.prototype.nOverlaps=0;jsts.noding.MCIndexNoder.prototype.getMonotoneChains=function(){return this.monoChains;};jsts.noding.MCIndexNoder.prototype.getIndex=function(){return this.index;};jsts.noding.MCIndexNoder.prototype.getNodedSubstrings=function(){return NodedSegmentString.getNodedSubstrings(this.nodedSegStrings);};jsts.noding.MCIndexNoder.prototype.computeNodes=function(inputSegStrings){this.nodedSegStrings=inputSegStrings;for(var i=inputSegStrings.iterator();i.hasNext();){this.add(i.next());}
this.intersectChains();};jsts.noding.MCIndexNoder.prototype.intersectChains=function(){var overlapAction=new SegmentOverlapAction(this.segInt);for(var i=0;i<this.monoChains.length;i++){var queryChain=this.monoChains[i];var overlapChains=this.index.query(queryChain.getEnvelope());for(var j=0;j<overlapChains.length;j++){var testChain=overlapChains[j];if(testChain.getId()>queryChain.getId()){queryChain.computeOverlaps(testChain,overlapAction);this.nOverlaps++;}
if(this.segInt.isDone())
return;}}};jsts.noding.MCIndexNoder.prototype.add=function(segStr){var segChains=MonotoneChainBuilder.getChains(segStr.getCoordinates(),segStr);for(var i=0;i<segChains.length;i++){var mc=segChains[i];mc.setId(this.idCounter++);this.index.insert(mc.getEnvelope(),mc);this.monoChains.push(mc);}};})();jsts.simplify.LineSegmentIndex=function(){this.index=new jsts.index.quadtree.Quadtree();};jsts.simplify.LineSegmentIndex.prototype.index=null;jsts.simplify.LineSegmentIndex.prototype.add=function(line){if(line instanceof jsts.geom.LineSegment){this.add2(line);return;}
var segs=line.getSegments();for(var i=0;i<segs.length;i++){var seg=segs[i];this.add2(seg);}};jsts.simplify.LineSegmentIndex.prototype.add2=function(seg){this.index.insert(new jsts.geom.Envelope(seg.p0,seg.p1),seg);};jsts.simplify.LineSegmentIndex.prototype.remove=function(seg){this.index.remove(new jsts.geom.Envelope(seg.p0,seg.p1),seg);};jsts.simplify.LineSegmentIndex.prototype.query=function(querySeg){var env=new jsts.geom.Envelope(querySeg.p0,querySeg.p1);var visitor=new jsts.simplify.LineSegmentIndex.LineSegmentVisitor(querySeg);this.index.query(env,visitor);var itemsFound=visitor.getItems();return itemsFound;};jsts.simplify.LineSegmentIndex.LineSegmentVisitor=function(querySeg){this.items=[];this.querySeg=querySeg;};jsts.simplify.LineSegmentIndex.LineSegmentVisitor.prototype=new jsts.index.ItemVisitor();jsts.simplify.LineSegmentIndex.LineSegmentVisitor.prototype.querySeg=null;jsts.simplify.LineSegmentIndex.LineSegmentVisitor.prototype.items=null;jsts.simplify.LineSegmentIndex.LineSegmentVisitor.prototype.visitItem=function(item){var seg=item;if(jsts.geom.Envelope.intersects(seg.p0,seg.p1,this.querySeg.p0,this.querySeg.p1))
this.items.push(item);};jsts.simplify.LineSegmentIndex.LineSegmentVisitor.prototype.getItems=function(){return this.items;};jsts.geomgraph.EdgeEndStar=function(){this.edgeMap=new javascript.util.TreeMap();this.edgeList=null;this.ptInAreaLocation=[jsts.geom.Location.NONE,jsts.geom.Location.NONE];};jsts.geomgraph.EdgeEndStar.prototype.edgeMap=null;jsts.geomgraph.EdgeEndStar.prototype.edgeList=null;jsts.geomgraph.EdgeEndStar.prototype.ptInAreaLocation=null;jsts.geomgraph.EdgeEndStar.prototype.insert=function(e){throw new jsts.error.AbstractMethodInvocationError();};jsts.geomgraph.EdgeEndStar.prototype.insertEdgeEnd=function(e,obj){this.edgeMap.put(e,obj);this.edgeList=null;};jsts.geomgraph.EdgeEndStar.prototype.getCoordinate=function(){var it=this.iterator();if(!it.hasNext())
return null;var e=it.next();return e.getCoordinate();};jsts.geomgraph.EdgeEndStar.prototype.getDegree=function(){return this.edgeMap.size();};jsts.geomgraph.EdgeEndStar.prototype.iterator=function(){return this.getEdges().iterator();};jsts.geomgraph.EdgeEndStar.prototype.getEdges=function(){if(this.edgeList===null){this.edgeList=new javascript.util.ArrayList(this.edgeMap.values());}
return this.edgeList;};jsts.geomgraph.EdgeEndStar.prototype.getNextCW=function(ee){this.getEdges();var i=this.edgeList.indexOf(ee);var iNextCW=i-1;if(i===0)
iNextCW=this.edgeList.length-1;return this.edgeList[iNextCW];};jsts.geomgraph.EdgeEndStar.prototype.computeLabelling=function(geomGraph){this.computeEdgeEndLabels(geomGraph[0].getBoundaryNodeRule());this.propagateSideLabels(0);this.propagateSideLabels(1);var hasDimensionalCollapseEdge=[false,false];for(var it=this.iterator();it.hasNext();){var e=it.next();var label=e.getLabel();for(var geomi=0;geomi<2;geomi++){if(label.isLine(geomi)&&label.getLocation(geomi)===jsts.geom.Location.BOUNDARY)
hasDimensionalCollapseEdge[geomi]=true;}}
for(var it=this.iterator();it.hasNext();){var e=it.next();var label=e.getLabel();for(var geomi=0;geomi<2;geomi++){if(label.isAnyNull(geomi)){var loc=jsts.geom.Location.NONE;if(hasDimensionalCollapseEdge[geomi]){loc=jsts.geom.Location.EXTERIOR;}else{var p=e.getCoordinate();loc=this.getLocation(geomi,p,geomGraph);}
label.setAllLocationsIfNull(geomi,loc);}}}};jsts.geomgraph.EdgeEndStar.prototype.computeEdgeEndLabels=function(boundaryNodeRule){for(var it=this.iterator();it.hasNext();){var ee=it.next();ee.computeLabel(boundaryNodeRule);}};jsts.geomgraph.EdgeEndStar.prototype.getLocation=function(geomIndex,p,geom){if(this.ptInAreaLocation[geomIndex]===jsts.geom.Location.NONE){this.ptInAreaLocation[geomIndex]=jsts.algorithm.locate.SimplePointInAreaLocator.locate(p,geom[geomIndex].getGeometry());}
return this.ptInAreaLocation[geomIndex];};jsts.geomgraph.EdgeEndStar.prototype.isAreaLabelsConsistent=function(geomGraph){this.computeEdgeEndLabels(geomGraph.getBoundaryNodeRule());return this.checkAreaLabelsConsistent(0);};jsts.geomgraph.EdgeEndStar.prototype.checkAreaLabelsConsistent=function(geomIndex){var edges=this.getEdges();if(edges.size()<=0)
return true;var lastEdgeIndex=edges.size()-1;var startLabel=edges.get(lastEdgeIndex).getLabel();var startLoc=startLabel.getLocation(geomIndex,jsts.geomgraph.Position.LEFT);jsts.util.Assert.isTrue(startLoc!=jsts.geom.Location.NONE,'Found unlabelled area edge');var currLoc=startLoc;for(var it=this.iterator();it.hasNext();){var e=it.next();var label=e.getLabel();jsts.util.Assert.isTrue(label.isArea(geomIndex),'Found non-area edge');var leftLoc=label.getLocation(geomIndex,jsts.geomgraph.Position.LEFT);var rightLoc=label.getLocation(geomIndex,jsts.geomgraph.Position.RIGHT);if(leftLoc===rightLoc){return false;}
if(rightLoc!==currLoc){return false;}
currLoc=leftLoc;}
return true;};jsts.geomgraph.EdgeEndStar.prototype.propagateSideLabels=function(geomIndex){var startLoc=jsts.geom.Location.NONE;for(var it=this.iterator();it.hasNext();){var e=it.next();var label=e.getLabel();if(label.isArea(geomIndex)&&label.getLocation(geomIndex,jsts.geomgraph.Position.LEFT)!==jsts.geom.Location.NONE)
startLoc=label.getLocation(geomIndex,jsts.geomgraph.Position.LEFT);}
if(startLoc===jsts.geom.Location.NONE)
return;var currLoc=startLoc;for(var it=this.iterator();it.hasNext();){var e=it.next();var label=e.getLabel();if(label.getLocation(geomIndex,jsts.geomgraph.Position.ON)===jsts.geom.Location.NONE)
label.setLocation(geomIndex,jsts.geomgraph.Position.ON,currLoc);if(label.isArea(geomIndex)){var leftLoc=label.getLocation(geomIndex,jsts.geomgraph.Position.LEFT);var rightLoc=label.getLocation(geomIndex,jsts.geomgraph.Position.RIGHT);if(rightLoc!==jsts.geom.Location.NONE){if(rightLoc!==currLoc)
throw new jsts.error.TopologyError('side location conflict',e.getCoordinate());if(leftLoc===jsts.geom.Location.NONE){jsts.util.Assert.shouldNeverReachHere('found single null side (at '+
e.getCoordinate()+')');}
currLoc=leftLoc;}else{jsts.util.Assert.isTrue(label.getLocation(geomIndex,jsts.geomgraph.Position.LEFT)===jsts.geom.Location.NONE,'found single null side');label.setLocation(geomIndex,jsts.geomgraph.Position.RIGHT,currLoc);label.setLocation(geomIndex,jsts.geomgraph.Position.LEFT,currLoc);}}}};jsts.geomgraph.EdgeEndStar.prototype.findIndex=function(eSearch){this.iterator();for(var i=0;i<this.edgeList.size();i++){var e=this.edgeList.get(i);if(e===eSearch)
return i;}
return-1;};jsts.operation.relate.EdgeEndBundleStar=function(){jsts.geomgraph.EdgeEndStar.apply(this,arguments);};jsts.operation.relate.EdgeEndBundleStar.prototype=new jsts.geomgraph.EdgeEndStar();jsts.operation.relate.EdgeEndBundleStar.prototype.insert=function(e){var eb=this.edgeMap.get(e);if(eb===null){eb=new jsts.operation.relate.EdgeEndBundle(e);this.insertEdgeEnd(e,eb);}
else{eb.insert(e);}};jsts.operation.relate.EdgeEndBundleStar.prototype.updateIM=function(im){for(var it=this.iterator();it.hasNext();){var esb=it.next();esb.updateIM(im);}};jsts.index.ArrayListVisitor=function(){this.items=[];};jsts.index.ArrayListVisitor.prototype.visitItem=function(item){this.items.push(item);};jsts.index.ArrayListVisitor.prototype.getItems=function(){return this.items;};jsts.algorithm.distance.DistanceToPoint=function(){};jsts.algorithm.distance.DistanceToPoint.computeDistance=function(geom,pt,ptDist){if(geom instanceof jsts.geom.LineString){jsts.algorithm.distance.DistanceToPoint.computeDistance2(geom,pt,ptDist);}else if(geom instanceof jsts.geom.Polygon){jsts.algorithm.distance.DistanceToPoint.computeDistance4(geom,pt,ptDist);}else if(geom instanceof jsts.geom.GeometryCollection){var gc=geom;for(var i=0;i<gc.getNumGeometries();i++){var g=gc.getGeometryN(i);jsts.algorithm.distance.DistanceToPoint.computeDistance(g,pt,ptDist);}}else{ptDist.setMinimum(geom.getCoordinate(),pt);}};jsts.algorithm.distance.DistanceToPoint.computeDistance2=function(line,pt,ptDist){var tempSegment=new jsts.geom.LineSegment();var coords=line.getCoordinates();for(var i=0;i<coords.length-1;i++){tempSegment.setCoordinates(coords[i],coords[i+1]);var closestPt=tempSegment.closestPoint(pt);ptDist.setMinimum(closestPt,pt);}};jsts.algorithm.distance.DistanceToPoint.computeDistance3=function(segment,pt,ptDist){var closestPt=segment.closestPoint(pt);ptDist.setMinimum(closestPt,pt);};jsts.algorithm.distance.DistanceToPoint.computeDistance4=function(poly,pt,ptDist){jsts.algorithm.distance.DistanceToPoint.computeDistance2(poly.getExteriorRing(),pt,ptDist);for(var i=0;i<poly.getNumInteriorRing();i++){jsts.algorithm.distance.DistanceToPoint.computeDistance2(poly.getInteriorRingN(i),pt,ptDist);}};jsts.index.strtree.ItemBoundable=function(bounds,item){this.bounds=bounds;this.item=item;};jsts.index.strtree.ItemBoundable.prototype=new jsts.index.strtree.Boundable();jsts.index.strtree.ItemBoundable.constructor=jsts.index.strtree.ItemBoundable;jsts.index.strtree.ItemBoundable.prototype.bounds=null;jsts.index.strtree.ItemBoundable.prototype.item=null;jsts.index.strtree.ItemBoundable.prototype.getBounds=function(){return this.bounds;};jsts.index.strtree.ItemBoundable.prototype.getItem=function(){return this.item;};(function(){var ArrayList=javascript.util.ArrayList;var TreeMap=javascript.util.TreeMap;jsts.geomgraph.EdgeList=function(){this.edges=new ArrayList();this.ocaMap=new TreeMap();};jsts.geomgraph.EdgeList.prototype.edges=null;jsts.geomgraph.EdgeList.prototype.ocaMap=null;jsts.geomgraph.EdgeList.prototype.add=function(e){this.edges.add(e);var oca=new jsts.noding.OrientedCoordinateArray(e.getCoordinates());this.ocaMap.put(oca,e);};jsts.geomgraph.EdgeList.prototype.addAll=function(edgeColl){for(var i=edgeColl.iterator();i.hasNext();){this.add(i.next());}};jsts.geomgraph.EdgeList.prototype.getEdges=function(){return this.edges;};jsts.geomgraph.EdgeList.prototype.findEqualEdge=function(e){var oca=new jsts.noding.OrientedCoordinateArray(e.getCoordinates());var matchEdge=this.ocaMap.get(oca);return matchEdge;};jsts.geomgraph.EdgeList.prototype.getEdges=function(){return this.edges;};jsts.geomgraph.EdgeList.prototype.iterator=function(){return this.edges.iterator();};jsts.geomgraph.EdgeList.prototype.get=function(i){return this.edges.get(i);};jsts.geomgraph.EdgeList.prototype.findEdgeIndex=function(e){for(var i=0;i<this.edges.size();i++){if(this.edges.get(i).equals(e))
return i;}
return-1;};})();jsts.operation.IsSimpleOp=function(geom){this.geom=geom;};jsts.operation.IsSimpleOp.prototype.geom=null;jsts.operation.IsSimpleOp.prototype.isClosedEndpointsInInterior=true;jsts.operation.IsSimpleOp.prototype.nonSimpleLocation=null;jsts.operation.IsSimpleOp.prototype.IsSimpleOp=function(geom){this.geom=geom;};jsts.operation.IsSimpleOp.prototype.isSimple=function(){this.nonSimpleLocation=null;if(this.geom instanceof jsts.geom.LineString){return this.isSimpleLinearGeometry(this.geom);}
if(this.geom instanceof jsts.geom.MultiLineString){return this.isSimpleLinearGeometry(this.geom);}
if(this.geom instanceof jsts.geom.MultiPoint){return this.isSimpleMultiPoint(this.geom);}
return true;};jsts.operation.IsSimpleOp.prototype.isSimpleMultiPoint=function(mp){if(mp.isEmpty())
return true;var points=[];for(var i=0;i<mp.getNumGeometries();i++){var pt=mp.getGeometryN(i);var p=pt.getCoordinate();for(var j=0;j<points.length;j++){var point=points[j];if(p.equals2D(point)){this.nonSimpleLocation=p;return false;}}
points.push(p);}
return true;};jsts.operation.IsSimpleOp.prototype.isSimpleLinearGeometry=function(geom){if(geom.isEmpty())
return true;var graph=new jsts.geomgraph.GeometryGraph(0,geom);var li=new jsts.algorithm.RobustLineIntersector();var si=graph.computeSelfNodes(li,true);if(!si.hasIntersection())
return true;if(si.hasProperIntersection()){this.nonSimpleLocation=si.getProperIntersectionPoint();return false;}
if(this.hasNonEndpointIntersection(graph))
return false;if(this.isClosedEndpointsInInterior){if(this.hasClosedEndpointIntersection(graph))
return false;}
return true;};jsts.operation.IsSimpleOp.prototype.hasNonEndpointIntersection=function(graph){for(var i=graph.getEdgeIterator();i.hasNext();){var e=i.next();var maxSegmentIndex=e.getMaximumSegmentIndex();for(var eiIt=e.getEdgeIntersectionList().iterator();eiIt.hasNext();){var ei=eiIt.next();if(!ei.isEndPoint(maxSegmentIndex)){this.nonSimpleLocation=ei.getCoordinate();return true;}}}
return false;};jsts.operation.IsSimpleOp.prototype.hasClosedEndpointIntersection=function(graph){var endPoints=new javascript.util.TreeMap();for(var i=graph.getEdgeIterator();i.hasNext();){var e=i.next();var maxSegmentIndex=e.getMaximumSegmentIndex();var isClosed=e.isClosed();var p0=e.getCoordinate(0);this.addEndpoint(endPoints,p0,isClosed);var p1=e.getCoordinate(e.getNumPoints()-1);this.addEndpoint(endPoints,p1,isClosed);}
for(var i=endPoints.values().iterator();i.hasNext();){var eiInfo=i.next();if(eiInfo.isClosed&&eiInfo.degree!=2){this.nonSimpleLocation=eiInfo.getCoordinate();return true;}}
return false;};jsts.operation.IsSimpleOp.EndpointInfo=function(pt){this.pt=pt;this.isClosed=false;this.degree=0;};jsts.operation.IsSimpleOp.EndpointInfo.prototype.pt=null;jsts.operation.IsSimpleOp.EndpointInfo.prototype.isClosed=null;jsts.operation.IsSimpleOp.EndpointInfo.prototype.degree=null;jsts.operation.IsSimpleOp.EndpointInfo.prototype.getCoordinate=function(){return this.pt;};jsts.operation.IsSimpleOp.EndpointInfo.prototype.addEndpoint=function(isClosed){this.degree++;this.isClosed=this.isClosed||isClosed;};jsts.operation.IsSimpleOp.prototype.addEndpoint=function(endPoints,p,isClosed){var eiInfo=endPoints.get(p);if(eiInfo===null){eiInfo=new jsts.operation.IsSimpleOp.EndpointInfo(p);endPoints.put(p,eiInfo);}
eiInfo.addEndpoint(isClosed);};(function(){var LineStringSnapper=function(){this.snapTolerance=0.0;this.seg=new jsts.geom.LineSegment();this.allowSnappingToSourceVertices=false;this.isClosed=false;this.srcPts=[];if(arguments[0]instanceof jsts.geom.LineString){this.initFromLine.apply(this,arguments);}else{this.initFromPoints.apply(this,arguments);}};LineStringSnapper.prototype.initFromLine=function(srcLine,snapTolerance){this.initFromPoints(srcLine.getCoordinates(),snapTolerance);};LineStringSnapper.prototype.initFromPoints=function(srcPts,snapTolerance){this.srcPts=srcPts;this.isClosed=this.calcIsClosed(srcPts);this.snapTolerance=snapTolerance;};LineStringSnapper.prototype.setAllowSnappingToSourceVertices=function(allowSnappingToSourceVertices){this.allowSnappingToSourceVertices=allowSnappingToSourceVertices;};LineStringSnapper.prototype.calcIsClosed=function(pts){if(pts.length<=1){return false;}
return pts[0].equals(pts[pts.length-1]);};LineStringSnapper.prototype.snapTo=function(snapPts){var coordList=new jsts.geom.CoordinateList(this.srcPts);this.snapVertices(coordList,snapPts);this.snapSegments(coordList,snapPts);return coordList.toCoordinateArray();};LineStringSnapper.prototype.snapVertices=function(srcCoords,snapPts){var end=this.isClosed?srcCoords.size()-1:srcCoords.size(),i=0,srcPt,snapVert;for(i;i<end;i++){srcPt=srcCoords.get(i);snapVert=this.findSnapForVertex(srcPt,snapPts);if(snapVert!==null){srcCoords.set(i,new jsts.geom.Coordinate(snapVert));if(i===0&&this.isClosed)
srcCoords.set(srcCoords.size()-1,new jsts.geom.Coordinate(snapVert));}}};LineStringSnapper.prototype.findSnapForVertex=function(pt,snapPts){var i=0,il=snapPts.length;for(i=0;i<il;i++){if(pt.equals(snapPts[i])){return null;}
if(pt.distance(snapPts[i])<this.snapTolerance){return snapPts[i];}}
return null;};LineStringSnapper.prototype.snapSegments=function(srcCoords,snapPts){if(snapPts.length===0){return;}
var distinctPtCount=snapPts.length,i,snapPt,index;if(snapPts.length>1&&snapPts[0].equals2D(snapPts[snapPts.length-1])){distinctPtCount=snapPts.length-1;}
i=0;for(i;i<distinctPtCount;i++){snapPt=snapPts[i];index=this.findSegmentIndexToSnap(snapPt,srcCoords);if(index>=0){srcCoords.add(index+1,new jsts.geom.Coordinate(snapPt),false);}}};LineStringSnapper.prototype.findSegmentIndexToSnap=function(snapPt,srcCoords){var minDist=Number.MAX_VALUE,snapIndex=-1,i=0,dist;for(i;i<srcCoords.size()-1;i++){this.seg.p0=srcCoords.get(i);this.seg.p1=srcCoords.get(i+1);if(this.seg.p0.equals(snapPt)||this.seg.p1.equals(snapPt)){if(this.allowSnappingToSourceVertices){continue;}else{return-1;}}
dist=this.seg.distance(snapPt);if(dist<this.snapTolerance&&dist<minDist){minDist=dist;snapIndex=i;}}
return snapIndex;};jsts.operation.overlay.snap.LineStringSnapper=LineStringSnapper;})();(function(){var ArrayList=javascript.util.ArrayList;var GeometryComponentFilter=jsts.geom.GeometryComponentFilter;var LineString=jsts.geom.LineString;var EdgeRing=jsts.operation.polygonize.EdgeRing;var PolygonizeGraph=jsts.operation.polygonize.PolygonizeGraph;var Polygonizer=function(){var that=this;var LineStringAdder=function(){};LineStringAdder.prototype=new GeometryComponentFilter();LineStringAdder.prototype.filter=function(g){if(g instanceof LineString)
that.add(g);};this.lineStringAdder=new LineStringAdder();this.dangles=new ArrayList();this.cutEdges=new ArrayList();this.invalidRingLines=new ArrayList();};Polygonizer.prototype.lineStringAdder=null;Polygonizer.prototype.graph=null;Polygonizer.prototype.dangles=null;Polygonizer.prototype.cutEdges=null;Polygonizer.prototype.invalidRingLines=null;Polygonizer.prototype.holeList=null;Polygonizer.prototype.shellList=null;Polygonizer.prototype.polyList=null;Polygonizer.prototype.add=function(geomList){if(geomList instanceof jsts.geom.LineString){return this.add3(geomList);}else if(geomList instanceof jsts.geom.Geometry){return this.add2(geomList);}
for(var i=geomList.iterator();i.hasNext();){var geometry=i.next();this.add2(geometry);}};Polygonizer.prototype.add2=function(g){g.apply(this.lineStringAdder);};Polygonizer.prototype.add3=function(line){if(this.graph==null)
this.graph=new PolygonizeGraph(line.getFactory());this.graph.addEdge(line);};Polygonizer.prototype.getPolygons=function(){this.polygonize();return this.polyList;};Polygonizer.prototype.getDangles=function(){this.polygonize();return this.dangles;};Polygonizer.prototype.getCutEdges=function(){this.polygonize();return this.cutEdges;};Polygonizer.prototype.getInvalidRingLines=function(){this.polygonize();return this.invalidRingLines;};Polygonizer.prototype.polygonize=function(){if(this.polyList!=null)
return;this.polyList=new ArrayList();if(this.graph==null)
return;this.dangles=this.graph.deleteDangles();this.cutEdges=this.graph.deleteCutEdges();var edgeRingList=this.graph.getEdgeRings();var validEdgeRingList=new ArrayList();this.invalidRingLines=new ArrayList();this.findValidRings(edgeRingList,validEdgeRingList,this.invalidRingLines);this.findShellsAndHoles(validEdgeRingList);Polygonizer.assignHolesToShells(this.holeList,this.shellList);this.polyList=new ArrayList();for(var i=this.shellList.iterator();i.hasNext();){var er=i.next();this.polyList.add(er.getPolygon());}};Polygonizer.prototype.findValidRings=function(edgeRingList,validEdgeRingList,invalidRingList){for(var i=edgeRingList.iterator();i.hasNext();){var er=i.next();if(er.isValid())
validEdgeRingList.add(er);else
invalidRingList.add(er.getLineString());}};Polygonizer.prototype.findShellsAndHoles=function(edgeRingList){this.holeList=new ArrayList();this.shellList=new ArrayList();for(var i=edgeRingList.iterator();i.hasNext();){var er=i.next();if(er.isHole())
this.holeList.add(er);else
this.shellList.add(er);}};Polygonizer.assignHolesToShells=function(holeList,shellList){for(var i=holeList.iterator();i.hasNext();){var holeER=i.next();Polygonizer.assignHoleToShell(holeER,shellList);}};Polygonizer.assignHoleToShell=function(holeER,shellList){var shell=EdgeRing.findEdgeRingContaining(holeER,shellList);if(shell!=null)
shell.addHole(holeER.getRing());};jsts.operation.polygonize.Polygonizer=Polygonizer;})();(function(){var ArrayList=javascript.util.ArrayList;var GeometryTransformer=function(){};GeometryTransformer.prototype.inputGeom=null;GeometryTransformer.prototype.factory=null;GeometryTransformer.prototype.pruneEmptyGeometry=true;GeometryTransformer.prototype.preserveGeometryCollectionType=true;GeometryTransformer.prototype.preserveCollections=false;GeometryTransformer.prototype.reserveType=false;GeometryTransformer.prototype.getInputGeometry=function(){return this.inputGeom;};GeometryTransformer.prototype.transform=function(inputGeom){this.inputGeom=inputGeom;this.factory=inputGeom.getFactory();if(inputGeom instanceof jsts.geom.Point)
return this.transformPoint(inputGeom,null);if(inputGeom instanceof jsts.geom.MultiPoint)
return this.transformMultiPoint(inputGeom,null);if(inputGeom instanceof jsts.geom.LinearRing)
return this.transformLinearRing(inputGeom,null);if(inputGeom instanceof jsts.geom.LineString)
return this.transformLineString(inputGeom,null);if(inputGeom instanceof jsts.geom.MultiLineString)
return this.transformMultiLineString(inputGeom,null);if(inputGeom instanceof jsts.geom.Polygon)
return this.transformPolygon(inputGeom,null);if(inputGeom instanceof jsts.geom.MultiPolygon)
return this.transformMultiPolygon(inputGeom,null);if(inputGeom instanceof jsts.geom.GeometryCollection)
return this.transformGeometryCollection(inputGeom,null);throw new jsts.error.IllegalArgumentException('Unknown Geometry subtype: '+
inputGeom.getClass().getName());};GeometryTransformer.prototype.createCoordinateSequence=function(coords){return this.factory.getCoordinateSequenceFactory().create(coords);};GeometryTransformer.prototype.copy=function(seq){return seq.clone();};GeometryTransformer.prototype.transformCoordinates=function(coords,parent){return this.copy(coords);};GeometryTransformer.prototype.transformPoint=function(geom,parent){return this.factory.createPoint(this.transformCoordinates(geom.getCoordinateSequence(),geom));};GeometryTransformer.prototype.transformMultiPoint=function(geom,parent){var transGeomList=new ArrayList();for(var i=0;i<geom.getNumGeometries();i++){var transformGeom=this.transformPoint(geom.getGeometryN(i),geom);if(transformGeom==null)
continue;if(transformGeom.isEmpty())
continue;transGeomList.add(transformGeom);}
return this.factory.buildGeometry(transGeomList);};GeometryTransformer.prototype.transformLinearRing=function(geom,parent){var seq=this.transformCoordinates(geom.getCoordinateSequence(),geom);var seqSize=seq.length;if(seqSize>0&&seqSize<4&&!this.preserveType)
return this.factory.createLineString(seq);return this.factory.createLinearRing(seq);};GeometryTransformer.prototype.transformLineString=function(geom,parent){return this.factory.createLineString(this.transformCoordinates(geom.getCoordinateSequence(),geom));};GeometryTransformer.prototype.transformMultiLineString=function(geom,parent){var transGeomList=new ArrayList();for(var i=0;i<geom.getNumGeometries();i++){var transformGeom=this.transformLineString(geom.getGeometryN(i),geom);if(transformGeom==null)
continue;if(transformGeom.isEmpty())
continue;transGeomList.add(transformGeom);}
return this.factory.buildGeometry(transGeomList);};GeometryTransformer.prototype.transformPolygon=function(geom,parent){var isAllValidLinearRings=true;var shell=this.transformLinearRing(geom.getExteriorRing(),geom);if(shell==null||!(shell instanceof jsts.geom.LinearRing)||shell.isEmpty())
isAllValidLinearRings=false;var holes=new ArrayList();for(var i=0;i<geom.getNumInteriorRing();i++){var hole=this.transformLinearRing(geom.getInteriorRingN(i),geom);if(hole==null||hole.isEmpty()){continue;}
if(!(hole instanceof jsts.geom.LinearRing))
isAllValidLinearRings=false;holes.add(hole);}
if(isAllValidLinearRings)
return this.factory.createPolygon(shell,holes.toArray());else{var components=new ArrayList();if(shell!=null)
components.add(shell);components.addAll(holes);return this.factory.buildGeometry(components);}};GeometryTransformer.prototype.transformMultiPolygon=function(geom,parent){var transGeomList=new ArrayList();for(var i=0;i<geom.getNumGeometries();i++){var transformGeom=this.transformPolygon(geom.getGeometryN(i),geom);if(transformGeom==null)
continue;if(transformGeom.isEmpty())
continue;transGeomList.add(transformGeom);}
return this.factory.buildGeometry(transGeomList);};GeometryTransformer.prototype.transformGeometryCollection=function(geom,parent){var transGeomList=new ArrayList();for(var i=0;i<geom.getNumGeometries();i++){var transformGeom=this.transform(geom.getGeometryN(i));if(transformGeom==null)
continue;if(this.pruneEmptyGeometry&&transformGeom.isEmpty())
continue;transGeomList.add(transformGeom);}
if(this.preserveGeometryCollectionType)
return this.factory.createGeometryCollection(GeometryFactory.toGeometryArray(transGeomList));return this.factory.buildGeometry(transGeomList);};jsts.geom.util.GeometryTransformer=GeometryTransformer;})();(function(){var LineStringSnapper=jsts.operation.overlay.snap.LineStringSnapper;var PrecisionModel=jsts.geom.PrecisionModel;var TreeSet=javascript.util.TreeSet;var SnapTransformer=function(snapTolerance,snapPts,isSelfSnap){this.snapTolerance=snapTolerance;this.snapPts=snapPts;this.isSelfSnap=isSelfSnap||false;};SnapTransformer.prototype=new jsts.geom.util.GeometryTransformer();SnapTransformer.prototype.snapTolerance=null;SnapTransformer.prototype.snapPts=null;SnapTransformer.prototype.isSelfSnap=false;SnapTransformer.prototype.transformCoordinates=function(coords,parent){var srcPts=coords;var newPts=this.snapLine(srcPts,this.snapPts);return newPts;};SnapTransformer.prototype.snapLine=function(srcPts,snapPts){var snapper=new LineStringSnapper(srcPts,this.snapTolerance);snapper.setAllowSnappingToSourceVertices(this.isSelfSnap);return snapper.snapTo(snapPts);};var GeometrySnapper=function(srcGeom){this.srcGeom=srcGeom;};GeometrySnapper.SNAP_PRECISION_FACTOR=1e-9;GeometrySnapper.computeOverlaySnapTolerance=function(g){if(arguments.length===2){return GeometrySnapper.computeOverlaySnapTolerance2.apply(this,arguments);}
var snapTolerance=this.computeSizeBasedSnapTolerance(g);var pm=g.getPrecisionModel();if(pm.getType()==PrecisionModel.FIXED){var fixedSnapTol=(1/pm.getScale())*2/1.415;if(fixedSnapTol>snapTolerance)
snapTolerance=fixedSnapTol;}
return snapTolerance;};GeometrySnapper.computeSizeBasedSnapTolerance=function(g){var env=g.getEnvelopeInternal();var minDimension=Math.min(env.getHeight(),env.getWidth());var snapTol=minDimension*GeometrySnapper.SNAP_PRECISION_FACTOR;return snapTol;};GeometrySnapper.computeOverlaySnapTolerance2=function(g0,g1){return Math.min(this.computeOverlaySnapTolerance(g0),this.computeOverlaySnapTolerance(g1));};GeometrySnapper.snap=function(g0,g1,snapTolerance){var snapGeom=[];var snapper0=new GeometrySnapper(g0);snapGeom[0]=snapper0.snapTo(g1,snapTolerance);var snapper1=new GeometrySnapper(g1);snapGeom[1]=snapper1.snapTo(snapGeom[0],snapTolerance);return snapGeom;};GeometrySnapper.snapToSelf=function(g0,snapTolerance,cleanResult){var snapper0=new GeometrySnapper(g0);return snapper0.snapToSelf(snapTolerance,cleanResult);};GeometrySnapper.prototype.srcGeom=null;GeometrySnapper.prototype.snapTo=function(snapGeom,snapTolerance){var snapPts=this.extractTargetCoordinates(snapGeom);var snapTrans=new SnapTransformer(snapTolerance,snapPts);return snapTrans.transform(this.srcGeom);};GeometrySnapper.prototype.snapToSelf=function(snapTolerance,cleanResult){var snapPts=this.extractTargetCoordinates(srcGeom);var snapTrans=new SnapTransformer(snapTolerance,snapPts,true);var snappedGeom=snapTrans.transform(srcGeom);var result=snappedGeom;if(cleanResult&&result instanceof Polygonal){result=snappedGeom.buffer(0);}
return result;};GeometrySnapper.prototype.extractTargetCoordinates=function(g){var ptSet=new TreeSet();var pts=g.getCoordinates();for(var i=0;i<pts.length;i++){ptSet.add(pts[i]);}
return ptSet.toArray();};GeometrySnapper.prototype.computeSnapTolerance=function(ringPts){var minSegLen=this.computeMinimumSegmentLength(ringPts);var snapTol=minSegLen/10;return snapTol;};GeometrySnapper.prototype.computeMinimumSegmentLength=function(pts){var minSegLen=Number.MAX_VALUE;for(var i=0;i<pts.length-1;i++){var segLen=pts[i].distance(pts[i+1]);if(segLen<minSegLen)
minSegLen=segLen;}
return minSegLen;};jsts.operation.overlay.snap.GeometrySnapper=GeometrySnapper;})();jsts.algorithm.PointLocator=function(boundaryRule){this.boundaryRule=boundaryRule?boundaryRule:jsts.algorithm.BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;};jsts.algorithm.PointLocator.prototype.boundaryRule=null;jsts.algorithm.PointLocator.prototype.isIn=null;jsts.algorithm.PointLocator.prototype.numBoundaries=null;jsts.algorithm.PointLocator.prototype.intersects=function(p,geom){return this.locate(p,geom)!==jsts.geom.Location.EXTERIOR;};jsts.algorithm.PointLocator.prototype.locate=function(p,geom){if(geom.isEmpty())
return jsts.geom.Location.EXTERIOR;if(geom instanceof jsts.geom.Point){return this.locate2(p,geom);}else if(geom instanceof jsts.geom.LineString){return this.locate3(p,geom);}else if(geom instanceof jsts.geom.Polygon){return this.locate4(p,geom);}
this.isIn=false;this.numBoundaries=0;this.computeLocation(p,geom);if(this.boundaryRule.isInBoundary(this.numBoundaries))
return jsts.geom.Location.BOUNDARY;if(this.numBoundaries>0||this.isIn)
return jsts.geom.Location.INTERIOR;return jsts.geom.Location.EXTERIOR;};jsts.algorithm.PointLocator.prototype.computeLocation=function(p,geom){if(geom instanceof jsts.geom.Point||geom instanceof jsts.geom.LineString||geom instanceof jsts.geom.Polygon){this.updateLocationInfo(this.locate(p,geom));}else if(geom instanceof jsts.geom.MultiLineString){var ml=geom;for(var i=0;i<ml.getNumGeometries();i++){var l=ml.getGeometryN(i);this.updateLocationInfo(this.locate(p,l));}}else if(geom instanceof jsts.geom.MultiPolygon){var mpoly=geom;for(var i=0;i<mpoly.getNumGeometries();i++){var poly=mpoly.getGeometryN(i);this.updateLocationInfo(this.locate(p,poly));}}else if(geom instanceof jsts.geom.MultiPoint||geom instanceof jsts.geom.GeometryCollection){for(var i=0;i<geom.getNumGeometries();i++){var part=geom.getGeometryN(i);if(part!==geom){this.computeLocation(p,part);}}}};jsts.algorithm.PointLocator.prototype.updateLocationInfo=function(loc){if(loc===jsts.geom.Location.INTERIOR)
this.isIn=true;if(loc===jsts.geom.Location.BOUNDARY)
this.numBoundaries++;};jsts.algorithm.PointLocator.prototype.locate2=function(p,pt){var ptCoord=pt.getCoordinate();if(ptCoord.equals2D(p))
return jsts.geom.Location.INTERIOR;return jsts.geom.Location.EXTERIOR;};jsts.algorithm.PointLocator.prototype.locate3=function(p,l){if(!l.getEnvelopeInternal().intersects(p))
return jsts.geom.Location.EXTERIOR;var pt=l.getCoordinates();if(!l.isClosed()){if(p.equals(pt[0])||p.equals(pt[pt.length-1])){return jsts.geom.Location.BOUNDARY;}}
if(jsts.algorithm.CGAlgorithms.isOnLine(p,pt))
return jsts.geom.Location.INTERIOR;return jsts.geom.Location.EXTERIOR;};jsts.algorithm.PointLocator.prototype.locateInPolygonRing=function(p,ring){if(!ring.getEnvelopeInternal().intersects(p))
return jsts.geom.Location.EXTERIOR;return jsts.algorithm.CGAlgorithms.locatePointInRing(p,ring.getCoordinates());};jsts.algorithm.PointLocator.prototype.locate4=function(p,poly){if(poly.isEmpty())
return jsts.geom.Location.EXTERIOR;var shell=poly.getExteriorRing();var shellLoc=this.locateInPolygonRing(p,shell);if(shellLoc===jsts.geom.Location.EXTERIOR)
return jsts.geom.Location.EXTERIOR;if(shellLoc===jsts.geom.Location.BOUNDARY)
return jsts.geom.Location.BOUNDARY;for(var i=0;i<poly.getNumInteriorRing();i++){var hole=poly.getInteriorRingN(i);var holeLoc=this.locateInPolygonRing(p,hole);if(holeLoc===jsts.geom.Location.INTERIOR)
return jsts.geom.Location.EXTERIOR;if(holeLoc===jsts.geom.Location.BOUNDARY)
return jsts.geom.Location.BOUNDARY;}
return jsts.geom.Location.INTERIOR;};(function(){var Location=jsts.geom.Location;var ArrayList=javascript.util.ArrayList;var TreeMap=javascript.util.TreeMap;jsts.geomgraph.NodeMap=function(nodeFactory){this.nodeMap=new TreeMap();this.nodeFact=nodeFactory;};jsts.geomgraph.NodeMap.prototype.nodeMap=null;jsts.geomgraph.NodeMap.prototype.nodeFact=null;jsts.geomgraph.NodeMap.prototype.addNode=function(arg){var node,coord;if(arg instanceof jsts.geom.Coordinate){coord=arg;node=this.nodeMap.get(coord);if(node===null){node=this.nodeFact.createNode(coord);this.nodeMap.put(coord,node);}
return node;}else if(arg instanceof jsts.geomgraph.Node){var n=arg;coord=n.getCoordinate();node=this.nodeMap.get(coord);if(node===null){this.nodeMap.put(coord,n);return n;}
node.mergeLabel(n);return node;}};jsts.geomgraph.NodeMap.prototype.add=function(e){var p=e.getCoordinate();var n=this.addNode(p);n.add(e);};jsts.geomgraph.NodeMap.prototype.find=function(coord){return this.nodeMap.get(coord);};jsts.geomgraph.NodeMap.prototype.values=function(){return this.nodeMap.values();};jsts.geomgraph.NodeMap.prototype.iterator=function(){return this.values().iterator();};jsts.geomgraph.NodeMap.prototype.getBoundaryNodes=function(geomIndex){var bdyNodes=new ArrayList();for(var i=this.iterator();i.hasNext();){var node=i.next();if(node.getLabel().getLocation(geomIndex)===Location.BOUNDARY){bdyNodes.add(node);}}
return bdyNodes;};})();(function(){var ArrayList=javascript.util.ArrayList;jsts.geomgraph.PlanarGraph=function(nodeFactory){this.edges=new ArrayList();this.edgeEndList=new ArrayList();this.nodes=new jsts.geomgraph.NodeMap(nodeFactory||new jsts.geomgraph.NodeFactory());};jsts.geomgraph.PlanarGraph.prototype.edges=null;jsts.geomgraph.PlanarGraph.prototype.nodes=null;jsts.geomgraph.PlanarGraph.prototype.edgeEndList=null;jsts.geomgraph.PlanarGraph.linkResultDirectedEdges=function(nodes){for(var nodeit=nodes.iterator();nodeit.hasNext();){var node=nodeit.next();node.getEdges().linkResultDirectedEdges();}};jsts.geomgraph.PlanarGraph.prototype.getEdgeIterator=function(){return this.edges.iterator();};jsts.geomgraph.PlanarGraph.prototype.getEdgeEnds=function(){return this.edgeEndList;};jsts.geomgraph.PlanarGraph.prototype.isBoundaryNode=function(geomIndex,coord){var node=this.nodes.find(coord);if(node===null)
return false;var label=node.getLabel();if(label!==null&&label.getLocation(geomIndex)===jsts.geom.Location.BOUNDARY)
return true;return false;};jsts.geomgraph.PlanarGraph.prototype.insertEdge=function(e){this.edges.add(e);};jsts.geomgraph.PlanarGraph.prototype.add=function(e){this.nodes.add(e);this.edgeEndList.add(e);};jsts.geomgraph.PlanarGraph.prototype.getNodeIterator=function(){return this.nodes.iterator();};jsts.geomgraph.PlanarGraph.prototype.getNodes=function(){return this.nodes.values();};jsts.geomgraph.PlanarGraph.prototype.addNode=function(node){return this.nodes.addNode(node);};jsts.geomgraph.PlanarGraph.prototype.addEdges=function(edgesToAdd){for(var it=edgesToAdd.iterator();it.hasNext();){var e=it.next();this.edges.add(e);var de1=new jsts.geomgraph.DirectedEdge(e,true);var de2=new jsts.geomgraph.DirectedEdge(e,false);de1.setSym(de2);de2.setSym(de1);this.add(de1);this.add(de2);}};jsts.geomgraph.PlanarGraph.prototype.linkResultDirectedEdges=function(){for(var nodeit=this.nodes.iterator();nodeit.hasNext();){var node=nodeit.next();node.getEdges().linkResultDirectedEdges();}};jsts.geomgraph.PlanarGraph.prototype.findEdgeInSameDirection=function(p0,p1){var i=0,il=this.edges.size(),e,eCoord;for(i;i<il;i++){e=this.edges.get(i);eCoord=e.getCoordinates();if(this.matchInSameDirection(p0,p1,eCoord[0],eCoord[1])){return e;}
if(this.matchInSameDirection(p0,p1,eCoord[eCoord.length-1],eCoord[eCoord.length-2])){return e;}}
return null;};jsts.geomgraph.PlanarGraph.prototype.matchInSameDirection=function(p0,p1,ep0,ep1){if(!p0.equals(ep0)){return false;}
if(jsts.algorithm.CGAlgorithms.computeOrientation(p0,p1,ep1)===jsts.algorithm.CGAlgorithms.COLLINEAR&&jsts.geomgraph.Quadrant.quadrant(p0,p1)===jsts.geomgraph.Quadrant.quadrant(ep0,ep1)){return true;}
return false;};jsts.geomgraph.PlanarGraph.prototype.findEdgeEnd=function(e){for(var i=this.getEdgeEnds().iterator();i.hasNext();){var ee=i.next();if(ee.getEdge()===e){return ee;}}
return null;};})();jsts.noding.SegmentIntersector=function(){};jsts.noding.SegmentIntersector.prototype.processIntersections=jsts.abstractFunc;jsts.noding.SegmentIntersector.prototype.isDone=jsts.abstractFunc;(function(){var SegmentIntersector=jsts.noding.SegmentIntersector;var ArrayList=javascript.util.ArrayList;jsts.noding.InteriorIntersectionFinder=function(li){this.li=li;this.intersections=new ArrayList();this.interiorIntersection=null;};jsts.noding.InteriorIntersectionFinder.prototype=new SegmentIntersector();jsts.noding.InteriorIntersectionFinder.constructor=jsts.noding.InteriorIntersectionFinder;jsts.noding.InteriorIntersectionFinder.prototype.findAllIntersections=false;jsts.noding.InteriorIntersectionFinder.prototype.isCheckEndSegmentsOnly=false;jsts.noding.InteriorIntersectionFinder.prototype.li=null;jsts.noding.InteriorIntersectionFinder.prototype.interiorIntersection=null;jsts.noding.InteriorIntersectionFinder.prototype.intSegments=null;jsts.noding.InteriorIntersectionFinder.prototype.intersections=null;jsts.noding.InteriorIntersectionFinder.prototype.setFindAllIntersections=function(findAllIntersections){this.findAllIntersections=findAllIntersections;};jsts.noding.InteriorIntersectionFinder.prototype.getIntersections=function(){return intersections;};jsts.noding.InteriorIntersectionFinder.prototype.setCheckEndSegmentsOnly=function(isCheckEndSegmentsOnly){this.isCheckEndSegmentsOnly=isCheckEndSegmentsOnly;}
jsts.noding.InteriorIntersectionFinder.prototype.hasIntersection=function(){return this.interiorIntersection!=null;};jsts.noding.InteriorIntersectionFinder.prototype.getInteriorIntersection=function(){return this.interiorIntersection;};jsts.noding.InteriorIntersectionFinder.prototype.getIntersectionSegments=function(){return this.intSegments;};jsts.noding.InteriorIntersectionFinder.prototype.processIntersections=function(e0,segIndex0,e1,segIndex1){if(this.hasIntersection())
return;if(e0==e1&&segIndex0==segIndex1)
return;if(this.isCheckEndSegmentsOnly){var isEndSegPresent=this.isEndSegment(e0,segIndex0)||isEndSegment(e1,segIndex1);if(!isEndSegPresent)
return;}
var p00=e0.getCoordinates()[segIndex0];var p01=e0.getCoordinates()[segIndex0+1];var p10=e1.getCoordinates()[segIndex1];var p11=e1.getCoordinates()[segIndex1+1];this.li.computeIntersection(p00,p01,p10,p11);if(this.li.hasIntersection()){if(this.li.isInteriorIntersection()){this.intSegments=[];this.intSegments[0]=p00;this.intSegments[1]=p01;this.intSegments[2]=p10;this.intSegments[3]=p11;this.interiorIntersection=this.li.getIntersection(0);this.intersections.add(this.interiorIntersection);}}};jsts.noding.InteriorIntersectionFinder.prototype.isEndSegment=function(segStr,index){if(index==0)
return true;if(index>=segStr.size()-2)
return true;return false;};jsts.noding.InteriorIntersectionFinder.prototype.isDone=function(){if(this.findAllIntersections)
return false;return this.interiorIntersection!=null;};})();(function(){var RobustLineIntersector=jsts.algorithm.RobustLineIntersector;var InteriorIntersectionFinder=jsts.noding.InteriorIntersectionFinder;var MCIndexNoder=jsts.noding.MCIndexNoder;jsts.noding.FastNodingValidator=function(segStrings){this.li=new RobustLineIntersector();this.segStrings=segStrings;};jsts.noding.FastNodingValidator.prototype.li=null;jsts.noding.FastNodingValidator.prototype.segStrings=null;jsts.noding.FastNodingValidator.prototype.findAllIntersections=false;jsts.noding.FastNodingValidator.prototype.segInt=null;jsts.noding.FastNodingValidator.prototype._isValid=true;jsts.noding.FastNodingValidator.prototype.setFindAllIntersections=function(findAllIntersections){this.findAllIntersections=findAllIntersections;};jsts.noding.FastNodingValidator.prototype.getIntersections=function(){return segInt.getIntersections();};jsts.noding.FastNodingValidator.prototype.isValid=function(){this.execute();return this._isValid;};jsts.noding.FastNodingValidator.prototype.getErrorMessage=function(){if(this._isValid)
return'no intersections found';var intSegs=this.segInt.getIntersectionSegments();return'found non-noded intersection between '+
jsts.io.WKTWriter.toLineString(intSegs[0],intSegs[1])+' and '+
jsts.io.WKTWriter.toLineString(intSegs[2],intSegs[3]);};jsts.noding.FastNodingValidator.prototype.checkValid=function(){this.execute();if(!this._isValid)
throw new jsts.error.TopologyError(this.getErrorMessage(),this.segInt.getInteriorIntersection());};jsts.noding.FastNodingValidator.prototype.execute=function(){if(this.segInt!=null)
return;this.checkInteriorIntersections();};jsts.noding.FastNodingValidator.prototype.checkInteriorIntersections=function(){this._isValid=true;this.segInt=new InteriorIntersectionFinder(this.li);this.segInt.setFindAllIntersections(this.findAllIntersections);var noder=new MCIndexNoder();noder.setSegmentIntersector(this.segInt);noder.computeNodes(this.segStrings);if(this.segInt.hasIntersection()){this._isValid=false;return;}};})();(function(){jsts.noding.BasicSegmentString=function(pts,data){this.pts=pts;this.data=data;};jsts.noding.BasicSegmentString.prototype=new jsts.noding.SegmentString();jsts.noding.BasicSegmentString.prototype.pts=null;jsts.noding.BasicSegmentString.prototype.data=null;jsts.noding.BasicSegmentString.prototype.getData=function(){return this.data;}
jsts.noding.BasicSegmentString.prototype.setData=function(data){this.data=data;};jsts.noding.BasicSegmentString.prototype.size=function(){return this.pts.length;};jsts.noding.BasicSegmentString.prototype.getCoordinate=function(i){return this.pts[i];};jsts.noding.BasicSegmentString.prototype.getCoordinates=function(){return this.pts;};jsts.noding.BasicSegmentString.prototype.isClosed=function(){return this.pts[0].equals(this.pts[this.pts.length-1]);};jsts.noding.BasicSegmentString.prototype.getSegmentOctant=function(index){if(index==this.pts.length-1)
return-1;return jsts.noding.Octant.octant(this.getCoordinate(index),this.getCoordinate(index+1));};})();(function(){var FastNodingValidator=jsts.noding.FastNodingValidator;var BasicSegmentString=jsts.noding.BasicSegmentString;var ArrayList=javascript.util.ArrayList;jsts.geomgraph.EdgeNodingValidator=function(edges){this.nv=new FastNodingValidator(jsts.geomgraph.EdgeNodingValidator.toSegmentStrings(edges));};jsts.geomgraph.EdgeNodingValidator.checkValid=function(edges){var validator=new jsts.geomgraph.EdgeNodingValidator(edges);validator.checkValid();};jsts.geomgraph.EdgeNodingValidator.toSegmentStrings=function(edges){var segStrings=new ArrayList();for(var i=edges.iterator();i.hasNext();){var e=i.next();segStrings.add(new BasicSegmentString(e.getCoordinates(),e));}
return segStrings;};jsts.geomgraph.EdgeNodingValidator.prototype.nv=null;jsts.geomgraph.EdgeNodingValidator.prototype.checkValid=function(){this.nv.checkValid();};})();jsts.operation.GeometryGraphOperation=function(g0,g1,boundaryNodeRule){this.li=new jsts.algorithm.RobustLineIntersector();this.arg=[];if(g0===undefined){return;}
if(g1===undefined){this.setComputationPrecision(g0.getPrecisionModel());this.arg[0]=new jsts.geomgraph.GeometryGraph(0,g0);return;}
boundaryNodeRule=boundaryNodeRule||jsts.algorithm.BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;if(g0.getPrecisionModel().compareTo(g1.getPrecisionModel())>=0)
this.setComputationPrecision(g0.getPrecisionModel());else
this.setComputationPrecision(g1.getPrecisionModel());this.arg[0]=new jsts.geomgraph.GeometryGraph(0,g0,boundaryNodeRule);this.arg[1]=new jsts.geomgraph.GeometryGraph(1,g1,boundaryNodeRule);};jsts.operation.GeometryGraphOperation.prototype.li=null;jsts.operation.GeometryGraphOperation.prototype.resultPrecisionModel=null;jsts.operation.GeometryGraphOperation.prototype.arg=null;jsts.operation.GeometryGraphOperation.prototype.getArgGeometry=function(i){return arg[i].getGeometry();};jsts.operation.GeometryGraphOperation.prototype.setComputationPrecision=function(pm){this.resultPrecisionModel=pm;this.li.setPrecisionModel(this.resultPrecisionModel);};jsts.operation.overlay.OverlayNodeFactory=function(){};jsts.operation.overlay.OverlayNodeFactory.prototype=new jsts.geomgraph.NodeFactory();jsts.operation.overlay.OverlayNodeFactory.constructor=jsts.operation.overlay.OverlayNodeFactory;jsts.operation.overlay.OverlayNodeFactory.prototype.createNode=function(coord){return new jsts.geomgraph.Node(coord,new jsts.geomgraph.DirectedEdgeStar());};jsts.operation.overlay.PolygonBuilder=function(geometryFactory){this.shellList=[];this.geometryFactory=geometryFactory;};jsts.operation.overlay.PolygonBuilder.prototype.geometryFactory=null;jsts.operation.overlay.PolygonBuilder.prototype.shellList=null;jsts.operation.overlay.PolygonBuilder.prototype.add=function(graph){if(arguments.length===2){this.add2.apply(this,arguments);return;}
this.add2(graph.getEdgeEnds(),graph.getNodes());};jsts.operation.overlay.PolygonBuilder.prototype.add2=function(dirEdges,nodes){jsts.geomgraph.PlanarGraph.linkResultDirectedEdges(nodes);var maxEdgeRings=this.buildMaximalEdgeRings(dirEdges);var freeHoleList=[];var edgeRings=this.buildMinimalEdgeRings(maxEdgeRings,this.shellList,freeHoleList);this.sortShellsAndHoles(edgeRings,this.shellList,freeHoleList);this.placeFreeHoles(this.shellList,freeHoleList);};jsts.operation.overlay.PolygonBuilder.prototype.getPolygons=function(){var resultPolyList=this.computePolygons(this.shellList);return resultPolyList;};jsts.operation.overlay.PolygonBuilder.prototype.buildMaximalEdgeRings=function(dirEdges){var maxEdgeRings=[];for(var it=dirEdges.iterator();it.hasNext();){var de=it.next();if(de.isInResult()&&de.getLabel().isArea()){if(de.getEdgeRing()==null){var er=new jsts.operation.overlay.MaximalEdgeRing(de,this.geometryFactory);maxEdgeRings.push(er);er.setInResult();}}}
return maxEdgeRings;};jsts.operation.overlay.PolygonBuilder.prototype.buildMinimalEdgeRings=function(maxEdgeRings,shellList,freeHoleList){var edgeRings=[];for(var i=0;i<maxEdgeRings.length;i++){var er=maxEdgeRings[i];if(er.getMaxNodeDegree()>2){er.linkDirectedEdgesForMinimalEdgeRings();var minEdgeRings=er.buildMinimalRings();var shell=this.findShell(minEdgeRings);if(shell!==null){this.placePolygonHoles(shell,minEdgeRings);shellList.push(shell);}else{freeHoleList=freeHoleList.concat(minEdgeRings);}}else{edgeRings.push(er);}}
return edgeRings;};jsts.operation.overlay.PolygonBuilder.prototype.findShell=function(minEdgeRings){var shellCount=0;var shell=null;for(var i=0;i<minEdgeRings.length;i++){var er=minEdgeRings[i];if(!er.isHole()){shell=er;shellCount++;}}
jsts.util.Assert.isTrue(shellCount<=1,'found two shells in MinimalEdgeRing list');return shell;};jsts.operation.overlay.PolygonBuilder.prototype.placePolygonHoles=function(shell,minEdgeRings){for(var i=0;i<minEdgeRings.length;i++){var er=minEdgeRings[i];if(er.isHole()){er.setShell(shell);}}};jsts.operation.overlay.PolygonBuilder.prototype.sortShellsAndHoles=function(edgeRings,shellList,freeHoleList){for(var i=0;i<edgeRings.length;i++){var er=edgeRings[i];if(er.isHole()){freeHoleList.push(er);}else{shellList.push(er);}}};jsts.operation.overlay.PolygonBuilder.prototype.placeFreeHoles=function(shellList,freeHoleList){for(var i=0;i<freeHoleList.length;i++){var hole=freeHoleList[i];if(hole.getShell()==null){var shell=this.findEdgeRingContaining(hole,shellList);if(shell===null)
throw new jsts.error.TopologyError('unable to assign hole to a shell',hole.getCoordinate(0));hole.setShell(shell);}}};jsts.operation.overlay.PolygonBuilder.prototype.findEdgeRingContaining=function(testEr,shellList){var testRing=testEr.getLinearRing();var testEnv=testRing.getEnvelopeInternal();var testPt=testRing.getCoordinateN(0);var minShell=null;var minEnv=null;for(var i=0;i<shellList.length;i++){var tryShell=shellList[i];var tryRing=tryShell.getLinearRing();var tryEnv=tryRing.getEnvelopeInternal();if(minShell!==null)
minEnv=minShell.getLinearRing().getEnvelopeInternal();var isContained=false;if(tryEnv.contains(testEnv)&&jsts.algorithm.CGAlgorithms.isPointInRing(testPt,tryRing.getCoordinates()))
isContained=true;if(isContained){if(minShell==null||minEnv.contains(tryEnv)){minShell=tryShell;}}}
return minShell;};jsts.operation.overlay.PolygonBuilder.prototype.computePolygons=function(shellList){var resultPolyList=new javascript.util.ArrayList();for(var i=0;i<shellList.length;i++){var er=shellList[i];var poly=er.toPolygon(this.geometryFactory);resultPolyList.add(poly);}
return resultPolyList;};jsts.operation.overlay.PolygonBuilder.prototype.containsPoint=function(p){for(var i=0;i<this.shellList.length;i++){var er=this.shellList[i];if(er.containsPoint(p))
return true;}
return false;};(function(){var Assert=jsts.util.Assert;var ArrayList=javascript.util.ArrayList;var LineBuilder=function(op,geometryFactory,ptLocator){this.lineEdgesList=new ArrayList();this.resultLineList=new ArrayList();this.op=op;this.geometryFactory=geometryFactory;this.ptLocator=ptLocator;};LineBuilder.prototype.op=null;LineBuilder.prototype.geometryFactory=null;LineBuilder.prototype.ptLocator=null;LineBuilder.prototype.lineEdgesList=null;LineBuilder.prototype.resultLineList=null;LineBuilder.prototype.build=function(opCode){this.findCoveredLineEdges();this.collectLines(opCode);this.buildLines(opCode);return this.resultLineList;};LineBuilder.prototype.findCoveredLineEdges=function(){for(var nodeit=this.op.getGraph().getNodes().iterator();nodeit.hasNext();){var node=nodeit.next();node.getEdges().findCoveredLineEdges();}
for(var it=this.op.getGraph().getEdgeEnds().iterator();it.hasNext();){var de=it.next();var e=de.getEdge();if(de.isLineEdge()&&!e.isCoveredSet()){var isCovered=this.op.isCoveredByA(de.getCoordinate());e.setCovered(isCovered);}}};LineBuilder.prototype.collectLines=function(opCode){for(var it=this.op.getGraph().getEdgeEnds().iterator();it.hasNext();){var de=it.next();this.collectLineEdge(de,opCode,this.lineEdgesList);this.collectBoundaryTouchEdge(de,opCode,this.lineEdgesList);}};LineBuilder.prototype.collectLineEdge=function(de,opCode,edges){var label=de.getLabel();var e=de.getEdge();if(de.isLineEdge()){if(!de.isVisited()&&jsts.operation.overlay.OverlayOp.isResultOfOp(label,opCode)&&!e.isCovered()){edges.add(e);de.setVisitedEdge(true);}}};LineBuilder.prototype.collectBoundaryTouchEdge=function(de,opCode,edges){var label=de.getLabel();if(de.isLineEdge())
return;if(de.isVisited())
return;if(de.isInteriorAreaEdge())
return;if(de.getEdge().isInResult())
return;Assert.isTrue(!(de.isInResult()||de.getSym().isInResult())||!de.getEdge().isInResult());if(jsts.operation.overlay.OverlayOp.isResultOfOp(label,opCode)&&opCode===jsts.operation.overlay.OverlayOp.INTERSECTION){edges.add(de.getEdge());de.setVisitedEdge(true);}};LineBuilder.prototype.buildLines=function(opCode){for(var it=this.lineEdgesList.iterator();it.hasNext();){var e=it.next();var label=e.getLabel();var line=this.geometryFactory.createLineString(e.getCoordinates());this.resultLineList.add(line);e.setInResult(true);}};LineBuilder.prototype.labelIsolatedLines=function(edgesList){for(var it=edgesList.iterator();it.hasNext();){var e=it.next();var label=e.getLabel();if(e.isIsolated()){if(label.isNull(0))
this.labelIsolatedLine(e,0);else
this.labelIsolatedLine(e,1);}}};LineBuilder.prototype.labelIsolatedLine=function(e,targetIndex){var loc=ptLocator.locate(e.getCoordinate(),op.getArgGeometry(targetIndex));e.getLabel().setLocation(targetIndex,loc);};jsts.operation.overlay.LineBuilder=LineBuilder;})();(function(){var ArrayList=javascript.util.ArrayList;var PointBuilder=function(op,geometryFactory,ptLocator){this.resultPointList=new ArrayList();this.op=op;this.geometryFactory=geometryFactory;};PointBuilder.prototype.op=null;PointBuilder.prototype.geometryFactory=null;PointBuilder.prototype.resultPointList=null;PointBuilder.prototype.build=function(opCode){this.extractNonCoveredResultNodes(opCode);return this.resultPointList;};PointBuilder.prototype.extractNonCoveredResultNodes=function(opCode){for(var nodeit=this.op.getGraph().getNodes().iterator();nodeit.hasNext();){var n=nodeit.next();if(n.isInResult())
continue;if(n.isIncidentEdgeInResult())
continue;if(n.getEdges().getDegree()===0||opCode===jsts.operation.overlay.OverlayOp.INTERSECTION){var label=n.getLabel();if(jsts.operation.overlay.OverlayOp.isResultOfOp(label,opCode)){this.filterCoveredNodeToPoint(n);}}}};PointBuilder.prototype.filterCoveredNodeToPoint=function(n){var coord=n.getCoordinate();if(!this.op.isCoveredByLA(coord)){var pt=this.geometryFactory.createPoint(coord);this.resultPointList.add(pt);}};jsts.operation.overlay.PointBuilder=PointBuilder;})();(function(){var PointLocator=jsts.algorithm.PointLocator;var Location=jsts.geom.Location;var EdgeList=jsts.geomgraph.EdgeList;var Label=jsts.geomgraph.Label;var PlanarGraph=jsts.geomgraph.PlanarGraph;var Position=jsts.geomgraph.Position;var EdgeNodingValidator=jsts.geomgraph.EdgeNodingValidator;var GeometryGraphOperation=jsts.operation.GeometryGraphOperation;var OverlayNodeFactory=jsts.operation.overlay.OverlayNodeFactory;var PolygonBuilder=jsts.operation.overlay.PolygonBuilder;var LineBuilder=jsts.operation.overlay.LineBuilder;var PointBuilder=jsts.operation.overlay.PointBuilder;var Assert=jsts.util.Assert;var ArrayList=javascript.util.ArrayList;jsts.operation.overlay.OverlayOp=function(g0,g1){this.ptLocator=new PointLocator();this.edgeList=new EdgeList();this.resultPolyList=new ArrayList();this.resultLineList=new ArrayList();this.resultPointList=new ArrayList();GeometryGraphOperation.call(this,g0,g1);this.graph=new PlanarGraph(new OverlayNodeFactory());this.geomFact=g0.getFactory();};jsts.operation.overlay.OverlayOp.prototype=new GeometryGraphOperation();jsts.operation.overlay.OverlayOp.constructor=jsts.operation.overlay.OverlayOp;jsts.operation.overlay.OverlayOp.INTERSECTION=1;jsts.operation.overlay.OverlayOp.UNION=2;jsts.operation.overlay.OverlayOp.DIFFERENCE=3;jsts.operation.overlay.OverlayOp.SYMDIFFERENCE=4;jsts.operation.overlay.OverlayOp.overlayOp=function(geom0,geom1,opCode){var gov=new jsts.operation.overlay.OverlayOp(geom0,geom1);var geomOv=gov.getResultGeometry(opCode);return geomOv;}
jsts.operation.overlay.OverlayOp.isResultOfOp=function(label,opCode){if(arguments.length===3){return jsts.operation.overlay.OverlayOp.isResultOfOp2.apply(this,arguments);}
var loc0=label.getLocation(0);var loc1=label.getLocation(1);return jsts.operation.overlay.OverlayOp.isResultOfOp2(loc0,loc1,opCode);}
jsts.operation.overlay.OverlayOp.isResultOfOp2=function(loc0,loc1,opCode){if(loc0==Location.BOUNDARY)
loc0=Location.INTERIOR;if(loc1==Location.BOUNDARY)
loc1=Location.INTERIOR;switch(opCode){case jsts.operation.overlay.OverlayOp.INTERSECTION:return loc0==Location.INTERIOR&&loc1==Location.INTERIOR;case jsts.operation.overlay.OverlayOp.UNION:return loc0==Location.INTERIOR||loc1==Location.INTERIOR;case jsts.operation.overlay.OverlayOp.DIFFERENCE:return loc0==Location.INTERIOR&&loc1!=Location.INTERIOR;case jsts.operation.overlay.OverlayOp.SYMDIFFERENCE:return(loc0==Location.INTERIOR&&loc1!=Location.INTERIOR)||(loc0!=Location.INTERIOR&&loc1==Location.INTERIOR);}
return false;}
jsts.operation.overlay.OverlayOp.prototype.ptLocator=null;jsts.operation.overlay.OverlayOp.prototype.geomFact=null;jsts.operation.overlay.OverlayOp.prototype.resultGeom=null;jsts.operation.overlay.OverlayOp.prototype.graph=null;jsts.operation.overlay.OverlayOp.prototype.edgeList=null;jsts.operation.overlay.OverlayOp.prototype.resultPolyList=null;jsts.operation.overlay.OverlayOp.prototype.resultLineList=null;jsts.operation.overlay.OverlayOp.prototype.resultPointList=null;jsts.operation.overlay.OverlayOp.prototype.getResultGeometry=function(funcCode){this.computeOverlay(funcCode);return this.resultGeom;}
jsts.operation.overlay.OverlayOp.prototype.getGraph=function(){return this.graph;}
jsts.operation.overlay.OverlayOp.prototype.computeOverlay=function(opCode){this.copyPoints(0);this.copyPoints(1);this.arg[0].computeSelfNodes(this.li,false);this.arg[1].computeSelfNodes(this.li,false);this.arg[0].computeEdgeIntersections(this.arg[1],this.li,true);var baseSplitEdges=new ArrayList();this.arg[0].computeSplitEdges(baseSplitEdges);this.arg[1].computeSplitEdges(baseSplitEdges);var splitEdges=baseSplitEdges;this.insertUniqueEdges(baseSplitEdges);this.computeLabelsFromDepths();this.replaceCollapsedEdges();EdgeNodingValidator.checkValid(this.edgeList.getEdges());this.graph.addEdges(this.edgeList.getEdges());this.computeLabelling();this.labelIncompleteNodes();this.findResultAreaEdges(opCode);this.cancelDuplicateResultEdges();var polyBuilder=new PolygonBuilder(this.geomFact);polyBuilder.add(this.graph);this.resultPolyList=polyBuilder.getPolygons();var lineBuilder=new LineBuilder(this,this.geomFact,this.ptLocator);this.resultLineList=lineBuilder.build(opCode);var pointBuilder=new PointBuilder(this,this.geomFact,this.ptLocator);this.resultPointList=pointBuilder.build(opCode);this.resultGeom=this.computeGeometry(this.resultPointList,this.resultLineList,this.resultPolyList,opCode);}
jsts.operation.overlay.OverlayOp.prototype.insertUniqueEdges=function(edges){for(var i=edges.iterator();i.hasNext();){var e=i.next();this.insertUniqueEdge(e);}}
jsts.operation.overlay.OverlayOp.prototype.insertUniqueEdge=function(e){var existingEdge=this.edgeList.findEqualEdge(e);if(existingEdge!==null){var existingLabel=existingEdge.getLabel();var labelToMerge=e.getLabel();if(!existingEdge.isPointwiseEqual(e)){labelToMerge=new Label(e.getLabel());labelToMerge.flip();}
var depth=existingEdge.getDepth();if(depth.isNull()){depth.add(existingLabel);}
depth.add(labelToMerge);existingLabel.merge(labelToMerge);}else{this.edgeList.add(e);}};jsts.operation.overlay.OverlayOp.prototype.computeLabelsFromDepths=function(){for(var it=this.edgeList.iterator();it.hasNext();){var e=it.next();var lbl=e.getLabel();var depth=e.getDepth();if(!depth.isNull()){depth.normalize();for(var i=0;i<2;i++){if(!lbl.isNull(i)&&lbl.isArea()&&!depth.isNull(i)){if(depth.getDelta(i)==0){lbl.toLine(i);}else{Assert.isTrue(!depth.isNull(i,Position.LEFT),'depth of LEFT side has not been initialized');lbl.setLocation(i,Position.LEFT,depth.getLocation(i,Position.LEFT));Assert.isTrue(!depth.isNull(i,Position.RIGHT),'depth of RIGHT side has not been initialized');lbl.setLocation(i,Position.RIGHT,depth.getLocation(i,Position.RIGHT));}}}}}}
jsts.operation.overlay.OverlayOp.prototype.replaceCollapsedEdges=function(){var newEdges=new ArrayList();for(var it=this.edgeList.iterator();it.hasNext();){var e=it.next();if(e.isCollapsed()){it.remove();newEdges.add(e.getCollapsedEdge());}}
this.edgeList.addAll(newEdges);}
jsts.operation.overlay.OverlayOp.prototype.copyPoints=function(argIndex){for(var i=this.arg[argIndex].getNodeIterator();i.hasNext();){var graphNode=i.next();var newNode=this.graph.addNode(graphNode.getCoordinate());newNode.setLabel(argIndex,graphNode.getLabel().getLocation(argIndex));}}
jsts.operation.overlay.OverlayOp.prototype.computeLabelling=function(){for(var nodeit=this.graph.getNodes().iterator();nodeit.hasNext();){var node=nodeit.next();node.getEdges().computeLabelling(this.arg);}
this.mergeSymLabels();this.updateNodeLabelling();}
jsts.operation.overlay.OverlayOp.prototype.mergeSymLabels=function(){for(var nodeit=this.graph.getNodes().iterator();nodeit.hasNext();){var node=nodeit.next();node.getEdges().mergeSymLabels();}}
jsts.operation.overlay.OverlayOp.prototype.updateNodeLabelling=function(){for(var nodeit=this.graph.getNodes().iterator();nodeit.hasNext();){var node=nodeit.next();var lbl=node.getEdges().getLabel();node.getLabel().merge(lbl);}}
jsts.operation.overlay.OverlayOp.prototype.labelIncompleteNodes=function(){var nodeCount=0;for(var ni=this.graph.getNodes().iterator();ni.hasNext();){var n=ni.next();var label=n.getLabel();if(n.isIsolated()){nodeCount++;if(label.isNull(0))
this.labelIncompleteNode(n,0);else
this.labelIncompleteNode(n,1);}
n.getEdges().updateLabelling(label);}};jsts.operation.overlay.OverlayOp.prototype.labelIncompleteNode=function(n,targetIndex){var loc=this.ptLocator.locate(n.getCoordinate(),this.arg[targetIndex].getGeometry());n.getLabel().setLocation(targetIndex,loc);};jsts.operation.overlay.OverlayOp.prototype.findResultAreaEdges=function(opCode){for(var it=this.graph.getEdgeEnds().iterator();it.hasNext();){var de=it.next();var label=de.getLabel();if(label.isArea()&&!de.isInteriorAreaEdge()&&jsts.operation.overlay.OverlayOp.isResultOfOp(label.getLocation(0,Position.RIGHT),label.getLocation(1,Position.RIGHT),opCode)){de.setInResult(true);}}};jsts.operation.overlay.OverlayOp.prototype.cancelDuplicateResultEdges=function(){for(var it=this.graph.getEdgeEnds().iterator();it.hasNext();){var de=it.next();var sym=de.getSym();if(de.isInResult()&&sym.isInResult()){de.setInResult(false);sym.setInResult(false);}}};jsts.operation.overlay.OverlayOp.prototype.isCoveredByLA=function(coord){if(this.isCovered(coord,this.resultLineList))
return true;if(this.isCovered(coord,this.resultPolyList))
return true;return false;};jsts.operation.overlay.OverlayOp.prototype.isCoveredByA=function(coord){if(this.isCovered(coord,this.resultPolyList))
return true;return false;};jsts.operation.overlay.OverlayOp.prototype.isCovered=function(coord,geomList){for(var it=geomList.iterator();it.hasNext();){var geom=it.next();var loc=this.ptLocator.locate(coord,geom);if(loc!=Location.EXTERIOR)
return true;}
return false;};jsts.operation.overlay.OverlayOp.prototype.computeGeometry=function(resultPointList,resultLineList,resultPolyList,opcode){var geomList=new ArrayList();geomList.addAll(resultPointList);geomList.addAll(resultLineList);geomList.addAll(resultPolyList);return this.geomFact.buildGeometry(geomList);};jsts.operation.overlay.OverlayOp.prototype.createEmptyResult=function(opCode){var result=null;switch(resultDimension(opCode,this.arg[0].getGeometry(),this.arg[1].getGeometry())){case-1:result=geomFact.createGeometryCollection();break;case 0:result=geomFact.createPoint(null);break;case 1:result=geomFact.createLineString(null);break;case 2:result=geomFact.createPolygon(null,null);break;}
return result;};jsts.operation.overlay.OverlayOp.prototype.resultDimension=function(opCode,g0,g1){var dim0=g0.getDimension();var dim1=g1.getDimension();var resultDimension=-1;switch(opCode){case jsts.operation.overlay.OverlayOp.INTERSECTION:resultDimension=Math.min(dim0,dim1);break;case jsts.operation.overlay.OverlayOp.UNION:resultDimension=Math.max(dim0,dim1);break;case jsts.operation.overlay.OverlayOp.DIFFERENCE:resultDimension=dim0;break;case jsts.operation.overlay.OverlayOp.SYMDIFFERENCE:resultDimension=Math.max(dim0,dim1);break;}
return resultDimension;};})();(function(){var OverlayOp=jsts.operation.overlay.OverlayOp;var GeometrySnapper=jsts.operation.overlay.snap.GeometrySnapper;var SnapOverlayOp=function(g1,g2){this.geom=[];this.geom[0]=g1;this.geom[1]=g2;this.computeSnapTolerance();};SnapOverlayOp.overlayOp=function(g0,g1,opCode){var op=new SnapOverlayOp(g0,g1);return op.getResultGeometry(opCode);};SnapOverlayOp.intersection=function(g0,g1){return this.overlayOp(g0,g1,OverlayOp.INTERSECTION);};SnapOverlayOp.union=function(g0,g1){return this.overlayOp(g0,g1,OverlayOp.UNION);};SnapOverlayOp.difference=function(g0,g1){return overlayOp(g0,g1,OverlayOp.DIFFERENCE);};SnapOverlayOp.symDifference=function(g0,g1){return overlayOp(g0,g1,OverlayOp.SYMDIFFERENCE);};SnapOverlayOp.prototype.geom=null;SnapOverlayOp.prototype.snapTolerance=null;SnapOverlayOp.prototype.computeSnapTolerance=function(){this.snapTolerance=GeometrySnapper.computeOverlaySnapTolerance(this.geom[0],this.geom[1]);};SnapOverlayOp.prototype.getResultGeometry=function(opCode){var prepGeom=this.snap(this.geom);var result=OverlayOp.overlayOp(prepGeom[0],prepGeom[1],opCode);return this.prepareResult(result);};SnapOverlayOp.prototype.selfSnap=function(geom){var snapper0=new GeometrySnapper(geom);var snapGeom=snapper0.snapTo(geom,this.snapTolerance);return snapGeom;};SnapOverlayOp.prototype.snap=function(geom){var remGeom=geom;var snapGeom=GeometrySnapper.snap(remGeom[0],remGeom[1],this.snapTolerance);return snapGeom;};SnapOverlayOp.prototype.prepareResult=function(geom){return geom;};SnapOverlayOp.prototype.cbr=null;SnapOverlayOp.prototype.removeCommonBits=function(geom){this.cbr=new jsts.precision.CommonBitsRemover();this.cbr.add(this.geom[0]);this.cbr.add(this.geom[1]);var remGeom=[];remGeom[0]=cbr.removeCommonBits(this.geom[0].clone());remGeom[1]=cbr.removeCommonBits(this.geom[1].clone());return remGeom;};jsts.operation.overlay.snap.SnapOverlayOp=SnapOverlayOp;})();jsts.geomgraph.index.EdgeSetIntersector=function(){};jsts.geomgraph.index.EdgeSetIntersector.prototype.computeIntersections=function(edges,si,testAllSegments){throw new jsts.error.AbstractMethodInvocationError();};jsts.geomgraph.index.EdgeSetIntersector.prototype.computeIntersections2=function(edges0,edges1,si){throw new jsts.error.AbstractMethodInvocationError();};jsts.geomgraph.index.SimpleMCSweepLineIntersector=function(){this.events=[];};jsts.geomgraph.index.SimpleMCSweepLineIntersector.prototype=new jsts.geomgraph.index.EdgeSetIntersector();jsts.geomgraph.index.SimpleMCSweepLineIntersector.prototype.events=null;jsts.geomgraph.index.SimpleMCSweepLineIntersector.prototype.nOverlaps=0;jsts.geomgraph.index.SimpleMCSweepLineIntersector.prototype.computeIntersections=function(edges,si,testAllSegments){if(si instanceof javascript.util.List){this.computeIntersections2.apply(this,arguments);return;}
if(testAllSegments){this.addList2(edges,null);}else{this.addList(edges);}
this.computeIntersections3(si);};jsts.geomgraph.index.SimpleMCSweepLineIntersector.prototype.computeIntersections2=function(edges0,edges1,si){this.addList2(edges0,edges0);this.addList2(edges1,edges1);this.computeIntersections3(si);};jsts.geomgraph.index.SimpleMCSweepLineIntersector.prototype.add=function(edge,edgeSet){if(edge instanceof javascript.util.List){this.addList.apply(this,arguments);return;}
var mce=edge.getMonotoneChainEdge();var startIndex=mce.getStartIndexes();for(var i=0;i<startIndex.length-1;i++){var mc=new jsts.geomgraph.index.MonotoneChain(mce,i);var insertEvent=new jsts.geomgraph.index.SweepLineEvent(mce.getMinX(i),mc,edgeSet);this.events.push(insertEvent);this.events.push(new jsts.geomgraph.index.SweepLineEvent(mce.getMaxX(i),insertEvent));}};jsts.geomgraph.index.SimpleMCSweepLineIntersector.prototype.addList=function(edges){for(var i=edges.iterator();i.hasNext();){var edge=i.next();this.add(edge,edge);}};jsts.geomgraph.index.SimpleMCSweepLineIntersector.prototype.addList2=function(edges,edgeSet){for(var i=edges.iterator();i.hasNext();){var edge=i.next();this.add(edge,edgeSet);}};jsts.geomgraph.index.SimpleMCSweepLineIntersector.prototype.prepareEvents=function(){this.events.sort(function(a,b){return a.compareTo(b);});for(var i=0;i<this.events.length;i++){var ev=this.events[i];if(ev.isDelete()){ev.getInsertEvent().setDeleteEventIndex(i);}}};jsts.geomgraph.index.SimpleMCSweepLineIntersector.prototype.computeIntersections3=function(si){this.nOverlaps=0;this.prepareEvents();for(var i=0;i<this.events.length;i++){var ev=this.events[i];if(ev.isInsert()){this.processOverlaps(i,ev.getDeleteEventIndex(),ev,si);}}};jsts.geomgraph.index.SimpleMCSweepLineIntersector.prototype.processOverlaps=function(start,end,ev0,si){var mc0=ev0.getObject();for(var i=start;i<end;i++){var ev1=this.events[i];if(ev1.isInsert()){var mc1=ev1.getObject();if(!ev0.isSameLabel(ev1)){mc0.computeIntersections(mc1,si);this.nOverlaps++;}}}};jsts.algorithm.locate.SimplePointInAreaLocator=function(geom){this.geom=geom;};jsts.algorithm.locate.SimplePointInAreaLocator.locate=function(p,geom){if(geom.isEmpty())
return jsts.geom.Location.EXTERIOR;if(jsts.algorithm.locate.SimplePointInAreaLocator.containsPoint(p,geom))
return jsts.geom.Location.INTERIOR;return jsts.geom.Location.EXTERIOR;};jsts.algorithm.locate.SimplePointInAreaLocator.containsPoint=function(p,geom){if(geom instanceof jsts.geom.Polygon){return jsts.algorithm.locate.SimplePointInAreaLocator.containsPointInPolygon(p,geom);}else if(geom instanceof jsts.geom.GeometryCollection||geom instanceof jsts.geom.MultiPoint||geom instanceof jsts.geom.MultiLineString||geom instanceof jsts.geom.MultiPolygon){for(var i=0;i<geom.geometries.length;i++){var g2=geom.geometries[i];if(g2!==geom)
if(jsts.algorithm.locate.SimplePointInAreaLocator.containsPoint(p,g2))
return true;}}
return false;};jsts.algorithm.locate.SimplePointInAreaLocator.containsPointInPolygon=function(p,poly){if(poly.isEmpty())
return false;var shell=poly.getExteriorRing();if(!jsts.algorithm.locate.SimplePointInAreaLocator.isPointInRing(p,shell))
return false;for(var i=0;i<poly.getNumInteriorRing();i++){var hole=poly.getInteriorRingN(i);if(jsts.algorithm.locate.SimplePointInAreaLocator.isPointInRing(p,hole))
return false;}
return true;};jsts.algorithm.locate.SimplePointInAreaLocator.isPointInRing=function(p,ring){if(!ring.getEnvelopeInternal().intersects(p))
return false;return jsts.algorithm.CGAlgorithms.isPointInRing(p,ring.getCoordinates());};jsts.algorithm.locate.SimplePointInAreaLocator.prototype.geom=null;jsts.algorithm.locate.SimplePointInAreaLocator.prototype.locate=function(p){return jsts.algorithm.locate.SimplePointInAreaLocator.locate(p,geom);};(function(){var Location=jsts.geom.Location;var Position=jsts.geomgraph.Position;var EdgeEndStar=jsts.geomgraph.EdgeEndStar;var Assert=jsts.util.Assert;jsts.geomgraph.DirectedEdgeStar=function(){jsts.geomgraph.EdgeEndStar.call(this);};jsts.geomgraph.DirectedEdgeStar.prototype=new EdgeEndStar();jsts.geomgraph.DirectedEdgeStar.constructor=jsts.geomgraph.DirectedEdgeStar;jsts.geomgraph.DirectedEdgeStar.prototype.resultAreaEdgeList=null;jsts.geomgraph.DirectedEdgeStar.prototype.label=null;jsts.geomgraph.DirectedEdgeStar.prototype.insert=function(ee){var de=ee;this.insertEdgeEnd(de,de);};jsts.geomgraph.DirectedEdgeStar.prototype.getLabel=function(){return this.label;};jsts.geomgraph.DirectedEdgeStar.prototype.getOutgoingDegree=function(){var degree=0;for(var it=this.iterator();it.hasNext();){var de=it.next();if(de.isInResult())
degree++;}
return degree;};jsts.geomgraph.DirectedEdgeStar.prototype.getOutgoingDegree=function(er){var degree=0;for(var it=this.iterator();it.hasNext();){var de=it.next();if(de.getEdgeRing()===er)
degree++;}
return degree;};jsts.geomgraph.DirectedEdgeStar.prototype.getRightmostEdge=function(){var edges=this.getEdges();var size=edges.size();if(size<1)
return null;var de0=edges.get(0);if(size==1)
return de0;var deLast=edges.get(size-1);var quad0=de0.getQuadrant();var quad1=deLast.getQuadrant();if(jsts.geomgraph.Quadrant.isNorthern(quad0)&&jsts.geomgraph.Quadrant.isNorthern(quad1))
return de0;else if(!jsts.geomgraph.Quadrant.isNorthern(quad0)&&!jsts.geomgraph.Quadrant.isNorthern(quad1))
return deLast;else{var nonHorizontalEdge=null;if(de0.getDy()!=0)
return de0;else if(deLast.getDy()!=0)
return deLast;}
Assert.shouldNeverReachHere('found two horizontal edges incident on node');return null;};jsts.geomgraph.DirectedEdgeStar.prototype.computeLabelling=function(geom){EdgeEndStar.prototype.computeLabelling.call(this,geom);this.label=new jsts.geomgraph.Label(Location.NONE);for(var it=this.iterator();it.hasNext();){var ee=it.next();var e=ee.getEdge();var eLabel=e.getLabel();for(var i=0;i<2;i++){var eLoc=eLabel.getLocation(i);if(eLoc===Location.INTERIOR||eLoc===Location.BOUNDARY)
this.label.setLocation(i,Location.INTERIOR);}}};jsts.geomgraph.DirectedEdgeStar.prototype.mergeSymLabels=function(){for(var it=this.iterator();it.hasNext();){var de=it.next();var label=de.getLabel();label.merge(de.getSym().getLabel());}};jsts.geomgraph.DirectedEdgeStar.prototype.updateLabelling=function(nodeLabel){for(var it=this.iterator();it.hasNext();){var de=it.next();var label=de.getLabel();label.setAllLocationsIfNull(0,nodeLabel.getLocation(0));label.setAllLocationsIfNull(1,nodeLabel.getLocation(1));}};jsts.geomgraph.DirectedEdgeStar.prototype.getResultAreaEdges=function(){if(this.resultAreaEdgeList!==null)
return this.resultAreaEdgeList;this.resultAreaEdgeList=new javascript.util.ArrayList();for(var it=this.iterator();it.hasNext();){var de=it.next();if(de.isInResult()||de.getSym().isInResult())
this.resultAreaEdgeList.add(de);}
return this.resultAreaEdgeList;};jsts.geomgraph.DirectedEdgeStar.prototype.SCANNING_FOR_INCOMING=1;jsts.geomgraph.DirectedEdgeStar.prototype.LINKING_TO_OUTGOING=2;jsts.geomgraph.DirectedEdgeStar.prototype.linkResultDirectedEdges=function(){this.getResultAreaEdges();var firstOut=null;var incoming=null;var state=this.SCANNING_FOR_INCOMING;for(var i=0;i<this.resultAreaEdgeList.size();i++){var nextOut=this.resultAreaEdgeList.get(i);var nextIn=nextOut.getSym();if(!nextOut.getLabel().isArea())
continue;if(firstOut===null&&nextOut.isInResult())
firstOut=nextOut;switch(state){case this.SCANNING_FOR_INCOMING:if(!nextIn.isInResult())
continue;incoming=nextIn;state=this.LINKING_TO_OUTGOING;break;case this.LINKING_TO_OUTGOING:if(!nextOut.isInResult())
continue;incoming.setNext(nextOut);state=this.SCANNING_FOR_INCOMING;break;}}
if(state===this.LINKING_TO_OUTGOING){if(firstOut===null)
throw new jsts.error.TopologyError('no outgoing dirEdge found',this.getCoordinate());Assert.isTrue(firstOut.isInResult(),'unable to link last incoming dirEdge');incoming.setNext(firstOut);}};jsts.geomgraph.DirectedEdgeStar.prototype.linkMinimalDirectedEdges=function(er){var firstOut=null;var incoming=null;var state=this.SCANNING_FOR_INCOMING;for(var i=this.resultAreaEdgeList.size()-1;i>=0;i--){var nextOut=this.resultAreaEdgeList.get(i);var nextIn=nextOut.getSym();if(firstOut===null&&nextOut.getEdgeRing()===er)
firstOut=nextOut;switch(state){case this.SCANNING_FOR_INCOMING:if(nextIn.getEdgeRing()!=er)
continue;incoming=nextIn;state=this.LINKING_TO_OUTGOING;break;case this.LINKING_TO_OUTGOING:if(nextOut.getEdgeRing()!==er)
continue;incoming.setNextMin(nextOut);state=this.SCANNING_FOR_INCOMING;break;}}
if(state===this.LINKING_TO_OUTGOING){Assert.isTrue(firstOut!==null,'found null for first outgoing dirEdge');Assert.isTrue(firstOut.getEdgeRing()===er,'unable to link last incoming dirEdge');incoming.setNextMin(firstOut);}};jsts.geomgraph.DirectedEdgeStar.prototype.linkAllDirectedEdges=function(){this.getEdges();var prevOut=null;var firstIn=null;for(var i=this.edgeList.size()-1;i>=0;i--){var nextOut=this.edgeList.get(i);var nextIn=nextOut.getSym();if(firstIn===null)
firstIn=nextIn;if(prevOut!==null)
nextIn.setNext(prevOut);prevOut=nextOut;}
firstIn.setNext(prevOut);};jsts.geomgraph.DirectedEdgeStar.prototype.findCoveredLineEdges=function(){var startLoc=Location.NONE;for(var it=this.iterator();it.hasNext();){var nextOut=it.next();var nextIn=nextOut.getSym();if(!nextOut.isLineEdge()){if(nextOut.isInResult()){startLoc=Location.INTERIOR;break;}
if(nextIn.isInResult()){startLoc=Location.EXTERIOR;break;}}}
if(startLoc===Location.NONE)
return;var currLoc=startLoc;for(var it=this.iterator();it.hasNext();){var nextOut=it.next();var nextIn=nextOut.getSym();if(nextOut.isLineEdge()){nextOut.getEdge().setCovered(currLoc===Location.INTERIOR);}else{if(nextOut.isInResult())
currLoc=Location.EXTERIOR;if(nextIn.isInResult())
currLoc=Location.INTERIOR;}}};jsts.geomgraph.DirectedEdgeStar.prototype.computeDepths=function(de){if(arguments.length===2){this.computeDepths2.apply(this,arguments);return;}
var edgeIndex=this.findIndex(de);var label=de.getLabel();var startDepth=de.getDepth(Position.LEFT);var targetLastDepth=de.getDepth(Position.RIGHT);var nextDepth=this.computeDepths2(edgeIndex+1,this.edgeList.size(),startDepth);var lastDepth=this.computeDepths2(0,edgeIndex,nextDepth);if(lastDepth!=targetLastDepth)
throw new jsts.error.TopologyError('depth mismatch at '+
de.getCoordinate());};jsts.geomgraph.DirectedEdgeStar.prototype.computeDepths2=function(startIndex,endIndex,startDepth){var currDepth=startDepth;for(var i=startIndex;i<endIndex;i++){var nextDe=this.edgeList.get(i);var label=nextDe.getLabel();nextDe.setEdgeDepths(Position.RIGHT,currDepth);currDepth=nextDe.getDepth(Position.LEFT);}
return currDepth;};})();jsts.algorithm.CentroidLine=function(){this.centSum=new jsts.geom.Coordinate();};jsts.algorithm.CentroidLine.prototype.centSum=null;jsts.algorithm.CentroidLine.prototype.totalLength=0.0;jsts.algorithm.CentroidLine.prototype.add=function(geom){if(geom instanceof Array){this.add2.apply(this,arguments);return;}
if(geom instanceof jsts.geom.LineString){this.add(geom.getCoordinates());}else if(geom instanceof jsts.geom.Polygon){var poly=geom;this.add(poly.getExteriorRing().getCoordinates());for(var i=0;i<poly.getNumInteriorRing();i++){this.add(poly.getInteriorRingN(i).getCoordinates());}}else if(geom instanceof jsts.geom.GeometryCollection||geom instanceof jsts.geom.MultiPoint||geom instanceof jsts.geom.MultiLineString||geom instanceof jsts.geom.MultiPolygon){var gc=geom;for(var i=0;i<gc.getNumGeometries();i++){this.add(gc.getGeometryN(i));}}};jsts.algorithm.CentroidLine.prototype.getCentroid=function(){var cent=new jsts.geom.Coordinate();cent.x=this.centSum.x/this.totalLength;cent.y=this.centSum.y/this.totalLength;return cent;};jsts.algorithm.CentroidLine.prototype.add2=function(pts){for(var i=0;i<pts.length-1;i++){var segmentLen=pts[i].distance(pts[i+1]);this.totalLength+=segmentLen;var midx=(pts[i].x+pts[i+1].x)/2;this.centSum.x+=segmentLen*midx;var midy=(pts[i].y+pts[i+1].y)/2;this.centSum.y+=segmentLen*midy;}};jsts.index.IntervalSize=function(){};jsts.index.IntervalSize.MIN_BINARY_EXPONENT=-50;jsts.index.IntervalSize.isZeroWidth=function(min,max){var width=max-min;if(width===0.0){return true;}
var maxAbs,scaledInterval,level;maxAbs=Math.max(Math.abs(min),Math.abs(max));scaledInterval=width/maxAbs;level=jsts.index.DoubleBits.exponent(scaledInterval);return level<=jsts.index.IntervalSize.MIN_BINARY_EXPONENT;};jsts.geomgraph.index.SimpleEdgeSetIntersector=function(){};jsts.geomgraph.index.SimpleEdgeSetIntersector.prototype=new jsts.geomgraph.index.EdgeSetIntersector();jsts.geomgraph.index.SimpleEdgeSetIntersector.prototype.nOverlaps=0;jsts.geomgraph.index.SimpleEdgeSetIntersector.prototype.computeIntersections=function(edges,si,testAllSegments){if(si instanceof javascript.util.List){this.computeIntersections2.apply(this,arguments);return;}
this.nOverlaps=0;for(var i0=edges.iterator();i0.hasNext();){var edge0=i0.next();for(var i1=edges.iterator();i1.hasNext();){var edge1=i1.next();if(testAllSegments||edge0!=edge1)
this.computeIntersects(edge0,edge1,si);}}};jsts.geomgraph.index.SimpleEdgeSetIntersector.prototype.computeIntersections2=function(edges0,edges1,si){this.nOverlaps=0;for(var i0=edges0.iterator();i0.hasNext();){var edge0=i0.next();for(var i1=edges1.iterator();i1.hasNext();){var edge1=i1.next();this.computeIntersects(edge0,edge1,si);}}};jsts.geomgraph.index.SimpleEdgeSetIntersector.prototype.computeIntersects=function(e0,e1,si){var pts0=e0.getCoordinates();var pts1=e1.getCoordinates();var i0,i1;for(i0=0;i0<pts0.length-1;i0++){for(i1=0;i1<pts1.length-1;i1++){si.addIntersections(e0,i0,e1,i1);}}};jsts.geomgraph.Edge=function(pts,label){this.pts=pts;this.label=label;this.eiList=new jsts.geomgraph.EdgeIntersectionList(this);this.depth=new jsts.geomgraph.Depth();};jsts.geomgraph.Edge.prototype=new jsts.geomgraph.GraphComponent();jsts.geomgraph.Edge.constructor=jsts.geomgraph.Edge;jsts.geomgraph.Edge.updateIM=function(label,im){im.setAtLeastIfValid(label.getLocation(0,jsts.geomgraph.Position.ON),label.getLocation(1,jsts.geomgraph.Position.ON),1);if(label.isArea()){im.setAtLeastIfValid(label.getLocation(0,jsts.geomgraph.Position.LEFT),label.getLocation(1,jsts.geomgraph.Position.LEFT),2);im.setAtLeastIfValid(label.getLocation(0,jsts.geomgraph.Position.RIGHT),label.getLocation(1,jsts.geomgraph.Position.RIGHT),2);}};jsts.geomgraph.Edge.prototype.pts=null;jsts.geomgraph.Edge.prototype.env=null;jsts.geomgraph.Edge.prototype.name=null;jsts.geomgraph.Edge.prototype.mce=null;jsts.geomgraph.Edge.prototype._isIsolated=true;jsts.geomgraph.Edge.prototype.depth=null;jsts.geomgraph.Edge.prototype.depthDelta=0;jsts.geomgraph.Edge.prototype.eiList=null;jsts.geomgraph.Edge.prototype.getNumPoints=function(){return this.pts.length;};jsts.geomgraph.Edge.prototype.getEnvelope=function(){if(this.env===null){this.env=new jsts.geom.Envelope();for(var i=0;i<this.pts.length;i++){this.env.expandToInclude(pts[i]);}}
return env;};jsts.geomgraph.Edge.prototype.getDepth=function(){return this.depth;};jsts.geomgraph.Edge.prototype.getDepthDelta=function(){return this.depthDelta;};jsts.geomgraph.Edge.prototype.setDepthDelta=function(depthDelta){this.depthDelta=depthDelta;};jsts.geomgraph.Edge.prototype.getCoordinates=function(){return this.pts;};jsts.geomgraph.Edge.prototype.getCoordinate=function(i){if(i===undefined){if(this.pts.length>0){return this.pts[0];}else{return null;}}
return this.pts[i];};jsts.geomgraph.Edge.prototype.isClosed=function(){return this.pts[0].equals(this.pts[this.pts.length-1]);};jsts.geomgraph.Edge.prototype.setIsolated=function(isIsolated){this._isIsolated=isIsolated;};jsts.geomgraph.Edge.prototype.isIsolated=function(){return this._isIsolated;};jsts.geomgraph.Edge.prototype.addIntersections=function(li,segmentIndex,geomIndex){for(var i=0;i<li.getIntersectionNum();i++){this.addIntersection(li,segmentIndex,geomIndex,i);}};jsts.geomgraph.Edge.prototype.addIntersection=function(li,segmentIndex,geomIndex,intIndex){var intPt=new jsts.geom.Coordinate(li.getIntersection(intIndex));var normalizedSegmentIndex=segmentIndex;var dist=li.getEdgeDistance(geomIndex,intIndex);var nextSegIndex=normalizedSegmentIndex+1;if(nextSegIndex<this.pts.length){var nextPt=this.pts[nextSegIndex];if(intPt.equals2D(nextPt)){normalizedSegmentIndex=nextSegIndex;dist=0.0;}}
var ei=this.eiList.add(intPt,normalizedSegmentIndex,dist);};jsts.geomgraph.Edge.prototype.getMaximumSegmentIndex=function(){return this.pts.length-1;};jsts.geomgraph.Edge.prototype.getEdgeIntersectionList=function(){return this.eiList;};jsts.geomgraph.Edge.prototype.getMonotoneChainEdge=function(){if(this.mce==null){this.mce=new jsts.geomgraph.index.MonotoneChainEdge(this);}
return this.mce;};jsts.geomgraph.Edge.prototype.isClosed=function()
{return this.pts[0].equals(this.pts[this.pts.length-1]);};jsts.geomgraph.Edge.prototype.isCollapsed=function()
{if(!this.label.isArea())return false;if(this.pts.length!=3)return false;if(this.pts[0].equals(this.pts[2]))return true;return false;};jsts.geomgraph.Edge.prototype.getCollapsedEdge=function()
{var newPts=[];newPts[0]=this.pts[0];newPts[1]=this.pts[1];var newe=new jsts.geomgraph.Edge(newPts,jsts.geomgraph.Label.toLineLabel(this.label));return newe;};jsts.geomgraph.Edge.prototype.computeIM=function(im){jsts.geomgraph.Edge.updateIM(this.label,im);};jsts.geomgraph.Edge.prototype.isPointwiseEqual=function(e)
{if(this.pts.length!=e.pts.length)return false;for(var i=0;i<this.pts.length;i++){if(!this.pts[i].equals2D(e.pts[i])){return false;}}
return true;};jsts.noding.Octant=function(){throw jsts.error.AbstractMethodInvocationError();};jsts.noding.Octant.octant=function(dx,dy){if(dx instanceof jsts.geom.Coordinate){return jsts.noding.Octant.octant2.apply(this,arguments);}
if(dx===0.0&&dy===0.0)
throw new jsts.error.IllegalArgumentError('Cannot compute the octant for point ( '+dx+', '+dy+' )');var adx=Math.abs(dx);var ady=Math.abs(dy);if(dx>=0){if(dy>=0){if(adx>=ady)
return 0;else
return 1;}
else{if(adx>=ady)
return 7;else
return 6;}}
else{if(dy>=0){if(adx>=ady)
return 3;else
return 2;}
else{if(adx>=ady)
return 4;else
return 5;}}};jsts.noding.Octant.octant2=function(p0,p1){var dx=p1.x-p0.x;var dy=p1.y-p0.y;if(dx===0.0&&dy===0.0)
throw new jsts.error.IllegalArgumentError('Cannot compute the octant for two identical points '+p0);return jsts.noding.Octant.octant(dx,dy);};jsts.operation.union.UnionInteracting=function(g0,g1){this.g0=g0;this.g1=g1;this.geomFactory=g0.getFactory();this.interacts0=[];this.interacts1=[];};jsts.operation.union.UnionInteracting.union=function(g0,g1){var uue=new jsts.operation.union.UnionInteracting(g0,g1);return uue.union();};jsts.operation.union.UnionInteracting.prototype.geomFactory=null;jsts.operation.union.UnionInteracting.prototype.g0=null;jsts.operation.union.UnionInteracting.prototype.g1=null;jsts.operation.union.UnionInteracting.prototype.interacts0=null;jsts.operation.union.UnionInteracting.prototype.interacts1=null;jsts.operation.union.UnionInteracting.prototype.union=function(){this.computeInteracting();var int0=this.extractElements(this.g0,this.interacts0,true);var int1=this.extractElements(this.g1,this.interacts1,true);if(int0.isEmpty()||int1.isEmpty()){}
var union=in0.union(int1);var disjoint0=this.extractElements(this.g0,this.interacts0,false);var disjoint1=this.extractElements(this.g1,this.interacts1,false);var overallUnion=jsts.geom.util.GeometryCombiner.combine(union,disjoint0,disjoint1);return overallUnion;};jsts.operation.union.UnionInteracting.prototype.bufferUnion=function(g0,g1){var factory=g0.getFactory();var gColl=factory.createGeometryCollection([g0,g1]);var unionAll=gColl.buffer(0.0);return unionAll;};jsts.operation.union.UnionInteracting.prototype.computeInteracting=function(elem0){if(!elem0){for(var i=0,l=this.g0.getNumGeometries();i<l;i++){var elem=this.g0.getGeometryN(i);this.interacts0[i]=this.computeInteracting(elem);}}
else{var interactsWithAny=false;for(var i=0,l=g1.getNumGeometries();i<l;i++){var elem1=this.g1.getGeometryN(i);var interacts=elem1.getEnvelopeInternal().intersects(elem0.getEnvelopeInternal());if(interacts){this.interacts1[i]=true;interactsWithAny=true;}}
return interactsWithAny;}};jsts.operation.union.UnionInteracting.prototype.extractElements=function(geom,interacts,isInteracting){var extractedGeoms=[];for(var i=0,l=geom.getNumGeometries();i<l;i++){var elem=geom.getGeometryN(i);if(interacts[i]===isInteracting){extractedGeoms.push(elem);}}
return this.geomFactory.buildGeometry(extractedGeoms);};jsts.triangulate.quadedge.TrianglePredicate=function(){};jsts.triangulate.quadedge.TrianglePredicate.isInCircleNonRobust=function(a,b,c,p){var isInCircle=(a.x*a.x+a.y*a.y)*jsts.triangulate.quadedge.TrianglePredicate.triArea(b,c,p)-
(b.x*b.x+b.y*b.y)*jsts.triangulate.quadedge.TrianglePredicate.triArea(a,c,p)+
(c.x*c.x+c.y*c.y)*jsts.triangulate.quadedge.TrianglePredicate.triArea(a,b,p)-
(p.x*p.x+p.y*p.y)*jsts.triangulate.quadedge.TrianglePredicate.triArea(a,b,c)>0;return isInCircle;};jsts.triangulate.quadedge.TrianglePredicate.isInCircleNormalized=function(a,b,c,p){var adx,ady,bdx,bdy,cdx,cdy,abdet,bcdet,cadet,alift,blift,clift,disc;adx=a.x-p.x;ady=a.y-p.y;bdx=b.x-p.x;bdy=b.y-p.y;cdx=c.x-p.x;cdy=c.y-p.y;abdet=adx*bdy-bdx*ady;bcdet=bdx*cdy-cdx*bdy;cadet=cdx*ady-adx*cdy;alift=adx*adx+ady*ady;blift=bdx*bdx+bdy*bdy;clift=cdx*cdx+cdy*cdy;disc=alift*bcdet+blift*cadet+clift*abdet;return disc>0;};jsts.triangulate.quadedge.TrianglePredicate.triArea=function(a,b,c){return(b.x-a.x)*(c.y-a.y)-(b.y-a.y)*(c.x-a.x);};jsts.triangulate.quadedge.TrianglePredicate.isInCircleRobust=function(a,b,c,p){return jsts.triangulate.quadedge.TrianglePredicate.isInCircleNormalized(a,b,c,p);};jsts.triangulate.quadedge.TrianglePredicate.isInCircleDDSlow=function(a,b,c,p){var px,py,ax,ay,bx,by,cx,cy,aTerm,bTerm,cTerm,pTerm,sum,isInCircle;px=jsts.math.DD.valueOf(p.x);py=jsts.math.DD.valueOf(p.y);ax=jsts.math.DD.valueOf(a.x);ay=jsts.math.DD.valueOf(a.y);bx=jsts.math.DD.valueOf(b.x);by=jsts.math.DD.valueOf(b.y);cx=jsts.math.DD.valueOf(c.x);cy=jsts.math.DD.valueOf(c.y);aTerm=(ax.multiply(ax).add(ay.multiply(ay))).multiply(jsts.triangulate.quadedge.TrianglePredicate.triAreaDDSlow(bx,by,cx,cy,px,py));bTerm=(bx.multiply(bx).add(by.multiply(by))).multiply(jsts.triangulate.quadedge.TrianglePredicate.triAreaDDSlow(ax,ay,cx,cy,px,py));cTerm=(cx.multiply(cx).add(cy.multiply(cy))).multiply(jsts.triangulate.quadedge.TrianglePredicate.triAreaDDSlow(ax,ay,bx,by,px,py));pTerm=(px.multiply(px).add(py.multiply(py))).multiply(jsts.triangulate.quadedge.TrianglePredicate.triAreaDDSlow(ax,ay,bx,by,cx,cy));sum=aTerm.subtract(bTerm).add(cTerm).subtract(pTerm);isInCircle=sum.doubleValue()>0;return isInCircle;};jsts.triangulate.quadedge.TrianglePredicate.triAreaDDSlow=function(ax,ay,bx,by,cx,cy){return(bx.subtract(ax).multiply(cy.subtract(ay)).subtract(by.subtract(ay).multiply(cx.subtract(ax))));};jsts.triangulate.quadedge.TrianglePredicate.isInCircleDDFast=function(a,b,c,p){var aTerm,bTerm,cTerm,pTerm,sum,isInCircle;aTerm=(jsts.math.DD.sqr(a.x).selfAdd(jsts.math.DD.sqr(a.y))).selfMultiply(jsts.triangulate.quadedge.TrianglePredicate.triAreaDDFast(b,c,p));bTerm=(jsts.math.DD.sqr(b.x).selfAdd(jsts.math.DD.sqr(b.y))).selfMultiply(jsts.triangulate.quadedge.TrianglePredicate.triAreaDDFast(a,c,p));cTerm=(jsts.math.DD.sqr(c.x).selfAdd(jsts.math.DD.sqr(c.y))).selfMultiply(jsts.triangulate.quadedge.TrianglePredicate.triAreaDDFast(a,b,p));pTerm=(jsts.math.DD.sqr(p.x).selfAdd(jsts.math.DD.sqr(p.y))).selfMultiply(jsts.triangulate.quadedge.TrianglePredicate.triAreaDDFast(a,b,c));sum=aTerm.selfSubtract(bTerm).selfAdd(cTerm).selfSubtract(pTerm);isInCircle=sum.doubleValue()>0;return isInCircle;};jsts.triangulate.quadedge.TrianglePredicate.triAreaDDFast=function(a,b,c){var t1,t2;t1=jsts.math.DD.valueOf(b.x).selfSubtract(a.x).selfMultiply(jsts.math.DD.valueOf(c.y).selfSubtract(a.y));t2=jsts.math.DD.valueOf(b.y).selSubtract(a.y).selfMultiply(jsts.math.DD.valueOf(c.x).selfSubtract(a.x));return t1.selfSubtract(t2);};jsts.triangulate.quadedge.TrianglePredicate.isInCircleDDNormalized=function(a,b,c,p){var adx,ady,bdx,bdy,cdx,cdy,abdet,bcdet,cadet,alift,blift,clift,sum,isInCircle;adx=jsts.math.DD.valueOf(a.x).selfSubtract(p.x);ady=jsts.math.DD.valueOf(a.y).selfSubtract(p.y);bdx=jsts.math.DD.valueOf(b.x).selfSubtract(p.x);bdx=jsts.math.DD.valueOf(b.y).selfSubtract(p.y);cdx=jsts.math.DD.valueOf(c.x).selfSubtract(p.x);cdx=jsts.math.DD.valueOf(c.y).selfSubtract(p.y);abdet=adx.multiply(bdy).selfSubtract(bdx.multiply(ady));bcdet=bdx.multiply(cdy).selfSubtract(cdx.multiply(bdy));cadet=cdx.multiply(ady).selfSubtract(adx.multiply(cdy));alift=adx.multiply(adx).selfAdd(ady.multiply(ady));blift=bdx.multiply(bdx).selfAdd(bdy.multiply(bdy));clift=cdx.multiply(cdx).selfAdd(cdy.multiply(cdy));sum=alift.selfMultiply(bcdet).selfAdd(blift.selfMultiply(cadet)).selfAdd(clift.selfMultiply(abdet));isInCircle=sum.doubleValue()>0;return isInCircle;};jsts.triangulate.quadedge.TrianglePredicate.isInCircleCC=function(a,b,c,p){var cc,ccRadius,pRadiusDiff;cc=jsts.geom.Triangle.circumcentre(a,b,c);ccRadius=a.distance(cc);pRadiusDiff=p.distance(cc)-ccRadius;return pRadiusDiff<=0;};jsts.operation.union.PointGeometryUnion=function(pointGeom,otherGeom){this.pointGeom=pointGeom;this.otherGeom=otherGeom;this.geomFact=otherGeom.getFactory();};jsts.operation.union.PointGeometryUnion.union=function(pointGeom,otherGeom){var unioner=new jsts.operation.union.PointGeometryUnion(pointGeom,otherGeom);return unioner.union();};jsts.operation.union.PointGeometryUnion.prototype.pointGeom=null;jsts.operation.union.PointGeometryUnion.prototype.otherGeom=null;jsts.operation.union.PointGeometryUnion.prototype.geomFact=null;jsts.operation.union.PointGeometryUnion.prototype.union=function(){var locator=new jsts.algorithm.PointLocator();var exteriorCoords=[];for(var i=0,l=this.pointGeom.getNumGeometries();i<l;i++){var point=this.pointGeom.getGeometryN(i);var coord=point.getCoordinate();var loc=locator.locate(coord,this.otherGeom);if(loc===jsts.geom.Location.EXTERIOR){var include=true;for(var j=exteriorCoords.length;i--;){if(exteriorCoords[j].equals(coord)){include=false;break;}}
if(include){exteriorCoords.push(coord);}}}
exteriorCoords.sort(function(x,y){return x.compareTo(y);});if(exteriorCoords.length===0){return this.otherGeom;}
var ptComp=null;var coords=jsts.geom.CoordinateArrays.toCoordinateArray(exteriorCoords);if(coords.length===1){ptComp=this.geomFact.createPoint(coords[0]);}
else{ptComp=this.geomFact.createMultiPoint(coords);}
return jsts.geom.util.GeometryCombiner.combine(ptComp,this.otherGeom);};jsts.noding.IntersectionFinderAdder=function(li){this.li=li;this.interiorIntersections=new javascript.util.ArrayList();};jsts.noding.IntersectionFinderAdder.prototype=new jsts.noding.SegmentIntersector();jsts.noding.IntersectionFinderAdder.constructor=jsts.noding.IntersectionFinderAdder;jsts.noding.IntersectionFinderAdder.prototype.li=null;jsts.noding.IntersectionFinderAdder.prototype.interiorIntersections=null;jsts.noding.IntersectionFinderAdder.prototype.getInteriorIntersections=function(){return this.interiorIntersections;};jsts.noding.IntersectionFinderAdder.prototype.processIntersections=function(e0,segIndex0,e1,segIndex1){if(e0===e1&&segIndex0===segIndex1)
return;var p00=e0.getCoordinates()[segIndex0];var p01=e0.getCoordinates()[segIndex0+1];var p10=e1.getCoordinates()[segIndex1];var p11=e1.getCoordinates()[segIndex1+1];this.li.computeIntersection(p00,p01,p10,p11);if(this.li.hasIntersection()){if(this.li.isInteriorIntersection()){for(var intIndex=0;intIndex<this.li.getIntersectionNum();intIndex++){this.interiorIntersections.add(this.li.getIntersection(intIndex));}
e0.addIntersections(this.li,segIndex0,0);e1.addIntersections(this.li,segIndex1,1);}}};jsts.noding.IntersectionFinderAdder.prototype.isDone=function(){return false;};jsts.noding.snapround.MCIndexSnapRounder=function(pm){this.pm=pm;this.li=new jsts.algorithm.RobustLineIntersector();this.li.setPrecisionModel(pm);this.scaleFactor=pm.getScale();};jsts.noding.snapround.MCIndexSnapRounder.prototype=new jsts.noding.Noder();jsts.noding.snapround.MCIndexSnapRounder.constructor=jsts.noding.snapround.MCIndexSnapRounder;jsts.noding.snapround.MCIndexSnapRounder.prototype.pm=null;jsts.noding.snapround.MCIndexSnapRounder.prototype.li=null;jsts.noding.snapround.MCIndexSnapRounder.prototype.scaleFactor=null;jsts.noding.snapround.MCIndexSnapRounder.prototype.noder=null;jsts.noding.snapround.MCIndexSnapRounder.prototype.pointSnapper=null;jsts.noding.snapround.MCIndexSnapRounder.prototype.nodedSegStrings=null;jsts.noding.snapround.MCIndexSnapRounder.prototype.getNodedSubstrings=function(){return jsts.noding.NodedSegmentString.getNodedSubstrings(this.nodedSegStrings);};jsts.noding.snapround.MCIndexSnapRounder.prototype.computeNodes=function(inputSegmentStrings){this.nodedSegStrings=inputSegmentStrings;this.noder=new jsts.noding.MCIndexNoder();this.pointSnapper=new jsts.noding.snapround.MCIndexPointSnapper(this.noder.getIndex());this.snapRound(inputSegmentStrings,this.li);};jsts.noding.snapround.MCIndexSnapRounder.prototype.snapRound=function(segStrings,li){var intersections=this.findInteriorIntersections(segStrings,li);this.computeIntersectionSnaps(intersections);this.computeVertexSnaps(segStrings);};jsts.noding.snapround.MCIndexSnapRounder.prototype.findInteriorIntersections=function(segStrings,li){var intFinderAdder=new jsts.noding.IntersectionFinderAdder(li);this.noder.setSegmentIntersector(intFinderAdder);this.noder.computeNodes(segStrings);return intFinderAdder.getInteriorIntersections();};jsts.noding.snapround.MCIndexSnapRounder.prototype.computeIntersectionSnaps=function(snapPts){for(var it=snapPts.iterator();it.hasNext();){var snapPt=it.next();var hotPixel=new jsts.noding.snapround.HotPixel(snapPt,this.scaleFactor,this.li);this.pointSnapper.snap(hotPixel);}};jsts.noding.snapround.MCIndexSnapRounder.prototype.computeVertexSnaps=function(edges){if(edges instanceof jsts.noding.NodedSegmentString){this.computeVertexSnaps2.apply(this,arguments);return;}
for(var i0=edges.iterator();i0.hasNext();){var edge0=i0.next();this.computeVertexSnaps(edge0);}};jsts.noding.snapround.MCIndexSnapRounder.prototype.computeVertexSnaps2=function(e){var pts0=e.getCoordinates();for(var i=0;i<pts0.length-1;i++){var hotPixel=new jsts.noding.snapround.HotPixel(pts0[i],this.scaleFactor,this.li);var isNodeAdded=this.pointSnapper.snap(hotPixel,e,i);if(isNodeAdded){e.addIntersection(pts0[i],i);}}};jsts.operation.valid.ConnectedInteriorTester=function(geomGraph){this.geomGraph=geomGraph;this.geometryFactory=new jsts.geom.GeometryFactory();this.disconnectedRingcoord=null;};jsts.operation.valid.ConnectedInteriorTester.findDifferentPoint=function(coord,pt){var i=0,il=coord.length;for(i;i<il;i++){if(!coord[i].equals(pt))
return coord[i];}
return null;};jsts.operation.valid.ConnectedInteriorTester.prototype.getCoordinate=function(){return this.disconnectedRingcoord;};jsts.operation.valid.ConnectedInteriorTester.prototype.isInteriorsConnected=function(){var splitEdges=new javascript.util.ArrayList();this.geomGraph.computeSplitEdges(splitEdges);var graph=new jsts.geomgraph.PlanarGraph(new jsts.operation.overlay.OverlayNodeFactory());graph.addEdges(splitEdges);this.setInteriorEdgesInResult(graph);graph.linkResultDirectedEdges();var edgeRings=this.buildEdgeRings(graph.getEdgeEnds());this.visitShellInteriors(this.geomGraph.getGeometry(),graph);return!this.hasUnvisitedShellEdge(edgeRings);};jsts.operation.valid.ConnectedInteriorTester.prototype.setInteriorEdgesInResult=function(graph){var it=graph.getEdgeEnds().iterator(),de;while(it.hasNext()){de=it.next();if(de.getLabel().getLocation(0,jsts.geomgraph.Position.RIGHT)==jsts.geom.Location.INTERIOR){de.setInResult(true);}}};jsts.operation.valid.ConnectedInteriorTester.prototype.buildEdgeRings=function(dirEdges){var edgeRings=new javascript.util.ArrayList();for(var it=dirEdges.iterator();it.hasNext();){var de=it.next();if(de.isInResult()&&de.getEdgeRing()==null){var er=new jsts.operation.overlay.MaximalEdgeRing(de,this.geometryFactory);er.linkDirectedEdgesForMinimalEdgeRings();var minEdgeRings=er.buildMinimalRings();var i=0,il=minEdgeRings.length;for(i;i<il;i++){edgeRings.add(minEdgeRings[i]);}}}
return edgeRings;};jsts.operation.valid.ConnectedInteriorTester.prototype.visitShellInteriors=function(g,graph){if(g instanceof jsts.geom.Polygon){var p=g;this.visitInteriorRing(p.getExteriorRing(),graph);}
if(g instanceof jsts.geom.MultiPolygon){var mp=g;for(var i=0;i<mp.getNumGeometries();i++){var p=mp.getGeometryN(i);this.visitInteriorRing(p.getExteriorRing(),graph);}}};jsts.operation.valid.ConnectedInteriorTester.prototype.visitInteriorRing=function(ring,graph){var pts=ring.getCoordinates();var pt0=pts[0];var pt1=jsts.operation.valid.ConnectedInteriorTester.findDifferentPoint(pts,pt0);var e=graph.findEdgeInSameDirection(pt0,pt1);var de=graph.findEdgeEnd(e);var intDe=null;if(de.getLabel().getLocation(0,jsts.geomgraph.Position.RIGHT)==jsts.geom.Location.INTERIOR){intDe=de;}else if(de.getSym().getLabel().getLocation(0,jsts.geomgraph.Position.RIGHT)==jsts.geom.Location.INTERIOR){intDe=de.getSym();}
this.visitLinkedDirectedEdges(intDe);};jsts.operation.valid.ConnectedInteriorTester.prototype.visitLinkedDirectedEdges=function(start){var startDe=start;var de=start;do{de.setVisited(true);de=de.getNext();}while(de!=startDe);};jsts.operation.valid.ConnectedInteriorTester.prototype.hasUnvisitedShellEdge=function(edgeRings){for(var i=0;i<edgeRings.size();i++){var er=edgeRings.get(i);if(er.isHole()){continue;}
var edges=er.getEdges();var de=edges[0];if(de.getLabel().getLocation(0,jsts.geomgraph.Position.RIGHT)!=jsts.geom.Location.INTERIOR){continue;}
for(var j=0;j<edges.length;j++){de=edges[j];if(!de.isVisited()){disconnectedRingcoord=de.getCoordinate();return true;}}}
return false;};jsts.algorithm.InteriorPointLine=function(geometry){this.centroid;this.minDistance=Number.MAX_VALUE;this.interiorPoint=null;this.centroid=geometry.getCentroid().getCoordinate();this.addInterior(geometry);if(this.interiorPoint==null){this.addEndpoints(geometry);}};jsts.algorithm.InteriorPointLine.prototype.getInteriorPoint=function(){return this.interiorPoint;};jsts.algorithm.InteriorPointLine.prototype.addInterior=function(geometry){if(geometry instanceof jsts.geom.LineString){this.addInteriorCoord(geometry.getCoordinates());}else if(geometry instanceof jsts.geom.GeometryCollection){for(var i=0;i<geometry.getNumGeometries();i++){this.addInterior(geometry.getGeometryN(i));}}};jsts.algorithm.InteriorPointLine.prototype.addInteriorCoord=function(pts){for(var i=1;i<pts.length-1;i++){this.add(pts[i]);}};jsts.algorithm.InteriorPointLine.prototype.addEndpoints=function(geometry){if(geometry instanceof jsts.geom.LineString){this.addEndpointsCoord(geometry.getCoordinates());}else if(geometry instanceof jsts.geom.GeometryCollection){for(var i=0;i<geometry.getNumGeometries();i++){this.addEndpoints(geometry.getGeometryN(i));}}};jsts.algorithm.InteriorPointLine.prototype.addEndpointsCoord=function(pts){this.add(pts[0]);this.add(pts[pts.length-1]);};jsts.algorithm.InteriorPointLine.prototype.add=function(point){var dist=point.distance(this.centroid);if(dist<this.minDistance){this.interiorPoint=new jsts.geom.Coordinate(point);this.minDistance=dist;}};jsts.index.chain.MonotoneChainSelectAction=function(){this.tempEnv1=new jsts.geom.Envelope();this.selectedSegment=new jsts.geom.LineSegment();};jsts.index.chain.MonotoneChainSelectAction.prototype.tempEnv1=null;jsts.index.chain.MonotoneChainSelectAction.prototype.selectedSegment=null;jsts.index.chain.MonotoneChainSelectAction.prototype.select=function(mc,start){mc.getLineSegment(start,this.selectedSegment);this.select2(this.selectedSegment);};jsts.index.chain.MonotoneChainSelectAction.prototype.select2=function(seg){};jsts.algorithm.MCPointInRing=function(ring){this.ring=ring;this.tree=null;this.crossings=0;this.interval=new jsts.index.bintree.Interval();this.buildIndex();};jsts.algorithm.MCPointInRing.MCSelecter=function(p,parent){this.parent=parent;this.p=p;};jsts.algorithm.MCPointInRing.MCSelecter.prototype=new jsts.index.chain.MonotoneChainSelectAction;jsts.algorithm.MCPointInRing.MCSelecter.prototype.constructor=jsts.algorithm.MCPointInRing.MCSelecter;jsts.algorithm.MCPointInRing.MCSelecter.prototype.select2=function(ls){this.parent.testLineSegment.apply(this.parent,[this.p,ls]);};jsts.algorithm.MCPointInRing.prototype.buildIndex=function(){this.tree=new jsts.index.bintree.Bintree();var pts=jsts.geom.CoordinateArrays.removeRepeatedPoints(this.ring.getCoordinates());var mcList=jsts.index.chain.MonotoneChainBuilder.getChains(pts);for(var i=0;i<mcList.length;i++){var mc=mcList[i];var mcEnv=mc.getEnvelope();this.interval.min=mcEnv.getMinY();this.interval.max=mcEnv.getMaxY();this.tree.insert(this.interval,mc);}};jsts.algorithm.MCPointInRing.prototype.isInside=function(pt){this.crossings=0;var rayEnv=new jsts.geom.Envelope(-Number.MAX_VALUE,Number.MAX_VALUE,pt.y,pt.y);this.interval.min=pt.y;this.interval.max=pt.y;var segs=this.tree.query(this.interval);var mcSelecter=new jsts.algorithm.MCPointInRing.MCSelecter(pt,this);for(var i=segs.iterator();i.hasNext();){var mc=i.next();this.testMonotoneChain(rayEnv,mcSelecter,mc);}
if((this.crossings%2)==1){return true;}
return false;};jsts.algorithm.MCPointInRing.prototype.testMonotoneChain=function(rayEnv,mcSelecter,mc){mc.select(rayEnv,mcSelecter);};jsts.algorithm.MCPointInRing.prototype.testLineSegment=function(p,seg){var xInt,x1,y1,x2,y2,p1,p2;p1=seg.p0;p2=seg.p1;x1=p1.x-p.x;y1=p1.y-p.y;x2=p2.x-p.x;y2=p2.y-p.y;if(((y1>0)&&(y2<=0))||((y2>0)&&(y1<=0))){xInt=jsts.algorithm.RobustDeterminant.signOfDet2x2(x1,y1,x2,y2)/(y2-y1);if(0.0<xInt){this.crossings++;}}};jsts.operation.valid.TopologyValidationError=function(errorType,pt){this.errorType=errorType;this.pt=null;if(pt!=null){this.pt=pt.clone();}};jsts.operation.valid.TopologyValidationError.HOLE_OUTSIDE_SHELL=2;jsts.operation.valid.TopologyValidationError.NESTED_HOLES=3;jsts.operation.valid.TopologyValidationError.DISCONNECTED_INTERIOR=4;jsts.operation.valid.TopologyValidationError.SELF_INTERSECTION=5;jsts.operation.valid.TopologyValidationError.RING_SELF_INTERSECTION=6;jsts.operation.valid.TopologyValidationError.NESTED_SHELLS=7;jsts.operation.valid.TopologyValidationError.DUPLICATE_RINGS=8;jsts.operation.valid.TopologyValidationError.TOO_FEW_POINTS=9;jsts.operation.valid.TopologyValidationError.INVALID_COORDINATE=10;jsts.operation.valid.TopologyValidationError.RING_NOT_CLOSED=11;jsts.operation.valid.TopologyValidationError.prototype.errMsg=['Topology Validation Error','Repeated Point','Hole lies outside shell','Holes are nested','Interior is disconnected','Self-intersection','Ring Self-intersection','Nested shells','Duplicate Rings','Too few distinct points in geometry component','Invalid Coordinate','Ring is not closed'];jsts.operation.valid.TopologyValidationError.prototype.getCoordinate=function(){return this.pt;};jsts.operation.valid.TopologyValidationError.prototype.getErrorType=function(){return this.errorType;};jsts.operation.valid.TopologyValidationError.prototype.getMessage=function(){return this.errMsg[this.errorType];};jsts.operation.valid.TopologyValidationError.prototype.toString=function(){var locStr='';if(this.pt!=null){locStr=' at or near point '+this.pt;return this.getMessage()+locStr;}
return locStr;};(function(){jsts.geom.MultiPolygon=function(geometries,factory){this.geometries=geometries||[];this.factory=factory;};jsts.geom.MultiPolygon.prototype=new jsts.geom.GeometryCollection();jsts.geom.MultiPolygon.constructor=jsts.geom.MultiPolygon;jsts.geom.MultiPolygon.prototype.getBoundary=function(){if(this.isEmpty()){return this.getFactory().createMultiLineString(null);}
var allRings=[];for(var i=0;i<this.geometries.length;i++){var polygon=this.geometries[i];var rings=polygon.getBoundary();for(var j=0;j<rings.getNumGeometries();j++){allRings.push(rings.getGeometryN(j));}}
return this.getFactory().createMultiLineString(allRings);};jsts.geom.MultiPolygon.prototype.equalsExact=function(other,tolerance){if(!this.isEquivalentClass(other)){return false;}
return jsts.geom.GeometryCollection.prototype.equalsExact.call(this,other,tolerance);};jsts.geom.MultiPolygon.prototype.CLASS_NAME='jsts.geom.MultiPolygon';})();jsts.geom.CoordinateSequenceFilter=function(){};jsts.geom.CoordinateSequenceFilter.prototype.filter=jsts.abstractFunc;jsts.geom.CoordinateSequenceFilter.prototype.isDone=jsts.abstractFunc;jsts.geom.CoordinateSequenceFilter.prototype.isGeometryChanged=jsts.abstractFunc;(function(){var Interval=function(){this.min=0.0;this.max=0.0;if(arguments.length===1){var interval=arguments[0];this.init(interval.min,interval.max);}else if(arguments.length===2){this.init(arguments[0],arguments[1]);}};Interval.prototype.init=function(min,max){this.min=min;this.max=max;if(min>max){this.min=max;this.max=min;}};Interval.prototype.getMin=function(){return this.min;};Interval.prototype.getMax=function(){return this.max;};Interval.prototype.getWidth=function(){return(this.max-this.min);};Interval.prototype.expandToInclude=function(interval){if(interval.max>this.max){this.max=interval.max;}
if(interval.min<this.min){this.min=interval.min;}};Interval.prototype.overlaps=function(){if(arguments.length===1){return this.overlapsInterval.apply(this,arguments);}else{return this.overlapsMinMax.apply(this,arguments);}};Interval.prototype.overlapsInterval=function(interval){return this.overlaps(interval.min,interval.max);};Interval.prototype.overlapsMinMax=function(min,max){if(this.min>max||this.max<min){return false;}
return true;};Interval.prototype.contains=function(){var interval;if(arguments[0]instanceof jsts.index.bintree.Interval){interval=arguments[0];return this.containsMinMax(interval.min,interval.max);}else if(arguments.length===1){return this.containsPoint(arguments[0]);}else{return this.containsMinMax(arguments[0],arguments[1]);}};Interval.prototype.containsMinMax=function(min,max){return(min>=this.min&&max<=this.max);};Interval.prototype.containsPoint=function(p){return(p>=this.min&&p<=this.max);};jsts.index.bintree.Interval=Interval;})();jsts.index.DoubleBits=function(){};jsts.index.DoubleBits.powerOf2=function(exp){return Math.pow(2,exp);};jsts.index.DoubleBits.exponent=function(d){return jsts.index.DoubleBits.CVTFWD(64,d)-1023;};jsts.index.DoubleBits.CVTFWD=function(NumW,Qty){var Sign,Expo,Mant,Bin,nb01='';var Inf={32:{d:0x7F,c:0x80,b:0,a:0},64:{d:0x7FF0,c:0,b:0,a:0}};var ExW={32:8,64:11}[NumW],MtW=NumW-ExW-1;if(!Bin){Sign=Qty<0||1/Qty<0;if(!isFinite(Qty)){Bin=Inf[NumW];if(Sign){Bin.d+=1<<(NumW/4-1);}
Expo=Math.pow(2,ExW)-1;Mant=0;}}
if(!Bin){Expo={32:127,64:1023}[NumW];Mant=Math.abs(Qty);while(Mant>=2){Expo++;Mant/=2;}
while(Mant<1&&Expo>0){Expo--;Mant*=2;}
if(Expo<=0){Mant/=2;nb01='Zero or Denormal';}
if(NumW===32&&Expo>254){nb01='Too big for Single';Bin={d:Sign?0xFF:0x7F,c:0x80,b:0,a:0};Expo=Math.pow(2,ExW)-1;Mant=0;}}
return Expo;};(function(){var DoubleBits=jsts.index.DoubleBits;var Interval=jsts.index.bintree.Interval;var Key=function(interval){this.pt=0.0;this.level=0;this.computeKey(interval);};Key.computeLevel=function(interval){var dx=interval.getWidth(),level;level=DoubleBits.exponent(dx)+1;return level;};Key.prototype.getPoint=function(){return this.pt;};Key.prototype.getLevel=function(){return this.level;};Key.prototype.getInterval=function(){return this.interval;};Key.prototype.computeKey=function(itemInterval){this.level=Key.computeLevel(itemInterval);this.interval=new Interval();this.computeInterval(this.level,itemInterval);while(!this.interval.contains(itemInterval)){this.level+=1;this.computeInterval(this.level,itemInterval);}};Key.prototype.computeInterval=function(level,itemInterval){var size=DoubleBits.powerOf2(level);this.pt=Math.floor(itemInterval.getMin()/size)*size;this.interval.init(this.pt,this.pt+size);};jsts.index.bintree.Key=Key;})();jsts.operation.buffer.SubgraphDepthLocater=function(subgraphs){this.subgraphs=[];this.seg=new jsts.geom.LineSegment();this.subgraphs=subgraphs;};jsts.operation.buffer.SubgraphDepthLocater.prototype.subgraphs=null;jsts.operation.buffer.SubgraphDepthLocater.prototype.seg=null;jsts.operation.buffer.SubgraphDepthLocater.prototype.getDepth=function(p){var stabbedSegments=this.findStabbedSegments(p);if(stabbedSegments.length===0)
return 0;stabbedSegments.sort();var ds=stabbedSegments[0];return ds.leftDepth;};jsts.operation.buffer.SubgraphDepthLocater.prototype.findStabbedSegments=function(stabbingRayLeftPt){if(arguments.length===3){this.findStabbedSegments2.apply(this,arguments);return;}
var stabbedSegments=[];for(var i=0;i<this.subgraphs.length;i++){var bsg=this.subgraphs[i];var env=bsg.getEnvelope();if(stabbingRayLeftPt.y<env.getMinY()||stabbingRayLeftPt.y>env.getMaxY())
continue;this.findStabbedSegments2(stabbingRayLeftPt,bsg.getDirectedEdges(),stabbedSegments);}
return stabbedSegments;};jsts.operation.buffer.SubgraphDepthLocater.prototype.findStabbedSegments2=function(stabbingRayLeftPt,dirEdges,stabbedSegments){if(arguments[1]instanceof jsts.geomgraph.DirectedEdge){this.findStabbedSegments3(stabbingRayLeftPt,dirEdges,stabbedSegments);return;}
for(var i=dirEdges.iterator();i.hasNext();){var de=i.next();if(!de.isForward())
continue;this.findStabbedSegments3(stabbingRayLeftPt,de,stabbedSegments);}};jsts.operation.buffer.SubgraphDepthLocater.prototype.findStabbedSegments3=function(stabbingRayLeftPt,dirEdge,stabbedSegments){var pts=dirEdge.getEdge().getCoordinates();for(var i=0;i<pts.length-1;i++){this.seg.p0=pts[i];this.seg.p1=pts[i+1];if(this.seg.p0.y>this.seg.p1.y)
this.seg.reverse();var maxx=Math.max(this.seg.p0.x,this.seg.p1.x);if(maxx<stabbingRayLeftPt.x)
continue;if(this.seg.isHorizontal())
continue;if(stabbingRayLeftPt.y<this.seg.p0.y||stabbingRayLeftPt.y>this.seg.p1.y)
continue;if(jsts.algorithm.CGAlgorithms.computeOrientation(this.seg.p0,this.seg.p1,stabbingRayLeftPt)===jsts.algorithm.CGAlgorithms.RIGHT)
continue;var depth=dirEdge.getDepth(jsts.geomgraph.Position.LEFT);if(!this.seg.p0.equals(pts[i]))
depth=dirEdge.getDepth(jsts.geomgraph.Position.RIGHT);var ds=new jsts.operation.buffer.SubgraphDepthLocater.DepthSegment(this.seg,depth);stabbedSegments.push(ds);}};jsts.operation.buffer.SubgraphDepthLocater.DepthSegment=function(seg,depth){this.upwardSeg=new jsts.geom.LineSegment(seg);this.leftDepth=depth;};jsts.operation.buffer.SubgraphDepthLocater.DepthSegment.prototype.upwardSeg=null;jsts.operation.buffer.SubgraphDepthLocater.DepthSegment.prototype.leftDepth=null;jsts.operation.buffer.SubgraphDepthLocater.DepthSegment.prototype.compareTo=function(obj){var other=obj;var orientIndex=this.upwardSeg.orientationIndex(other.upwardSeg);if(orientIndex===0)
orientIndex=-1*other.upwardSeg.orientationIndex(upwardSeg);if(orientIndex!==0)
return orientIndex;return this.compareX(this.upwardSeg,other.upwardSeg);};jsts.operation.buffer.SubgraphDepthLocater.DepthSegment.prototype.compareX=function(seg0,seg1){var compare0=seg0.p0.compareTo(seg1.p0);if(compare0!==0)
return compare0;return seg0.p1.compareTo(seg1.p1);};jsts.noding.snapround.HotPixel=function(pt,scaleFactor,li){this.corner=[];this.originalPt=pt;this.pt=pt;this.scaleFactor=scaleFactor;this.li=li;if(this.scaleFactor!==1.0){this.pt=new jsts.geom.Coordinate(this.scale(pt.x),this.scale(pt.y));this.p0Scaled=new jsts.geom.Coordinate();this.p1Scaled=new jsts.geom.Coordinate();}
this.initCorners(this.pt);};jsts.noding.snapround.HotPixel.prototype.li=null;jsts.noding.snapround.HotPixel.prototype.pt=null;jsts.noding.snapround.HotPixel.prototype.originalPt=null;jsts.noding.snapround.HotPixel.prototype.ptScaled=null;jsts.noding.snapround.HotPixel.prototype.p0Scaled=null;jsts.noding.snapround.HotPixel.prototype.p1Scaled=null;jsts.noding.snapround.HotPixel.prototype.scaleFactor=undefined;jsts.noding.snapround.HotPixel.prototype.minx=undefined;jsts.noding.snapround.HotPixel.prototype.maxx=undefined;jsts.noding.snapround.HotPixel.prototype.miny=undefined;jsts.noding.snapround.HotPixel.prototype.maxy=undefined;jsts.noding.snapround.HotPixel.prototype.corner=null;jsts.noding.snapround.HotPixel.prototype.safeEnv=null;jsts.noding.snapround.HotPixel.prototype.getCoordinate=function(){return this.originalPt;};jsts.noding.snapround.HotPixel.SAFE_ENV_EXPANSION_FACTOR=0.75;jsts.noding.snapround.HotPixel.prototype.getSafeEnvelope=function(){if(this.safeEnv===null){var safeTolerance=jsts.noding.snapround.HotPixel.SAFE_ENV_EXPANSION_FACTOR/this.scaleFactor;this.safeEnv=new jsts.geom.Envelope(this.originalPt.x-safeTolerance,this.originalPt.x+safeTolerance,this.originalPt.y-safeTolerance,this.originalPt.y+safeTolerance);}
return this.safeEnv;};jsts.noding.snapround.HotPixel.prototype.initCorners=function(pt){var tolerance=0.5;this.minx=pt.x-tolerance;this.maxx=pt.x+tolerance;this.miny=pt.y-tolerance;this.maxy=pt.y+tolerance;this.corner[0]=new jsts.geom.Coordinate(this.maxx,this.maxy);this.corner[1]=new jsts.geom.Coordinate(this.minx,this.maxy);this.corner[2]=new jsts.geom.Coordinate(this.minx,this.miny);this.corner[3]=new jsts.geom.Coordinate(this.maxx,this.miny);};jsts.noding.snapround.HotPixel.prototype.scale=function(val){return Math.round(val*this.scaleFactor);};jsts.noding.snapround.HotPixel.prototype.intersects=function(p0,p1){if(this.scaleFactor===1.0)
return this.intersectsScaled(p0,p1);this.copyScaled(p0,this.p0Scaled);this.copyScaled(p1,this.p1Scaled);return this.intersectsScaled(this.p0Scaled,this.p1Scaled);};jsts.noding.snapround.HotPixel.prototype.copyScaled=function(p,pScaled){pScaled.x=this.scale(p.x);pScaled.y=this.scale(p.y);};jsts.noding.snapround.HotPixel.prototype.intersectsScaled=function(p0,p1){var segMinx=Math.min(p0.x,p1.x);var segMaxx=Math.max(p0.x,p1.x);var segMiny=Math.min(p0.y,p1.y);var segMaxy=Math.max(p0.y,p1.y);var isOutsidePixelEnv=this.maxx<segMinx||this.minx>segMaxx||this.maxy<segMiny||this.miny>segMaxy;if(isOutsidePixelEnv)
return false;var intersects=this.intersectsToleranceSquare(p0,p1);jsts.util.Assert.isTrue(!(isOutsidePixelEnv&&intersects),'Found bad envelope test');return intersects;};jsts.noding.snapround.HotPixel.prototype.intersectsToleranceSquare=function(p0,p1){var intersectsLeft=false;var intersectsBottom=false;this.li.computeIntersection(p0,p1,this.corner[0],this.corner[1]);if(this.li.isProper())
return true;this.li.computeIntersection(p0,p1,this.corner[1],this.corner[2]);if(this.li.isProper())
return true;if(this.li.hasIntersection())
intersectsLeft=true;this.li.computeIntersection(p0,p1,this.corner[2],this.corner[3]);if(this.li.isProper())
return true;if(this.li.hasIntersection())
intersectsBottom=true;this.li.computeIntersection(p0,p1,this.corner[3],this.corner[0]);if(this.li.isProper())
return true;if(intersectsLeft&&intersectsBottom)
return true;if(p0.equals(this.pt))
return true;if(p1.equals(this.pt))
return true;return false;};jsts.noding.snapround.HotPixel.prototype.intersectsPixelClosure=function(p0,p1){this.li.computeIntersection(p0,p1,this.corner[0],this.corner[1]);if(this.li.hasIntersection())
return true;this.li.computeIntersection(p0,p1,this.corner[1],this.corner[2]);if(this.li.hasIntersection())
return true;this.li.computeIntersection(p0,p1,this.corner[2],this.corner[3]);if(this.li.hasIntersection())
return true;this.li.computeIntersection(p0,p1,this.corner[3],this.corner[0]);if(this.li.hasIntersection())
return true;return false;};jsts.noding.snapround.HotPixel.prototype.addSnappedNode=function(segStr,segIndex){var p0=segStr.getCoordinate(segIndex);var p1=segStr.getCoordinate(segIndex+1);if(this.intersects(p0,p1)){segStr.addIntersection(this.getCoordinate(),segIndex);return true;}
return false;};jsts.operation.buffer.BufferInputLineSimplifier=function(inputLine){this.inputLine=inputLine;};jsts.operation.buffer.BufferInputLineSimplifier.simplify=function(inputLine,distanceTol){var simp=new jsts.operation.buffer.BufferInputLineSimplifier(inputLine);return simp.simplify(distanceTol);};jsts.operation.buffer.BufferInputLineSimplifier.INIT=0;jsts.operation.buffer.BufferInputLineSimplifier.DELETE=1;jsts.operation.buffer.BufferInputLineSimplifier.KEEP=1;jsts.operation.buffer.BufferInputLineSimplifier.prototype.inputLine=null;jsts.operation.buffer.BufferInputLineSimplifier.prototype.distanceTol=null;jsts.operation.buffer.BufferInputLineSimplifier.prototype.isDeleted=null;jsts.operation.buffer.BufferInputLineSimplifier.prototype.angleOrientation=jsts.algorithm.CGAlgorithms.COUNTERCLOCKWISE;jsts.operation.buffer.BufferInputLineSimplifier.prototype.simplify=function(distanceTol){this.distanceTol=Math.abs(distanceTol);if(distanceTol<0)
this.angleOrientation=jsts.algorithm.CGAlgorithms.CLOCKWISE;this.isDeleted=[];this.isDeleted.length=this.inputLine.length;var isChanged=false;do{isChanged=this.deleteShallowConcavities();}while(isChanged);return this.collapseLine();};jsts.operation.buffer.BufferInputLineSimplifier.prototype.deleteShallowConcavities=function(){var index=1;var maxIndex=this.inputLine.length-1;var midIndex=this.findNextNonDeletedIndex(index);var lastIndex=this.findNextNonDeletedIndex(midIndex);var isChanged=false;while(lastIndex<this.inputLine.length){var isMiddleVertexDeleted=false;if(this.isDeletable(index,midIndex,lastIndex,this.distanceTol)){this.isDeleted[midIndex]=jsts.operation.buffer.BufferInputLineSimplifier.DELETE;isMiddleVertexDeleted=true;isChanged=true;}
if(isMiddleVertexDeleted)
index=lastIndex;else
index=midIndex;midIndex=this.findNextNonDeletedIndex(index);lastIndex=this.findNextNonDeletedIndex(midIndex);}
return isChanged;};jsts.operation.buffer.BufferInputLineSimplifier.prototype.findNextNonDeletedIndex=function(index){var next=index+1;while(next<this.inputLine.length&&this.isDeleted[next]===jsts.operation.buffer.BufferInputLineSimplifier.DELETE)
next++;return next;};jsts.operation.buffer.BufferInputLineSimplifier.prototype.collapseLine=function(){var coordList=[];for(var i=0;i<this.inputLine.length;i++){if(this.isDeleted[i]!==jsts.operation.buffer.BufferInputLineSimplifier.DELETE)
coordList.push(this.inputLine[i]);}
return coordList;};jsts.operation.buffer.BufferInputLineSimplifier.prototype.isDeletable=function(i0,i1,i2,distanceTol){var p0=this.inputLine[i0];var p1=this.inputLine[i1];var p2=this.inputLine[i2];if(!this.isConcave(p0,p1,p2))
return false;if(!this.isShallow(p0,p1,p2,distanceTol))
return false;return this.isShallowSampled(p0,p1,i0,i2,distanceTol);};jsts.operation.buffer.BufferInputLineSimplifier.prototype.isShallowConcavity=function(p0,p1,p2,distanceTol){var orientation=jsts.algorithm.CGAlgorithms.computeOrientation(p0,p1,p2);var isAngleToSimplify=(orientation===this.angleOrientation);if(!isAngleToSimplify)
return false;var dist=jsts.algorithm.CGAlgorithms.distancePointLine(p1,p0,p2);return dist<distanceTol;};jsts.operation.buffer.BufferInputLineSimplifier.NUM_PTS_TO_CHECK=10;jsts.operation.buffer.BufferInputLineSimplifier.prototype.isShallowSampled=function(p0,p2,i0,i2,distanceTol){var inc=parseInt((i2-i0)/jsts.operation.buffer.BufferInputLineSimplifier.NUM_PTS_TO_CHECK);if(inc<=0)
inc=1;for(var i=i0;i<i2;i+=inc){if(!this.isShallow(p0,p2,this.inputLine[i],distanceTol))
return false;}
return true;};jsts.operation.buffer.BufferInputLineSimplifier.prototype.isShallow=function(p0,p1,p2,distanceTol){var dist=jsts.algorithm.CGAlgorithms.distancePointLine(p1,p0,p2);return dist<distanceTol;};jsts.operation.buffer.BufferInputLineSimplifier.prototype.isConcave=function(p0,p1,p2){var orientation=jsts.algorithm.CGAlgorithms.computeOrientation(p0,p1,p2);var isConcave=(orientation===this.angleOrientation);return isConcave;};jsts.geomgraph.index.SweepLineEvent=function(x,obj,label){if(!(obj instanceof jsts.geomgraph.index.SweepLineEvent)){this.eventType=jsts.geomgraph.index.SweepLineEvent.INSERT;this.label=label;this.xValue=x;this.obj=obj;return;}
this.eventType=jsts.geomgraph.index.SweepLineEvent.DELETE;this.xValue=x;this.insertEvent=obj;};jsts.geomgraph.index.SweepLineEvent.INSERT=1;jsts.geomgraph.index.SweepLineEvent.DELETE=2;jsts.geomgraph.index.SweepLineEvent.prototype.label=null;jsts.geomgraph.index.SweepLineEvent.prototype.xValue=null;jsts.geomgraph.index.SweepLineEvent.prototype.eventType=null;jsts.geomgraph.index.SweepLineEvent.prototype.insertEvent=null;jsts.geomgraph.index.SweepLineEvent.prototype.deleteEventIndex=null;jsts.geomgraph.index.SweepLineEvent.prototype.obj=null;jsts.geomgraph.index.SweepLineEvent.prototype.isInsert=function(){return this.eventType==jsts.geomgraph.index.SweepLineEvent.INSERT;};jsts.geomgraph.index.SweepLineEvent.prototype.isDelete=function(){return this.eventType==jsts.geomgraph.index.SweepLineEvent.DELETE;};jsts.geomgraph.index.SweepLineEvent.prototype.getInsertEvent=function(){return this.insertEvent;};jsts.geomgraph.index.SweepLineEvent.prototype.getDeleteEventIndex=function(){return this.deleteEventIndex;};jsts.geomgraph.index.SweepLineEvent.prototype.setDeleteEventIndex=function(deleteEventIndex){this.deleteEventIndex=deleteEventIndex;};jsts.geomgraph.index.SweepLineEvent.prototype.getObject=function(){return this.obj;};jsts.geomgraph.index.SweepLineEvent.prototype.isSameLabel=function(ev){if(this.label==null){return false;}
return this.label==ev.label;};jsts.geomgraph.index.SweepLineEvent.prototype.compareTo=function(pe){if(this.xValue<pe.xValue){return-1;}
if(this.xValue>pe.xValue){return 1;}
if(this.eventType<pe.eventType){return-1;}
if(this.eventType>pe.eventType){return 1;}
return 0;};jsts.geom.CoordinateList=function(coord,allowRepeated){this.array=[];allowRepeated=(allowRepeated===undefined)?true:allowRepeated;if(coord!==undefined){this.add(coord,allowRepeated);}};jsts.geom.CoordinateList.prototype=new javascript.util.ArrayList();jsts.geom.CoordinateList.prototype.iterator=null;jsts.geom.CoordinateList.prototype.remove=null;jsts.geom.CoordinateList.prototype.get=function(i){return this.array[i];};jsts.geom.CoordinateList.prototype.set=function(i,e){var o=this.array[i];this.array[i]=e;return o;};jsts.geom.CoordinateList.prototype.size=function(){return this.array.length;};jsts.geom.CoordinateList.prototype.add=function(){if(arguments.length>1){return this.addCoordinates.apply(this,arguments);}else{return this.array.push(arguments[0]);}};jsts.geom.CoordinateList.prototype.addCoordinates=function(coord,allowRepeated,direction){if(coord instanceof jsts.geom.Coordinate){return this.addCoordinate.apply(this,arguments);}else if(typeof coord==='number'){return this.insertCoordinate.apply(this,arguments);}
direction=direction||true;if(direction){for(var i=0;i<coord.length;i++){this.addCoordinate(coord[i],allowRepeated);}}else{for(var i=coord.length-1;i>=0;i--){this.addCoordinate(coord[i],allowRepeated);}}
return true;};jsts.geom.CoordinateList.prototype.addCoordinate=function(coord,allowRepeated){if(!allowRepeated){if(this.size()>=1){var last=this.get(this.size()-1);if(last.equals2D(coord))return;}}
this.add(coord);};jsts.geom.CoordinateList.prototype.insertCoordinate=function(index,coord,allowRepeated){if(!allowRepeated){var before=index>0?index-1:-1;if(before!==-1&&this.get(before).equals2D(coord)){return;}
var after=index<this.size()-1?index+1:-1;if(after!==-1&&this.get(after).equals2D(coord)){return;}}
this.array.splice(index,0,coord);};jsts.geom.CoordinateList.prototype.closeRing=function(){if(this.size()>0){this.addCoordinate(new jsts.geom.Coordinate(this.get(0)),false);}};jsts.geom.CoordinateList.prototype.toArray=function(){return this.array;};jsts.geom.CoordinateList.prototype.toCoordinateArray=function(){return this.array;};jsts.operation.buffer.OffsetSegmentGenerator=function(precisionModel,bufParams,distance){this.seg0=new jsts.geom.LineSegment();this.seg1=new jsts.geom.LineSegment();this.offset0=new jsts.geom.LineSegment();this.offset1=new jsts.geom.LineSegment();this.precisionModel=precisionModel;this.bufParams=bufParams;this.li=new jsts.algorithm.RobustLineIntersector();this.filletAngleQuantum=Math.PI/2.0/bufParams.getQuadrantSegments();if(this.bufParams.getQuadrantSegments()>=8&&this.bufParams.getJoinStyle()===jsts.operation.buffer.BufferParameters.JOIN_ROUND){this.closingSegLengthFactor=jsts.operation.buffer.OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR;}
this.init(distance);};jsts.operation.buffer.OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR=1.0E-3;jsts.operation.buffer.OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR=1.0E-3;jsts.operation.buffer.OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR=1.0E-6;jsts.operation.buffer.OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR=80;jsts.operation.buffer.OffsetSegmentGenerator.prototype.maxCurveSegmentError=0.0;jsts.operation.buffer.OffsetSegmentGenerator.prototype.filletAngleQuantum=null;jsts.operation.buffer.OffsetSegmentGenerator.prototype.closingSegLengthFactor=1;jsts.operation.buffer.OffsetSegmentGenerator.prototype.segList=null;jsts.operation.buffer.OffsetSegmentGenerator.prototype.distance=0.0;jsts.operation.buffer.OffsetSegmentGenerator.prototype.precisionModel=null;jsts.operation.buffer.OffsetSegmentGenerator.prototype.bufParams=null;jsts.operation.buffer.OffsetSegmentGenerator.prototype.li=null;jsts.operation.buffer.OffsetSegmentGenerator.prototype.s0=null;jsts.operation.buffer.OffsetSegmentGenerator.prototype.s1=null;jsts.operation.buffer.OffsetSegmentGenerator.prototype.s2=null;jsts.operation.buffer.OffsetSegmentGenerator.prototype.seg0=null;jsts.operation.buffer.OffsetSegmentGenerator.prototype.seg1=null;jsts.operation.buffer.OffsetSegmentGenerator.prototype.offset0=null;jsts.operation.buffer.OffsetSegmentGenerator.prototype.offset1=null;jsts.operation.buffer.OffsetSegmentGenerator.prototype.side=0;jsts.operation.buffer.OffsetSegmentGenerator.prototype.hasNarrowConcaveAngle=false;jsts.operation.buffer.OffsetSegmentGenerator.prototype.hasNarrowConcaveAngle=function(){return this.hasNarrowConcaveAngle;};jsts.operation.buffer.OffsetSegmentGenerator.prototype.init=function(distance){this.distance=distance;this.maxCurveSegmentError=this.distance*(1-Math.cos(this.filletAngleQuantum/2.0));this.segList=new jsts.operation.buffer.OffsetSegmentString();this.segList.setPrecisionModel(this.precisionModel);this.segList.setMinimumVertexDistance(this.distance*jsts.operation.buffer.OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);};jsts.operation.buffer.OffsetSegmentGenerator.prototype.initSideSegments=function(s1,s2,side){this.s1=s1;this.s2=s2;this.side=side;this.seg1.setCoordinates(this.s1,this.s2);this.computeOffsetSegment(this.seg1,this.side,this.distance,this.offset1);};jsts.operation.buffer.OffsetSegmentGenerator.prototype.getCoordinates=function(){return this.segList.getCoordinates();};jsts.operation.buffer.OffsetSegmentGenerator.prototype.closeRing=function(){this.segList.closeRing();};jsts.operation.buffer.OffsetSegmentGenerator.prototype.addSegments=function(pt,isForward){this.segList.addPts(pt,isForward);};jsts.operation.buffer.OffsetSegmentGenerator.prototype.addFirstSegment=function(){this.segList.addPt(this.offset1.p0);};jsts.operation.buffer.OffsetSegmentGenerator.prototype.addLastSegment=function(){this.segList.addPt(this.offset1.p1);};jsts.operation.buffer.OffsetSegmentGenerator.prototype.addNextSegment=function(p,addStartPoint){this.s0=this.s1;this.s1=this.s2;this.s2=p;this.seg0.setCoordinates(this.s0,this.s1);this.computeOffsetSegment(this.seg0,this.side,this.distance,this.offset0);this.seg1.setCoordinates(this.s1,this.s2);this.computeOffsetSegment(this.seg1,this.side,this.distance,this.offset1);if(this.s1.equals(this.s2))
return;var orientation=jsts.algorithm.CGAlgorithms.computeOrientation(this.s0,this.s1,this.s2);var outsideTurn=(orientation===jsts.algorithm.CGAlgorithms.CLOCKWISE&&this.side===jsts.geomgraph.Position.LEFT)||(orientation===jsts.algorithm.CGAlgorithms.COUNTERCLOCKWISE&&this.side===jsts.geomgraph.Position.RIGHT);if(orientation==0){this.addCollinear(addStartPoint);}else if(outsideTurn){this.addOutsideTurn(orientation,addStartPoint);}else{this.addInsideTurn(orientation,addStartPoint);}};jsts.operation.buffer.OffsetSegmentGenerator.prototype.addCollinear=function(addStartPoint){this.li.computeIntersection(this.s0,this.s1,this.s1,this.s2);var numInt=this.li.getIntersectionNum();if(numInt>=2){if(this.bufParams.getJoinStyle()===jsts.operation.buffer.BufferParameters.JOIN_BEVEL||this.bufParams.getJoinStyle()===jsts.operation.buffer.BufferParameters.JOIN_MITRE){if(addStartPoint)
this.segList.addPt(this.offset0.p1);this.segList.addPt(this.offset1.p0);}else{this.addFillet(this.s1,this.offset0.p1,this.offset1.p0,jsts.algorithm.CGAlgorithms.CLOCKWISE,this.distance);}}};jsts.operation.buffer.OffsetSegmentGenerator.prototype.addOutsideTurn=function(orientation,addStartPoint){if(this.offset0.p1.distance(this.offset1.p0)<this.distance*jsts.operation.buffer.OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR){this.segList.addPt(this.offset0.p1);return;}
if(this.bufParams.getJoinStyle()===jsts.operation.buffer.BufferParameters.JOIN_MITRE){this.addMitreJoin(this.s1,this.offset0,this.offset1,this.distance);}else if(this.bufParams.getJoinStyle()===jsts.operation.buffer.BufferParameters.JOIN_BEVEL){this.addBevelJoin(this.offset0,this.offset1);}else{if(addStartPoint)
this.segList.addPt(this.offset0.p1);this.addFillet(this.s1,this.offset0.p1,this.offset1.p0,orientation,this.distance);this.segList.addPt(this.offset1.p0);}};jsts.operation.buffer.OffsetSegmentGenerator.prototype.addInsideTurn=function(orientation,addStartPoint){this.li.computeIntersection(this.offset0.p0,this.offset0.p1,this.offset1.p0,this.offset1.p1);if(this.li.hasIntersection()){this.segList.addPt(this.li.getIntersection(0));}else{this.hasNarrowConcaveAngle=true;if(this.offset0.p1.distance(this.offset1.p0)<this.distance*jsts.operation.buffer.OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR){this.segList.addPt(this.offset0.p1);}else{this.segList.addPt(this.offset0.p1);if(this.closingSegLengthFactor>0){var mid0=new jsts.geom.Coordinate((this.closingSegLengthFactor*this.offset0.p1.x+this.s1.x)/(this.closingSegLengthFactor+1),(this.closingSegLengthFactor*this.offset0.p1.y+this.s1.y)/(this.closingSegLengthFactor+1));this.segList.addPt(mid0);var mid1=new jsts.geom.Coordinate((this.closingSegLengthFactor*this.offset1.p0.x+this.s1.x)/(this.closingSegLengthFactor+1),(this.closingSegLengthFactor*this.offset1.p0.y+this.s1.y)/(this.closingSegLengthFactor+1));this.segList.addPt(mid1);}else{this.segList.addPt(this.s1);}
this.segList.addPt(this.offset1.p0);}}};jsts.operation.buffer.OffsetSegmentGenerator.prototype.computeOffsetSegment=function(seg,side,distance,offset){var sideSign=side===jsts.geomgraph.Position.LEFT?1:-1;var dx=seg.p1.x-seg.p0.x;var dy=seg.p1.y-seg.p0.y;var len=Math.sqrt(dx*dx+dy*dy);var ux=sideSign*distance*dx/len;var uy=sideSign*distance*dy/len;offset.p0.x=seg.p0.x-uy;offset.p0.y=seg.p0.y+ux;offset.p1.x=seg.p1.x-uy;offset.p1.y=seg.p1.y+ux;};jsts.operation.buffer.OffsetSegmentGenerator.prototype.addLineEndCap=function(p0,p1){var seg=new jsts.geom.LineSegment(p0,p1);var offsetL=new jsts.geom.LineSegment();this.computeOffsetSegment(seg,jsts.geomgraph.Position.LEFT,this.distance,offsetL);var offsetR=new jsts.geom.LineSegment();this.computeOffsetSegment(seg,jsts.geomgraph.Position.RIGHT,this.distance,offsetR);var dx=p1.x-p0.x;var dy=p1.y-p0.y;var angle=Math.atan2(dy,dx);switch(this.bufParams.getEndCapStyle()){case jsts.operation.buffer.BufferParameters.CAP_ROUND:this.segList.addPt(offsetL.p1);this.addFillet(p1,angle+Math.PI/2,angle-Math.PI/2,jsts.algorithm.CGAlgorithms.CLOCKWISE,this.distance);this.segList.addPt(offsetR.p1);break;case jsts.operation.buffer.BufferParameters.CAP_FLAT:this.segList.addPt(offsetL.p1);this.segList.addPt(offsetR.p1);break;case jsts.operation.buffer.BufferParameters.CAP_SQUARE:var squareCapSideOffset=new jsts.geom.Coordinate();squareCapSideOffset.x=Math.abs(this.distance)*Math.cos(angle);squareCapSideOffset.y=Math.abs(this.distance)*Math.sin(angle);var squareCapLOffset=new jsts.geom.Coordinate(offsetL.p1.x+
squareCapSideOffset.x,offsetL.p1.y+squareCapSideOffset.y);var squareCapROffset=new jsts.geom.Coordinate(offsetR.p1.x+
squareCapSideOffset.x,offsetR.p1.y+squareCapSideOffset.y);this.segList.addPt(squareCapLOffset);this.segList.addPt(squareCapROffset);break;}};jsts.operation.buffer.OffsetSegmentGenerator.prototype.addMitreJoin=function(p,offset0,offset1,distance){var isMitreWithinLimit=true;var intPt=null;try{intPt=jsts.algorithm.HCoordinate.intersection(offset0.p0,offset0.p1,offset1.p0,offset1.p1);var mitreRatio=distance<=0.0?1.0:intPt.distance(p)/Math.abs(distance);if(mitreRatio>this.bufParams.getMitreLimit())
this.isMitreWithinLimit=false;}catch(e){if(e instanceof jsts.error.NotRepresentableError){intPt=new jsts.geom.Coordinate(0,0);this.isMitreWithinLimit=false;}}
if(isMitreWithinLimit){this.segList.addPt(intPt);}else{this.addLimitedMitreJoin(offset0,offset1,distance,bufParams.getMitreLimit());}};jsts.operation.buffer.OffsetSegmentGenerator.prototype.addLimitedMitreJoin=function(offset0,offset1,distance,mitreLimit){var basePt=this.seg0.p1;var ang0=jsts.algorithm.Angle.angle(basePt,this.seg0.p0);var ang1=jsts.algorithm.Angle.angle(basePt,this.seg1.p1);var angDiff=jsts.algorithm.Angle.angleBetweenOriented(this.seg0.p0,basePt,this.seg1.p1);var angDiffHalf=angDiff/2;var midAng=jsts.algorithm.Angle.normalize(ang0+angDiffHalf);var mitreMidAng=jsts.algorithm.Angle.normalize(midAng+Math.PI);var mitreDist=mitreLimit*distance;var bevelDelta=mitreDist*Math.abs(Math.sin(angDiffHalf));var bevelHalfLen=distance-bevelDelta;var bevelMidX=basePt.x+mitreDist*Math.cos(mitreMidAng);var bevelMidY=basePt.y+mitreDist*Math.sin(mitreMidAng);var bevelMidPt=new jsts.geom.Coordinate(bevelMidX,bevelMidY);var mitreMidLine=new jsts.geom.LineSegment(basePt,bevelMidPt);var bevelEndLeft=mitreMidLine.pointAlongOffset(1.0,bevelHalfLen);var bevelEndRight=mitreMidLine.pointAlongOffset(1.0,-bevelHalfLen);if(this.side==jsts.geomgraph.Position.LEFT){this.segList.addPt(bevelEndLeft);this.segList.addPt(bevelEndRight);}else{this.segList.addPt(bevelEndRight);this.segList.addPt(bevelEndLeft);}};jsts.operation.buffer.OffsetSegmentGenerator.prototype.addBevelJoin=function(offset0,offset1){this.segList.addPt(offset0.p1);this.segList.addPt(offset1.p0);};jsts.operation.buffer.OffsetSegmentGenerator.prototype.addFillet=function(p,p0,p1,direction,radius){if(!(p1 instanceof jsts.geom.Coordinate)){this.addFillet2.apply(this,arguments);return;}
var dx0=p0.x-p.x;var dy0=p0.y-p.y;var startAngle=Math.atan2(dy0,dx0);var dx1=p1.x-p.x;var dy1=p1.y-p.y;var endAngle=Math.atan2(dy1,dx1);if(direction===jsts.algorithm.CGAlgorithms.CLOCKWISE){if(startAngle<=endAngle)
startAngle+=2.0*Math.PI;}else{if(startAngle>=endAngle)
startAngle-=2.0*Math.PI;}
this.segList.addPt(p0);this.addFillet(p,startAngle,endAngle,direction,radius);this.segList.addPt(p1);};jsts.operation.buffer.OffsetSegmentGenerator.prototype.addFillet2=function(p,startAngle,endAngle,direction,radius){var directionFactor=direction===jsts.algorithm.CGAlgorithms.CLOCKWISE?-1:1;var totalAngle=Math.abs(startAngle-endAngle);var nSegs=parseInt((totalAngle/this.filletAngleQuantum+0.5));if(nSegs<1)
return;var initAngle,currAngleInc;initAngle=0.0;currAngleInc=totalAngle/nSegs;var currAngle=initAngle;var pt=new jsts.geom.Coordinate();while(currAngle<totalAngle){var angle=startAngle+directionFactor*currAngle;pt.x=p.x+radius*Math.cos(angle);pt.y=p.y+radius*Math.sin(angle);this.segList.addPt(pt);currAngle+=currAngleInc;}};jsts.operation.buffer.OffsetSegmentGenerator.prototype.createCircle=function(p){var pt=new jsts.geom.Coordinate(p.x+this.distance,p.y);this.segList.addPt(pt);this.addFillet(p,0.0,2.0*Math.PI,-1,this.distance);this.segList.closeRing();};jsts.operation.buffer.OffsetSegmentGenerator.prototype.createSquare=function(p){this.segList.addPt(new jsts.geom.Coordinate(p.x+distance,p.y+distance));this.segList.addPt(new jsts.geom.Coordinate(p.x+distance,p.y-distance));this.segList.addPt(new jsts.geom.Coordinate(p.x-distance,p.y-distance));this.segList.addPt(new jsts.geom.Coordinate(p.x-distance,p.y+distance));this.segList.closeRing();};jsts.operation.overlay.MaximalEdgeRing=function(start,geometryFactory){jsts.geomgraph.EdgeRing.call(this,start,geometryFactory);};jsts.operation.overlay.MaximalEdgeRing.prototype=new jsts.geomgraph.EdgeRing();jsts.operation.overlay.MaximalEdgeRing.constructor=jsts.operation.overlay.MaximalEdgeRing;jsts.operation.overlay.MaximalEdgeRing.prototype.getNext=function(de)
{return de.getNext();};jsts.operation.overlay.MaximalEdgeRing.prototype.setEdgeRing=function(de,er)
{de.setEdgeRing(er);};jsts.operation.overlay.MaximalEdgeRing.prototype.linkDirectedEdgesForMinimalEdgeRings=function()
{var de=this.startDe;do{var node=de.getNode();node.getEdges().linkMinimalDirectedEdges(this);de=de.getNext();}while(de!=this.startDe);};jsts.operation.overlay.MaximalEdgeRing.prototype.buildMinimalRings=function()
{var minEdgeRings=[];var de=this.startDe;do{if(de.getMinEdgeRing()===null){var minEr=new jsts.operation.overlay.MinimalEdgeRing(de,this.geometryFactory);minEdgeRings.push(minEr);}
de=de.getNext();}while(de!=this.startDe);return minEdgeRings;};jsts.algorithm.CentroidPoint=function(){this.centSum=new jsts.geom.Coordinate();};jsts.algorithm.CentroidPoint.prototype.ptCount=0;jsts.algorithm.CentroidPoint.prototype.centSum=null;jsts.algorithm.CentroidPoint.prototype.add=function(geom){if(geom instanceof jsts.geom.Point){this.add2(geom.getCoordinate());}else if(geom instanceof jsts.geom.GeometryCollection||geom instanceof jsts.geom.MultiPoint||geom instanceof jsts.geom.MultiLineString||geom instanceof jsts.geom.MultiPolygon){var gc=geom;for(var i=0;i<gc.getNumGeometries();i++){this.add(gc.getGeometryN(i));}}};jsts.algorithm.CentroidPoint.prototype.add2=function(pt){this.ptCount+=1;this.centSum.x+=pt.x;this.centSum.y+=pt.y;};jsts.algorithm.CentroidPoint.prototype.getCentroid=function(){var cent=new jsts.geom.Coordinate();cent.x=this.centSum.x/this.ptCount;cent.y=this.centSum.y/this.ptCount;return cent;};jsts.operation.distance.ConnectedElementLocationFilter=function(locations){this.locations=locations;};jsts.operation.distance.ConnectedElementLocationFilter.prototype=new jsts.geom.GeometryFilter();jsts.operation.distance.ConnectedElementLocationFilter.prototype.locations=null;jsts.operation.distance.ConnectedElementLocationFilter.getLocations=function(geom){var locations=[];geom.apply(new jsts.operation.distance.ConnectedElementLocationFilter(locations));return locations;};jsts.operation.distance.ConnectedElementLocationFilter.prototype.filter=function(geom){if(geom instanceof jsts.geom.Point||geom instanceof jsts.geom.LineString||geom instanceof jsts.geom.Polygon)
this.locations.push(new jsts.operation.distance.GeometryLocation(geom,0,geom.getCoordinate()));};jsts.geomgraph.index.MonotoneChainEdge=function(e){this.e=e;this.pts=e.getCoordinates();var mcb=new jsts.geomgraph.index.MonotoneChainIndexer();this.startIndex=mcb.getChainStartIndices(this.pts);};jsts.geomgraph.index.MonotoneChainEdge.prototype.e=null;jsts.geomgraph.index.MonotoneChainEdge.prototype.pts=null;jsts.geomgraph.index.MonotoneChainEdge.prototype.startIndex=null;jsts.geomgraph.index.MonotoneChainEdge.prototype.env1=new jsts.geom.Envelope();jsts.geomgraph.index.MonotoneChainEdge.prototype.env2=new jsts.geom.Envelope();jsts.geomgraph.index.MonotoneChainEdge.prototype.getCoordinates=function(){return this.pts;};jsts.geomgraph.index.MonotoneChainEdge.prototype.getStartIndexes=function(){return this.startIndex;};jsts.geomgraph.index.MonotoneChainEdge.prototype.getMinX=function(chainIndex){var x1=this.pts[this.startIndex[chainIndex]].x;var x2=this.pts[this.startIndex[chainIndex+1]].x;if(x1<x2){return x1;}
return x2;};jsts.geomgraph.index.MonotoneChainEdge.prototype.getMaxX=function(chainIndex){var x1=this.pts[this.startIndex[chainIndex]].x;var x2=this.pts[this.startIndex[chainIndex+1]].x;if(x1>x2){return x1;}
return x2;};jsts.geomgraph.index.MonotoneChainEdge.prototype.computeIntersects=function(mce,si){for(var i=0;i<this.startIndex.length-1;i++){for(var j=0;j<mce.startIndex.length-1;j++){this.computeIntersectsForChain(i,mce,j,si);}}};jsts.geomgraph.index.MonotoneChainEdge.prototype.computeIntersectsForChain=function(chainIndex0,mce,chainIndex1,si){this.computeIntersectsForChain2(this.startIndex[chainIndex0],this.startIndex[chainIndex0+1],mce,mce.startIndex[chainIndex1],mce.startIndex[chainIndex1+1],si);};jsts.geomgraph.index.MonotoneChainEdge.prototype.computeIntersectsForChain2=function(start0,end0,mce,start1,end1,ei){var p00=this.pts[start0];var p01=this.pts[end0];var p10=mce.pts[start1];var p11=mce.pts[end1];if(end0-start0==1&&end1-start1==1){ei.addIntersections(this.e,start0,mce.e,start1);return;}
this.env1.init(p00,p01);this.env2.init(p10,p11);if(!this.env1.intersects(this.env2)){return;}
var mid0=Math.floor((start0+end0)/2);var mid1=Math.floor((start1+end1)/2);if(start0<mid0){if(start1<mid1){this.computeIntersectsForChain2(start0,mid0,mce,start1,mid1,ei);}
if(mid1<end1){this.computeIntersectsForChain2(start0,mid0,mce,mid1,end1,ei);}}
if(mid0<end0){if(start1<mid1){this.computeIntersectsForChain2(mid0,end0,mce,start1,mid1,ei);}
if(mid1<end1){this.computeIntersectsForChain2(mid0,end0,mce,mid1,end1,ei);}}};(function(){var ArrayList=javascript.util.ArrayList;jsts.operation.relate.EdgeEndBuilder=function(){};jsts.operation.relate.EdgeEndBuilder.prototype.computeEdgeEnds=function(edges){if(arguments.length==2){this.computeEdgeEnds2.apply(this,arguments);return;}
var l=new ArrayList();for(var i=edges;i.hasNext();){var e=i.next();this.computeEdgeEnds2(e,l);}
return l;};jsts.operation.relate.EdgeEndBuilder.prototype.computeEdgeEnds2=function(edge,l){var eiList=edge.getEdgeIntersectionList();eiList.addEndpoints();var it=eiList.iterator();var eiPrev=null;var eiCurr=null;if(!it.hasNext())
return;var eiNext=it.next();do{eiPrev=eiCurr;eiCurr=eiNext;eiNext=null;if(it.hasNext())
eiNext=it.next();if(eiCurr!==null){this.createEdgeEndForPrev(edge,l,eiCurr,eiPrev);this.createEdgeEndForNext(edge,l,eiCurr,eiNext);}}while(eiCurr!==null);};jsts.operation.relate.EdgeEndBuilder.prototype.createEdgeEndForPrev=function(edge,l,eiCurr,eiPrev){var iPrev=eiCurr.segmentIndex;if(eiCurr.dist===0.0){if(iPrev===0)
return;iPrev--;}
var pPrev=edge.getCoordinate(iPrev);if(eiPrev!==null&&eiPrev.segmentIndex>=iPrev)
pPrev=eiPrev.coord;var label=new jsts.geomgraph.Label(edge.getLabel());label.flip();var e=new jsts.geomgraph.EdgeEnd(edge,eiCurr.coord,pPrev,label);l.add(e);};jsts.operation.relate.EdgeEndBuilder.prototype.createEdgeEndForNext=function(edge,l,eiCurr,eiNext){var iNext=eiCurr.segmentIndex+1;if(iNext>=edge.getNumPoints()&&eiNext===null)
return;var pNext=edge.getCoordinate(iNext);if(eiNext!==null&&eiNext.segmentIndex===eiCurr.segmentIndex)
pNext=eiNext.coord;var e=new jsts.geomgraph.EdgeEnd(edge,eiCurr.coord,pNext,new jsts.geomgraph.Label(edge.getLabel()));l.add(e);};})();(function(){var ArrayList=javascript.util.ArrayList;var TreeSet=javascript.util.TreeSet;var CoordinateFilter=jsts.geom.CoordinateFilter;jsts.util.UniqueCoordinateArrayFilter=function(){this.treeSet=new TreeSet();this.list=new ArrayList();};jsts.util.UniqueCoordinateArrayFilter.prototype=new CoordinateFilter();jsts.util.UniqueCoordinateArrayFilter.prototype.treeSet=null;jsts.util.UniqueCoordinateArrayFilter.prototype.list=null;jsts.util.UniqueCoordinateArrayFilter.prototype.getCoordinates=function(){return this.list.toArray();};jsts.util.UniqueCoordinateArrayFilter.prototype.filter=function(coord){if(!this.treeSet.contains(coord)){this.list.add(coord);this.treeSet.add(coord);}};})();(function(){var CGAlgorithms=jsts.algorithm.CGAlgorithms;var UniqueCoordinateArrayFilter=jsts.util.UniqueCoordinateArrayFilter;var Assert=jsts.util.Assert;var Stack=javascript.util.Stack;var ArrayList=javascript.util.ArrayList;var Arrays=javascript.util.Arrays;var RadialComparator=function(origin){this.origin=origin;};RadialComparator.prototype.origin=null;RadialComparator.prototype.compare=function(o1,o2){var p1=o1;var p2=o2;return RadialComparator.polarCompare(this.origin,p1,p2);};RadialComparator.polarCompare=function(o,p,q){var dxp=p.x-o.x;var dyp=p.y-o.y;var dxq=q.x-o.x;var dyq=q.y-o.y;var orient=CGAlgorithms.computeOrientation(o,p,q);if(orient==CGAlgorithms.COUNTERCLOCKWISE)
return 1;if(orient==CGAlgorithms.CLOCKWISE)
return-1;var op=dxp*dxp+dyp*dyp;var oq=dxq*dxq+dyq*dyq;if(op<oq){return-1;}
if(op>oq){return 1;}
return 0;};jsts.algorithm.ConvexHull=function(){if(arguments.length===1){var geometry=arguments[0];this.inputPts=jsts.algorithm.ConvexHull.extractCoordinates(geometry);this.geomFactory=geometry.getFactory();}else{this.pts=arguments[0];this.geomFactory=arguments[1];}};jsts.algorithm.ConvexHull.prototype.geomFactory=null;jsts.algorithm.ConvexHull.prototype.inputPts=null;jsts.algorithm.ConvexHull.extractCoordinates=function(geom){var filter=new UniqueCoordinateArrayFilter();geom.apply(filter);return filter.getCoordinates();};jsts.algorithm.ConvexHull.prototype.getConvexHull=function(){if(this.inputPts.length==0){return this.geomFactory.createGeometryCollection(null);}
if(this.inputPts.length==1){return this.geomFactory.createPoint(this.inputPts[0]);}
if(this.inputPts.length==2){return this.geomFactory.createLineString(this.inputPts);}
var reducedPts=this.inputPts;if(this.inputPts.length>50){reducedPts=this.reduce(this.inputPts);}
var sortedPts=this.preSort(reducedPts);var cHS=this.grahamScan(sortedPts);var cH=cHS.toArray();return this.lineOrPolygon(cH);};jsts.algorithm.ConvexHull.prototype.reduce=function(inputPts){var polyPts=this.computeOctRing(inputPts);if(polyPts==null)
return this.inputPts;var reducedSet=new javascript.util.TreeSet();for(var i=0;i<polyPts.length;i++){reducedSet.add(polyPts[i]);}
for(var i=0;i<inputPts.length;i++){if(!CGAlgorithms.isPointInRing(inputPts[i],polyPts)){reducedSet.add(inputPts[i]);}}
var reducedPts=reducedSet.toArray();if(reducedPts.length<3)
return this.padArray3(reducedPts);return reducedPts;};jsts.algorithm.ConvexHull.prototype.padArray3=function(pts){var pad=[];for(var i=0;i<pad.length;i++){if(i<pts.length){pad[i]=pts[i];}else
pad[i]=pts[0];}
return pad;};jsts.algorithm.ConvexHull.prototype.preSort=function(pts){var t;for(var i=1;i<pts.length;i++){if((pts[i].y<pts[0].y)||((pts[i].y==pts[0].y)&&(pts[i].x<pts[0].x))){t=pts[0];pts[0]=pts[i];pts[i]=t;}}
Arrays.sort(pts,1,pts.length,new RadialComparator(pts[0]));return pts;};jsts.algorithm.ConvexHull.prototype.grahamScan=function(c){var p;var ps=new Stack();p=ps.push(c[0]);p=ps.push(c[1]);p=ps.push(c[2]);for(var i=3;i<c.length;i++){p=ps.pop();while(!ps.empty()&&CGAlgorithms.computeOrientation(ps.peek(),p,c[i])>0){p=ps.pop();}
p=ps.push(p);p=ps.push(c[i]);}
p=ps.push(c[0]);return ps;};jsts.algorithm.ConvexHull.prototype.isBetween=function(c1,c2,c3){if(CGAlgorithms.computeOrientation(c1,c2,c3)!==0){return false;}
if(c1.x!=c3.x){if(c1.x<=c2.x&&c2.x<=c3.x){return true;}
if(c3.x<=c2.x&&c2.x<=c1.x){return true;}}
if(c1.y!=c3.y){if(c1.y<=c2.y&&c2.y<=c3.y){return true;}
if(c3.y<=c2.y&&c2.y<=c1.y){return true;}}
return false;};jsts.algorithm.ConvexHull.prototype.computeOctRing=function(inputPts){var octPts=this.computeOctPts(inputPts);var coordList=new jsts.geom.CoordinateList();coordList.add(octPts,false);if(coordList.size()<3){return null;}
coordList.closeRing();return coordList.toCoordinateArray();};jsts.algorithm.ConvexHull.prototype.computeOctPts=function(inputPts){var pts=[];for(var j=0;j<8;j++){pts[j]=inputPts[0];}
for(var i=1;i<inputPts.length;i++){if(inputPts[i].x<pts[0].x){pts[0]=inputPts[i];}
if(inputPts[i].x-inputPts[i].y<pts[1].x-pts[1].y){pts[1]=inputPts[i];}
if(inputPts[i].y>pts[2].y){pts[2]=inputPts[i];}
if(inputPts[i].x+inputPts[i].y>pts[3].x+pts[3].y){pts[3]=inputPts[i];}
if(inputPts[i].x>pts[4].x){pts[4]=inputPts[i];}
if(inputPts[i].x-inputPts[i].y>pts[5].x-pts[5].y){pts[5]=inputPts[i];}
if(inputPts[i].y<pts[6].y){pts[6]=inputPts[i];}
if(inputPts[i].x+inputPts[i].y<pts[7].x+pts[7].y){pts[7]=inputPts[i];}}
return pts;};jsts.algorithm.ConvexHull.prototype.lineOrPolygon=function(coordinates){coordinates=this.cleanRing(coordinates);if(coordinates.length==3){return this.geomFactory.createLineString([coordinates[0],coordinates[1]]);}
var linearRing=this.geomFactory.createLinearRing(coordinates);return this.geomFactory.createPolygon(linearRing,null);};jsts.algorithm.ConvexHull.prototype.cleanRing=function(original){Assert.equals(original[0],original[original.length-1]);var cleanedRing=new ArrayList();var previousDistinctCoordinate=null;for(var i=0;i<=original.length-2;i++){var currentCoordinate=original[i];var nextCoordinate=original[i+1];if(currentCoordinate.equals(nextCoordinate)){continue;}
if(previousDistinctCoordinate!=null&&this.isBetween(previousDistinctCoordinate,currentCoordinate,nextCoordinate)){continue;}
cleanedRing.add(currentCoordinate);previousDistinctCoordinate=currentCoordinate;}
cleanedRing.add(original[original.length-1]);var cleanedRingCoordinates=[];return cleanedRing.toArray(cleanedRingCoordinates);};})();jsts.algorithm.MinimumDiameter=function(inputGeom,isConvex){this.convexHullPts=null;this.minBaseSeg=new jsts.geom.LineSegment();this.minWidthPt=null;this.minPtIndex=0;this.minWidth=0;jsts.algorithm.MinimumDiameter.inputGeom=inputGeom;jsts.algorithm.MinimumDiameter.isConvex=isConvex||false;};jsts.algorithm.MinimumDiameter.inputGeom=null;jsts.algorithm.MinimumDiameter.isConvex=false;jsts.algorithm.MinimumDiameter.nextIndex=function(pts,index){index++;if(index>=pts.length){index=0;}
return index;};jsts.algorithm.MinimumDiameter.computeC=function(a,b,p){return a*p.y-b*p.x;};jsts.algorithm.MinimumDiameter.computeSegmentForLine=function(a,b,c){var p0;var p1;if(Math.abs(b)>Math.abs(a)){p0=new jsts.geom.Coordinate(0,c/b);p1=new jsts.geom.Coordinate(1,c/b-a/b);}
else{p0=new jsts.geom.Coordinate(c/a,0);p1=new jsts.geom.Coordinate(c/a-b/a,1);}
return new jsts.geom.LineSegment(p0,p1);};jsts.algorithm.MinimumDiameter.prototype.getLength=function(){this.computeMinimumDiameter();return this.minWidth;};jsts.algorithm.MinimumDiameter.prototype.getWidthCoordinate=function(){this.computeMinimumDiameter();return this.minWidthPt;};jsts.algorithm.MinimumDiameter.prototype.getSupportingSegment=function(){this.computeMinimumDiameter();var coord=[this.minBaseSeg.p0,this.minBaseSeg.p1];return jsts.algorithm.MinimumDiameter.inputGeom.getFactory().createLineString(coord);};jsts.algorithm.MinimumDiameter.prototype.getDiameter=function(){this.computeMinimumDiameter();if(this.minWidthPt===null){return jsts.algorithm.MinimumDiameter.inputGeom.getFactory().createLineString(null);}
var basePt=this.minBaseSeg.project(this.minWidthPt);return jsts.algorithm.MinimumDiameter.inputGeom.getFactory().createLineString([basePt,this.minWidthPt]);};jsts.algorithm.MinimumDiameter.prototype.computeMinimumDiameter=function(){if(this.minWidthPt!==null){return;}
if(jsts.algorithm.MinimumDiameter.isConvex)
this.computeWidthConvex(jsts.algorithm.MinimumDiameter.inputGeom);else{var convexGeom=new jsts.algorithm.ConvexHull(jsts.algorithm.MinimumDiameter.inputGeom).getConvexHull();this.computeWidthConvex(convexGeom);}};jsts.algorithm.MinimumDiameter.prototype.computeWidthConvex=function(convexGeom){if(convexGeom instanceof jsts.geom.Polygon){this.convexHullPts=convexGeom.getExteriorRing().getCoordinates();}else{this.convexHullPts=convexGeom.getCoordinates();}
if(this.convexHullPts.length===0){this.minWidth=0;this.minWidthPt=null;this.minBaseSeg=null;}else if(this.convexHullPts.length===1){this.minWidth=0;this.minWidthPt=this.convexHullPts[0];this.minBaseSeg.p0=this.convexHullPts[0];this.minBaseSeg.p1=this.convexHullPts[0];}else if(this.convexHullPts.length===2||this.convexHullPts.length===3){this.minWidth=0;this.minWidthPt=this.convexHullPts[0];this.minBaseSeg.p0=this.convexHullPts[0];this.minBaseSeg.p1=this.convexHullPts[1];}else{this.computeConvexRingMinDiameter(this.convexHullPts);}};jsts.algorithm.MinimumDiameter.prototype.computeConvexRingMinDiameter=function(pts){this.minWidth=Number.MAX_VALUE;var currMaxIndex=1;var seg=new jsts.geom.LineSegment();for(var i=0;i<pts.length-1;i++){seg.p0=pts[i];seg.p1=pts[i+1];currMaxIndex=this.findMaxPerpDistance(pts,seg,currMaxIndex);}};jsts.algorithm.MinimumDiameter.prototype.findMaxPerpDistance=function(pts,seg,startIndex){var maxPerpDistance=seg.distancePerpendicular(pts[startIndex]);var nextPerpDistance=maxPerpDistance;var maxIndex=startIndex;var nextIndex=maxIndex;while(nextPerpDistance>=maxPerpDistance){maxPerpDistance=nextPerpDistance;maxIndex=nextIndex;nextIndex=jsts.algorithm.MinimumDiameter.nextIndex(pts,maxIndex);nextPerpDistance=seg.distancePerpendicular(pts[nextIndex]);}
if(maxPerpDistance<this.minWidth){this.minPtIndex=maxIndex;this.minWidth=maxPerpDistance;this.minWidthPt=pts[this.minPtIndex];this.minBaseSeg=new jsts.geom.LineSegment(seg);}
return maxIndex;};jsts.algorithm.MinimumDiameter.prototype.getMinimumRectangle=function(){this.computeMinimumDiameter();if(this.minWidth===0){if(this.minBaseSeg.p0.equals2D(this.minBaseSeg.p1)){return jsts.algorithm.MinimumDiameter.inputGeom.getFactory().createPoint(this.minBaseSeg.p0);}
return this.minBaseSeg.toGeometry(jsts.algorithm.MinimumDiameter.inputGeom.getFactory());}
var dx=this.minBaseSeg.p1.x-this.minBaseSeg.p0.x;var dy=this.minBaseSeg.p1.y-this.minBaseSeg.p0.y;var minPara=Number.MAX_VALUE;var maxPara=-Number.MAX_VALUE;var minPerp=Number.MAX_VALUE;var maxPerp=-Number.MAX_VALUE;for(var i=0;i<this.convexHullPts.length;i++){var paraC=jsts.algorithm.MinimumDiameter.computeC(dx,dy,this.convexHullPts[i]);if(paraC>maxPara)maxPara=paraC;if(paraC<minPara)minPara=paraC;var perpC=jsts.algorithm.MinimumDiameter.computeC(-dy,dx,this.convexHullPts[i]);if(perpC>maxPerp)maxPerp=perpC;if(perpC<minPerp)minPerp=perpC;}
var maxPerpLine=jsts.algorithm.MinimumDiameter.computeSegmentForLine(-dx,-dy,maxPerp);var minPerpLine=jsts.algorithm.MinimumDiameter.computeSegmentForLine(-dx,-dy,minPerp);var maxParaLine=jsts.algorithm.MinimumDiameter.computeSegmentForLine(-dy,dx,maxPara);var minParaLine=jsts.algorithm.MinimumDiameter.computeSegmentForLine(-dy,dx,minPara);var p0=maxParaLine.lineIntersection(maxPerpLine);var p1=minParaLine.lineIntersection(maxPerpLine);var p2=minParaLine.lineIntersection(minPerpLine);var p3=maxParaLine.lineIntersection(minPerpLine);var shell=jsts.algorithm.MinimumDiameter.inputGeom.getFactory().createLinearRing([p0,p1,p2,p3,p0]);return jsts.algorithm.MinimumDiameter.inputGeom.getFactory().createPolygon(shell,null);};(function(){jsts.io.GeoJSONParser=function(geometryFactory){this.geometryFactory=geometryFactory||new jsts.geom.GeometryFactory();this.geometryTypes=['Point','MultiPoint','LineString','MultiLineString','Polygon','MultiPolygon'];};jsts.io.GeoJSONParser.prototype.read=function(json){var obj;if(typeof json==='string'){obj=JSON.parse(json);}else{obj=json;}
var type=obj.type;if(!this.parse[type]){throw new Error('Unknown GeoJSON type: '+obj.type);}
if(this.geometryTypes.indexOf(type)!=-1){return this.parse[type].apply(this,[obj.coordinates]);}else if(type==='GeometryCollection'){return this.parse[type].apply(this,[obj.geometries]);}
return this.parse[type].apply(this,[obj]);};jsts.io.GeoJSONParser.prototype.parse={'Feature':function(obj){var feature={};for(var key in obj){feature[key]=obj[key];}
if(obj.geometry){var type=obj.geometry.type;if(!this.parse[type]){throw new Error('Unknown GeoJSON type: '+obj.type);}
feature.geometry=this.read(obj.geometry);}
if(obj.bbox){feature.bbox=this.parse.bbox.apply(this,[obj.bbox]);}
return feature;},'FeatureCollection':function(obj){var featureCollection={};if(obj.features){featureCollection.features=[];for(var i=0;i<obj.features.length;++i){featureCollection.features.push(this.read(obj.features[i]));}}
if(obj.bbox){featureCollection.bbox=this.parse.bbox.apply(this,[obj.bbox]);}
return featureCollection;},'coordinates':function(array){var coordinates=[];for(var i=0;i<array.length;++i){var sub=array[i];coordinates.push(new jsts.geom.Coordinate(sub[0],sub[1]));}
return coordinates;},'bbox':function(array){return this.geometryFactory.createLinearRing([new jsts.geom.Coordinate(array[0],array[1]),new jsts.geom.Coordinate(array[2],array[1]),new jsts.geom.Coordinate(array[2],array[3]),new jsts.geom.Coordinate(array[0],array[3]),new jsts.geom.Coordinate(array[0],array[1])]);},'Point':function(array){var coordinate=new jsts.geom.Coordinate(array[0],array[1]);return this.geometryFactory.createPoint(coordinate);},'MultiPoint':function(array){var points=[];for(var i=0;i<array.length;++i){points.push(this.parse.Point.apply(this,[array[i]]));}
return this.geometryFactory.createMultiPoint(points);},'LineString':function(array){var coordinates=this.parse.coordinates.apply(this,[array]);return this.geometryFactory.createLineString(coordinates);},'MultiLineString':function(array){var lineStrings=[];for(var i=0;i<array.length;++i){lineStrings.push(this.parse.LineString.apply(this,[array[i]]));}
return this.geometryFactory.createMultiLineString(lineStrings);},'Polygon':function(array){var shellCoordinates=this.parse.coordinates.apply(this,[array[0]]);var shell=this.geometryFactory.createLinearRing(shellCoordinates);var holes=[];for(var i=1;i<array.length;++i){var hole=array[i];var coordinates=this.parse.coordinates.apply(this,[hole]);var linearRing=this.geometryFactory.createLinearRing(coordinates);holes.push(linearRing);}
return this.geometryFactory.createPolygon(shell,holes);},'MultiPolygon':function(array){var polygons=[];for(var i=0;i<array.length;++i){var polygon=array[i];polygons.push(this.parse.Polygon.apply(this,[polygon]));}
return this.geometryFactory.createMultiPolygon(polygons);},'GeometryCollection':function(array){var geometries=[];for(var i=0;i<array.length;++i){var geometry=array[i];geometries.push(this.read(geometry));}
return this.geometryFactory.createGeometryCollection(geometries);}};jsts.io.GeoJSONParser.prototype.write=function(geometry){var type=geometry.CLASS_NAME.slice(10);if(!this.extract[type]){throw new Error('Geometry is not supported');}
return this.extract[type].apply(this,[geometry]);};jsts.io.GeoJSONParser.prototype.extract={'coordinate':function(coordinate){return[coordinate.x,coordinate.y];},'Point':function(point){var array=this.extract.coordinate.apply(this,[point.coordinate]);return{type:'Point',coordinates:array};},'MultiPoint':function(multipoint){var array=[];for(var i=0;i<multipoint.geometries.length;++i){var point=multipoint.geometries[i];var geoJson=this.extract.Point.apply(this,[point]);array.push(geoJson.coordinates);}
return{type:'MultiPoint',coordinates:array};},'LineString':function(linestring){var array=[];for(var i=0;i<linestring.points.length;++i){var coordinate=linestring.points[i];array.push(this.extract.coordinate.apply(this,[coordinate]));}
return{type:'LineString',coordinates:array};},'MultiLineString':function(multilinestring){var array=[];for(var i=0;i<multilinestring.geometries.length;++i){var linestring=multilinestring.geometries[i];var geoJson=this.extract.LineString.apply(this,[linestring]);array.push(geoJson.coordinates);}
return{type:'MultiLineString',coordinates:array};},'Polygon':function(polygon){var array=[];var shellGeoJson=this.extract.LineString.apply(this,[polygon.shell]);array.push(shellGeoJson.coordinates);for(var i=0;i<polygon.holes.length;++i){var hole=polygon.holes[i];var holeGeoJson=this.extract.LineString.apply(this,[hole]);array.push(holeGeoJson.coordinates);}
return{type:'Polygon',coordinates:array};},'MultiPolygon':function(multipolygon){var array=[];for(var i=0;i<multipolygon.geometries.length;++i){var polygon=multipolygon.geometries[i];var geoJson=this.extract.Polygon.apply(this,[polygon]);array.push(geoJson.coordinates);}
return{type:'MultiPolygon',coordinates:array};},'GeometryCollection':function(collection){var array=[];for(var i=0;i<collection.geometries.length;++i){var geometry=collection.geometries[i];var type=geometry.CLASS_NAME.slice(10);array.push(this.extract[type].apply(this,[geometry]));}
return{type:'GeometryCollection',geometries:array};}};})();jsts.triangulate.quadedge.Vertex=function(){if(arguments.length===1){this.initFromCoordinate(arguments[0]);}else{this.initFromXY(arguments[0],arguments[1]);}};jsts.triangulate.quadedge.Vertex.LEFT=0;jsts.triangulate.quadedge.Vertex.RIGHT=1;jsts.triangulate.quadedge.Vertex.BEYOND=2;jsts.triangulate.quadedge.Vertex.BEHIND=3;jsts.triangulate.quadedge.Vertex.BETWEEN=4;jsts.triangulate.quadedge.Vertex.ORIGIN=5;jsts.triangulate.quadedge.Vertex.DESTINATION=6;jsts.triangulate.quadedge.Vertex.prototype.initFromXY=function(x,y){this.p=new jsts.geom.Coordinate(x,y);};jsts.triangulate.quadedge.Vertex.prototype.initFromCoordinate=function(_p){this.p=new jsts.geom.Coordinate(_p);};jsts.triangulate.quadedge.Vertex.prototype.getX=function(){return this.p.x;};jsts.triangulate.quadedge.Vertex.prototype.getY=function(){return this.p.y;};jsts.triangulate.quadedge.Vertex.prototype.getZ=function(){return this.p.z;};jsts.triangulate.quadedge.Vertex.prototype.setZ=function(z){this.p.z=z;};jsts.triangulate.quadedge.Vertex.prototype.getCoordinate=function(){return this.p;};jsts.triangulate.quadedge.Vertex.prototype.toString=function(){return'POINT ('+this.p.x+' '+this.p.y+')';};jsts.triangulate.quadedge.Vertex.prototype.equals=function(){if(arguments.length===1){return this.equalsExact(arguments[0]);}else{return this.equalsWithTolerance(arguments[0],arguments[1]);}};jsts.triangulate.quadedge.Vertex.prototype.equalsExact=function(other){return(this.p.x===other.getX()&&this.p.y===other.getY());};jsts.triangulate.quadedge.Vertex.prototype.equalsWithTolerance=function(other,tolerance){return(this.p.distance(other.getCoordinate())<tolerance);};jsts.triangulate.quadedge.Vertex.prototype.classify=function(p0,p1){var p2,a,b,sa;p2=this;a=p1.sub(p0);b=p2.sub(p0);sa=a.crossProduct(b);if(sa>0.0){return jsts.triangulate.quadedge.Vertex.LEFT;}
if(sa<0.0){return jsts.triangulate.quadedge.Vertex.RIGHT;}
if((a.getX()*b.getX()<0.0)||(a.getY()*b.getY()<0.0)){return jsts.triangulate.quadedge.Vertex.BEHIND;}
if(a.magn()<b.magn()){return jsts.triangulate.quadedge.Vertex.BEYOND;}
if(p0.equals(p2)){return jsts.triangulate.quadedge.Vertex.ORIGIN;}
if(p1.equals(p2)){return jsts.triangulate.quadedge.Vertex.DESTINATION;}
return jsts.triangulate.quadedge.Vertex.BETWEEN;};jsts.triangulate.quadedge.Vertex.prototype.crossProduct=function(v){return((this.p.x*v.getY())-(this.p.y*v.getX()));};jsts.triangulate.quadedge.Vertex.prototype.dot=function(v){return((this.p.x*v.getX())+(this.p.y*v.getY()));};jsts.triangulate.quadedge.Vertex.prototype.times=function(c){return new jsts.triangulate.quadedge.Vertex(c*this.p.x,c*this.p.y);};jsts.triangulate.quadedge.Vertex.prototype.sum=function(v){return new jsts.triangulate.quadedge.Vertex(this.p.x+v.getX(),this.p.y+
v.getY());};jsts.triangulate.quadedge.Vertex.prototype.sub=function(v){return new jsts.triangulate.quadedge.Vertex(this.p.x-v.getX(),this.p.y-
v.getY());};jsts.triangulate.quadedge.Vertex.prototype.magn=function(){return(Math.sqrt((this.p.x*this.p.x)+(this.p.y*this.p.y)));};jsts.triangulate.quadedge.Vertex.prototype.cross=function(){return new Vertex(this.p.y,-this.p.x);};jsts.triangulate.quadedge.Vertex.prototype.isInCircle=function(a,b,c){return jsts.triangulate.quadedge.TrianglePredicate.isInCircleRobust(a.p,b.p,c.p,this.p);};jsts.triangulate.quadedge.Vertex.prototype.isCCW=function(b,c){return((b.p.x-this.p.x)*(c.p.y-this.p.y)-(b.p.y-this.p.y)*(c.p.x-this.p.x)>0);};jsts.triangulate.quadedge.Vertex.prototype.rightOf=function(e){return this.isCCW(e.dest(),e.orig());};jsts.triangulate.quadedge.Vertex.prototype.leftOf=function(e){return this.isCCW(e.orig(),e.dest());};jsts.triangulate.quadedge.Vertex.prototype.bisector=function(a,b){var dx,dy,l1,l2;dx=b.getX()-a.getX();dy=b.getY()-a.getY();l1=new jsts.algorithm.HCoordinate(a.getX()+(dx/2.0),a.getY()+
(dy/2.0),1.0);l2=new jsts.algorithm.HCoordinate(a.getX()-dy+(dx/2.0),a.getY()+
dx+(dy/2.0),1.0);return new jsts.algorithm.HCoordinate(l1,l2);};jsts.triangulate.quadedge.Vertex.prototype.distance=function(v1,v2){return v1.p.distance(v2.p);};jsts.triangulate.quadedge.Vertex.prototype.circumRadiusRatio=function(b,c){var x,radius,edgeLength,el;x=this.circleCenter(b,c);radius=this.distance(x,b);edgeLength=this.distance(this,b);el=this.distance(b,c);if(el<edgeLength){edgeLength=el;}
el=this.distance(c,this);if(el<edgeLength){edgeLength=el;}
return radius/edgeLength;};jsts.triangulate.quadedge.Vertex.prototype.midPoint=function(a){var xm,ym;xm=(this.p.x+a.getX())/2.0;ym=(this.p.y+a.getY())/2.0;return new jsts.triangulate.quadedge.Vertex(xm,ym);};jsts.triangulate.quadedge.Vertex.prototype.circleCenter=function(b,c){var a,cab,cbc,hcc,cc;a=new jsts.triangulate.quadedge.Vertex(this.getX(),this.getY());cab=this.bisector(a,b);cbc=this.bisector(b,c);hcc=new jsts.algorithm.HCoordinate(cab,cbc);cc=null;try{cc=new jsts.triangulate.quadedge.Vertex(hcc.getX(),hcc.getY());}catch(err){}
return cc;};jsts.operation.valid.IsValidOp=function(parentGeometry){this.parentGeometry=parentGeometry;this.isSelfTouchingRingFormingHoleValid=false;this.validErr=null;};jsts.operation.valid.IsValidOp.isValid=function(arg){if(arguments[0]instanceof jsts.geom.Coordinate){if(isNaN(arg.x)){return false;}
if(!isFinite(arg.x)&&!isNaN(arg.x)){return false;}
if(isNaN(arg.y)){return false;}
if(!isFinite(arg.y)&&!isNaN(arg.y)){return false;}
return true;}else{var isValidOp=new jsts.operation.valid.IsValidOp(arg);return isValidOp.isValid();}};jsts.operation.valid.IsValidOp.findPtNotNode=function(testCoords,searchRing,graph){var searchEdge=graph.findEdge(searchRing);var eiList=searchEdge.getEdgeIntersectionList();for(var i=0;i<testCoords.length;i++){var pt=testCoords[i];if(!eiList.isIntersection(pt)){return pt;}}
return null;};jsts.operation.valid.IsValidOp.prototype.setSelfTouchingRingFormingHoleValid=function(isValid){this.isSelfTouchingRingFormingHoleValid=isValid;};jsts.operation.valid.IsValidOp.prototype.isValid=function(){this.checkValid(this.parentGeometry);return this.validErr==null;};jsts.operation.valid.IsValidOp.prototype.getValidationError=function(){this.checkValid(this.parentGeometry);return this.validErr;};jsts.operation.valid.IsValidOp.prototype.checkValid=function(g){this.validErr=null;if(g.isEmpty()){return;}
if(g instanceof jsts.geom.Point){this.checkValidPoint(g);}else if(g instanceof jsts.geom.MultiPoint){this.checkValidMultiPoint(g);}else if(g instanceof jsts.geom.LinearRing){this.checkValidLinearRing(g);}else if(g instanceof jsts.geom.LineString){this.checkValidLineString(g);}else if(g instanceof jsts.geom.Polygon){this.checkValidPolygon(g);}else if(g instanceof jsts.geom.MultiPolygon){this.checkValidMultiPolygon(g);}else if(g instanceof jsts.geom.GeometryCollection){this.checkValidGeometryCollection(g);}else{throw g.constructor;}};jsts.operation.valid.IsValidOp.prototype.checkValidPoint=function(g){this.checkInvalidCoordinates(g.getCoordinates());};jsts.operation.valid.IsValidOp.prototype.checkValidMultiPoint=function(g){this.checkInvalidCoordinates(g.getCoordinates());};jsts.operation.valid.IsValidOp.prototype.checkValidLineString=function(g){this.checkInvalidCoordinates(g.getCoordinates());if(this.validErr!=null){return;}
var graph=new jsts.geomgraph.GeometryGraph(0,g);this.checkTooFewPoints(graph);};jsts.operation.valid.IsValidOp.prototype.checkValidLinearRing=function(g){this.checkInvalidCoordinates(g.getCoordinates());if(this.validErr!=null){return;}
this.checkClosedRing(g);if(this.validErr!=null){return;}
var graph=new jsts.geomgraph.GeometryGraph(0,g);this.checkTooFewPoints(graph);if(this.validErr!=null){return;}
var li=new jsts.algorithm.RobustLineIntersector();graph.computeSelfNodes(li,true);this.checkNoSelfIntersectingRings(graph);};jsts.operation.valid.IsValidOp.prototype.checkValidPolygon=function(g){this.checkInvalidCoordinates(g);if(this.validErr!=null){return;}
this.checkClosedRings(g);if(this.validErr!=null){return;}
var graph=new jsts.geomgraph.GeometryGraph(0,g);this.checkTooFewPoints(graph);if(this.validErr!=null){return;}
this.checkConsistentArea(graph);if(this.validErr!=null){return;}
if(!this.isSelfTouchingRingFormingHoleValid){this.checkNoSelfIntersectingRings(graph);if(this.validErr!=null){return;}}
this.checkHolesInShell(g,graph);if(this.validErr!=null){return;}
this.checkHolesNotNested(g,graph);if(this.validErr!=null){return;}
this.checkConnectedInteriors(graph);};jsts.operation.valid.IsValidOp.prototype.checkValidMultiPolygon=function(g){var il=g.getNumGeometries();for(var i=0;i<il;i++){var p=g.getGeometryN(i);this.checkInvalidCoordinates(p);if(this.validErr!=null){return;}
this.checkClosedRings(p);if(this.validErr!=null){return;}}
var graph=new jsts.geomgraph.GeometryGraph(0,g);this.checkTooFewPoints(graph);if(this.validErr!=null){return;}
this.checkConsistentArea(graph);if(this.validErr!=null){return;}
if(!this.isSelfTouchingRingFormingHoleValid){this.checkNoSelfIntersectingRings(graph);if(this.validErr!=null){return;}}
for(var i=0;i<g.getNumGeometries();i++){var p=g.getGeometryN(i);this.checkHolesInShell(p,graph);if(this.validErr!=null){return;}}
for(var i=0;i<g.getNumGeometries();i++){var p=g.getGeometryN(i);this.checkHolesNotNested(p,graph);if(this.validErr!=null){return;}}
this.checkShellsNotNested(g,graph);if(this.validErr!=null){return;}
this.checkConnectedInteriors(graph);};jsts.operation.valid.IsValidOp.prototype.checkValidGeometryCollection=function(gc){for(var i=0;i<gc.getNumGeometries();i++){var g=gc.getGeometryN(i);this.checkValid(g);if(this.validErr!=null){return;}}};jsts.operation.valid.IsValidOp.prototype.checkInvalidCoordinates=function(arg){if(arg instanceof jsts.geom.Polygon){var poly=arg;this.checkInvalidCoordinates(poly.getExteriorRing().getCoordinates());if(this.validErr!=null){return;}
for(var i=0;i<poly.getNumInteriorRing();i++){this.checkInvalidCoordinates(poly.getInteriorRingN(i).getCoordinates());if(this.validErr!=null){return;}}}else{var coords=arg;for(var i=0;i<coords.length;i++){if(!jsts.operation.valid.IsValidOp.isValid(coords[i])){this.validErr=new jsts.operation.valid.TopologyValidationError(jsts.operation.valid.TopologyValidationError.INVALID_COORDINATE,coords[i]);return;}}}};jsts.operation.valid.IsValidOp.prototype.checkClosedRings=function(poly){this.checkClosedRing(poly.getExteriorRing());if(this.validErr!=null){return;}
for(var i=0;i<poly.getNumInteriorRing();i++){this.checkClosedRing(poly.getInteriorRingN(i));if(this.validErr!=null){return;}}};jsts.operation.valid.IsValidOp.prototype.checkClosedRing=function(ring){if(!ring.isClosed()){var pt=null;if(ring.getNumPoints()>=1){pt=ring.getCoordinateN(0);}
this.validErr=new jsts.operation.valid.TopologyValidationError(jsts.operation.valid.TopologyValidationError.RING_NOT_CLOSED,pt);}};jsts.operation.valid.IsValidOp.prototype.checkTooFewPoints=function(graph){if(graph.hasTooFewPoints){this.validErr=new jsts.operation.valid.TopologyValidationError(jsts.operation.valid.TopologyValidationError.TOO_FEW_POINTS,graph.getInvalidPoint());return;}};jsts.operation.valid.IsValidOp.prototype.checkConsistentArea=function(graph){var cat=new jsts.operation.valid.ConsistentAreaTester(graph);var isValidArea=cat.isNodeConsistentArea();if(!isValidArea){this.validErr=new jsts.operation.valid.TopologyValidationError(jsts.operation.valid.TopologyValidationError.SELF_INTERSECTION,cat.getInvalidPoint());return;}
if(cat.hasDuplicateRings()){this.validErr=new jsts.operation.valid.TopologyValidationError(jsts.operation.valid.TopologyValidationError.DUPLICATE_RINGS,cat.getInvalidPoint());}};jsts.operation.valid.IsValidOp.prototype.checkNoSelfIntersectingRings=function(graph){for(var i=graph.getEdgeIterator();i.hasNext();){var e=i.next();this.checkNoSelfIntersectingRing(e.getEdgeIntersectionList());if(this.validErr!=null){return;}}};jsts.operation.valid.IsValidOp.prototype.checkNoSelfIntersectingRing=function(eiList){var nodeSet=[];var isFirst=true;for(var i=eiList.iterator();i.hasNext();){var ei=i.next();if(isFirst){isFirst=false;continue;}
if(nodeSet.indexOf(ei.coord)>=0){this.validErr=new jsts.operation.valid.TopologyValidationError(jsts.operation.valid.TopologyValidationError.RING_SELF_INTERSECTION,ei.coord);return;}else{nodeSet.push(ei.coord);}}};jsts.operation.valid.IsValidOp.prototype.checkHolesInShell=function(p,graph){var shell=p.getExteriorRing();var pir=new jsts.algorithm.MCPointInRing(shell);for(var i=0;i<p.getNumInteriorRing();i++){var hole=p.getInteriorRingN(i);var holePt=jsts.operation.valid.IsValidOp.findPtNotNode(hole.getCoordinates(),shell,graph);if(holePt==null){return;}
var outside=!pir.isInside(holePt);if(outside){this.validErr=new jsts.operation.valid.TopologyValidationError(jsts.operation.valid.TopologyValidationError.HOLE_OUTSIDE_SHELL,holePt);return;}}};jsts.operation.valid.IsValidOp.prototype.checkHolesNotNested=function(p,graph){var nestedTester=new jsts.operation.valid.IndexedNestedRingTester(graph);for(var i=0;i<p.getNumInteriorRing();i++){var innerHole=p.getInteriorRingN(i);nestedTester.add(innerHole);}
var isNonNested=nestedTester.isNonNested();if(!isNonNested){this.validErr=new jsts.operation.valid.TopologyValidationError(jsts.operation.valid.TopologyValidationError.NESTED_HOLES,nestedTester.getNestedPoint());}};jsts.operation.valid.IsValidOp.prototype.checkShellsNotNested=function(mp,graph){for(var i=0;i<mp.getNumGeometries();i++){var p=mp.getGeometryN(i);var shell=p.getExteriorRing();for(var j=0;j<mp.getNumGeometries();j++){if(i==j){continue;}
var p2=mp.getGeometryN(j);this.checkShellNotNested(shell,p2,graph);if(this.validErr!=null){return;}}}};jsts.operation.valid.IsValidOp.prototype.checkShellNotNested=function(shell,p,graph){var shellPts=shell.getCoordinates();var polyShell=p.getExteriorRing();var polyPts=polyShell.getCoordinates();var shellPt=jsts.operation.valid.IsValidOp.findPtNotNode(shellPts,polyShell,graph);if(shellPt==null){return;}
var insidePolyShell=jsts.algorithm.CGAlgorithms.isPointInRing(shellPt,polyPts);if(!insidePolyShell){return;}
if(p.getNumInteriorRing()<=0){this.validErr=new jsts.operation.valid.TopologyValidationError(jsts.operation.valid.TopologyValidationError.NESTED_SHELLS,shellPt);return;}
var badNestedPt=null;for(var i=0;i<p.getNumInteriorRing();i++){var hole=p.getInteriorRingN(i);badNestedPt=this.checkShellInsideHole(shell,hole,graph);if(badNestedPt==null){return;}}
this.validErr=new jsts.operation.valid.TopologyValidationError(jsts.operation.valid.TopologyValidationError.NESTED_SHELLS,badNestedPt);};jsts.operation.valid.IsValidOp.prototype.checkShellInsideHole=function(shell,hole,graph){var shellPts=shell.getCoordinates();var holePts=hole.getCoordinates();var shellPt=jsts.operation.valid.IsValidOp.findPtNotNode(shellPts,hole,graph);if(shellPt!=null){var insideHole=jsts.algorithm.CGAlgorithms.isPointInRing(shellPt,holePts);if(!insideHole){return shellPt;}}
var holePt=jsts.operation.valid.IsValidOp.findPtNotNode(holePts,shell,graph);if(holePt!=null){var insideShell=jsts.algorithm.CGAlgorithms.isPointInRing(holePt,shellPts);if(insideShell){return holePt;}
return null;}
jsts.util.Assert.shouldNeverReachHere('points in shell and hole appear to be equal');return null;};jsts.operation.valid.IsValidOp.prototype.checkConnectedInteriors=function(graph){var cit=new jsts.operation.valid.ConnectedInteriorTester(graph);if(!cit.isInteriorsConnected()){this.validErr=new jsts.operation.valid.TopologyValidationError(jsts.operation.valid.TopologyValidationError.DISCONNECTED_INTERIOR,cit.getCoordinate());}};jsts.algorithm.RobustDeterminant=function(){};jsts.algorithm.RobustDeterminant.signOfDet2x2=function(x1,y1,x2,y2){var sign,swap,k,count;count=0;sign=1;if((x1===0.0)||(y2===0.0)){if((y1===0.0)||(x2===0.0)){return 0;}
else if(y1>0){if(x2>0){return-sign;}
else{return sign;}}
else{if(x2>0){return sign;}
else{return-sign;}}}
if((y1===0.0)||(x2===0.0)){if(y2>0){if(x1>0){return sign;}
else{return-sign;}}
else{if(x1>0){return-sign;}
else{return sign;}}}
if(0.0<y1){if(0.0<y2){if(y1>y2){sign=-sign;swap=x1;x1=x2;x2=swap;swap=y1;y1=y2;y2=swap;}}
else{if(y1<=-y2){sign=-sign;x2=-x2;y2=-y2;}
else{swap=x1;x1=-x2;x2=swap;swap=y1;y1=-y2;y2=swap;}}}
else{if(0.0<y2){if(-y1<=y2){sign=-sign;x1=-x1;y1=-y1;}
else{swap=-x1;x1=x2;x2=swap;swap=-y1;y1=y2;y2=swap;}}
else{if(y1>=y2){x1=-x1;y1=-y1;x2=-x2;y2=-y2;}
else{sign=-sign;swap=-x1;x1=-x2;x2=swap;swap=-y1;y1=-y2;y2=swap;}}}
if(0.0<x1){if(0.0<x2){if(x1>x2){return sign;}}
else{return sign;}}
else{if(0.0<x2){return-sign;}
else{if(x1>=x2){sign=-sign;x1=-x1;x2=-x2;}
else{return-sign;}}}
while(true){count=count+1;k=Math.floor(x2/x1);x2=x2-k*x1;y2=y2-k*y1;if(y2<0.0){return-sign;}
if(y2>y1){return sign;}
if(x1>x2+x2){if(y1<y2+y2){return sign;}}
else{if(y1>y2+y2){return-sign;}
else{x2=x1-x2;y2=y1-y2;sign=-sign;}}
if(y2===0.0){if(x2===0.0){return 0;}
else{return-sign;}}
if(x2===0.0){return sign;}
k=Math.floor(x1/x2);x1=x1-k*x2;y1=y1-k*y2;if(y1<0.0){return sign;}
if(y1>y2){return-sign;}
if(x2>x1+x1){if(y2<y1+y1){return-sign;}}
else{if(y2>y1+y1){return sign;}
else{x1=x2-x1;y1=y2-y1;sign=-sign;}}
if(y1===0.0){if(x1===0.0){return 0;}
else{return sign;}}
if(x1===0.0){return-sign;}}};jsts.algorithm.RobustDeterminant.orientationIndex=function(p1,p2,q){var dx1=p2.x-p1.x;var dy1=p2.y-p1.y;var dx2=q.x-p2.x;var dy2=q.y-p2.y;return jsts.algorithm.RobustDeterminant.signOfDet2x2(dx1,dy1,dx2,dy2);};jsts.index.quadtree.NodeBase=function(){this.subnode=new Array(4);this.subnode[0]=null;this.subnode[1]=null;this.subnode[2]=null;this.subnode[3]=null;this.items=[];};jsts.index.quadtree.NodeBase.prototype.getSubnodeIndex=function(env,centre){var subnodeIndex=-1;if(env.getMinX()>=centre.x){if(env.getMinY()>=centre.y){subnodeIndex=3;}
if(env.getMaxY()<=centre.y){subnodeIndex=1;}}
if(env.getMaxX()<=centre.x){if(env.getMinY()>=centre.y){subnodeIndex=2;}
if(env.getMaxY()<=centre.y){subnodeIndex=0;}}
return subnodeIndex;};jsts.index.quadtree.NodeBase.prototype.getItems=function(){return this.items;};jsts.index.quadtree.NodeBase.prototype.hasItems=function(){return(this.items.length>0);};jsts.index.quadtree.NodeBase.prototype.add=function(item){this.items.push(item);};jsts.index.quadtree.NodeBase.prototype.remove=function(itemEnv,item){if(!this.isSearchMatch(itemEnv)){return false;}
var found=false,i=0;for(i;i<4;i++){if(this.subnode[i]!==null){found=this.subnode[i].remove(itemEnv,item);if(found){if(this.subnode[i].isPrunable()){this.subnode[i]=null;}
break;}}}
if(found){return found;}
if(this.items.indexOf(item)!==-1){for(var i=this.items.length-1;i>=0;i--){if(this.items[i]===item){this.items.splice(i,1);}}
found=true;}
return found;};jsts.index.quadtree.NodeBase.prototype.isPrunable=function(){return!(this.hasChildren()||this.hasItems());};jsts.index.quadtree.NodeBase.prototype.hasChildren=function(){var i=0;for(i;i<4;i++){if(this.subnode[i]!==null){return true;}}
return false;};jsts.index.quadtree.NodeBase.prototype.isEmpty=function(){var isEmpty=true;if(this.items.length>0){isEmpty=false;}
var i=0;for(i;i<4;i++){if(this.subnode[i]!==null){if(!this.subnode[i].isEmpty()){isEmpty=false;}}}
return isEmpty;};jsts.index.quadtree.NodeBase.prototype.addAllItems=function(resultItems){resultItems=resultItems.concat(this.items);var i=0;for(i;i<4;i++){if(this.subnode[i]!==null){resultItems=this.subnode[i].addAllItems(resultItems);}}
return resultItems;};jsts.index.quadtree.NodeBase.prototype.addAllItemsFromOverlapping=function(searchEnv,resultItems){if(!this.isSearchMatch(searchEnv)){return;}
resultItems=resultItems.concat(this.items);var i=0;for(i;i<4;i++){if(this.subnode[i]!==null){resultItems=this.subnode[i].addAllItemsFromOverlapping(searchEnv,resultItems);}}};jsts.index.quadtree.NodeBase.prototype.visit=function(searchEnv,visitor){if(!this.isSearchMatch(searchEnv)){return;}
this.visitItems(searchEnv,visitor);var i=0;for(i;i<4;i++){if(this.subnode[i]!==null){this.subnode[i].visit(searchEnv,visitor);}}};jsts.index.quadtree.NodeBase.prototype.visitItems=function(env,visitor){var i=0,il=this.items.length;for(i;i<il;i++){visitor.visitItem(this.items[i]);}};jsts.index.quadtree.NodeBase.prototype.depth=function(){var maxSubDepth=0,i=0,sqd;for(i;i<4;i++){if(this.subnode[i]!==null){sqd=this.subnode[i].depth();if(sqd>maxSubDepth){maxSubDepth=sqd;}}}
return maxSubDepth+1;};jsts.index.quadtree.NodeBase.prototype.size=function(){var subSize=0,i=0;for(i;i<4;i++){if(this.subnode[i]!==null){subSize+=this.subnode[i].size();}}
return subSize+this.items.length;};jsts.index.quadtree.NodeBase.prototype.getNodeCount=function(){var subSize=0,i=0;for(i;i<4;i++){if(this.subnode[i]!==null){subSize+=this.subnode[i].size();}}
return subSize+1;};jsts.index.quadtree.Node=function(env,level){jsts.index.quadtree.NodeBase.prototype.constructor.apply(this,arguments);this.env=env;this.level=level;this.centre=new jsts.geom.Coordinate();this.centre.x=(env.getMinX()+env.getMaxX())/2;this.centre.y=(env.getMinY()+env.getMaxY())/2;};jsts.index.quadtree.Node.prototype=new jsts.index.quadtree.NodeBase();jsts.index.quadtree.Node.createNode=function(env){var key,node;key=new jsts.index.quadtree.Key(env);node=new jsts.index.quadtree.Node(key.getEnvelope(),key.getLevel());return node;};jsts.index.quadtree.Node.createExpanded=function(node,addEnv){var expandEnv=new jsts.geom.Envelope(addEnv),largerNode;if(node!==null){expandEnv.expandToInclude(node.env);}
largerNode=jsts.index.quadtree.Node.createNode(expandEnv);if(node!==null){largerNode.insertNode(node);}
return largerNode;};jsts.index.quadtree.Node.prototype.getEnvelope=function(){return this.env;};jsts.index.quadtree.Node.prototype.isSearchMatch=function(searchEnv){return this.env.intersects(searchEnv);};jsts.index.quadtree.Node.prototype.getNode=function(searchEnv){var subnodeIndex=this.getSubnodeIndex(searchEnv,this.centre),node;if(subnodeIndex!==-1){node=this.getSubnode(subnodeIndex);return node.getNode(searchEnv);}else{return this;}};jsts.index.quadtree.Node.prototype.find=function(searchEnv){var subnodeIndex=this.getSubnodeIndex(searchEnv,this.centre),node;if(subnodeIndex===-1){return this;}
if(this.subnode[subnodeIndex]!==null){node=this.subnode[subnodeIndex];return node.find(searchEnv);}
return this;};jsts.index.quadtree.Node.prototype.insertNode=function(node){var index=this.getSubnodeIndex(node.env,this.centre),childNode;if(node.level===this.level-1){this.subnode[index]=node;}else{childNode=this.createSubnode(index);childNode.insertNode(node);this.subnode[index]=childNode;}};jsts.index.quadtree.Node.prototype.getSubnode=function(index){if(this.subnode[index]===null){this.subnode[index]=this.createSubnode(index);}
return this.subnode[index];};jsts.index.quadtree.Node.prototype.createSubnode=function(index){var minx=0.0,maxx=0.0,miny=0.0,maxy=0.0,sqEnv,node;switch(index){case 0:minx=this.env.getMinX();maxx=this.centre.x;miny=this.env.getMinY();maxy=this.centre.y;break;case 1:minx=this.centre.x;maxx=this.env.getMaxX();miny=this.env.getMinY();maxy=this.centre.y;break;case 2:minx=this.env.getMinX();maxx=this.centre.x;miny=this.centre.y;maxy=this.env.getMaxY();break;case 3:minx=this.centre.x;maxx=this.env.getMaxX();miny=this.centre.y;maxy=this.env.getMaxY();break;}
sqEnv=new jsts.geom.Envelope(minx,maxx,miny,maxy);node=new jsts.index.quadtree.Node(sqEnv,this.level-1);return node;};(function(){jsts.triangulate.quadedge.QuadEdge=function(){this.rot=null;this.vertex=null;this.next=null;this.data=null;};var QuadEdge=jsts.triangulate.quadedge.QuadEdge;jsts.triangulate.quadedge.QuadEdge.makeEdge=function(o,d){var q0,q1,q2,q3,base;q0=new QuadEdge();q1=new QuadEdge();q2=new QuadEdge();q3=new QuadEdge();q0.rot=q1;q1.rot=q2;q2.rot=q3;q3.rot=q0;q0.setNext(q0);q1.setNext(q3);q2.setNext(q2);q3.setNext(q1);base=q0;base.setOrig(o);base.setDest(d);return base;};jsts.triangulate.quadedge.QuadEdge.connect=function(a,b){var e=QuadEdge.makeEdge(a.dest(),b.orig());QuadEdge.splice(e,a.lNext());QuadEdge.splice(e.sym(),b);return e;};jsts.triangulate.quadedge.QuadEdge.splice=function(a,b){var alpha,beta,t1,t2,t3,t4;alpha=a.oNext().rot;beta=b.oNext().rot;t1=b.oNext();t2=a.oNext();t3=beta.oNext();t4=alpha.oNext();a.setNext(t1);b.setNext(t2);alpha.setNext(t3);beta.setNext(t4);};jsts.triangulate.quadedge.QuadEdge.swap=function(e){var a,b;a=e.oPrev();b=e.sym().oPrev();QuadEdge.splice(e,a);QuadEdge.splice(e.sym(),b);QuadEdge.splice(e,a.lNext());QuadEdge.splice(e.sym(),b.lNext());e.setOrig(a.dest());e.setDest(b.dest());};jsts.triangulate.quadedge.QuadEdge.prototype.getPrimary=function(){if(this.orig().getCoordinate().compareTo(this.dest().getCoordinate())<=0){return this;}
else{return this.sym();}};jsts.triangulate.quadedge.QuadEdge.prototype.setData=function(data){this.data=data;};jsts.triangulate.quadedge.QuadEdge.prototype.getData=function(){return this.data;};jsts.triangulate.quadedge.QuadEdge.prototype.delete_jsts=function(){this.rot=null;};jsts.triangulate.quadedge.QuadEdge.prototype.isLive=function(){return this.rot!==null;};jsts.triangulate.quadedge.QuadEdge.prototype.setNext=function(next){this.next=next;};jsts.triangulate.quadedge.QuadEdge.prototype.invRot=function(){return this.rot.sym();};jsts.triangulate.quadedge.QuadEdge.prototype.sym=function(){return this.rot.rot;};jsts.triangulate.quadedge.QuadEdge.prototype.oNext=function(){return this.next;};jsts.triangulate.quadedge.QuadEdge.prototype.oPrev=function(){return this.rot.next.rot;};jsts.triangulate.quadedge.QuadEdge.prototype.dNext=function(){return this.sym().oNext().sym();};jsts.triangulate.quadedge.QuadEdge.prototype.dPrev=function(){return this.invRot().oNext().invRot();};jsts.triangulate.quadedge.QuadEdge.prototype.lNext=function(){return this.invRot().oNext().rot;};jsts.triangulate.quadedge.QuadEdge.prototype.lPrev=function(){return this.next.sym();};jsts.triangulate.quadedge.QuadEdge.prototype.rNext=function(){return this.rot.next.invRot();};jsts.triangulate.quadedge.QuadEdge.prototype.rPrev=function(){return this.sym().oNext();};jsts.triangulate.quadedge.QuadEdge.prototype.setOrig=function(o){this.vertex=o;};jsts.triangulate.quadedge.QuadEdge.prototype.setDest=function(d){this.sym().setOrig(d);};jsts.triangulate.quadedge.QuadEdge.prototype.orig=function(){return this.vertex;};jsts.triangulate.quadedge.QuadEdge.prototype.dest=function(){return this.sym().orig();};jsts.triangulate.quadedge.QuadEdge.prototype.getLength=function(){return this.orig().getCoordinate().distance(dest().getCoordinate());};jsts.triangulate.quadedge.QuadEdge.prototype.equalsNonOriented=function(qe){if(this.equalsOriented(qe)){return true;}
if(this.equalsOriented(qe.sym())){return true;}
return false;};jsts.triangulate.quadedge.QuadEdge.prototype.equalsOriented=function(qe){if(this.orig().getCoordinate().equals2D(qe.orig().getCoordinate())&&this.dest().getCoordinate().equals2D(qe.dest().getCoordinate())){return true;}
return false;};jsts.triangulate.quadedge.QuadEdge.prototype.toLineSegment=function()
{return new jsts.geom.LineSegment(this.vertex.getCoordinate(),this.dest().getCoordinate());};jsts.triangulate.quadedge.QuadEdge.prototype.toString=function(){var p0,p1;p0=this.vertex.getCoordinate();p1=this.dest().getCoordinate();return jsts.io.WKTWriter.toLineString(p0,p1);};})();(function(){var Assert=jsts.util.Assert;jsts.geomgraph.EdgeEnd=function(edge,p0,p1,label){this.edge=edge;if(p0&&p1){this.init(p0,p1);}
if(label){this.label=label||null;}};jsts.geomgraph.EdgeEnd.prototype.edge=null;jsts.geomgraph.EdgeEnd.prototype.label=null;jsts.geomgraph.EdgeEnd.prototype.node=null;jsts.geomgraph.EdgeEnd.prototype.p0=null;jsts.geomgraph.EdgeEnd.prototype.p1=null;jsts.geomgraph.EdgeEnd.prototype.dx=null;jsts.geomgraph.EdgeEnd.prototype.dy=null;jsts.geomgraph.EdgeEnd.prototype.quadrant=null;jsts.geomgraph.EdgeEnd.prototype.init=function(p0,p1){this.p0=p0;this.p1=p1;this.dx=p1.x-p0.x;this.dy=p1.y-p0.y;this.quadrant=jsts.geomgraph.Quadrant.quadrant(this.dx,this.dy);Assert.isTrue(!(this.dx===0&&this.dy===0),'EdgeEnd with identical endpoints found');};jsts.geomgraph.EdgeEnd.prototype.getEdge=function(){return this.edge;};jsts.geomgraph.EdgeEnd.prototype.getLabel=function(){return this.label;};jsts.geomgraph.EdgeEnd.prototype.getCoordinate=function(){return this.p0;};jsts.geomgraph.EdgeEnd.prototype.getDirectedCoordinate=function(){return this.p1;};jsts.geomgraph.EdgeEnd.prototype.getQuadrant=function(){return this.quadrant;};jsts.geomgraph.EdgeEnd.prototype.getDx=function(){return this.dx;};jsts.geomgraph.EdgeEnd.prototype.getDy=function(){return this.dy;};jsts.geomgraph.EdgeEnd.prototype.setNode=function(node){this.node=node;};jsts.geomgraph.EdgeEnd.prototype.getNode=function(){return this.node;};jsts.geomgraph.EdgeEnd.prototype.compareTo=function(e){return this.compareDirection(e);};jsts.geomgraph.EdgeEnd.prototype.compareDirection=function(e){if(this.dx===e.dx&&this.dy===e.dy)
return 0;if(this.quadrant>e.quadrant)
return 1;if(this.quadrant<e.quadrant)
return-1;return jsts.algorithm.CGAlgorithms.computeOrientation(e.p0,e.p1,this.p1);};jsts.geomgraph.EdgeEnd.prototype.computeLabel=function(boundaryNodeRule){};})();jsts.operation.buffer.RightmostEdgeFinder=function(){};jsts.operation.buffer.RightmostEdgeFinder.prototype.minIndex=-1;jsts.operation.buffer.RightmostEdgeFinder.prototype.minCoord=null;jsts.operation.buffer.RightmostEdgeFinder.prototype.minDe=null;jsts.operation.buffer.RightmostEdgeFinder.prototype.orientedDe=null;jsts.operation.buffer.RightmostEdgeFinder.prototype.getEdge=function(){return this.orientedDe;};jsts.operation.buffer.RightmostEdgeFinder.prototype.getCoordinate=function(){return this.minCoord;};jsts.operation.buffer.RightmostEdgeFinder.prototype.findEdge=function(dirEdgeList){for(var i=dirEdgeList.iterator();i.hasNext();){var de=i.next();if(!de.isForward())
continue;this.checkForRightmostCoordinate(de);}
jsts.util.Assert.isTrue(this.minIndex!==0||this.minCoord.equals(this.minDe.getCoordinate()),'inconsistency in rightmost processing');if(this.minIndex===0){this.findRightmostEdgeAtNode();}else{this.findRightmostEdgeAtVertex();}
this.orientedDe=this.minDe;var rightmostSide=this.getRightmostSide(this.minDe,this.minIndex);if(rightmostSide==jsts.geomgraph.Position.LEFT){this.orientedDe=this.minDe.getSym();}};jsts.operation.buffer.RightmostEdgeFinder.prototype.findRightmostEdgeAtNode=function(){var node=this.minDe.getNode();var star=node.getEdges();this.minDe=star.getRightmostEdge();if(!this.minDe.isForward()){this.minDe=this.minDe.getSym();this.minIndex=this.minDe.getEdge().getCoordinates().length-1;}};jsts.operation.buffer.RightmostEdgeFinder.prototype.findRightmostEdgeAtVertex=function(){var pts=this.minDe.getEdge().getCoordinates();jsts.util.Assert.isTrue(this.minIndex>0&&this.minIndex<pts.length,'rightmost point expected to be interior vertex of edge');var pPrev=pts[this.minIndex-1];var pNext=pts[this.minIndex+1];var orientation=jsts.algorithm.CGAlgorithms.computeOrientation(this.minCoord,pNext,pPrev);var usePrev=false;if(pPrev.y<this.minCoord.y&&pNext.y<this.minCoord.y&&orientation===jsts.algorithm.CGAlgorithms.COUNTERCLOCKWISE){usePrev=true;}else if(pPrev.y>this.minCoord.y&&pNext.y>this.minCoord.y&&orientation===jsts.algorithm.CGAlgorithms.CLOCKWISE){usePrev=true;}
if(usePrev){this.minIndex=this.minIndex-1;}};jsts.operation.buffer.RightmostEdgeFinder.prototype.checkForRightmostCoordinate=function(de){var coord=de.getEdge().getCoordinates();for(var i=0;i<coord.length-1;i++){if(this.minCoord===null||coord[i].x>this.minCoord.x){this.minDe=de;this.minIndex=i;this.minCoord=coord[i];}}};jsts.operation.buffer.RightmostEdgeFinder.prototype.getRightmostSide=function(de,index){var side=this.getRightmostSideOfSegment(de,index);if(side<0)
side=this.getRightmostSideOfSegment(de,index-1);if(side<0){this.minCoord=null;this.checkForRightmostCoordinate(de);}
return side;};jsts.operation.buffer.RightmostEdgeFinder.prototype.getRightmostSideOfSegment=function(de,i){var e=de.getEdge();var coord=e.getCoordinates();if(i<0||i+1>=coord.length)
return-1;if(coord[i].y==coord[i+1].y)
return-1;var pos=jsts.geomgraph.Position.LEFT;if(coord[i].y<coord[i+1].y)
pos=jsts.geomgraph.Position.RIGHT;return pos;};(function(){jsts.triangulate.IncrementalDelaunayTriangulator=function(subdiv){this.subdiv=subdiv;this.isUsingTolerance=subdiv.getTolerance()>0.0;};jsts.triangulate.IncrementalDelaunayTriangulator.prototype.insertSites=function(vertices){var i=0,il=vertices.length,v;for(i;i<il;i++){v=vertices[i];this.insertSite(v);}};jsts.triangulate.IncrementalDelaunayTriangulator.prototype.insertSite=function(v){var e,base,startEdge,t;e=this.subdiv.locate(v);if(this.subdiv.isVertexOfEdge(e,v)){return e;}
else if(this.subdiv.isOnEdge(e,v.getCoordinate())){e=e.oPrev();this.subdiv.delete_jsts(e.oNext());}
base=this.subdiv.makeEdge(e.orig(),v);jsts.triangulate.quadedge.QuadEdge.splice(base,e);startEdge=base;do{base=this.subdiv.connect(e,base.sym());e=base.oPrev();}while(e.lNext()!=startEdge);do{t=e.oPrev();if(t.dest().rightOf(e)&&v.isInCircle(e.orig(),t.dest(),e.dest())){jsts.triangulate.quadedge.QuadEdge.swap(e);e=e.oPrev();}else if(e.oNext()==startEdge){return base;}else{e=e.oNext().lPrev();}}while(true);};}());jsts.algorithm.CentroidArea=function(){this.basePt=null;this.triangleCent3=new jsts.geom.Coordinate();this.centSum=new jsts.geom.Coordinate();this.cg3=new jsts.geom.Coordinate();};jsts.algorithm.CentroidArea.prototype.basePt=null;jsts.algorithm.CentroidArea.prototype.triangleCent3=null;jsts.algorithm.CentroidArea.prototype.areasum2=0;jsts.algorithm.CentroidArea.prototype.cg3=null;jsts.algorithm.CentroidArea.prototype.centSum=null;jsts.algorithm.CentroidArea.prototype.totalLength=0.0;jsts.algorithm.CentroidArea.prototype.add=function(geom){if(geom instanceof jsts.geom.Polygon){var poly=geom;this.setBasePoint(poly.getExteriorRing().getCoordinateN(0));this.add3(poly);}else if(geom instanceof jsts.geom.GeometryCollection||geom instanceof jsts.geom.MultiPolygon){var gc=geom;for(var i=0;i<gc.getNumGeometries();i++){this.add(gc.getGeometryN(i));}}else if(geom instanceof Array){this.add2(geom);}};jsts.algorithm.CentroidArea.prototype.add2=function(ring){this.setBasePoint(ring[0]);this.addShell(ring);};jsts.algorithm.CentroidArea.prototype.getCentroid=function(){var cent=new jsts.geom.Coordinate();if(Math.abs(this.areasum2)>0.0){cent.x=this.cg3.x/3/this.areasum2;cent.y=this.cg3.y/3/this.areasum2;}else{cent.x=this.centSum.x/this.totalLength;cent.y=this.centSum.y/this.totalLength;}
return cent;};jsts.algorithm.CentroidArea.prototype.setBasePoint=function(basePt){if(this.basePt==null)
this.basePt=basePt;};jsts.algorithm.CentroidArea.prototype.add3=function(poly){this.addShell(poly.getExteriorRing().getCoordinates());for(var i=0;i<poly.getNumInteriorRing();i++){this.addHole(poly.getInteriorRingN(i).getCoordinates());}};jsts.algorithm.CentroidArea.prototype.addShell=function(pts){var isPositiveArea=!jsts.algorithm.CGAlgorithms.isCCW(pts);for(var i=0;i<pts.length-1;i++){this.addTriangle(this.basePt,pts[i],pts[i+1],isPositiveArea);}
this.addLinearSegments(pts);};jsts.algorithm.CentroidArea.prototype.addHole=function(pts){var isPositiveArea=jsts.algorithm.CGAlgorithms.isCCW(pts);for(var i=0;i<pts.length-1;i++){this.addTriangle(this.basePt,pts[i],pts[i+1],isPositiveArea);}
this.addLinearSegments(pts);};jsts.algorithm.CentroidArea.prototype.addTriangle=function(p0,p1,p2,isPositiveArea){var sign=(isPositiveArea)?1.0:-1.0;jsts.algorithm.CentroidArea.centroid3(p0,p1,p2,this.triangleCent3);var area2=jsts.algorithm.CentroidArea.area2(p0,p1,p2);this.cg3.x+=sign*area2*this.triangleCent3.x;this.cg3.y+=sign*area2*this.triangleCent3.y;this.areasum2+=sign*area2;};jsts.algorithm.CentroidArea.centroid3=function(p1,p2,p3,c){c.x=p1.x+p2.x+p3.x;c.y=p1.y+p2.y+p3.y;return;};jsts.algorithm.CentroidArea.area2=function(p1,p2,p3){return(p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y);};jsts.algorithm.CentroidArea.prototype.addLinearSegments=function(pts){for(var i=0;i<pts.length-1;i++){var segmentLen=pts[i].distance(pts[i+1]);this.totalLength+=segmentLen;var midx=(pts[i].x+pts[i+1].x)/2;this.centSum.x+=segmentLen*midx;var midy=(pts[i].y+pts[i+1].y)/2;this.centSum.y+=segmentLen*midy;}};jsts.geomgraph.index.SweepLineSegment=function(edge,ptIndex){this.edge=edge;this.ptIndex=ptIndex;this.pts=edge.getCoordinates();};jsts.geomgraph.index.SweepLineSegment.prototype.edge=null;jsts.geomgraph.index.SweepLineSegment.prototype.pts=null;jsts.geomgraph.index.SweepLineSegment.prototype.ptIndex=null;jsts.geomgraph.index.SweepLineSegment.prototype.getMinX=function(){var x1=this.pts[this.ptIndex].x;var x2=this.pts[this.ptIndex+1].x;if(x1<x2){return x1;}
return x2;};jsts.geomgraph.index.SweepLineSegment.prototype.getMaxX=function(){var x1=this.pts[this.ptIndex].x;var x2=this.pts[this.ptIndex+1].x;if(x1>x2){return x1;}
return x2;};jsts.geomgraph.index.SweepLineSegment.prototype.computeIntersections=function(ss,si){si.addIntersections(this.edge,this.ptIndex,ss.edge,ss.ptIndex);};jsts.index.quadtree.Root=function(){jsts.index.quadtree.NodeBase.prototype.constructor.apply(this,arguments);this.origin=new jsts.geom.Coordinate(0.0,0.0);};jsts.index.quadtree.Root.prototype=new jsts.index.quadtree.NodeBase();jsts.index.quadtree.Root.prototype.insert=function(itemEnv,item){var index=this.getSubnodeIndex(itemEnv,this.origin);if(index===-1){this.add(item);return;}
var node=this.subnode[index];if(node===null||!node.getEnvelope().contains(itemEnv)){var largerNode=jsts.index.quadtree.Node.createExpanded(node,itemEnv);this.subnode[index]=largerNode;}
this.insertContained(this.subnode[index],itemEnv,item);};jsts.index.quadtree.Root.prototype.insertContained=function(tree,itemEnv,item){var isZeroX,isZeroY,node;isZeroX=jsts.index.IntervalSize.isZeroWidth(itemEnv.getMinX(),itemEnv.getMaxX());isZeroY=jsts.index.IntervalSize.isZeroWidth(itemEnv.getMinY(),itemEnv.getMaxY());if(isZeroX||isZeroY){node=tree.find(itemEnv);}else{node=tree.getNode(itemEnv);}
node.add(item);};jsts.index.quadtree.Root.prototype.isSearchMatch=function(searchEnv){return true;};jsts.geomgraph.index.MonotoneChainIndexer=function(){};jsts.geomgraph.index.MonotoneChainIndexer.toIntArray=function(list){var array=[];for(var i=list.iterator();i.hasNext();){var element=i.next();array.push(element);}
return array;};jsts.geomgraph.index.MonotoneChainIndexer.prototype.getChainStartIndices=function(pts){var start=0;var startIndexList=new javascript.util.ArrayList();startIndexList.add(start);do{var last=this.findChainEnd(pts,start);startIndexList.add(last);start=last;}while(start<pts.length-1);var startIndex=jsts.geomgraph.index.MonotoneChainIndexer.toIntArray(startIndexList);return startIndex;};jsts.geomgraph.index.MonotoneChainIndexer.prototype.findChainEnd=function(pts,start){var chainQuad=jsts.geomgraph.Quadrant.quadrant(pts[start],pts[start+1]);var last=start+1;while(last<pts.length){var quad=jsts.geomgraph.Quadrant.quadrant(pts[last-1],pts[last]);if(quad!=chainQuad){break;}
last++;}
return last-1;};jsts.noding.IntersectionAdder=function(li){this.li=li;};jsts.noding.IntersectionAdder.prototype=new jsts.noding.SegmentIntersector();jsts.noding.IntersectionAdder.constructor=jsts.noding.IntersectionAdder;jsts.noding.IntersectionAdder.isAdjacentSegments=function(i1,i2){return Math.abs(i1-i2)===1;};jsts.noding.IntersectionAdder.prototype._hasIntersection=false;jsts.noding.IntersectionAdder.prototype.hasProper=false;jsts.noding.IntersectionAdder.prototype.hasProperInterior=false;jsts.noding.IntersectionAdder.prototype.hasInterior=false;jsts.noding.IntersectionAdder.prototype.properIntersectionPoint=null;jsts.noding.IntersectionAdder.prototype.li=null;jsts.noding.IntersectionAdder.prototype.isSelfIntersection=null;jsts.noding.IntersectionAdder.prototype.numIntersections=0;jsts.noding.IntersectionAdder.prototype.numInteriorIntersections=0;jsts.noding.IntersectionAdder.prototype.numProperIntersections=0;jsts.noding.IntersectionAdder.prototype.numTests=0;jsts.noding.IntersectionAdder.prototype.getLineIntersector=function(){return this.li;};jsts.noding.IntersectionAdder.prototype.getProperIntersectionPoint=function(){return this.properIntersectionPoint;};jsts.noding.IntersectionAdder.prototype.hasIntersection=function(){return this._hasIntersection;};jsts.noding.IntersectionAdder.prototype.hasProperIntersection=function(){return this.hasProper;};jsts.noding.IntersectionAdder.prototype.hasProperInteriorIntersection=function(){return this.hasProperInterior;};jsts.noding.IntersectionAdder.prototype.hasInteriorIntersection=function(){return this.hasInterior;};jsts.noding.IntersectionAdder.prototype.isTrivialIntersection=function(e0,segIndex0,e1,segIndex1){if(e0==e1){if(this.li.getIntersectionNum()==1){if(jsts.noding.IntersectionAdder.isAdjacentSegments(segIndex0,segIndex1))
return true;if(e0.isClosed()){var maxSegIndex=e0.size()-1;if((segIndex0===0&&segIndex1===maxSegIndex)||(segIndex1===0&&segIndex0===maxSegIndex)){return true;}}}}
return false;};jsts.noding.IntersectionAdder.prototype.processIntersections=function(e0,segIndex0,e1,segIndex1){if(e0===e1&&segIndex0===segIndex1)
return;this.numTests++;var p00=e0.getCoordinates()[segIndex0];var p01=e0.getCoordinates()[segIndex0+1];var p10=e1.getCoordinates()[segIndex1];var p11=e1.getCoordinates()[segIndex1+1];this.li.computeIntersection(p00,p01,p10,p11);if(this.li.hasIntersection()){this.numIntersections++;if(this.li.isInteriorIntersection()){this.numInteriorIntersections++;this.hasInterior=true;}
if(!this.isTrivialIntersection(e0,segIndex0,e1,segIndex1)){this._hasIntersection=true;e0.addIntersections(this.li,segIndex0,0);e1.addIntersections(this.li,segIndex1,1);if(this.li.isProper()){this.numProperIntersections++;this.hasProper=true;this.hasProperInterior=true;}}}};jsts.noding.IntersectionAdder.prototype.isDone=function(){return false;};jsts.operation.union.CascadedPolygonUnion=function(polys){this.inputPolys=polys;};jsts.operation.union.CascadedPolygonUnion.union=function(polys){var op=new jsts.operation.union.CascadedPolygonUnion(polys);return op.union();};jsts.operation.union.CascadedPolygonUnion.prototype.inputPolys;jsts.operation.union.CascadedPolygonUnion.prototype.geomFactory=null;jsts.operation.union.CascadedPolygonUnion.prototype.STRTREE_NODE_CAPACITY=4;jsts.operation.union.CascadedPolygonUnion.prototype.union=function(){if(this.inputPolys.length===0){return null;}
this.geomFactory=this.inputPolys[0].getFactory();var index=new jsts.index.strtree.STRtree(this.STRTREE_NODE_CAPACITY);for(var i=0,l=this.inputPolys.length;i<l;i++){var item=this.inputPolys[i];index.insert(item.getEnvelopeInternal(),item);}
var itemTree=index.itemsTree();var unionAll=this.unionTree(itemTree);return unionAll;};jsts.operation.union.CascadedPolygonUnion.prototype.unionTree=function(geomTree){var geoms=this.reduceToGeometries(geomTree);var union=this.binaryUnion(geoms);return union;};jsts.operation.union.CascadedPolygonUnion.prototype.binaryUnion=function(geoms,start,end){start=start||0;end=end||geoms.length;if(end-start<=1){var g0=this.getGeometry(geoms,start);return this.unionSafe(g0,null);}
else if(end-start===2){return this.unionSafe(this.getGeometry(geoms,start),this.getGeometry(geoms,start+1));}
else{var mid=parseInt((end+start)/2);var g0=this.binaryUnion(geoms,start,mid);var g1=this.binaryUnion(geoms,mid,end);return this.unionSafe(g0,g1);}};jsts.operation.union.CascadedPolygonUnion.prototype.getGeometry=function(list,index){if(index>=list.length){return null;}
return list[index];};jsts.operation.union.CascadedPolygonUnion.prototype.reduceToGeometries=function(geomTree){var geoms=[];for(var i=0,l=geomTree.length;i<l;i++){var o=geomTree[i],geom=null;if(o instanceof Array){geom=this.unionTree(o);}
else if(o instanceof jsts.geom.Geometry){geom=o;}
geoms.push(geom);}
return geoms;};jsts.operation.union.CascadedPolygonUnion.prototype.unionSafe=function(g0,g1){if(g0===null&&g1===null){return null;}
if(g0===null){return g1.clone();}
if(g1===null){return g0.clone();}
return this.unionOptimized(g0,g1);};jsts.operation.union.CascadedPolygonUnion.prototype.unionOptimized=function(g0,g1){var g0Env=g0.getEnvelopeInternal(),g1Env=g1.getEnvelopeInternal();if(!g0Env.intersects(g1Env)){var combo=jsts.geom.util.GeometryCombiner.combine(g0,g1);return combo;}
if(g0.getNumGeometries<=1&&g1.getNumGeometries<=1){return this.unionActual(g0,g1);}
var commonEnv=g0Env.intersection(g1Env);return this.unionUsingEnvelopeIntersection(g0,g1,commonEnv);};jsts.operation.union.CascadedPolygonUnion.prototype.unionUsingEnvelopeIntersection=function(g0,g1,common){var disjointPolys=new javascript.util.ArrayList();var g0Int=this.extractByEnvelope(common,g0,disjointPolys);var g1Int=this.extractByEnvelope(common,g1,disjointPolys);var union=this.unionActual(g0Int,g1Int);disjointPolys.add(union);var overallUnion=jsts.geom.util.GeometryCombiner.combine(disjointPolys);return overallUnion;};jsts.operation.union.CascadedPolygonUnion.prototype.extractByEnvelope=function(env,geom,disjointGeoms){var intersectingGeoms=new javascript.util.ArrayList();for(var i=0;i<geom.getNumGeometries();i++){var elem=geom.getGeometryN(i);if(elem.getEnvelopeInternal().intersects(env)){intersectingGeoms.add(elem);}
else{disjointGeoms.add(elem);}}
return this.geomFactory.buildGeometry(intersectingGeoms);};jsts.operation.union.CascadedPolygonUnion.prototype.unionActual=function(g0,g1){return g0.union(g1);};(function(){jsts.geom.MultiPoint=function(points,factory){this.geometries=points||[];this.factory=factory;};jsts.geom.MultiPoint.prototype=new jsts.geom.GeometryCollection();jsts.geom.MultiPoint.constructor=jsts.geom.MultiPoint;jsts.geom.MultiPoint.prototype.getBoundary=function(){return this.getFactory().createGeometryCollection(null);};jsts.geom.MultiPoint.prototype.getGeometryN=function(n){return this.geometries[n];};jsts.geom.MultiPoint.prototype.equalsExact=function(other,tolerance){if(!this.isEquivalentClass(other)){return false;}
return jsts.geom.GeometryCollection.prototype.equalsExact.call(this,other,tolerance);};jsts.geom.MultiPoint.prototype.CLASS_NAME='jsts.geom.MultiPoint';})();jsts.operation.buffer.OffsetCurveBuilder=function(precisionModel,bufParams){this.precisionModel=precisionModel;this.bufParams=bufParams;};jsts.operation.buffer.OffsetCurveBuilder.prototype.distance=0.0;jsts.operation.buffer.OffsetCurveBuilder.prototype.precisionModel=null;jsts.operation.buffer.OffsetCurveBuilder.prototype.bufParams=null;jsts.operation.buffer.OffsetCurveBuilder.prototype.getBufferParameters=function(){return this.bufParams;};jsts.operation.buffer.OffsetCurveBuilder.prototype.getLineCurve=function(inputPts,distance){this.distance=distance;if(this.distance<0.0&&!this.bufParams.isSingleSided())
return null;if(this.distance==0.0)
return null;var posDistance=Math.abs(this.distance);var segGen=this.getSegGen(posDistance);if(inputPts.length<=1){this.computePointCurve(inputPts[0],segGen);}else{if(this.bufParams.isSingleSided()){var isRightSide=distance<0.0;this.computeSingleSidedBufferCurve(inputPts,isRightSide,segGen);}else
this.computeLineBufferCurve(inputPts,segGen);}
var lineCoord=segGen.getCoordinates();return lineCoord;};jsts.operation.buffer.OffsetCurveBuilder.prototype.getRingCurve=function(inputPts,side,distance){this.distance=distance;if(inputPts.length<=2)
return this.getLineCurve(inputPts,distance);if(this.distance==0.0){return jsts.operation.buffer.OffsetCurveBuilder.copyCoordinates(inputPts);}
var segGen=this.getSegGen(this.distance);this.computeRingBufferCurve(inputPts,side,segGen);return segGen.getCoordinates();};jsts.operation.buffer.OffsetCurveBuilder.prototype.getOffsetCurve=function(inputPts,distance){this.distance=distance;if(this.distance===0.0)
return null;var isRightSide=this.distance<0.0;var posDistance=Math.abs(this.distance);var segGen=this.getSegGen(posDistance);if(inputPts.length<=1){this.computePointCurve(inputPts[0],segGen);}else{this.computeOffsetCurve(inputPts,isRightSide,segGen);}
var curvePts=segGen.getCoordinates();if(isRightSide)
curvePts.reverse();return curvePts;};jsts.operation.buffer.OffsetCurveBuilder.copyCoordinates=function(pts){var copy=[];for(var i=0;i<pts.length;i++){copy.push(pts[i].clone());}
return copy;};jsts.operation.buffer.OffsetCurveBuilder.prototype.getSegGen=function(distance){return new jsts.operation.buffer.OffsetSegmentGenerator(this.precisionModel,this.bufParams,distance);};jsts.operation.buffer.OffsetCurveBuilder.SIMPLIFY_FACTOR=100.0;jsts.operation.buffer.OffsetCurveBuilder.simplifyTolerance=function(bufDistance){return bufDistance/jsts.operation.buffer.OffsetCurveBuilder.SIMPLIFY_FACTOR;};jsts.operation.buffer.OffsetCurveBuilder.prototype.computePointCurve=function(pt,segGen){switch(this.bufParams.getEndCapStyle()){case jsts.operation.buffer.BufferParameters.CAP_ROUND:segGen.createCircle(pt);break;case jsts.operation.buffer.BufferParameters.CAP_SQUARE:segGen.createSquare(pt);break;}};jsts.operation.buffer.OffsetCurveBuilder.prototype.computeLineBufferCurve=function(inputPts,segGen){var distTol=jsts.operation.buffer.OffsetCurveBuilder.simplifyTolerance(this.distance);var simp1=jsts.operation.buffer.BufferInputLineSimplifier.simplify(inputPts,distTol);var n1=simp1.length-1;segGen.initSideSegments(simp1[0],simp1[1],jsts.geomgraph.Position.LEFT);for(var i=2;i<=n1;i++){segGen.addNextSegment(simp1[i],true);}
segGen.addLastSegment();segGen.addLineEndCap(simp1[n1-1],simp1[n1]);var simp2=jsts.operation.buffer.BufferInputLineSimplifier.simplify(inputPts,-distTol);var n2=simp2.length-1;segGen.initSideSegments(simp2[n2],simp2[n2-1],jsts.geomgraph.Position.LEFT);for(var i=n2-2;i>=0;i--){segGen.addNextSegment(simp2[i],true);}
segGen.addLastSegment();segGen.addLineEndCap(simp2[1],simp2[0]);segGen.closeRing();};jsts.operation.buffer.OffsetCurveBuilder.prototype.computeSingleSidedBufferCurve=function(inputPts,isRightSide,segGen){var distTol=jsts.operation.buffer.OffsetCurveBuilder.simplifyTolerance(this.distance);if(isRightSide){segGen.addSegments(inputPts,true);var simp2=jsts.operation.buffer.BufferInputLineSimplifier.simplify(inputPts,-distTol);var n2=simp2.length-1;segGen.initSideSegments(simp2[n2],simp2[n2-1],jsts.geomgraph.Position.LEFT);segGen.addFirstSegment();for(var i=n2-2;i>=0;i--){segGen.addNextSegment(simp2[i],true);}}else{segGen.addSegments(inputPts,false);var simp1=jsts.operation.buffer.BufferInputLineSimplifier.simplify(inputPts,distTol);var n1=simp1.length-1;segGen.initSideSegments(simp1[0],simp1[1],jsts.geomgraph.Position.LEFT);segGen.addFirstSegment();for(var i=2;i<=n1;i++){segGen.addNextSegment(simp1[i],true);}}
segGen.addLastSegment();segGen.closeRing();};jsts.operation.buffer.OffsetCurveBuilder.prototype.computeOffsetCurve=function(inputPts,isRightSide,segGen){var distTol=jsts.operation.buffer.OffsetCurveBuilder.simplifyTolerance(this.distance);if(isRightSide){var simp2=jsts.operation.buffer.BufferInputLineSimplifier.simplify(inputPts,-distTol);var n2=simp2.length-1;segGen.initSideSegments(simp2[n2],simp2[n2-1],jsts.geomgraph.Position.LEFT);segGen.addFirstSegment();for(var i=n2-2;i>=0;i--){segGen.addNextSegment(simp2[i],true);}}else{var simp1=jsts.operation.buffer.BufferInputLineSimplifier.simplify(inputPts,distTol);var n1=simp1.length-1;segGen.initSideSegments(simp1[0],simp1[1],jsts.geomgraph.Position.LEFT);segGen.addFirstSegment();for(var i=2;i<=n1;i++){segGen.addNextSegment(simp1[i],true);}}
segGen.addLastSegment();};jsts.operation.buffer.OffsetCurveBuilder.prototype.computeRingBufferCurve=function(inputPts,side,segGen){var distTol=jsts.operation.buffer.OffsetCurveBuilder.simplifyTolerance(this.distance);if(side===jsts.geomgraph.Position.RIGHT)
distTol=-distTol;var simp=jsts.operation.buffer.BufferInputLineSimplifier.simplify(inputPts,distTol);var n=simp.length-1;segGen.initSideSegments(simp[n-1],simp[0],side);for(var i=1;i<=n;i++){var addStartPoint=i!==1;segGen.addNextSegment(simp[i],addStartPoint);}
segGen.closeRing();};(function(){var HotPixelSnapAction=function(hotPixel,parentEdge,vertexIndex){this.hotPixel=hotPixel;this.parentEdge=parentEdge;this.vertexIndex=vertexIndex;};HotPixelSnapAction.prototype=new jsts.index.chain.MonotoneChainSelectAction();HotPixelSnapAction.constructor=HotPixelSnapAction;HotPixelSnapAction.prototype.hotPixel=null;HotPixelSnapAction.prototype.parentEdge=null;HotPixelSnapAction.prototype.vertexIndex=null;HotPixelSnapAction.prototype._isNodeAdded=false;HotPixelSnapAction.prototype.isNodeAdded=function(){return this._isNodeAdded;};HotPixelSnapAction.prototype.select=function(mc,startIndex){var ss=mc.getContext();if(this.parentEdge!==null){if(ss===this.parentEdge&&startIndex===this.vertexIndex)
return;}
this._isNodeAdded=this.hotPixel.addSnappedNode(ss,startIndex);};jsts.noding.snapround.MCIndexPointSnapper=function(index){this.index=index;};jsts.noding.snapround.MCIndexPointSnapper.prototype.index=null;jsts.noding.snapround.MCIndexPointSnapper.prototype.snap=function(hotPixel,parentEdge,vertexIndex){if(arguments.length===1){this.snap2.apply(this,arguments);return;}
var pixelEnv=hotPixel.getSafeEnvelope();var hotPixelSnapAction=new HotPixelSnapAction(hotPixel,parentEdge,vertexIndex);this.index.query(pixelEnv,{visitItem:function(testChain){testChain.select(pixelEnv,hotPixelSnapAction);}});return hotPixelSnapAction.isNodeAdded();};jsts.noding.snapround.MCIndexPointSnapper.prototype.snap2=function(hotPixel){return this.snap(hotPixel,null,-1);};})();(function(){var NodeBase=function(){this.items=new javascript.util.ArrayList();this.subnode=[null,null];};NodeBase.getSubnodeIndex=function(interval,centre){var subnodeIndex=-1;if(interval.min>=centre){subnodeIndex=1;}
if(interval.max<=centre){subnodeIndex=0;}
return subnodeIndex;};NodeBase.prototype.getItems=function(){return this.items;};NodeBase.prototype.add=function(item){this.items.add(item);};NodeBase.prototype.addAllItems=function(items){items.addAll(this.items);var i=0,il=2;for(i;i<il;i++){if(this.subnode[i]!==null){this.subnode[i].addAllItems(items);}}
return items;};NodeBase.prototype.addAllItemsFromOverlapping=function(interval,resultItems){if(interval!==null&&!this.isSearchMatch(interval)){return;}
resultItems.addAll(this.items);if(this.subnode[0]!==null){this.subnode[0].addAllItemsFromOverlapping(interval,resultItems);}
if(this.subnode[1]!==null){this.subnode[1].addAllItemsFromOverlapping(interval,resultItems);}};NodeBase.prototype.remove=function(itemInterval,item){if(!this.isSearchMatch(itemInterval)){return false;}
var found=false,i=0,il=2;for(i;i<il;i++){if(this.subnode[i]!==null){found=this.subnode[i].remove(itemInterval,item);if(found){if(this.subnode[i].isPrunable()){this.subnode[i]=null;}
break;}}}
if(found){return found;}
found=this.items.remove(item);return found;};NodeBase.prototype.isPrunable=function(){return!(this.hasChildren()||this.hasItems());};NodeBase.prototype.hasChildren=function(){var i=0,il=2;for(i;i<il;i++){if(this.subnode[i]!==null){return true;}}
return false;};NodeBase.prototype.hasItems=function(){return!this.items.isEmpty();};NodeBase.prototype.depth=function(){var maxSubDepth=0,i=0,il=2,sqd;for(i;i<il;i++){if(this.subnode[i]!==null){sqd=this.subnode[i].depth();if(sqd>maxSubDepth){maxSubDepth=sqd;}}}
return maxSubDepth+1;};NodeBase.prototype.size=function(){var subSize=0,i=0,il=2;for(i;i<il;i++){if(this.subnode[i]!==null){subSize+=this.subnode[i].size();}}
return subSize+this.items.size();};NodeBase.prototype.nodeSize=function(){var subSize=0,i=0,il=2;for(i;i<il;i++){if(this.subnode[i]!==null){subSize+=this.subnode[i].nodeSize();}}
return subSize+1;};jsts.index.bintree.NodeBase=NodeBase;})();(function(){var NodeBase=jsts.index.bintree.NodeBase;var Key=jsts.index.bintree.Key;var Interval=jsts.index.bintree.Interval;var Node=function(interval,level){this.items=new javascript.util.ArrayList();this.subnode=[null,null];this.interval=interval;this.level=level;this.centre=(interval.getMin()+interval.getMax())/2;};Node.prototype=new NodeBase();Node.constructor=Node;Node.createNode=function(itemInterval){var key,node;key=new Key(itemInterval);node=new Node(key.getInterval(),key.getLevel());return node;};Node.createExpanded=function(node,addInterval){var expandInt,largerNode;expandInt=new Interval(addInterval);if(node!==null){expandInt.expandToInclude(node.interval);}
largerNode=Node.createNode(expandInt);if(node!==null){largerNode.insert(node);}
return largerNode;};Node.prototype.getInterval=function(){return this.interval;};Node.prototype.isSearchMatch=function(itemInterval){return itemInterval.overlaps(this.interval);};Node.prototype.getNode=function(searchInterval){var subnodeIndex=NodeBase.getSubnodeIndex(searchInterval,this.centre),node;if(subnodeIndex!=-1){node=this.getSubnode(subnodeIndex);return node.getNode(searchInterval);}else{return this;}};Node.prototype.find=function(searchInterval){var subnodeIndex=NodeBase.getSubnodeIndex(searchInterval,this.centre),node;if(subnodeIndex===-1){return this;}
if(this.subnode[subnodeIndex]!==null){node=this.subnode[subnodeIndex];return node.find(searchInterval);}
return this;};Node.prototype.insert=function(node){var index=NodeBase.getSubnodeIndex(node.interval,this.centre),childNode;if(node.level===this.level-1){this.subnode[index]=node;}else{childNode=this.createSubnode(index);childNode.insert(node);this.subnode[index]=childNode;}};Node.prototype.getSubnode=function(index){if(this.subnode[index]===null){this.subnode[index]=this.createSubnode(index);}
return this.subnode[index];};Node.prototype.createSubnode=function(index){var min,max,subInt,node;min=0.0;max=0.0;switch(index){case 0:min=this.interval.getMin();max=this.centre;break;case 1:min=this.centre;max=this.interval.getMax();break;}
subInt=new Interval(min,max);node=new Node(subInt,this.level-1);return node;};jsts.index.bintree.Node=Node;})();(function(){var Node=jsts.index.bintree.Node;var NodeBase=jsts.index.bintree.NodeBase;var Root=function(){this.subnode=[null,null];this.items=new javascript.util.ArrayList();};Root.prototype=new jsts.index.bintree.NodeBase();Root.constructor=Root;Root.origin=0.0;Root.prototype.insert=function(itemInterval,item){var index=NodeBase.getSubnodeIndex(itemInterval,Root.origin),node,largerNode;if(index===-1){this.add(item);return;}
node=this.subnode[index];if(node===null||!node.getInterval().contains(itemInterval)){largerNode=Node.createExpanded(node,itemInterval);this.subnode[index]=largerNode;}
this.insertContained(this.subnode[index],itemInterval,item);};Root.prototype.insertContained=function(tree,itemInterval,item){var isZeroArea,node;isZeroArea=jsts.index.IntervalSize.isZeroWidth(itemInterval.getMin(),itemInterval.getMax());node=isZeroArea?tree.find(itemInterval):tree.getNode(itemInterval);node.add(item);};Root.prototype.isSearchMatch=function(interval){return true;};jsts.index.bintree.Root=Root;})();jsts.geomgraph.Quadrant=function(){};jsts.geomgraph.Quadrant.NE=0;jsts.geomgraph.Quadrant.NW=1;jsts.geomgraph.Quadrant.SW=2;jsts.geomgraph.Quadrant.SE=3;jsts.geomgraph.Quadrant.quadrant=function(dx,dy){if(dx instanceof jsts.geom.Coordinate){return jsts.geomgraph.Quadrant.quadrant2.apply(this,arguments);}
if(dx===0.0&&dy===0.0)
throw new jsts.error.IllegalArgumentError('Cannot compute the quadrant for point ( '+dx+', '+dy+' )');if(dx>=0.0){if(dy>=0.0)
return jsts.geomgraph.Quadrant.NE;else
return jsts.geomgraph.Quadrant.SE;}else{if(dy>=0.0)
return jsts.geomgraph.Quadrant.NW;else
return jsts.geomgraph.Quadrant.SW;}};jsts.geomgraph.Quadrant.quadrant2=function(p0,p1){if(p1.x===p0.x&&p1.y===p0.y)
throw new jsts.error.IllegalArgumentError('Cannot compute the quadrant for two identical points '+p0);if(p1.x>=p0.x){if(p1.y>=p0.y)
return jsts.geomgraph.Quadrant.NE;else
return jsts.geomgraph.Quadrant.SE;}else{if(p1.y>=p0.y)
return jsts.geomgraph.Quadrant.NW;else
return jsts.geomgraph.Quadrant.SW;}};jsts.geomgraph.Quadrant.isOpposite=function(quad1,quad2){if(quad1===quad2)
return false;var diff=(quad1-quad2+4)%4;if(diff===2)
return true;return false;};jsts.geomgraph.Quadrant.commonHalfPlane=function(quad1,quad2){if(quad1===quad2)
return quad1;var diff=(quad1-quad2+4)%4;if(diff===2)
return-1;var min=(quad1<quad2)?quad1:quad2;var max=(quad1>quad2)?quad1:quad2;if(min===0&&max===3)
return 3;return min;};jsts.geomgraph.Quadrant.isInHalfPlane=function(quad,halfPlane){if(halfPlane===jsts.geomgraph.Quadrant.SE){return quad===jsts.geomgraph.Quadrant.SE||quad===jsts.geomgraph.Quadrant.SW;}
return quad===halfPlane||quad===halfPlane+1;};jsts.geomgraph.Quadrant.isNorthern=function(quad){return quad===jsts.geomgraph.Quadrant.NE||quad===jsts.geomgraph.Quadrant.NW;};jsts.operation.valid.ConsistentAreaTester=function(geomGraph){this.geomGraph=geomGraph;this.li=new jsts.algorithm.RobustLineIntersector();this.nodeGraph=new jsts.operation.relate.RelateNodeGraph();this.invalidPoint=null;};jsts.operation.valid.ConsistentAreaTester.prototype.getInvalidPoint=function(){return this.invalidPoint;};jsts.operation.valid.ConsistentAreaTester.prototype.isNodeConsistentArea=function(){var intersector=this.geomGraph.computeSelfNodes(this.li,true);if(intersector.hasProperIntersection()){this.invalidPoint=intersector.getProperIntersectionPoint();return false;}
this.nodeGraph.build(this.geomGraph);return this.isNodeEdgeAreaLabelsConsistent();};jsts.operation.valid.ConsistentAreaTester.prototype.isNodeEdgeAreaLabelsConsistent=function(){for(var nodeIt=this.nodeGraph.getNodeIterator();nodeIt.hasNext();){var node=nodeIt.next();if(!node.getEdges().isAreaLabelsConsistent(this.geomGraph)){this.invalidPoint=node.getCoordinate().clone();return false;}}
return true;};jsts.operation.valid.ConsistentAreaTester.prototype.hasDuplicateRings=function(){for(var nodeIt=this.nodeGraph.getNodeIterator();nodeIt.hasNext();){var node=nodeIt.next();for(var i=node.getEdges().iterator();i.hasNext();){var eeb=i.next();if(eeb.getEdgeEnds().length>1){invalidPoint=eeb.getEdge().getCoordinate(0);return true;}}}
return false;};jsts.operation.relate.RelateNode=function(coord,edges){jsts.geomgraph.Node.apply(this,arguments);};jsts.operation.relate.RelateNode.prototype=new jsts.geomgraph.Node();jsts.operation.relate.RelateNode.prototype.computeIM=function(im){im.setAtLeastIfValid(this.label.getLocation(0),this.label.getLocation(1),0);};jsts.operation.relate.RelateNode.prototype.updateIMFromEdges=function(im){this.edges.updateIM(im);};(function(){var Location=jsts.geom.Location;var Position=jsts.geomgraph.Position;var EdgeEnd=jsts.geomgraph.EdgeEnd;jsts.geomgraph.DirectedEdge=function(edge,isForward){EdgeEnd.call(this,edge);this.depth=[0,-999,-999];this._isForward=isForward;if(isForward){this.init(edge.getCoordinate(0),edge.getCoordinate(1));}else{var n=edge.getNumPoints()-1;this.init(edge.getCoordinate(n),edge.getCoordinate(n-1));}
this.computeDirectedLabel();};jsts.geomgraph.DirectedEdge.prototype=new EdgeEnd();jsts.geomgraph.DirectedEdge.constructor=jsts.geomgraph.DirectedEdge;jsts.geomgraph.DirectedEdge.depthFactor=function(currLocation,nextLocation){if(currLocation===Location.EXTERIOR&&nextLocation===Location.INTERIOR)
return 1;else if(currLocation===Location.INTERIOR&&nextLocation===Location.EXTERIOR)
return-1;return 0;};jsts.geomgraph.DirectedEdge.prototype._isForward=null;jsts.geomgraph.DirectedEdge.prototype._isInResult=false;jsts.geomgraph.DirectedEdge.prototype._isVisited=false;jsts.geomgraph.DirectedEdge.prototype.sym=null;jsts.geomgraph.DirectedEdge.prototype.next=null;jsts.geomgraph.DirectedEdge.prototype.nextMin=null;jsts.geomgraph.DirectedEdge.prototype.edgeRing=null;jsts.geomgraph.DirectedEdge.prototype.minEdgeRing=null;jsts.geomgraph.DirectedEdge.prototype.depth=null;jsts.geomgraph.DirectedEdge.prototype.getEdge=function(){return this.edge;};jsts.geomgraph.DirectedEdge.prototype.setInResult=function(isInResult){this._isInResult=isInResult;};jsts.geomgraph.DirectedEdge.prototype.isInResult=function(){return this._isInResult;};jsts.geomgraph.DirectedEdge.prototype.isVisited=function(){return this._isVisited;};jsts.geomgraph.DirectedEdge.prototype.setVisited=function(isVisited){this._isVisited=isVisited;};jsts.geomgraph.DirectedEdge.prototype.setEdgeRing=function(edgeRing){this.edgeRing=edgeRing;};jsts.geomgraph.DirectedEdge.prototype.getEdgeRing=function(){return this.edgeRing;};jsts.geomgraph.DirectedEdge.prototype.setMinEdgeRing=function(minEdgeRing){this.minEdgeRing=minEdgeRing;};jsts.geomgraph.DirectedEdge.prototype.getMinEdgeRing=function(){return this.minEdgeRing;};jsts.geomgraph.DirectedEdge.prototype.getDepth=function(position){return this.depth[position];};jsts.geomgraph.DirectedEdge.prototype.setDepth=function(position,depthVal){if(this.depth[position]!==-999){if(this.depth[position]!==depthVal)
throw new jsts.error.TopologyError('assigned depths do not match',this.getCoordinate());}
this.depth[position]=depthVal;};jsts.geomgraph.DirectedEdge.prototype.getDepthDelta=function(){var depthDelta=this.edge.getDepthDelta();if(!this._isForward)
depthDelta=-depthDelta;return depthDelta;};jsts.geomgraph.DirectedEdge.prototype.setVisitedEdge=function(isVisited){this.setVisited(isVisited);this.sym.setVisited(isVisited);};jsts.geomgraph.DirectedEdge.prototype.getSym=function(){return this.sym;};jsts.geomgraph.DirectedEdge.prototype.isForward=function(){return this._isForward;};jsts.geomgraph.DirectedEdge.prototype.setSym=function(de){this.sym=de;};jsts.geomgraph.DirectedEdge.prototype.getNext=function(){return this.next;};jsts.geomgraph.DirectedEdge.prototype.setNext=function(next){this.next=next;};jsts.geomgraph.DirectedEdge.prototype.getNextMin=function(){return this.nextMin;};jsts.geomgraph.DirectedEdge.prototype.setNextMin=function(nextMin){this.nextMin=nextMin;};jsts.geomgraph.DirectedEdge.prototype.isLineEdge=function(){var isLine=this.label.isLine(0)||this.label.isLine(1);var isExteriorIfArea0=!this.label.isArea(0)||this.label.allPositionsEqual(0,Location.EXTERIOR);var isExteriorIfArea1=!this.label.isArea(1)||this.label.allPositionsEqual(1,Location.EXTERIOR);return isLine&&isExteriorIfArea0&&isExteriorIfArea1;};jsts.geomgraph.DirectedEdge.prototype.isInteriorAreaEdge=function(){var isInteriorAreaEdge=true;for(var i=0;i<2;i++){if(!(this.label.isArea(i)&&this.label.getLocation(i,Position.LEFT)===Location.INTERIOR&&this.label.getLocation(i,Position.RIGHT)===Location.INTERIOR)){isInteriorAreaEdge=false;}}
return isInteriorAreaEdge;};jsts.geomgraph.DirectedEdge.prototype.computeDirectedLabel=function(){this.label=new jsts.geomgraph.Label(this.edge.getLabel());if(!this._isForward)
this.label.flip();};jsts.geomgraph.DirectedEdge.prototype.setEdgeDepths=function(position,depth){var depthDelta=this.getEdge().getDepthDelta();if(!this._isForward)
depthDelta=-depthDelta;var directionFactor=1;if(position===Position.LEFT)
directionFactor=-1;var oppositePos=Position.opposite(position);var delta=depthDelta*directionFactor;var oppositeDepth=depth+delta;this.setDepth(position,depth);this.setDepth(oppositePos,oppositeDepth);};})();jsts.operation.distance.DistanceOp=function(g0,g1,terminateDistance){this.ptLocator=new jsts.algorithm.PointLocator();this.geom=[];this.geom[0]=g0;this.geom[1]=g1;this.terminateDistance=terminateDistance;};jsts.operation.distance.DistanceOp.prototype.geom=null;jsts.operation.distance.DistanceOp.prototype.terminateDistance=0.0;jsts.operation.distance.DistanceOp.prototype.ptLocator=null;jsts.operation.distance.DistanceOp.prototype.minDistanceLocation=null;jsts.operation.distance.DistanceOp.prototype.minDistance=Number.MAX_VALUE;jsts.operation.distance.DistanceOp.distance=function(g0,g1){var distOp=new jsts.operation.distance.DistanceOp(g0,g1,0.0);return distOp.distance();};jsts.operation.distance.DistanceOp.isWithinDistance=function(g0,g1,distance){var distOp=new jsts.operation.distance.DistanceOp(g0,g1,distance);return distOp.distance()<=distance;};jsts.operation.distance.DistanceOp.nearestPoints=function(g0,g1){var distOp=new jsts.operation.distance.DistanceOp(g0,g1,0.0);return distOp.nearestPoints();};jsts.operation.distance.DistanceOp.prototype.distance=function(){if(this.geom[0]===null||this.geom[1]===null)
throw new jsts.error.IllegalArgumentError('null geometries are not supported');if(this.geom[0].isEmpty()||this.geom[1].isEmpty())
return 0.0;this.computeMinDistance();return this.minDistance;};jsts.operation.distance.DistanceOp.prototype.nearestPoints=function(){this.computeMinDistance();var nearestPts=[this.minDistanceLocation[0].getCoordinate(),this.minDistanceLocation[1].getCoordinate()];return nearestPts;};jsts.operation.distance.DistanceOp.prototype.nearestLocations=function(){this.computeMinDistance();return this.minDistanceLocation;};jsts.operation.distance.DistanceOp.prototype.updateMinDistance=function(locGeom,flip){if(locGeom[0]===null)
return;if(flip){this.minDistanceLocation[0]=locGeom[1];this.minDistanceLocation[1]=locGeom[0];}else{this.minDistanceLocation[0]=locGeom[0];this.minDistanceLocation[1]=locGeom[1];}};jsts.operation.distance.DistanceOp.prototype.computeMinDistance=function(){if(arguments.length>0){this.computeMinDistance2.apply(this,arguments);return;}
if(this.minDistanceLocation!==null)
return;this.minDistanceLocation=[];this.computeContainmentDistance();if(this.minDistance<=this.terminateDistance)
return;this.computeFacetDistance();};jsts.operation.distance.DistanceOp.prototype.computeContainmentDistance=function(){if(arguments.length===2){this.computeContainmentDistance2.apply(this,arguments);return;}else if(arguments.length===3&&(!arguments[0]instanceof jsts.operation.distance.GeometryLocation)){this.computeContainmentDistance3.apply(this,arguments);return;}else if(arguments.length===3){this.computeContainmentDistance4.apply(this,arguments);return;}
var locPtPoly=[];this.computeContainmentDistance2(0,locPtPoly);if(this.minDistance<=this.terminateDistance)
return;this.computeContainmentDistance2(1,locPtPoly);};jsts.operation.distance.DistanceOp.prototype.computeContainmentDistance2=function(polyGeomIndex,locPtPoly){var locationsIndex=1-polyGeomIndex;var polys=jsts.geom.util.PolygonExtracter.getPolygons(this.geom[polyGeomIndex]);if(polys.length>0){var insideLocs=jsts.operation.distance.ConnectedElementLocationFilter.getLocations(this.geom[locationsIndex]);this.computeContainmentDistance3(insideLocs,polys,locPtPoly);if(this.minDistance<=this.terminateDistance){this.minDistanceLocation[locationsIndex]=locPtPoly[0];this.minDistanceLocation[polyGeomIndex]=locPtPoly[1];return;}}};jsts.operation.distance.DistanceOp.prototype.computeContainmentDistance3=function(locs,polys,locPtPoly){for(var i=0;i<locs.length;i++){var loc=locs[i];for(var j=0;j<polys.length;j++){this.computeContainmentDistance4(loc,polys[j],locPtPoly);if(this.minDistance<=this.terminateDistance)
return;}}};jsts.operation.distance.DistanceOp.prototype.computeContainmentDistance4=function(ptLoc,poly,locPtPoly){var pt=ptLoc.getCoordinate();if(jsts.geom.Location.EXTERIOR!==this.ptLocator.locate(pt,poly)){this.minDistance=0.0;locPtPoly[0]=ptLoc;locPtPoly[1]=new jsts.operation.distance.GeometryLocation(poly,pt);return;}};jsts.operation.distance.DistanceOp.prototype.computeFacetDistance=function(){var locGeom=[];var lines0=jsts.geom.util.LinearComponentExtracter.getLines(this.geom[0]);var lines1=jsts.geom.util.LinearComponentExtracter.getLines(this.geom[1]);var pts0=jsts.geom.util.PointExtracter.getPoints(this.geom[0]);var pts1=jsts.geom.util.PointExtracter.getPoints(this.geom[1]);this.computeMinDistanceLines(lines0,lines1,locGeom);this.updateMinDistance(locGeom,false);if(this.minDistance<=this.terminateDistance)
return;locGeom[0]=null;locGeom[1]=null;this.computeMinDistanceLinesPoints(lines0,pts1,locGeom);this.updateMinDistance(locGeom,false);if(this.minDistance<=this.terminateDistance)
return;locGeom[0]=null;locGeom[1]=null;this.computeMinDistanceLinesPoints(lines1,pts0,locGeom);this.updateMinDistance(locGeom,true);if(this.minDistance<=this.terminateDistance)
return;locGeom[0]=null;locGeom[1]=null;this.computeMinDistancePoints(pts0,pts1,locGeom);this.updateMinDistance(locGeom,false);};jsts.operation.distance.DistanceOp.prototype.computeMinDistanceLines=function(lines0,lines1,locGeom){for(var i=0;i<lines0.length;i++){var line0=lines0[i];for(var j=0;j<lines1.length;j++){var line1=lines1[j];this.computeMinDistance(line0,line1,locGeom);if(this.minDistance<=this.terminateDistance)
return;}}};jsts.operation.distance.DistanceOp.prototype.computeMinDistancePoints=function(points0,points1,locGeom){for(var i=0;i<points0.length;i++){var pt0=points0[i];for(var j=0;j<points1.length;j++){var pt1=points1[j];var dist=pt0.getCoordinate().distance(pt1.getCoordinate());if(dist<this.minDistance){this.minDistance=dist;locGeom[0]=new jsts.operation.distance.GeometryLocation(pt0,0,pt0.getCoordinate());locGeom[1]=new jsts.operation.distance.GeometryLocation(pt1,0,pt1.getCoordinate());}
if(this.minDistance<=this.terminateDistance)
return;}}};jsts.operation.distance.DistanceOp.prototype.computeMinDistanceLinesPoints=function(lines,points,locGeom){for(var i=0;i<lines.length;i++){var line=lines[i];for(var j=0;j<points.length;j++){var pt=points[j];this.computeMinDistance(line,pt,locGeom);if(this.minDistance<=this.terminateDistance)
return;}}};jsts.operation.distance.DistanceOp.prototype.computeMinDistance2=function(line0,line1,locGeom){if(line1 instanceof jsts.geom.Point){this.computeMinDistance3(line0,line1,locGeom);return;}
if(line0.getEnvelopeInternal().distance(line1.getEnvelopeInternal())>this.minDistance){return;}
var coord0=line0.getCoordinates();var coord1=line1.getCoordinates();for(var i=0;i<coord0.length-1;i++){for(var j=0;j<coord1.length-1;j++){var dist=jsts.algorithm.CGAlgorithms.distanceLineLine(coord0[i],coord0[i+1],coord1[j],coord1[j+1]);if(dist<this.minDistance){this.minDistance=dist;var seg0=new jsts.geom.LineSegment(coord0[i],coord0[i+1]);var seg1=new jsts.geom.LineSegment(coord1[j],coord1[j+1]);var closestPt=seg0.closestPoints(seg1);locGeom[0]=new jsts.operation.distance.GeometryLocation(line0,i,closestPt[0]);locGeom[1]=new jsts.operation.distance.GeometryLocation(line1,j,closestPt[1]);}
if(this.minDistance<=this.terminateDistance){return;}}}};jsts.operation.distance.DistanceOp.prototype.computeMinDistance3=function(line,pt,locGeom){if(line.getEnvelopeInternal().distance(pt.getEnvelopeInternal())>this.minDistance){return;}
var coord0=line.getCoordinates();var coord=pt.getCoordinate();for(var i=0;i<coord0.length-1;i++){var dist=jsts.algorithm.CGAlgorithms.distancePointLine(coord,coord0[i],coord0[i+1]);if(dist<this.minDistance){this.minDistance=dist;var seg=new jsts.geom.LineSegment(coord0[i],coord0[i+1]);var segClosestPoint=seg.closestPoint(coord);locGeom[0]=new jsts.operation.distance.GeometryLocation(line,i,segClosestPoint);locGeom[1]=new jsts.operation.distance.GeometryLocation(pt,0,coord);}
if(this.minDistance<=this.terminateDistance){return;}}};jsts.index.strtree.SIRtree=function(nodeCapacity){nodeCapacity=nodeCapacity||10;jsts.index.strtree.AbstractSTRtree.call(this,nodeCapacity);};jsts.index.strtree.SIRtree.prototype=new jsts.index.strtree.AbstractSTRtree();jsts.index.strtree.SIRtree.constructor=jsts.index.strtree.SIRtree;jsts.index.strtree.SIRtree.prototype.comperator={compare:function(o1,o2){return o1.getBounds().getCentre()-o2.getBounds().getCentre();}};jsts.index.strtree.SIRtree.prototype.intersectionOp={intersects:function(aBounds,bBounds){return aBounds.intersects(bBounds);}};jsts.index.strtree.SIRtree.prototype.createNode=function(level){var AbstractNode=function(level){jsts.index.strtree.AbstractNode.apply(this,arguments);};AbstractNode.prototype=new jsts.index.strtree.AbstractNode();AbstractNode.constructor=AbstractNode;AbstractNode.prototype.computeBounds=function(){var bounds=null,childBoundables=this.getChildBoundables(),childBoundable;for(var i=0,l=childBoundables.length;i<l;i++){childBoundable=childBoundables[i];if(bounds===null){bounds=new jsts.index.strtree.Interval(childBoundable.getBounds());}
else{bounds.expandToInclude(childBoundable.getBounds());}}
return bounds;};return AbstractNode;};jsts.index.strtree.SIRtree.prototype.insert=function(x1,x2,item){jsts.index.strtree.AbstractSTRtree.prototype.insert(new jsts.index.strtree.Interval(Math.min(x1,x2),Math.max(x1,x2)),item);};jsts.index.strtree.SIRtree.prototype.query=function(x1,x2){x2=x2||x1;jsts.index.strtree.AbstractSTRtree.prototype.query(new jsts.index.strtree.Interval(Math.min(x1,x2),Math.max(x1,x2)));};jsts.index.strtree.SIRtree.prototype.getIntersectsOp=function(){return this.intersectionOp;};jsts.index.strtree.SIRtree.prototype.getComparator=function(){return this.comperator;};jsts.simplify.DouglasPeuckerSimplifier=function(inputGeom){this.inputGeom=inputGeom;this.isEnsureValidTopology=true;};jsts.simplify.DouglasPeuckerSimplifier.prototype.inputGeom=null;jsts.simplify.DouglasPeuckerSimplifier.prototype.distanceTolerance=null;jsts.simplify.DouglasPeuckerSimplifier.prototype.isEnsureValidTopology=null;jsts.simplify.DouglasPeuckerSimplifier.simplify=function(geom,distanceTolerance){var tss=new jsts.simplify.DouglasPeuckerSimplifier(geom);tss.setDistanceTolerance(distanceTolerance);return tss.getResultGeometry();};jsts.simplify.DouglasPeuckerSimplifier.prototype.setDistanceTolerance=function(distanceTolerance){if(distanceTolerance<0.0){throw"Tolerance must be non-negative";}
this.distanceTolerance=distanceTolerance;};jsts.simplify.DouglasPeuckerSimplifier.prototype.setEnsureValid=function(isEnsureValidTopology){this.isEnsureValidTopology=isEnsureValidTopology;};jsts.simplify.DouglasPeuckerSimplifier.prototype.getResultGeometry=function(){if(this.inputGeom.isEmpty()){return this.inputGeom.clone();}
return(new jsts.simplify.DPTransformer(this.distanceTolerance,this.isEnsureValidTopology)).transform(this.inputGeom);};(function(){jsts.operation.predicate.RectangleContains=function(rectangle){this.rectEnv=rectangle.getEnvelopeInternal();}
jsts.operation.predicate.RectangleContains.contains=function(rectangle,b){var rc=new jsts.operation.predicate.RectangleContains(rectangle);return rc.contains(b);}
jsts.operation.predicate.RectangleContains.prototype.rectEnv=null;jsts.operation.predicate.RectangleContains.prototype.contains=function(geom){if(!this.rectEnv.contains(geom.getEnvelopeInternal()))
return false;if(this.isContainedInBoundary(geom))
return false;return true;}
jsts.operation.predicate.RectangleContains.prototype.isContainedInBoundary=function(geom){if(geom instanceof jsts.geom.Polygon)return false;if(geom instanceof jsts.geom.Point)return this.isPointContainedInBoundary(geom.getCoordinate());if(geom instanceof jsts.geom.LineString)return this.isLineStringContainedInBoundary(geom);for(var i=0;i<geom.getNumGeometries();i++){var comp=geom.getGeometryN(i);if(!this.isContainedInBoundary(comp))
return false;}
return true;}
jsts.operation.predicate.RectangleContains.prototype.isPointContainedInBoundary=function(pt){return pt.x==this.rectEnv.getMinX()||pt.x==this.rectEnv.getMaxX()||pt.y==this.rectEnv.getMinY()||pt.y==this.rectEnv.getMaxY();}
jsts.operation.predicate.RectangleContains.prototype.isLineStringContainedInBoundary=function(line){var seq=line.getCoordinateSequence();for(var i=0;i<seq.length-1;i++){var p0=seq[i];var p1=seq[i+1];if(!this.isLineSegmentContainedInBoundary(p0,p1))
return false;}
return true;}
jsts.operation.predicate.RectangleContains.prototype.isLineSegmentContainedInBoundary=function(p0,p1){if(p0.equals(p1))
return this.isPointContainedInBoundary(p0);if(p0.x==p1.x){if(p0.x==this.rectEnv.getMinX()||p0.x==this.rectEnv.getMaxX())
return true;}
else if(p0.y==p1.y){if(p0.y==this.rectEnv.getMinY()||p0.y==this.rectEnv.getMaxY())
return true;}
return false;}})();(function(){var Location=jsts.geom.Location;var Position=jsts.geomgraph.Position;jsts.geomgraph.Depth=function(){this.depth=[[],[]];for(var i=0;i<2;i++){for(var j=0;j<3;j++){this.depth[i][j]=jsts.geomgraph.Depth.NULL_VALUE;}}};jsts.geomgraph.Depth.NULL_VALUE=-1;jsts.geomgraph.Depth.depthAtLocation=function(location){if(location===Location.EXTERIOR)
return 0;if(location===Location.INTERIOR)
return 1;return jsts.geomgraph.Depth.NULL_VALUE;};jsts.geomgraph.Depth.prototype.depth=null;jsts.geomgraph.Depth.prototype.getDepth=function(geomIndex,posIndex){return this.depth[geomIndex][posIndex];};jsts.geomgraph.Depth.prototype.setDepth=function(geomIndex,posIndex,depthValue){this.depth[geomIndex][posIndex]=depthValue;};jsts.geomgraph.Depth.prototype.getLocation=function(geomIndex,posIndex){if(this.depth[geomIndex][posIndex]<=0)
return Location.EXTERIOR;return Location.INTERIOR;};jsts.geomgraph.Depth.prototype.add=function(geomIndex,posIndex,location){if(location===Location.INTERIOR)
this.depth[geomIndex][posIndex]++;};jsts.geomgraph.Depth.prototype.isNull=function(){if(arguments.length>0){return this.isNull2.apply(this,arguments);}
for(var i=0;i<2;i++){for(var j=0;j<3;j++){if(this.depth[i][j]!==jsts.geomgraph.Depth.NULL_VALUE)
return false;}}
return true;};jsts.geomgraph.Depth.prototype.isNull2=function(geomIndex){if(arguments.length>1){return this.isNull3.apply(this,arguments);}
return this.depth[geomIndex][1]==jsts.geomgraph.Depth.NULL_VALUE;};jsts.geomgraph.Depth.prototype.isNull3=function(geomIndex,posIndex){return this.depth[geomIndex][posIndex]==jsts.geomgraph.Depth.NULL_VALUE;};jsts.geomgraph.Depth.prototype.add=function(lbl){for(var i=0;i<2;i++){for(var j=1;j<3;j++){var loc=lbl.getLocation(i,j);if(loc===Location.EXTERIOR||loc===Location.INTERIOR){if(this.isNull(i,j)){this.depth[i][j]=jsts.geomgraph.Depth.depthAtLocation(loc);}else
this.depth[i][j]+=jsts.geomgraph.Depth.depthAtLocation(loc);}}}};jsts.geomgraph.Depth.prototype.getDelta=function(geomIndex){return this.depth[geomIndex][Position.RIGHT]-
this.depth[geomIndex][Position.LEFT];};jsts.geomgraph.Depth.prototype.normalize=function(){for(var i=0;i<2;i++){if(!this.isNull(i)){var minDepth=this.depth[i][1];if(this.depth[i][2]<minDepth)
minDepth=this.depth[i][2];if(minDepth<0)
minDepth=0;for(var j=1;j<3;j++){var newValue=0;if(this.depth[i][j]>minDepth)
newValue=1;this.depth[i][j]=newValue;}}}};jsts.geomgraph.Depth.prototype.toString=function(){return'A: '+this.depth[0][1]+','+this.depth[0][2]+' B: '+
this.depth[1][1]+','+this.depth[1][2];};})();jsts.algorithm.BoundaryNodeRule=function(){};jsts.algorithm.BoundaryNodeRule.prototype.isInBoundary=function(boundaryCount){throw new jsts.error.AbstractMethodInvocationError();};jsts.algorithm.Mod2BoundaryNodeRule=function(){};jsts.algorithm.Mod2BoundaryNodeRule.prototype=new jsts.algorithm.BoundaryNodeRule();jsts.algorithm.Mod2BoundaryNodeRule.prototype.isInBoundary=function(boundaryCount){return boundaryCount%2===1;};jsts.algorithm.BoundaryNodeRule.MOD2_BOUNDARY_RULE=new jsts.algorithm.Mod2BoundaryNodeRule();jsts.algorithm.BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE=jsts.algorithm.BoundaryNodeRule.MOD2_BOUNDARY_RULE;jsts.operation.distance.GeometryLocation=function(component,segIndex,pt){this.component=component;this.segIndex=segIndex;this.pt=pt;};jsts.operation.distance.GeometryLocation.INSIDE_AREA=-1;jsts.operation.distance.GeometryLocation.prototype.component=null;jsts.operation.distance.GeometryLocation.prototype.segIndex=null;jsts.operation.distance.GeometryLocation.prototype.pt=null;jsts.operation.distance.GeometryLocation.prototype.getGeometryComponent=function(){return this.component;};jsts.operation.distance.GeometryLocation.prototype.getSegmentIndex=function(){return this.segIndex;};jsts.operation.distance.GeometryLocation.prototype.getCoordinate=function(){return this.pt;};jsts.operation.distance.GeometryLocation.prototype.isInsideArea=function(){return this.segIndex===jsts.operation.distance.GeometryLocation.INSIDE_AREA;};jsts.geom.util.PointExtracter=function(pts){this.pts=pts;};jsts.geom.util.PointExtracter.prototype=new jsts.geom.GeometryFilter();jsts.geom.util.PointExtracter.prototype.pts=null;jsts.geom.util.PointExtracter.getPoints=function(geom,list){if(list===undefined){list=[];}
if(geom instanceof jsts.geom.Point){list.push(geom);}else if(geom instanceof jsts.geom.GeometryCollection||geom instanceof jsts.geom.MultiPoint||geom instanceof jsts.geom.MultiLineString||geom instanceof jsts.geom.MultiPolygon){geom.apply(new jsts.geom.util.PointExtracter(list));}
return list;};jsts.geom.util.PointExtracter.prototype.filter=function(geom){if(geom instanceof jsts.geom.Point)
this.pts.push(geom);};(function(){var Location=jsts.geom.Location;jsts.operation.relate.RelateNodeGraph=function(){this.nodes=new jsts.geomgraph.NodeMap(new jsts.operation.relate.RelateNodeFactory());};jsts.operation.relate.RelateNodeGraph.prototype.nodes=null;jsts.operation.relate.RelateNodeGraph.prototype.build=function(geomGraph){this.computeIntersectionNodes(geomGraph,0);this.copyNodesAndLabels(geomGraph,0);var eeBuilder=new jsts.operation.relate.EdgeEndBuilder();var eeList=eeBuilder.computeEdgeEnds(geomGraph.getEdgeIterator());this.insertEdgeEnds(eeList);};jsts.operation.relate.RelateNodeGraph.prototype.computeIntersectionNodes=function(geomGraph,argIndex){for(var edgeIt=geomGraph.getEdgeIterator();edgeIt.hasNext();){var e=edgeIt.next();var eLoc=e.getLabel().getLocation(argIndex);for(var eiIt=e.getEdgeIntersectionList().iterator();eiIt.hasNext();){var ei=eiIt.next();var n=this.nodes.addNode(ei.coord);if(eLoc===Location.BOUNDARY)
n.setLabelBoundary(argIndex);else{if(n.getLabel().isNull(argIndex))
n.setLabel(argIndex,Location.INTERIOR);}}}};jsts.operation.relate.RelateNodeGraph.prototype.copyNodesAndLabels=function(geomGraph,argIndex){for(var nodeIt=geomGraph.getNodeIterator();nodeIt.hasNext();){var graphNode=nodeIt.next();var newNode=this.nodes.addNode(graphNode.getCoordinate());newNode.setLabel(argIndex,graphNode.getLabel().getLocation(argIndex));}};jsts.operation.relate.RelateNodeGraph.prototype.insertEdgeEnds=function(ee){for(var i=ee.iterator();i.hasNext();){var e=i.next();this.nodes.add(e);}};jsts.operation.relate.RelateNodeGraph.prototype.getNodeIterator=function(){return this.nodes.iterator();};})();jsts.geomgraph.index.SimpleSweepLineIntersector=function(){};jsts.geomgraph.index.SimpleSweepLineIntersector.prototype=new jsts.geomgraph.index.EdgeSetIntersector();jsts.geomgraph.index.SimpleSweepLineIntersector.prototype.events=[];jsts.geomgraph.index.SimpleSweepLineIntersector.prototype.nOverlaps=null;jsts.geomgraph.index.SimpleSweepLineIntersector.prototype.computeIntersections=function(edges,si,testAllSegments){if(si instanceof javascript.util.List){this.computeIntersections2.apply(this,arguments);return;}
if(testAllSegments){this.add(edges,null);}else{this.add(edges);}
this.computeIntersections3(si);};jsts.geomgraph.index.SimpleSweepLineIntersector.prototype.computeIntersections2=function(edges0,edges1,si){this.add(edges0,edges0);this.add(edges1,edges1);this.computeIntersections3(si);};jsts.geomgraph.index.SimpleSweepLineIntersector.prototype.add=function(edge,edgeSet){if(edge instanceof javascript.util.List){this.add2.apply(this,arguments);return;}
var pts=edge.getCoordinates();for(var i=0;i<pts.length-1;i++){var ss=new jsts.geomgraph.index.SweepLineSegment(edge,i);var insertEvent=new jsts.geomgraph.index.SweepLineEvent(ss.getMinX(),ss,edgeSet);this.events.push(insertEvent);this.events.push(new jsts.geomgraph.index.SweepLineEvent(ss.getMaxX(),insertEvent));}};jsts.geomgraph.index.SimpleSweepLineIntersector.prototype.add2=function(edges,edgeSet){for(var i=edges.iterator();i.hasNext();){var edge=i.next();if(edgeSet){this.add(edge,edgeSet);}else{this.add(edge,edge);}}};jsts.geomgraph.index.SimpleSweepLineIntersector.prototype.prepareEvents=function(){this.events.sort(function(a,b){return a.compareTo(b);});for(var i=0;i<this.events.length;i++){var ev=this.events[i];if(ev.isDelete()){ev.getInsertEvent().setDeleteEventIndex(i);}}};jsts.geomgraph.index.SimpleSweepLineIntersector.prototype.computeIntersections3=function(si){this.nOverlaps=0;this.prepareEvents();for(var i=0;i<this.events.length;i++){var ev=this.events[i];if(ev.isInsert()){this.processOverlaps(i,ev.getDeleteEventIndex(),ev,si);}}};jsts.geomgraph.index.SimpleSweepLineIntersector.prototype.processOverlaps=function(start,end,ev0,si){var ss0=ev0.getObject();for(var i=start;i<end;i++){var ev1=this.events[i];if(ev1.isInsert()){var ss1=ev1.getObject();if(!ev0.isSameLabel(ev1)){ss0.computeIntersections(ss1,si);this.nOverlaps++;}}}}
jsts.triangulate.VoronoiDiagramBuilder=function(){this.siteCoords=null;this.tolerance=0.0;this.subdiv=null;this.clipEnv=null;this.diagramEnv=null;};jsts.triangulate.VoronoiDiagramBuilder.prototype.setSites=function(){var arg=arguments[0];if(arg instanceof jsts.geom.Geometry||arg instanceof jsts.geom.Coordinate||arg instanceof jsts.geom.Point||arg instanceof jsts.geom.MultiPoint||arg instanceof jsts.geom.LineString||arg instanceof jsts.geom.MultiLineString||arg instanceof jsts.geom.LinearRing||arg instanceof jsts.geom.Polygon||arg instanceof jsts.geom.MultiPolygon){this.setSitesByGeometry(arg);}else{this.setSitesByArray(arg);}};jsts.triangulate.VoronoiDiagramBuilder.prototype.setSitesByGeometry=function(geom){this.siteCoords=jsts.triangulate.DelaunayTriangulationBuilder.extractUniqueCoordinates(geom);};jsts.triangulate.VoronoiDiagramBuilder.prototype.setSitesByArray=function(coords){this.siteCoords=jsts.triangulate.DelaunayTriangulationBuilder.unique(coords);};jsts.triangulate.VoronoiDiagramBuilder.prototype.setClipEnvelope=function(clipEnv){this.clipEnv=clipEnv;};jsts.triangulate.VoronoiDiagramBuilder.prototype.setTolerance=function(tolerance)
{this.tolerance=tolerance;};jsts.triangulate.VoronoiDiagramBuilder.prototype.create=function(){if(this.subdiv!==null){return;}
var siteEnv,expandBy,vertices,triangulator;siteEnv=jsts.triangulate.DelaunayTriangulationBuilder.envelope(this.siteCoords);this.diagramEnv=siteEnv;expandBy=Math.max(this.diagramEnv.getWidth(),this.diagramEnv.getHeight());this.diagramEnv.expandBy(expandBy);if(this.clipEnv!==null){this.diagramEnv.expandToInclude(this.clipEnv);}
vertices=jsts.triangulate.DelaunayTriangulationBuilder.toVertices(this.siteCoords);this.subdiv=new jsts.triangulate.quadedge.QuadEdgeSubdivision(siteEnv,this.tolerance);triangulator=new jsts.triangulate.IncrementalDelaunayTriangulator(this.subdiv);triangulator.insertSites(vertices);};jsts.triangulate.VoronoiDiagramBuilder.prototype.getSubdivision=function(){this.create();return this.subdiv;};jsts.triangulate.VoronoiDiagramBuilder.prototype.getDiagram=function(geomFact){this.create();var polys=this.subdiv.getVoronoiDiagram(geomFact);return this.clipGeometryCollection(polys,this.diagramEnv);};jsts.triangulate.VoronoiDiagramBuilder.prototype.clipGeometryCollection=function(geom,clipEnv){var clipPoly,clipped,i,il,g,result;clipPoly=geom.getFactory().toGeometry(clipEnv);clipped=[];i=0,il=geom.getNumGeometries();for(i;i<il;i++){g=geom.getGeometryN(i);result=null;if(clipEnv.contains(g.getEnvelopeInternal())){result=g;}
else if(clipEnv.intersects(g.getEnvelopeInternal())){result=clipPoly.intersection(g);}
if(result!==null&&!result.isEmpty()){clipped.push(result);}}
return geom.getFactory().createGeometryCollection(clipped);};jsts.operation.valid.IndexedNestedRingTester=function(graph){this.graph=graph;this.rings=new javascript.util.ArrayList();this.totalEnv=new jsts.geom.Envelope();this.index=null;this.nestedPt=null;};jsts.operation.valid.IndexedNestedRingTester.prototype.getNestedPoint=function(){return this.nestedPt;};jsts.operation.valid.IndexedNestedRingTester.prototype.add=function(ring){this.rings.add(ring);this.totalEnv.expandToInclude(ring.getEnvelopeInternal());};jsts.operation.valid.IndexedNestedRingTester.prototype.isNonNested=function(){this.buildIndex();for(var i=0;i<this.rings.size();i++){var innerRing=this.rings.get(i);var innerRingPts=innerRing.getCoordinates();var results=this.index.query(innerRing.getEnvelopeInternal());for(var j=0;j<results.length;j++){var searchRing=results[j];var searchRingPts=searchRing.getCoordinates();if(innerRing==searchRing){continue;}
if(!innerRing.getEnvelopeInternal().intersects(searchRing.getEnvelopeInternal())){continue;}
var innerRingPt=jsts.operation.valid.IsValidOp.findPtNotNode(innerRingPts,searchRing,this.graph);if(innerRingPt==null){continue;}
var isInside=jsts.algorithm.CGAlgorithms.isPointInRing(innerRingPt,searchRingPts);if(isInside){this.nestedPt=innerRingPt;return false;}}}
return true;};jsts.operation.valid.IndexedNestedRingTester.prototype.buildIndex=function(){this.index=new jsts.index.strtree.STRtree();for(var i=0;i<this.rings.size();i++){var ring=this.rings.get(i);var env=ring.getEnvelopeInternal();this.index.insert(env,ring);}};jsts.geomgraph.index.MonotoneChain=function(mce,chainIndex){this.mce=mce;this.chainIndex=chainIndex;};jsts.geomgraph.index.MonotoneChain.prototype.mce=null;jsts.geomgraph.index.MonotoneChain.prototype.chainIndex=null;jsts.geomgraph.index.MonotoneChain.prototype.computeIntersections=function(mc,si){this.mce.computeIntersectsForChain(this.chainIndex,mc.mce,mc.chainIndex,si);};jsts.noding.SegmentNode=function(segString,coord,segmentIndex,segmentOctant){this.segString=segString;this.coord=new jsts.geom.Coordinate(coord);this.segmentIndex=segmentIndex;this.segmentOctant=segmentOctant;this._isInterior=!coord.equals2D(segString.getCoordinate(segmentIndex));};jsts.noding.SegmentNode.prototype.segString=null;jsts.noding.SegmentNode.prototype.coord=null;jsts.noding.SegmentNode.prototype.segmentIndex=null;jsts.noding.SegmentNode.prototype.segmentOctant=null;jsts.noding.SegmentNode.prototype._isInterior=null;jsts.noding.SegmentNode.prototype.getCoordinate=function(){return this.coord;};jsts.noding.SegmentNode.prototype.isInterior=function(){return this._isInterior;};jsts.noding.SegmentNode.prototype.isEndPoint=function(maxSegmentIndex){if(this.segmentIndex===0&&!this._isInterior)return true;if(this.segmentIndex===this.maxSegmentIndex)return true;return false;};jsts.noding.SegmentNode.prototype.compareTo=function(obj){var other=obj;if(this.segmentIndex<other.segmentIndex)return-1;if(this.segmentIndex>other.segmentIndex)return 1;if(this.coord.equals2D(other.coord))return 0;return jsts.noding.SegmentPointComparator.compare(this.segmentOctant,this.coord,other.coord);};(function(){jsts.io.GeoJSONWriter=function(){this.parser=new jsts.io.GeoJSONParser(this.geometryFactory);};jsts.io.GeoJSONWriter.prototype.write=function(geometry){var geoJson=this.parser.write(geometry);return geoJson;};})();jsts.io.OpenLayersParser=function(geometryFactory){this.geometryFactory=geometryFactory||new jsts.geom.GeometryFactory();};jsts.io.OpenLayersParser.prototype.read=function(geometry){if(geometry.CLASS_NAME==='OpenLayers.Geometry.Point'){return this.convertFromPoint(geometry);}else if(geometry.CLASS_NAME==='OpenLayers.Geometry.LineString'){return this.convertFromLineString(geometry);}else if(geometry.CLASS_NAME==='OpenLayers.Geometry.LinearRing'){return this.convertFromLinearRing(geometry);}else if(geometry.CLASS_NAME==='OpenLayers.Geometry.Polygon'){return this.convertFromPolygon(geometry);}else if(geometry.CLASS_NAME==='OpenLayers.Geometry.MultiPoint'){return this.convertFromMultiPoint(geometry);}else if(geometry.CLASS_NAME==='OpenLayers.Geometry.MultiLineString'){return this.convertFromMultiLineString(geometry);}else if(geometry.CLASS_NAME==='OpenLayers.Geometry.MultiPolygon'){return this.convertFromMultiPolygon(geometry);}else if(geometry.CLASS_NAME==='OpenLayers.Geometry.Collection'){return this.convertFromCollection(geometry);}};jsts.io.OpenLayersParser.prototype.convertFromPoint=function(point){return this.geometryFactory.createPoint(new jsts.geom.Coordinate(point.x,point.y));};jsts.io.OpenLayersParser.prototype.convertFromLineString=function(lineString){var i;var coordinates=[];for(i=0;i<lineString.components.length;i++){coordinates.push(new jsts.geom.Coordinate(lineString.components[i].x,lineString.components[i].y));}
return this.geometryFactory.createLineString(coordinates);};jsts.io.OpenLayersParser.prototype.convertFromLinearRing=function(linearRing){var i;var coordinates=[];for(i=0;i<linearRing.components.length;i++){coordinates.push(new jsts.geom.Coordinate(linearRing.components[i].x,linearRing.components[i].y));}
return this.geometryFactory.createLinearRing(coordinates);};jsts.io.OpenLayersParser.prototype.convertFromPolygon=function(polygon){var i;var shell=null;var holes=[];for(i=0;i<polygon.components.length;i++){var linearRing=this.convertFromLinearRing(polygon.components[i]);if(i===0){shell=linearRing;}else{holes.push(linearRing);}}
return this.geometryFactory.createPolygon(shell,holes);};jsts.io.OpenLayersParser.prototype.convertFromMultiPoint=function(multiPoint){var i;var points=[];for(i=0;i<multiPoint.components.length;i++){points.push(this.convertFromPoint(multiPoint.components[i]));}
return this.geometryFactory.createMultiPoint(points);};jsts.io.OpenLayersParser.prototype.convertFromMultiLineString=function(multiLineString){var i;var lineStrings=[];for(i=0;i<multiLineString.components.length;i++){lineStrings.push(this.convertFromLineString(multiLineString.components[i]));}
return this.geometryFactory.createMultiLineString(lineStrings);};jsts.io.OpenLayersParser.prototype.convertFromMultiPolygon=function(multiPolygon){var i;var polygons=[];for(i=0;i<multiPolygon.components.length;i++){polygons.push(this.convertFromPolygon(multiPolygon.components[i]));}
return this.geometryFactory.createMultiPolygon(polygons);};jsts.io.OpenLayersParser.prototype.convertFromCollection=function(collection){var i;var geometries=[];for(i=0;i<collection.components.length;i++){geometries.push(this.read(collection.components[i]));}
return this.geometryFactory.createGeometryCollection(geometries);};jsts.io.OpenLayersParser.prototype.write=function(geometry){if(geometry.CLASS_NAME==='jsts.geom.Point'){return this.convertToPoint(geometry.coordinate);}else if(geometry.CLASS_NAME==='jsts.geom.LineString'){return this.convertToLineString(geometry);}else if(geometry.CLASS_NAME==='jsts.geom.LinearRing'){return this.convertToLinearRing(geometry);}else if(geometry.CLASS_NAME==='jsts.geom.Polygon'){return this.convertToPolygon(geometry);}else if(geometry.CLASS_NAME==='jsts.geom.MultiPoint'){return this.convertToMultiPoint(geometry);}else if(geometry.CLASS_NAME==='jsts.geom.MultiLineString'){return this.convertToMultiLineString(geometry);}else if(geometry.CLASS_NAME==='jsts.geom.MultiPolygon'){return this.convertToMultiPolygon(geometry);}else if(geometry.CLASS_NAME==='jsts.geom.GeometryCollection'){return this.convertToCollection(geometry);}};jsts.io.OpenLayersParser.prototype.convertToPoint=function(coordinate){return new OpenLayers.Geometry.Point(coordinate.x,coordinate.y);};jsts.io.OpenLayersParser.prototype.convertToLineString=function(lineString){var i;var points=[];for(i=0;i<lineString.points.length;i++){var coordinate=lineString.points[i];points.push(this.convertToPoint(coordinate));}
return new OpenLayers.Geometry.LineString(points);};jsts.io.OpenLayersParser.prototype.convertToLinearRing=function(linearRing){var i;var points=[];for(i=0;i<linearRing.points.length;i++){var coordinate=linearRing.points[i];points.push(this.convertToPoint(coordinate));}
return new OpenLayers.Geometry.LinearRing(points);};jsts.io.OpenLayersParser.prototype.convertToPolygon=function(polygon){var i;var rings=[];rings.push(this.convertToLinearRing(polygon.shell));for(i=0;i<polygon.holes.length;i++){var ring=polygon.holes[i];rings.push(this.convertToLinearRing(ring));}
return new OpenLayers.Geometry.Polygon(rings);};jsts.io.OpenLayersParser.prototype.convertToMultiPoint=function(multiPoint){var i;var points=[];for(i=0;i<multiPoint.geometries.length;i++){var coordinate=multiPoint.geometries[i].coordinate;points.push(new OpenLayers.Geometry.Point(coordinate.x,coordinate.y));}
return new OpenLayers.Geometry.MultiPoint(points);};jsts.io.OpenLayersParser.prototype.convertToMultiLineString=function(multiLineString){var i;var lineStrings=[];for(i=0;i<multiLineString.geometries.length;i++){lineStrings.push(this.convertToLineString(multiLineString.geometries[i]));}
return new OpenLayers.Geometry.MultiLineString(lineStrings);};jsts.io.OpenLayersParser.prototype.convertToMultiPolygon=function(multiPolygon){var i;var polygons=[];for(i=0;i<multiPolygon.geometries.length;i++){polygons.push(this.convertToPolygon(multiPolygon.geometries[i]));}
return new OpenLayers.Geometry.MultiPolygon(polygons);};jsts.io.OpenLayersParser.prototype.convertToCollection=function(geometryCollection){var i;var geometries=[];for(i=0;i<geometryCollection.geometries.length;i++){var geometry=geometryCollection.geometries[i];var geometryOpenLayers=this.write(geometry);geometries.push(geometryOpenLayers);}
return new OpenLayers.Geometry.Collection(geometries);};jsts.index.quadtree.Quadtree=function(){this.root=new jsts.index.quadtree.Root();this.minExtent=1.0;};jsts.index.quadtree.Quadtree.ensureExtent=function(itemEnv,minExtent){var minx,maxx,miny,maxy;minx=itemEnv.getMinX();maxx=itemEnv.getMaxX();miny=itemEnv.getMinY();maxy=itemEnv.getMaxY();if(minx!==maxx&&miny!==maxy){return itemEnv;}
if(minx===maxx){minx=minx-(minExtent/2.0);maxx=minx+(minExtent/2.0);}
if(miny===maxy){miny=miny-(minExtent/2.0);maxy=miny+(minExtent/2.0);}
return new jsts.geom.Envelope(minx,maxx,miny,maxy);};jsts.index.quadtree.Quadtree.prototype.depth=function(){return this.root.depth();};jsts.index.quadtree.Quadtree.prototype.size=function(){return this.root.size();};jsts.index.quadtree.Quadtree.prototype.insert=function(itemEnv,item){this.collectStats(itemEnv);var insertEnv=jsts.index.quadtree.Quadtree.ensureExtent(itemEnv,this.minExtent);this.root.insert(insertEnv,item);};jsts.index.quadtree.Quadtree.prototype.remove=function(itemEnv,item){var posEnv=jsts.index.quadtree.Quadtree.ensureExtent(itemEnv,this.minExtent);return this.root.remove(posEnv,item);};jsts.index.quadtree.Quadtree.prototype.query=function(){if(arguments.length===1){return jsts.index.quadtree.Quadtree.prototype.queryByEnvelope.apply(this,arguments);}else{jsts.index.quadtree.Quadtree.prototype.queryWithVisitor.apply(this,arguments);}};jsts.index.quadtree.Quadtree.prototype.queryByEnvelope=function(searchEnv){var visitor=new jsts.index.ArrayListVisitor();this.query(searchEnv,visitor);return visitor.getItems();};jsts.index.quadtree.Quadtree.prototype.queryWithVisitor=function(searchEnv,visitor){this.root.visit(searchEnv,visitor);};jsts.index.quadtree.Quadtree.prototype.queryAll=function(){var foundItems=[];foundItems=this.root.addAllItems(foundItems);return foundItems;};jsts.index.quadtree.Quadtree.prototype.collectStats=function(itemEnv){var delX=itemEnv.getWidth();if(delX<this.minExtent&&delX>0.0){this.minExtent=delX;}
var delY=itemEnv.getHeight();if(delY<this.minExtent&&delY>0.0){this.minExtent=delY;}};jsts.operation.relate.RelateNodeFactory=function(){};jsts.operation.relate.RelateNodeFactory.prototype=new jsts.geomgraph.NodeFactory();jsts.operation.relate.RelateNodeFactory.prototype.createNode=function(coord){return new jsts.operation.relate.RelateNode(coord,new jsts.operation.relate.EdgeEndBundleStar());};jsts.index.quadtree.Key=function(itemEnv){this.pt=new jsts.geom.Coordinate();this.level=0;this.env=null;this.computeKey(itemEnv);};jsts.index.quadtree.Key.computeQuadLevel=function(env){var dx,dy,dMax,level;dx=env.getWidth();dy=env.getHeight();dMax=dx>dy?dx:dy;level=jsts.index.DoubleBits.exponent(dMax)+1;return level;};jsts.index.quadtree.Key.prototype.getPoint=function(){return this.pt;};jsts.index.quadtree.Key.prototype.getLevel=function(){return this.level;};jsts.index.quadtree.Key.prototype.getEnvelope=function(){return this.env;};jsts.index.quadtree.Key.prototype.getCentre=function(){var x,y;x=(this.env.getMinX()+this.env.getMaxX())/2;y=(this.env.getMinY()+this.env.getMaxY())/2;return new jsts.geom.Coordinate(x,y);};jsts.index.quadtree.Key.prototype.computeKey=function(){if(arguments[0]instanceof jsts.geom.Envelope){this.computeKeyFromEnvelope(arguments[0]);}else{this.computeKeyFromLevel(arguments[0],arguments[1]);}};jsts.index.quadtree.Key.prototype.computeKeyFromEnvelope=function(env){this.level=jsts.index.quadtree.Key.computeQuadLevel(env);this.env=new jsts.geom.Envelope();this.computeKey(this.level,env);while(!this.env.contains(env)){this.level+=1;this.computeKey(this.level,env);}};jsts.index.quadtree.Key.prototype.computeKeyFromLevel=function(level,env){var quadSize=jsts.index.DoubleBits.powerOf2(level);this.pt.x=Math.floor(env.getMinX()/quadSize)*quadSize;this.pt.y=Math.floor(env.getMinY()/quadSize)*quadSize;this.env.init(this.pt.x,this.pt.x+quadSize,this.pt.y,this.pt.y+
quadSize);};jsts.geom.CoordinateArrays=function(){throw new jsts.error.AbstractMethodInvocationError();};jsts.geom.CoordinateArrays.copyDeep=function(){if(arguments.length===1){return jsts.geom.CoordinateArrays.copyDeep1(arguments[0]);}else if(arguments.length===5){jsts.geom.CoordinateArrays.copyDeep2(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4]);}};jsts.geom.CoordinateArrays.copyDeep1=function(coordinates){var copy=[];for(var i=0;i<coordinates.length;i++){copy[i]=new jsts.geom.Coordinate(coordinates[i]);}
return copy;};jsts.geom.CoordinateArrays.copyDeep2=function(src,srcStart,dest,destStart,length){for(var i=0;i<length;i++){dest[destStart+i]=new jsts.geom.Coordinate(src[srcStart+i]);}};jsts.geom.CoordinateArrays.removeRepeatedPoints=function(coord){var coordList;if(!this.hasRepeatedPoints(coord)){return coord;}
coordList=new jsts.geom.CoordinateList(coord,false);return coordList.toCoordinateArray();};jsts.geom.CoordinateArrays.hasRepeatedPoints=function(coord){var i;for(i=1;i<coord.length;i++){if(coord[i-1].equals(coord[i])){return true;}}
return false;};jsts.geom.CoordinateArrays.ptNotInList=function(testPts,pts){for(var i=0;i<testPts.length;i++){var testPt=testPts[i];if(jsts.geom.CoordinateArrays.indexOf(testPt,pts)<0)
return testPt;}
return null;};jsts.geom.CoordinateArrays.increasingDirection=function(pts){for(var i=0;i<parseInt(pts.length/2);i++){var j=pts.length-1-i;var comp=pts[i].compareTo(pts[j]);if(comp!=0)
return comp;}
return 1;};jsts.geom.CoordinateArrays.minCoordinate=function(coordinates){var minCoord=null;for(var i=0;i<coordinates.length;i++){if(minCoord===null||minCoord.compareTo(coordinates[i])>0){minCoord=coordinates[i];}}
return minCoord;};jsts.geom.CoordinateArrays.scroll=function(coordinates,firstCoordinate){var i=jsts.geom.CoordinateArrays.indexOf(firstCoordinate,coordinates);if(i<0)
return;var newCoordinates=coordinates.slice(i).concat(coordinates.slice(0,i));for(i=0;i<newCoordinates.length;i++){coordinates[i]=newCoordinates[i];}};jsts.geom.CoordinateArrays.indexOf=function(coordinate,coordinates){for(var i=0;i<coordinates.length;i++){if(coordinate.equals(coordinates[i])){return i;}}
return-1;};jsts.operation.overlay.MinimalEdgeRing=function(start,geometryFactory){jsts.geomgraph.EdgeRing.call(this,start,geometryFactory);};jsts.operation.overlay.MinimalEdgeRing.prototype=new jsts.geomgraph.EdgeRing();jsts.operation.overlay.MinimalEdgeRing.constructor=jsts.operation.overlay.MinimalEdgeRing;jsts.operation.overlay.MinimalEdgeRing.prototype.getNext=function(de){return de.getNextMin();};jsts.operation.overlay.MinimalEdgeRing.prototype.setEdgeRing=function(de,er){de.setMinEdgeRing(er);};jsts.triangulate.DelaunayTriangulationBuilder=function(){this.siteCoords=null;this.tolerance=0.0;this.subdiv=null;};jsts.triangulate.DelaunayTriangulationBuilder.extractUniqueCoordinates=function(geom){if(geom===undefined||geom===null){return new jsts.geom.CoordinateList([],false).toArray();}
var coords=geom.getCoordinates();return jsts.triangulate.DelaunayTriangulationBuilder.unique(coords);};jsts.triangulate.DelaunayTriangulationBuilder.unique=function(coords){coords.sort(function(a,b){return a.compareTo(b);});var coordList=new jsts.geom.CoordinateList(coords,false);return coordList.toArray();};jsts.triangulate.DelaunayTriangulationBuilder.toVertices=function(coords){var verts=new Array(coords.length),i=0,il=coords.length,coord;for(i;i<il;i++){coord=coords[i];verts[i]=new jsts.triangulate.quadedge.Vertex(coord);}
return verts;};jsts.triangulate.DelaunayTriangulationBuilder.envelope=function(coords){var env=new jsts.geom.Envelope(),i=0,il=coords.length;for(i;i<il;i++){env.expandToInclude(coords[i]);}
return env;};jsts.triangulate.DelaunayTriangulationBuilder.prototype.setSites=function(){var arg=arguments[0];if(arg instanceof jsts.geom.Geometry||arg instanceof jsts.geom.Coordinate||arg instanceof jsts.geom.Point||arg instanceof jsts.geom.MultiPoint||arg instanceof jsts.geom.LineString||arg instanceof jsts.geom.MultiLineString||arg instanceof jsts.geom.LinearRing||arg instanceof jsts.geom.Polygon||arg instanceof jsts.geom.MultiPolygon){this.setSitesFromGeometry(arg);}else{this.setSitesFromCollection(arg);}};jsts.triangulate.DelaunayTriangulationBuilder.prototype.setSitesFromGeometry=function(geom){this.siteCoords=jsts.triangulate.DelaunayTriangulationBuilder.extractUniqueCoordinates(geom);};jsts.triangulate.DelaunayTriangulationBuilder.prototype.setSitesFromCollection=function(coords){this.siteCoords=jsts.triangulate.DelaunayTriangulationBuilder.unique(coords);};jsts.triangulate.DelaunayTriangulationBuilder.prototype.setTolerance=function(tolerance){this.tolerance=tolerance;};jsts.triangulate.DelaunayTriangulationBuilder.prototype.create=function(){if(this.subdiv===null){var siteEnv,vertices,triangulator;siteEnv=jsts.triangulate.DelaunayTriangulationBuilder.envelope(this.siteCoords);vertices=jsts.triangulate.DelaunayTriangulationBuilder.toVertices(this.siteCoords);this.subdiv=new jsts.triangulate.quadedge.QuadEdgeSubdivision(siteEnv,this.tolerance);triangulator=new jsts.triangulate.IncrementalDelaunayTriangulator(this.subdiv);triangulator.insertSites(vertices);}};jsts.triangulate.DelaunayTriangulationBuilder.prototype.getSubdivision=function(){this.create();return this.subdiv;};jsts.triangulate.DelaunayTriangulationBuilder.prototype.getEdges=function(geomFact){this.create();return this.subdiv.getEdges(geomFact);};jsts.triangulate.DelaunayTriangulationBuilder.prototype.getTriangles=function(geomFact){this.create();return this.subdiv.getTriangles(geomFact);};jsts.algorithm.RayCrossingCounter=function(p){this.p=p;};jsts.algorithm.RayCrossingCounter.locatePointInRing=function(p,ring){var counter=new jsts.algorithm.RayCrossingCounter(p);for(var i=1;i<ring.length;i++){var p1=ring[i];var p2=ring[i-1];counter.countSegment(p1,p2);if(counter.isOnSegment())
return counter.getLocation();}
return counter.getLocation();};jsts.algorithm.RayCrossingCounter.prototype.p=null;jsts.algorithm.RayCrossingCounter.prototype.crossingCount=0;jsts.algorithm.RayCrossingCounter.prototype.isPointOnSegment=false;jsts.algorithm.RayCrossingCounter.prototype.countSegment=function(p1,p2){if(p1.x<this.p.x&&p2.x<this.p.x)
return;if(this.p.x==p2.x&&this.p.y===p2.y){this.isPointOnSegment=true;return;}
if(p1.y===this.p.y&&p2.y===this.p.y){var minx=p1.x;var maxx=p2.x;if(minx>maxx){minx=p2.x;maxx=p1.x;}
if(this.p.x>=minx&&this.p.x<=maxx){this.isPointOnSegment=true;}
return;}
if(((p1.y>this.p.y)&&(p2.y<=this.p.y))||((p2.y>this.p.y)&&(p1.y<=this.p.y))){var x1=p1.x-this.p.x;var y1=p1.y-this.p.y;var x2=p2.x-this.p.x;var y2=p2.y-this.p.y;var xIntSign=jsts.algorithm.RobustDeterminant.signOfDet2x2(x1,y1,x2,y2);if(xIntSign===0.0){this.isPointOnSegment=true;return;}
if(y2<y1)
xIntSign=-xIntSign;if(xIntSign>0.0){this.crossingCount++;}}};jsts.algorithm.RayCrossingCounter.prototype.isOnSegment=function(){return jsts.geom.isPointOnSegment;};jsts.algorithm.RayCrossingCounter.prototype.getLocation=function(){if(this.isPointOnSegment)
return jsts.geom.Location.BOUNDARY;if((this.crossingCount%2)===1){return jsts.geom.Location.INTERIOR;}
return jsts.geom.Location.EXTERIOR;};jsts.algorithm.RayCrossingCounter.prototype.isPointInPolygon=function(){return this.getLocation()!==jsts.geom.Location.EXTERIOR;};jsts.operation.BoundaryOp=function(geom,bnRule){this.geom=geom;this.geomFact=geom.getFactory();this.bnRule=bnRule||jsts.algorithm.BoundaryNodeRule.MOD2_BOUNDARY_RULE;};jsts.operation.BoundaryOp.prototype.geom=null;jsts.operation.BoundaryOp.prototype.geomFact=null;jsts.operation.BoundaryOp.prototype.bnRule=null;jsts.operation.BoundaryOp.prototype.getBoundary=function(){if(this.geom instanceof jsts.geom.LineString)return this.boundaryLineString(this.geom);if(this.geom instanceof jsts.geom.MultiLineString)return this.boundaryMultiLineString(this.geom);return this.geom.getBoundary();};jsts.operation.BoundaryOp.prototype.getEmptyMultiPoint=function(){return this.geomFact.createMultiPoint(null);};jsts.operation.BoundaryOp.prototype.boundaryMultiLineString=function(mLine){if(this.geom.isEmpty()){return this.getEmptyMultiPoint();}
var bdyPts=this.computeBoundaryCoordinates(mLine);if(bdyPts.length==1){return this.geomFact.createPoint(bdyPts[0]);}
return this.geomFact.createMultiPoint(bdyPts);};jsts.operation.BoundaryOp.prototype.endpoints=null;jsts.operation.BoundaryOp.prototype.computeBoundaryCoordinates=function(mLine){var i,line,endpoint,bdyPts=[];this.endpoints=[];for(i=0;i<mLine.getNumGeometries();i++){line=mLine.getGeometryN(i);if(line.getNumPoints()==0)
continue;this.addEndpoint(line.getCoordinateN(0));this.addEndpoint(line.getCoordinateN(line.getNumPoints()-1));}
for(i=0;i<this.endpoints.length;i++){endpoint=this.endpoints[i];if(this.bnRule.isInBoundary(endpoint.count)){bdyPts.push(endpoint.coordinate);}}
return bdyPts;};jsts.operation.BoundaryOp.prototype.addEndpoint=function(pt){var i,endpoint,found=false;for(i=0;i<this.endpoints.length;i++){endpoint=this.endpoints[i];if(endpoint.coordinate.equals(pt)){found=true;break;}}
if(!found){endpoint={};endpoint.coordinate=pt;endpoint.count=0;this.endpoints.push(endpoint);}
endpoint.count++;};jsts.operation.BoundaryOp.prototype.boundaryLineString=function(line){if(this.geom.isEmpty()){return this.getEmptyMultiPoint();}
if(line.isClosed()){var closedEndpointOnBoundary=this.bnRule.isInBoundary(2);if(closedEndpointOnBoundary){return line.getStartPoint();}
else{return this.geomFact.createMultiPoint(null);}}
return this.geomFact.createMultiPoint([line.getStartPoint(),line.getEndPoint()]);};jsts.operation.buffer.OffsetCurveSetBuilder=function(inputGeom,distance,curveBuilder){this.inputGeom=inputGeom;this.distance=distance;this.curveBuilder=curveBuilder;this.curveList=new javascript.util.ArrayList();};jsts.operation.buffer.OffsetCurveSetBuilder.prototype.inputGeom=null;jsts.operation.buffer.OffsetCurveSetBuilder.prototype.distance=null;jsts.operation.buffer.OffsetCurveSetBuilder.prototype.curveBuilder=null;jsts.operation.buffer.OffsetCurveSetBuilder.prototype.curveList=null;jsts.operation.buffer.OffsetCurveSetBuilder.prototype.getCurves=function(){this.add(this.inputGeom);return this.curveList;};jsts.operation.buffer.OffsetCurveSetBuilder.prototype.addCurve=function(coord,leftLoc,rightLoc){if(coord==null||coord.length<2)
return;var e=new jsts.noding.NodedSegmentString(coord,new jsts.geomgraph.Label(0,jsts.geom.Location.BOUNDARY,leftLoc,rightLoc));this.curveList.add(e);};jsts.operation.buffer.OffsetCurveSetBuilder.prototype.add=function(g){if(g.isEmpty())
return;if(g instanceof jsts.geom.Polygon)
this.addPolygon(g);else if(g instanceof jsts.geom.LineString)
this.addLineString(g);else if(g instanceof jsts.geom.Point)
this.addPoint(g);else if(g instanceof jsts.geom.MultiPoint)
this.addCollection(g);else if(g instanceof jsts.geom.MultiLineString)
this.addCollection(g);else if(g instanceof jsts.geom.MultiPolygon)
this.addCollection(g);else if(g instanceof jsts.geom.GeometryCollection)
this.addCollection(g);else
throw new jsts.error.IllegalArgumentError();};jsts.operation.buffer.OffsetCurveSetBuilder.prototype.addCollection=function(gc){for(var i=0;i<gc.getNumGeometries();i++){var g=gc.getGeometryN(i);this.add(g);}};jsts.operation.buffer.OffsetCurveSetBuilder.prototype.addPoint=function(p){if(this.distance<=0.0)
return;var coord=p.getCoordinates();var curve=this.curveBuilder.getLineCurve(coord,this.distance);this.addCurve(curve,jsts.geom.Location.EXTERIOR,jsts.geom.Location.INTERIOR);};jsts.operation.buffer.OffsetCurveSetBuilder.prototype.addLineString=function(line){if(this.distance<=0.0&&!this.curveBuilder.getBufferParameters().isSingleSided())
return;var coord=jsts.geom.CoordinateArrays.removeRepeatedPoints(line.getCoordinates());var curve=this.curveBuilder.getLineCurve(coord,this.distance);this.addCurve(curve,jsts.geom.Location.EXTERIOR,jsts.geom.Location.INTERIOR);};jsts.operation.buffer.OffsetCurveSetBuilder.prototype.addPolygon=function(p){var offsetDistance=this.distance;var offsetSide=jsts.geomgraph.Position.LEFT;if(this.distance<0.0){offsetDistance=-this.distance;offsetSide=jsts.geomgraph.Position.RIGHT;}
var shell=p.getExteriorRing();var shellCoord=jsts.geom.CoordinateArrays.removeRepeatedPoints(shell.getCoordinates());if(this.distance<0.0&&this.isErodedCompletely(shell,this.distance))
return;if(this.distance<=0.0&&shellCoord.length<3)
return;this.addPolygonRing(shellCoord,offsetDistance,offsetSide,jsts.geom.Location.EXTERIOR,jsts.geom.Location.INTERIOR);for(var i=0;i<p.getNumInteriorRing();i++){var hole=p.getInteriorRingN(i);var holeCoord=jsts.geom.CoordinateArrays.removeRepeatedPoints(hole.getCoordinates());if(this.distance>0.0&&this.isErodedCompletely(hole,-this.distance))
continue;this.addPolygonRing(holeCoord,offsetDistance,jsts.geomgraph.Position.opposite(offsetSide),jsts.geom.Location.INTERIOR,jsts.geom.Location.EXTERIOR);}};jsts.operation.buffer.OffsetCurveSetBuilder.prototype.addPolygonRing=function(coord,offsetDistance,side,cwLeftLoc,cwRightLoc){if(offsetDistance==0.0&&coord.length<jsts.geom.LinearRing.MINIMUM_VALID_SIZE)
return;var leftLoc=cwLeftLoc;var rightLoc=cwRightLoc;if(coord.length>=jsts.geom.LinearRing.MINIMUM_VALID_SIZE&&jsts.algorithm.CGAlgorithms.isCCW(coord)){leftLoc=cwRightLoc;rightLoc=cwLeftLoc;side=jsts.geomgraph.Position.opposite(side);}
var curve=this.curveBuilder.getRingCurve(coord,side,offsetDistance);this.addCurve(curve,leftLoc,rightLoc);};jsts.operation.buffer.OffsetCurveSetBuilder.prototype.isErodedCompletely=function(ring,bufferDistance){var ringCoord=ring.getCoordinates();var minDiam=0.0;if(ringCoord.length<4)
return bufferDistance<0;if(ringCoord.length==4)
return this.isTriangleErodedCompletely(ringCoord,bufferDistance);var env=ring.getEnvelopeInternal();var envMinDimension=Math.min(env.getHeight(),env.getWidth());if(bufferDistance<0.0&&2*Math.abs(bufferDistance)>envMinDimension)
return true;return false;};jsts.operation.buffer.OffsetCurveSetBuilder.prototype.isTriangleErodedCompletely=function(triangleCoord,bufferDistance){var tri=new jsts.geom.Triangle(triangleCoord[0],triangleCoord[1],triangleCoord[2]);var inCentre=tri.inCentre();var distToCentre=jsts.algorithm.CGAlgorithms.distancePointLine(inCentre,tri.p0,tri.p1);return distToCentre<Math.abs(bufferDistance);};jsts.operation.buffer.BufferSubgraph=function(){this.dirEdgeList=new javascript.util.ArrayList();this.nodes=new javascript.util.ArrayList();this.finder=new jsts.operation.buffer.RightmostEdgeFinder();};jsts.operation.buffer.BufferSubgraph.prototype.finder=null;jsts.operation.buffer.BufferSubgraph.prototype.dirEdgeList=null;jsts.operation.buffer.BufferSubgraph.prototype.nodes=null;jsts.operation.buffer.BufferSubgraph.prototype.rightMostCoord=null;jsts.operation.buffer.BufferSubgraph.prototype.env=null;jsts.operation.buffer.BufferSubgraph.prototype.getDirectedEdges=function(){return this.dirEdgeList;};jsts.operation.buffer.BufferSubgraph.prototype.getNodes=function(){return this.nodes;};jsts.operation.buffer.BufferSubgraph.prototype.getEnvelope=function(){if(this.env===null){var edgeEnv=new jsts.geom.Envelope();for(var it=this.dirEdgeList.iterator();it.hasNext();){var dirEdge=it.next();var pts=dirEdge.getEdge().getCoordinates();for(var j=0;j<pts.length-1;j++){edgeEnv.expandToInclude(pts[j]);}}
this.env=edgeEnv;}
return this.env;};jsts.operation.buffer.BufferSubgraph.prototype.getRightmostCoordinate=function(){return this.rightMostCoord;};jsts.operation.buffer.BufferSubgraph.prototype.create=function(node){this.addReachable(node);this.finder.findEdge(this.dirEdgeList);this.rightMostCoord=this.finder.getCoordinate();};jsts.operation.buffer.BufferSubgraph.prototype.addReachable=function(startNode){var nodeStack=[];nodeStack.push(startNode);while(nodeStack.length!==0){var node=nodeStack.pop();this.add(node,nodeStack);}};jsts.operation.buffer.BufferSubgraph.prototype.add=function(node,nodeStack){node.setVisited(true);this.nodes.add(node);for(var i=node.getEdges().iterator();i.hasNext();){var de=i.next();this.dirEdgeList.add(de);var sym=de.getSym();var symNode=sym.getNode();if(!symNode.isVisited())
nodeStack.push(symNode);}};jsts.operation.buffer.BufferSubgraph.prototype.clearVisitedEdges=function(){for(var it=this.dirEdgeList.iterator();it.hasNext();){var de=it.next();de.setVisited(false);}};jsts.operation.buffer.BufferSubgraph.prototype.computeDepth=function(outsideDepth){this.clearVisitedEdges();var de=this.finder.getEdge();var n=de.getNode();var label=de.getLabel();de.setEdgeDepths(jsts.geomgraph.Position.RIGHT,outsideDepth);this.copySymDepths(de);this.computeDepths(de);};jsts.operation.buffer.BufferSubgraph.prototype.computeDepths=function(startEdge){var nodesVisited=[];var nodeQueue=[];var startNode=startEdge.getNode();nodeQueue.push(startNode);nodesVisited.push(startNode);startEdge.setVisited(true);while(nodeQueue.length!==0){var n=nodeQueue.shift();nodesVisited.push(n);this.computeNodeDepth(n);for(var i=n.getEdges().iterator();i.hasNext();){var de=i.next();var sym=de.getSym();if(sym.isVisited())
continue;var adjNode=sym.getNode();if(nodesVisited.indexOf(adjNode)===-1){nodeQueue.push(adjNode);nodesVisited.push(adjNode);}}}};jsts.operation.buffer.BufferSubgraph.prototype.computeNodeDepth=function(n){var startEdge=null;for(var i=n.getEdges().iterator();i.hasNext();){var de=i.next();if(de.isVisited()||de.getSym().isVisited()){startEdge=de;break;}}
if(startEdge==null)
throw new jsts.error.TopologyError('unable to find edge to compute depths at '+n.getCoordinate());n.getEdges().computeDepths(startEdge);for(var i=n.getEdges().iterator();i.hasNext();){var de=i.next();de.setVisited(true);this.copySymDepths(de);}};jsts.operation.buffer.BufferSubgraph.prototype.copySymDepths=function(de){var sym=de.getSym();sym.setDepth(jsts.geomgraph.Position.LEFT,de.getDepth(jsts.geomgraph.Position.RIGHT));sym.setDepth(jsts.geomgraph.Position.RIGHT,de.getDepth(jsts.geomgraph.Position.LEFT));};jsts.operation.buffer.BufferSubgraph.prototype.findResultEdges=function(){for(var it=this.dirEdgeList.iterator();it.hasNext();){var de=it.next();if(de.getDepth(jsts.geomgraph.Position.RIGHT)>=1&&de.getDepth(jsts.geomgraph.Position.LEFT)<=0&&!de.isInteriorAreaEdge()){de.setInResult(true);}}};jsts.operation.buffer.BufferSubgraph.prototype.compareTo=function(o){var graph=o;if(this.rightMostCoord.x<graph.rightMostCoord.x){return-1;}
if(this.rightMostCoord.x>graph.rightMostCoord.x){return 1;}
return 0;};jsts.simplify.DPTransformer=function(distanceTolerance,isEnsureValidTopology){this.distanceTolerance=distanceTolerance;this.isEnsureValidTopology=isEnsureValidTopology;};jsts.simplify.DPTransformer.prototype=new jsts.geom.util.GeometryTransformer();jsts.simplify.DPTransformer.prototype.distanceTolerance=null;jsts.simplify.DPTransformer.prototype.isEnsureValidTopology=null;jsts.simplify.DPTransformer.prototype.transformCoordinates=function(coords,parent){var inputPts=coords;var newPts=null;if(inputPts.length==0){newPts=[];}else{newPts=jsts.simplify.DouglasPeuckerLineSimplifier.simplify(inputPts,this.distanceTolerance);}
return newPts;};jsts.simplify.DPTransformer.prototype.transformPolygon=function(geom,parent){if(geom.isEmpty()){return null;}
var rawGeom=jsts.geom.util.GeometryTransformer.prototype.transformPolygon.apply(this,arguments);if(parent instanceof jsts.geom.MultiPolygon){return rawGeom;}
return this.createValidArea(rawGeom);};jsts.simplify.DPTransformer.prototype.transformLinearRing=function(geom,parent){var removeDegenerateRings=parent instanceof jsts.geom.Polygon;var simpResult=jsts.geom.util.GeometryTransformer.prototype.transformLinearRing.apply(this,arguments);if(removeDegenerateRings&&!(simpResult instanceof jsts.geom.LinearRing)){return null;}
return simpResult;};jsts.simplify.DPTransformer.prototype.transformMultiPolygon=function(geom,parent){var rawGeom=jsts.geom.util.GeometryTransformer.prototype.transformMultiPolygon.apply(this,arguments);return this.createValidArea(rawGeom);};jsts.simplify.DPTransformer.prototype.createValidArea=function(rawAreaGeom){if(this.isEnsureValidTopology){return rawAreaGeom.buffer(0.0);}
return rawAreaGeom;};jsts.geom.util.GeometryExtracter=function(clz,comps){this.clz=clz;this.comps=comps;};jsts.geom.util.GeometryExtracter.prototype=new jsts.geom.GeometryFilter();jsts.geom.util.GeometryExtracter.prototype.clz=null;jsts.geom.util.GeometryExtracter.prototype.comps=null;jsts.geom.util.GeometryExtracter.extract=function(geom,clz,list){list=list||new javascript.util.ArrayList();if(geom instanceof clz){list.add(geom);}
else if(geom instanceof jsts.geom.GeometryCollection||geom instanceof jsts.geom.MultiPoint||geom instanceof jsts.geom.MultiLineString||geom instanceof jsts.geom.MultiPolygon){geom.apply(new jsts.geom.util.GeometryExtracter(clz,list));}
return list;};jsts.geom.util.GeometryExtracter.prototype.filter=function(geom){if(this.clz===null||geom instanceof this.clz){this.comps.add(geom);}};(function(){var OverlayOp=jsts.operation.overlay.OverlayOp;var SnapOverlayOp=jsts.operation.overlay.snap.SnapOverlayOp;var SnapIfNeededOverlayOp=function(g1,g2){this.geom=[];this.geom[0]=g1;this.geom[1]=g2;};SnapIfNeededOverlayOp.overlayOp=function(g0,g1,opCode){var op=new SnapIfNeededOverlayOp(g0,g1);return op.getResultGeometry(opCode);};SnapIfNeededOverlayOp.intersection=function(g0,g1){return overlayOp(g0,g1,OverlayOp.INTERSECTION);};SnapIfNeededOverlayOp.union=function(g0,g1){return overlayOp(g0,g1,OverlayOp.UNION);};SnapIfNeededOverlayOp.difference=function(g0,g1){return overlayOp(g0,g1,OverlayOp.DIFFERENCE);};SnapIfNeededOverlayOp.symDifference=function(g0,g1){return overlayOp(g0,g1,OverlayOp.SYMDIFFERENCE);};SnapIfNeededOverlayOp.prototype.geom=null;SnapIfNeededOverlayOp.prototype.getResultGeometry=function(opCode){var result=null;var isSuccess=false;var savedException=null;try{result=OverlayOp.overlayOp(this.geom[0],this.geom[1],opCode);var isValid=true;if(isValid)
isSuccess=true;}catch(ex){savedException=ex;}
if(!isSuccess){try{result=SnapOverlayOp.overlayOp(this.geom[0],this.geom[1],opCode);}catch(ex){throw savedException;}}
return result;};jsts.operation.overlay.snap.SnapIfNeededOverlayOp=SnapIfNeededOverlayOp;})();(function(){var GeometryExtracter=jsts.geom.util.GeometryExtracter;var CascadedPolygonUnion=jsts.operation.union.CascadedPolygonUnion;var PointGeometryUnion=jsts.operation.union.PointGeometryUnion;var OverlayOp=jsts.operation.overlay.OverlayOp;var SnapIfNeededOverlayOp=jsts.operation.overlay.snap.SnapIfNeededOverlayOp;var ArrayList=javascript.util.ArrayList;jsts.operation.union.UnaryUnionOp=function(geoms,geomFact){this.polygons=new ArrayList();this.lines=new ArrayList();this.points=new ArrayList();if(geomFact){this.geomFact=geomFact;}
this.extract(geoms);};jsts.operation.union.UnaryUnionOp.union=function(geoms,geomFact){var op=new jsts.operation.union.UnaryUnionOp(geoms,geomFact);return op.union();};jsts.operation.union.UnaryUnionOp.prototype.polygons=null;jsts.operation.union.UnaryUnionOp.prototype.lines=null;jsts.operation.union.UnaryUnionOp.prototype.points=null;jsts.operation.union.UnaryUnionOp.prototype.geomFact=null;jsts.operation.union.UnaryUnionOp.prototype.extract=function(geoms){if(geoms instanceof ArrayList){for(var i=geoms.iterator();i.hasNext();){var geom=i.next();this.extract(geom);}}else{if(this.geomFact===null){this.geomFact=geoms.getFactory();}
GeometryExtracter.extract(geoms,jsts.geom.Polygon,this.polygons);GeometryExtracter.extract(geoms,jsts.geom.LineString,this.lines);GeometryExtracter.extract(geoms,jsts.geom.Point,this.points);}};jsts.operation.union.UnaryUnionOp.prototype.union=function(){if(this.geomFact===null){return null;}
var unionPoints=null;if(this.points.size()>0){var ptGeom=this.geomFact.buildGeometry(this.points);unionPoints=this.unionNoOpt(ptGeom);}
var unionLines=null;if(this.lines.size()>0){var lineGeom=this.geomFact.buildGeometry(this.lines);unionLines=this.unionNoOpt(lineGeom);}
var unionPolygons=null;if(this.polygons.size()>0){unionPolygons=CascadedPolygonUnion.union(this.polygons);}
var unionLA=this.unionWithNull(unionLines,unionPolygons);var union=null;if(unionPoints===null){union=unionLA;}else if(unionLA===null){union=unionPoints;}else{union=PointGeometryUnion(unionPoints,unionLA);}
if(union===null){return this.geomFact.createGeometryCollection(null);}
return union;};jsts.operation.union.UnaryUnionOp.prototype.unionWithNull=function(g0,g1){if(g0===null&&g1===null){return null;}
if(g1===null){return g0;}
if(g0===null){return g1;}
return g0.union(g1);};jsts.operation.union.UnaryUnionOp.prototype.unionNoOpt=function(g0){var empty=this.geomFact.createPoint(null);return SnapIfNeededOverlayOp.overlayOp(g0,empty,OverlayOp.UNION);};}());jsts.index.kdtree.KdNode=function(){this.left=null;this.right=null;this.count=1;if(arguments.length===2){this.initializeFromCoordinate.apply(this,arguments[0],arguments[1]);}else if(arguments.length===3){this.initializeFromXY.apply(this,arguments[0],arguments[1],arguments[2]);}};jsts.index.kdtree.KdNode.prototype.initializeFromXY=function(x,y,data){this.p=new jsts.geom.Coordinate(x,y);this.data=data;};jsts.index.kdtree.KdNode.prototype.initializeFromCoordinate=function(p,data){this.p=p;this.data=data;};jsts.index.kdtree.KdNode.prototype.getX=function(){return this.p.x;};jsts.index.kdtree.KdNode.prototype.getY=function(){return this.p.y;};jsts.index.kdtree.KdNode.prototype.getCoordinate=function(){return this.p;};jsts.index.kdtree.KdNode.prototype.getData=function(){return this.data;};jsts.index.kdtree.KdNode.prototype.getLeft=function(){return this.left;};jsts.index.kdtree.KdNode.prototype.getRight=function(){return this.right;};jsts.index.kdtree.KdNode.prototype.increment=function(){this.count+=1;};jsts.index.kdtree.KdNode.prototype.getCount=function(){return this.count;};jsts.index.kdtree.KdNode.prototype.isRepeated=function(){return count>1;};jsts.index.kdtree.KdNode.prototype.setLeft=function(left){this.left=left;};jsts.index.kdtree.KdNode.prototype.setRight=function(right){this.right=right;};jsts.algorithm.InteriorPointPoint=function(geometry){this.minDistance=Number.MAX_VALUE;this.interiorPoint=null;this.centroid=geometry.getCentroid().getCoordinate();this.add(geometry);};jsts.algorithm.InteriorPointPoint.prototype.add=function(geometry){if(geometry instanceof jsts.geom.Point){this.addPoint(geometry.getCoordinate());}else if(geometry instanceof jsts.geom.GeometryCollection){for(var i=0;i<geometry.getNumGeometries();i++){this.add(geometry.getGeometryN(i));}}};jsts.algorithm.InteriorPointPoint.prototype.addPoint=function(point){var dist=point.distance(this.centroid);if(dist<this.minDistance){this.interiorPoint=new jsts.geom.Coordinate(point);this.minDistance=dist;}};jsts.algorithm.InteriorPointPoint.prototype.getInteriorPoint=function(){return this.interiorPoint;};(function(){jsts.geom.MultiLineString=function(geometries,factory){this.geometries=geometries||[];this.factory=factory;};jsts.geom.MultiLineString.prototype=new jsts.geom.GeometryCollection();jsts.geom.MultiLineString.constructor=jsts.geom.MultiLineString;jsts.geom.MultiLineString.prototype.getBoundary=function(){return(new jsts.operation.BoundaryOp(this)).getBoundary();};jsts.geom.MultiLineString.prototype.equalsExact=function(other,tolerance){if(!this.isEquivalentClass(other)){return false;}
return jsts.geom.GeometryCollection.prototype.equalsExact.call(this,other,tolerance);};jsts.geom.MultiLineString.prototype.CLASS_NAME='jsts.geom.MultiLineString';})();(function(){var Interval=jsts.index.bintree.Interval;var Root=jsts.index.bintree.Root;var Bintree=function(){this.root=new Root();this.minExtent=1.0;};Bintree.ensureExtent=function(itemInterval,minExtent){var min,max;min=itemInterval.getMin();max=itemInterval.getMax();if(min!==max){return itemInterval;}
if(min===max){min=min-(minExtent/2.0);max=min+(minExtent/2.0);}
return new Interval(min,max);};Bintree.prototype.depth=function(){if(this.root!==null){return this.root.depth();}
return 0;};Bintree.prototype.size=function(){if(this.root!==null){return this.root.size();}
return 0;};Bintree.prototype.nodeSize=function(){if(this.root!==null){return this.root.nodeSize();}
return 0;};Bintree.prototype.insert=function(itemInterval,item){this.collectStats(itemInterval);var insertInterval=Bintree.ensureExtent(itemInterval,this.minExtent);this.root.insert(insertInterval,item);};Bintree.prototype.remove=function(itemInterval,item){var insertInterval=Bintree.ensureExtent(itemInterval,this.minExtent);return this.root.remove(insertInterval,item);};Bintree.prototype.iterator=function(){var foundItems=new javascript.util.ArrayList();this.root.addAllItems(foundItems);return foundItems.iterator();};Bintree.prototype.query=function(){if(arguments.length===2){this.queryAndAdd(arguments[0],arguments[1]);}else{var x=arguments[0];if(!x instanceof Interval){x=new Interval(x,x);}
return this.queryInterval(x);}};Bintree.prototype.queryInterval=function(interval){var foundItems=new javascript.util.ArrayList();this.query(interval,foundItems);return foundItems;};Bintree.prototype.queryAndAdd=function(interval,foundItems){this.root.addAllItemsFromOverlapping(interval,foundItems);};Bintree.prototype.collectStats=function(interval){var del=interval.getWidth();if(del<this.minExtent&&del>0.0){this.minExtent=del;}};jsts.index.bintree.Bintree=Bintree;})();jsts.algorithm.InteriorPointArea=function(geometry){this.factory;this.interiorPoint=null;this.maxWidth=0;this.factory=geometry.getFactory();this.add(geometry);};jsts.algorithm.InteriorPointArea.avg=function(a,b){return(a+b)/2;};jsts.algorithm.InteriorPointArea.prototype.getInteriorPoint=function(){return this.interiorPoint;};jsts.algorithm.InteriorPointArea.prototype.add=function(geometry){if(geometry instanceof jsts.geom.Polygon){this.addPolygon(geometry);}else if(geometry instanceof jsts.geom.GeometryCollection){for(var i=0;i<geometry.getNumGeometries();i++){this.add(geometry.getGeometryN(i));}}};jsts.algorithm.InteriorPointArea.prototype.addPolygon=function(geometry){if(geometry.isEmpty()){return;}
var intPt;var width=0;var bisector=this.horizontalBisector(geometry);if(bisector.getLength()==0.0){width=0;intPt=bisector.getCoordinate();}else{var intersections=bisector.intersection(geometry);var widestIntersection=this.widestGeometry(intersections);width=widestIntersection.getEnvelopeInternal().getWidth();intPt=this.centre(widestIntersection.getEnvelopeInternal());}
if(this.interiorPoint==null||width>this.maxWidth){this.interiorPoint=intPt;this.maxWidth=width;}};jsts.algorithm.InteriorPointArea.prototype.widestGeometry=function(obj){if(obj instanceof jsts.geom.GeometryCollection){var gc=obj;if(gc.isEmpty()){return gc;}
var widestGeometry=gc.getGeometryN(0);for(var i=1;i<gc.getNumGeometries();i++){if(gc.getGeometryN(i).getEnvelopeInternal().getWidth()>widestGeometry.getEnvelopeInternal().getWidth()){widestGeometry=gc.getGeometryN(i);}}
return widestGeometry;}else if(obj instanceof jsts.geom.Geometry){return obj;}};jsts.algorithm.InteriorPointArea.prototype.horizontalBisector=function(geometry){var envelope=geometry.getEnvelopeInternal();var bisectY=jsts.algorithm.SafeBisectorFinder.getBisectorY(geometry);return this.factory.createLineString([new jsts.geom.Coordinate(envelope.getMinX(),bisectY),new jsts.geom.Coordinate(envelope.getMaxX(),bisectY)]);};jsts.algorithm.InteriorPointArea.prototype.centre=function(envelope){return new jsts.geom.Coordinate(jsts.algorithm.InteriorPointArea.avg(envelope.getMinX(),envelope.getMaxX()),jsts.algorithm.InteriorPointArea.avg(envelope.getMinY(),envelope.getMaxY()));};jsts.algorithm.SafeBisectorFinder=function(poly){this.poly;this.centreY;this.hiY=Number.MAX_VALUE;this.loY=-Number.MAX_VALUE;this.poly=poly;this.hiY=poly.getEnvelopeInternal().getMaxY();this.loY=poly.getEnvelopeInternal().getMinY();this.centreY=jsts.algorithm.InteriorPointArea.avg(this.loY,this.hiY);};jsts.algorithm.SafeBisectorFinder.getBisectorY=function(poly){var finder=new jsts.algorithm.SafeBisectorFinder(poly);return finder.getBisectorY();};jsts.algorithm.SafeBisectorFinder.prototype.getBisectorY=function(){this.process(this.poly.getExteriorRing());for(var i=0;i<this.poly.getNumInteriorRing();i++){this.process(this.poly.getInteriorRingN(i));}
var bisectY=jsts.algorithm.InteriorPointArea.avg(this.hiY,this.loY);return bisectY;};jsts.algorithm.SafeBisectorFinder.prototype.process=function(line){var seq=line.getCoordinateSequence();for(var i=0;i<seq.length;i++){var y=seq[i].y;this.updateInterval(y);}};jsts.algorithm.SafeBisectorFinder.prototype.updateInterval=function(y){if(y<=this.centreY){if(y>this.loY){this.loY=y;}}else if(y>this.centreY){if(y<this.hiY){this.hiY=y;}}};jsts.operation.buffer.BufferParameters=function(quadrantSegments,endCapStyle,joinStyle,mitreLimit){if(quadrantSegments)
this.setQuadrantSegments(quadrantSegments);if(endCapStyle)
this.setEndCapStyle(endCapStyle);if(joinStyle)
this.setJoinStyle(joinStyle);if(mitreLimit)
this.setMitreLimit(mitreLimit);};jsts.operation.buffer.BufferParameters.CAP_ROUND=1;jsts.operation.buffer.BufferParameters.CAP_FLAT=2;jsts.operation.buffer.BufferParameters.CAP_SQUARE=3;jsts.operation.buffer.BufferParameters.JOIN_ROUND=1;jsts.operation.buffer.BufferParameters.JOIN_MITRE=2;jsts.operation.buffer.BufferParameters.JOIN_BEVEL=3;jsts.operation.buffer.BufferParameters.DEFAULT_QUADRANT_SEGMENTS=8;jsts.operation.buffer.BufferParameters.DEFAULT_MITRE_LIMIT=5.0;jsts.operation.buffer.BufferParameters.prototype.quadrantSegments=jsts.operation.buffer.BufferParameters.DEFAULT_QUADRANT_SEGMENTS;jsts.operation.buffer.BufferParameters.prototype.endCapStyle=jsts.operation.buffer.BufferParameters.CAP_ROUND;jsts.operation.buffer.BufferParameters.prototype.joinStyle=jsts.operation.buffer.BufferParameters.JOIN_ROUND;jsts.operation.buffer.BufferParameters.prototype.mitreLimit=jsts.operation.buffer.BufferParameters.DEFAULT_MITRE_LIMIT;jsts.operation.buffer.BufferParameters.prototype._isSingleSided=false;jsts.operation.buffer.BufferParameters.prototype.getQuadrantSegments=function(){return this.quadrantSegments;};jsts.operation.buffer.BufferParameters.prototype.setQuadrantSegments=function(quadrantSegments){this.quadrantSegments=quadrantSegments;};jsts.operation.buffer.BufferParameters.prototype.setQuadrantSegments=function(quadSegs){this.quadrantSegments=quadSegs;if(this.quadrantSegments===0)
this.joinStyle=jsts.operation.buffer.BufferParameters.JOIN_BEVEL;if(this.quadrantSegments<0){this.joinStyle=jsts.operation.buffer.BufferParameters.JOIN_MITRE;this.mitreLimit=Math.abs(this.quadrantSegments);}
if(quadSegs<=0){this.quadrantSegments=1;}
if(this.joinStyle!==jsts.operation.buffer.BufferParameters.JOIN_ROUND){this.quadrantSegments=jsts.operation.buffer.BufferParameters.DEFAULT_QUADRANT_SEGMENTS;}};jsts.operation.buffer.BufferParameters.bufferDistanceError=function(quadSegs){var alpha=Math.PI/2.0/quadSegs;return 1-Math.cos(alpha/2.0);};jsts.operation.buffer.BufferParameters.prototype.getEndCapStyle=function(){return this.endCapStyle;};jsts.operation.buffer.BufferParameters.prototype.setEndCapStyle=function(endCapStyle){this.endCapStyle=endCapStyle;};jsts.operation.buffer.BufferParameters.prototype.getJoinStyle=function(){return this.joinStyle;};jsts.operation.buffer.BufferParameters.prototype.setJoinStyle=function(joinStyle){this.joinStyle=joinStyle;};jsts.operation.buffer.BufferParameters.prototype.getMitreLimit=function(){return this.mitreLimit;};jsts.operation.buffer.BufferParameters.prototype.setMitreLimit=function(mitreLimit){this.mitreLimit=mitreLimit;};jsts.operation.buffer.BufferParameters.prototype.setSingleSided=function(isSingleSided){this._isSingleSided=isSingleSided;};jsts.operation.buffer.BufferParameters.prototype.isSingleSided=function(){return this._isSingleSided;};(function(){jsts.geom.util.ShortCircuitedGeometryVisitor=function(){};jsts.geom.util.ShortCircuitedGeometryVisitor.prototype.isDone=false;jsts.geom.util.ShortCircuitedGeometryVisitor.prototype.applyTo=function(geom){for(var i=0;i<geom.getNumGeometries()&&!this.isDone;i++){var element=geom.getGeometryN(i);if(!(element instanceof jsts.geom.GeometryCollection)){this.visit(element);if(this.isDone()){this.isDone=true;return;}}
else
this.applyTo(element);}}
jsts.geom.util.ShortCircuitedGeometryVisitor.prototype.visit=function(element){};jsts.geom.util.ShortCircuitedGeometryVisitor.prototype.isDone=function(){};})();(function(){var EnvelopeIntersectsVisitor=function(rectEnv){this.rectEnv=rectEnv;};EnvelopeIntersectsVisitor.prototype=new jsts.geom.util.ShortCircuitedGeometryVisitor();EnvelopeIntersectsVisitor.constructor=EnvelopeIntersectsVisitor;EnvelopeIntersectsVisitor.prototype.rectEnv=null;EnvelopeIntersectsVisitor.prototype.intersects=false;EnvelopeIntersectsVisitor.prototype.intersects=function(){return this.intersects;}
EnvelopeIntersectsVisitor.prototype.visit=function(element){var elementEnv=element.getEnvelopeInternal();if(!this.rectEnv.intersects(elementEnv)){return;}
if(this.rectEnv.contains(elementEnv)){this.intersects=true;return;}
if(elementEnv.getMinX()>=rectEnv.getMinX()&&elementEnv.getMaxX()<=rectEnv.getMaxX()){this.intersects=true;return;}
if(elementEnv.getMinY()>=rectEnv.getMinY()&&elementEnv.getMaxY()<=rectEnv.getMaxY()){this.intersects=true;return;}}
EnvelopeIntersectsVisitor.prototype.isDone=function(){return this.intersects==true;}
var GeometryContainsPointVisitor=function(rectangle){this.rectSeq=rectangle.getExteriorRing().getCoordinateSequence();this.rectEnv=rectangle.getEnvelopeInternal();};GeometryContainsPointVisitor.prototype=new jsts.geom.util.ShortCircuitedGeometryVisitor();GeometryContainsPointVisitor.constructor=GeometryContainsPointVisitor;GeometryContainsPointVisitor.prototype.rectSeq=null;GeometryContainsPointVisitor.prototype.rectEnv=null;GeometryContainsPointVisitor.prototype.containsPoint=false;GeometryContainsPointVisitor.prototype.containsPoint=function(){return this.containsPoint;}
GeometryContainsPointVisitor.prototype.visit=function(geom){if(!(geom instanceof jsts.geom.Polygon))
return;var elementEnv=geom.getEnvelopeInternal();if(!this.rectEnv.intersects(elementEnv))
return;var rectPt=new jsts.geom.Coordinate();for(var i=0;i<4;i++){this.rectSeq.getCoordinate(i,rectPt);if(!elementEnv.contains(rectPt))
continue;if(SimplePointInAreaLocator.containsPointInPolygon(rectPt,geom)){this.containsPoint=true;return;}}}
GeometryContainsPointVisitor.prototype.isDone=function(){return this.containsPoint==true;}
var RectangleIntersectsSegmentVisitor=function(rectangle){this.rectEnv=rectangle.getEnvelopeInternal();this.rectIntersector=new RectangleLineIntersector(rectEnv);};RectangleIntersectsSegmentVisitor.prototype=new jsts.geom.util.ShortCircuitedGeometryVisitor();RectangleIntersectsSegmentVisitor.constructor=RectangleIntersectsSegmentVisitor;RectangleIntersectsSegmentVisitor.prototype.rectEnv=null;RectangleIntersectsSegmentVisitor.prototype.rectIntersector=null;RectangleIntersectsSegmentVisitor.prototype.hasIntersection=false;RectangleIntersectsSegmentVisitor.prototype.p0=null;RectangleIntersectsSegmentVisitor.prototype.p1=null;RectangleIntersectsSegmentVisitor.prototype.intersects=function(){return this.hasIntersection;}
RectangleIntersectsSegmentVisitor.prototype.visit=function(geom){var elementEnv=geom.getEnvelopeInternal();if(!this.rectEnv.intersects(elementEnv))
return;var lines=LinearComponentExtracter.getLines(geom);this.checkIntersectionWithLineStrings(lines);}
RectangleIntersectsSegmentVisitor.prototype.checkIntersectionWithLineStrings=function(lines){for(var i=lines.iterator();i.hasNext();){var testLine=i.next();this.checkIntersectionWithSegments(testLine);if(this.hasIntersection)
return;}}
RectangleIntersectsSegmentVisitor.prototype.checkIntersectionWithSegments=function(testLine){var seq1=testLine.getCoordinateSequence();for(var j=1;j<seq1.length;j++){this.p0=seq1[j-1];this.p1=seq1[j];if(rectIntersector.intersects(p0,p1)){this.hasIntersection=true;return;}}}
RectangleIntersectsSegmentVisitor.prototype.isDone=function(){return this.hasIntersection==true;}
jsts.operation.predicate.RectangleIntersects=function(rectangle){this.rectangle=rectangle;this.rectEnv=rectangle.getEnvelopeInternal();}
jsts.operation.predicate.RectangleIntersects.intersects=function(rectangle,b){var rp=new jsts.operation.predicate.RectangleIntersects(rectangle);return rp.intersects(b);}
jsts.operation.predicate.RectangleIntersects.prototype.rectangle=null;jsts.operation.predicate.RectangleIntersects.prototype.rectEnv=null;jsts.operation.predicate.RectangleIntersects.prototype.intersects=function(geom){if(!this.rectEnv.intersects(geom.getEnvelopeInternal()))
return false;var visitor=new EnvelopeIntersectsVisitor(this.rectEnv);visitor.applyTo(geom);if(visitor.intersects())
return true;var ecpVisitor=new GeometryContainsPointVisitor(rectangle);ecpVisitor.applyTo(geom);if(ecpVisitor.containsPoint())
return true;var riVisitor=new RectangleIntersectsSegmentVisitor(rectangle);riVisitor.applyTo(geom);if(riVisitor.intersects())
return true;return false;}})();jsts.operation.buffer.BufferBuilder=function(bufParams){this.bufParams=bufParams;this.edgeList=new jsts.geomgraph.EdgeList();};jsts.operation.buffer.BufferBuilder.depthDelta=function(label){var lLoc=label.getLocation(0,jsts.geomgraph.Position.LEFT);var rLoc=label.getLocation(0,jsts.geomgraph.Position.RIGHT);if(lLoc===jsts.geom.Location.INTERIOR&&rLoc===jsts.geom.Location.EXTERIOR)
return 1;else if(lLoc===jsts.geom.Location.EXTERIOR&&rLoc===jsts.geom.Location.INTERIOR)
return-1;return 0;};jsts.operation.buffer.BufferBuilder.prototype.bufParams=null;jsts.operation.buffer.BufferBuilder.prototype.workingPrecisionModel=null;jsts.operation.buffer.BufferBuilder.prototype.workingNoder=null;jsts.operation.buffer.BufferBuilder.prototype.geomFact=null;jsts.operation.buffer.BufferBuilder.prototype.graph=null;jsts.operation.buffer.BufferBuilder.prototype.edgeList=null;jsts.operation.buffer.BufferBuilder.prototype.setWorkingPrecisionModel=function(pm){this.workingPrecisionModel=pm;};jsts.operation.buffer.BufferBuilder.prototype.setNoder=function(noder){this.workingNoder=noder;};jsts.operation.buffer.BufferBuilder.prototype.buffer=function(g,distance){var precisionModel=this.workingPrecisionModel;if(precisionModel===null)
precisionModel=g.getPrecisionModel();this.geomFact=g.getFactory();var curveBuilder=new jsts.operation.buffer.OffsetCurveBuilder(precisionModel,this.bufParams);var curveSetBuilder=new jsts.operation.buffer.OffsetCurveSetBuilder(g,distance,curveBuilder);var bufferSegStrList=curveSetBuilder.getCurves();if(bufferSegStrList.size()<=0){return this.createEmptyResultGeometry();}
this.computeNodedEdges(bufferSegStrList,precisionModel);this.graph=new jsts.geomgraph.PlanarGraph(new jsts.operation.overlay.OverlayNodeFactory());this.graph.addEdges(this.edgeList.getEdges());var subgraphList=this.createSubgraphs(this.graph);var polyBuilder=new jsts.operation.overlay.PolygonBuilder(this.geomFact);this.buildSubgraphs(subgraphList,polyBuilder);var resultPolyList=polyBuilder.getPolygons();if(resultPolyList.size()<=0){return this.createEmptyResultGeometry();}
var resultGeom=this.geomFact.buildGeometry(resultPolyList);return resultGeom;};jsts.operation.buffer.BufferBuilder.prototype.getNoder=function(precisionModel){if(this.workingNoder!==null)
return this.workingNoder;var noder=new jsts.noding.MCIndexNoder();var li=new jsts.algorithm.RobustLineIntersector();li.setPrecisionModel(precisionModel);noder.setSegmentIntersector(new jsts.noding.IntersectionAdder(li));return noder;};jsts.operation.buffer.BufferBuilder.prototype.computeNodedEdges=function(bufferSegStrList,precisionModel){var noder=this.getNoder(precisionModel);noder.computeNodes(bufferSegStrList);var nodedSegStrings=noder.getNodedSubstrings();for(var i=nodedSegStrings.iterator();i.hasNext();){var segStr=i.next();var oldLabel=segStr.getData();var edge=new jsts.geomgraph.Edge(segStr.getCoordinates(),new jsts.geomgraph.Label(oldLabel));this.insertUniqueEdge(edge);}};jsts.operation.buffer.BufferBuilder.prototype.insertUniqueEdge=function(e){var existingEdge=this.edgeList.findEqualEdge(e);if(existingEdge!=null){var existingLabel=existingEdge.getLabel();var labelToMerge=e.getLabel();if(!existingEdge.isPointwiseEqual(e)){labelToMerge=new jsts.geomgraph.Label(e.getLabel());labelToMerge.flip();}
existingLabel.merge(labelToMerge);var mergeDelta=jsts.operation.buffer.BufferBuilder.depthDelta(labelToMerge);var existingDelta=existingEdge.getDepthDelta();var newDelta=existingDelta+mergeDelta;existingEdge.setDepthDelta(newDelta);}else{this.edgeList.add(e);e.setDepthDelta(jsts.operation.buffer.BufferBuilder.depthDelta(e.getLabel()));}};jsts.operation.buffer.BufferBuilder.prototype.createSubgraphs=function(graph){var subgraphList=[];for(var i=graph.getNodes().iterator();i.hasNext();){var node=i.next();if(!node.isVisited()){var subgraph=new jsts.operation.buffer.BufferSubgraph();subgraph.create(node);subgraphList.push(subgraph);}}
var compare=function(a,b){return a.compareTo(b);};subgraphList.sort(compare);subgraphList.reverse();return subgraphList;};jsts.operation.buffer.BufferBuilder.prototype.buildSubgraphs=function(subgraphList,polyBuilder){var processedGraphs=[];for(var i=0;i<subgraphList.length;i++){var subgraph=subgraphList[i];var p=subgraph.getRightmostCoordinate();var locater=new jsts.operation.buffer.SubgraphDepthLocater(processedGraphs);var outsideDepth=locater.getDepth(p);subgraph.computeDepth(outsideDepth);subgraph.findResultEdges();processedGraphs.push(subgraph);polyBuilder.add(subgraph.getDirectedEdges(),subgraph.getNodes());}};jsts.operation.buffer.BufferBuilder.convertSegStrings=function(it){var fact=new jsts.geom.GeometryFactory();var lines=new javascript.util.ArrayList();while(it.hasNext()){var ss=it.next();var line=fact.createLineString(ss.getCoordinates());lines.add(line);}
return fact.buildGeometry(lines);};jsts.operation.buffer.BufferBuilder.prototype.createEmptyResultGeometry=function(){var emptyGeom=this.geomFact.createPolygon(null,null);return emptyGeom;};jsts.noding.SegmentPointComparator=function(){};jsts.noding.SegmentPointComparator.compare=function(octant,p0,p1){if(p0.equals2D(p1))
return 0;var xSign=jsts.noding.SegmentPointComparator.relativeSign(p0.x,p1.x);var ySign=jsts.noding.SegmentPointComparator.relativeSign(p0.y,p1.y);switch(octant){case 0:return jsts.noding.SegmentPointComparator.compareValue(xSign,ySign);case 1:return jsts.noding.SegmentPointComparator.compareValue(ySign,xSign);case 2:return jsts.noding.SegmentPointComparator.compareValue(ySign,-xSign);case 3:return jsts.noding.SegmentPointComparator.compareValue(-xSign,ySign);case 4:return jsts.noding.SegmentPointComparator.compareValue(-xSign,-ySign);case 5:return jsts.noding.SegmentPointComparator.compareValue(-ySign,-xSign);case 6:return jsts.noding.SegmentPointComparator.compareValue(-ySign,xSign);case 7:return jsts.noding.SegmentPointComparator.compareValue(xSign,-ySign);}
return 0;};jsts.noding.SegmentPointComparator.relativeSign=function(x0,x1){if(x0<x1)
return-1;if(x0>x1)
return 1;return 0;};jsts.noding.SegmentPointComparator.compareValue=function(compareSign0,compareSign1){if(compareSign0<0)
return-1;if(compareSign0>0)
return 1;if(compareSign1<0)
return-1;if(compareSign1>0)
return 1;return 0;};jsts.operation.relate.RelateOp=function(){jsts.operation.GeometryGraphOperation.apply(this,arguments);this._relate=new jsts.operation.relate.RelateComputer(this.arg);};jsts.operation.relate.RelateOp.prototype=new jsts.operation.GeometryGraphOperation();jsts.operation.relate.RelateOp.relate=function(a,b,boundaryNodeRule){var relOp=new jsts.operation.relate.RelateOp(a,b,boundaryNodeRule);var im=relOp.getIntersectionMatrix();return im;};jsts.operation.relate.RelateOp.prototype._relate=null;jsts.operation.relate.RelateOp.prototype.getIntersectionMatrix=function(){return this._relate.computeIM();};jsts.index.chain.MonotoneChain=function(pts,start,end,context){this.pts=pts;this.start=start;this.end=end;this.context=context;};jsts.index.chain.MonotoneChain.prototype.pts=null;jsts.index.chain.MonotoneChain.prototype.start=null;jsts.index.chain.MonotoneChain.prototype.end=null;jsts.index.chain.MonotoneChain.prototype.env=null;jsts.index.chain.MonotoneChain.prototype.context=null;jsts.index.chain.MonotoneChain.prototype.id=null;jsts.index.chain.MonotoneChain.prototype.setId=function(id){this.id=id;};jsts.index.chain.MonotoneChain.prototype.getId=function(){return this.id;};jsts.index.chain.MonotoneChain.prototype.getContext=function(){return this.context;};jsts.index.chain.MonotoneChain.prototype.getEnvelope=function(){if(this.env==null){var p0=this.pts[this.start];var p1=this.pts[this.end];this.env=new jsts.geom.Envelope(p0,p1);}
return this.env;};jsts.index.chain.MonotoneChain.prototype.getStartIndex=function(){return this.start;};jsts.index.chain.MonotoneChain.prototype.getEndIndex=function(){return this.end;};jsts.index.chain.MonotoneChain.prototype.getLineSegment=function(index,ls){ls.p0=this.pts[index];ls.p1=this.pts[index+1];};jsts.index.chain.MonotoneChain.prototype.getCoordinates=function(){var coord=[];var index=0;for(var i=this.start;i<=this.end;i++){coord[index++]=this.pts[i];}
return coord;};jsts.index.chain.MonotoneChain.prototype.select=function(searchEnv,mcs){this.computeSelect2(searchEnv,this.start,this.end,mcs);};jsts.index.chain.MonotoneChain.prototype.computeSelect2=function(searchEnv,start0,end0,mcs){var p0=this.pts[start0];var p1=this.pts[end0];mcs.tempEnv1.init(p0,p1);if(end0-start0===1){mcs.select(this,start0);return;}
if(!searchEnv.intersects(mcs.tempEnv1))
return;var mid=parseInt((start0+end0)/2);if(start0<mid){this.computeSelect2(searchEnv,start0,mid,mcs);}
if(mid<end0){this.computeSelect2(searchEnv,mid,end0,mcs);}};jsts.index.chain.MonotoneChain.prototype.computeOverlaps=function(mc,mco){if(arguments.length===6){return this.computeOverlaps2.apply(this,arguments);}
this.computeOverlaps2(this.start,this.end,mc,mc.start,mc.end,mco);};jsts.index.chain.MonotoneChain.prototype.computeOverlaps2=function(start0,end0,mc,start1,end1,mco){var p00=this.pts[start0];var p01=this.pts[end0];var p10=mc.pts[start1];var p11=mc.pts[end1];if(end0-start0===1&&end1-start1===1){mco.overlap(this,start0,mc,start1);return;}
mco.tempEnv1.init(p00,p01);mco.tempEnv2.init(p10,p11);if(!mco.tempEnv1.intersects(mco.tempEnv2))
return;var mid0=parseInt((start0+end0)/2);var mid1=parseInt((start1+end1)/2);if(start0<mid0){if(start1<mid1)
this.computeOverlaps2(start0,mid0,mc,start1,mid1,mco);if(mid1<end1)
this.computeOverlaps2(start0,mid0,mc,mid1,end1,mco);}
if(mid0<end0){if(start1<mid1)
this.computeOverlaps2(mid0,end0,mc,start1,mid1,mco);if(mid1<end1)
this.computeOverlaps2(mid0,end0,mc,mid1,end1,mco);}};(function(){var Location=jsts.geom.Location;var Dimension=jsts.geom.Dimension;jsts.geom.IntersectionMatrix=function(elements){var other=elements;if(elements===undefined||elements===null){this.matrix=[[],[],[]];this.setAll(Dimension.FALSE);}else if(typeof elements==='string'){this.set(elements);}else if(other instanceof jsts.geom.IntersectionMatrix){this.matrix[Location.INTERIOR][Location.INTERIOR]=other.matrix[Location.INTERIOR][Location.INTERIOR];this.matrix[Location.INTERIOR][Location.BOUNDARY]=other.matrix[Location.INTERIOR][Location.BOUNDARY];this.matrix[Location.INTERIOR][Location.EXTERIOR]=other.matrix[Location.INTERIOR][Location.EXTERIOR];this.matrix[Location.BOUNDARY][Location.INTERIOR]=other.matrix[Location.BOUNDARY][Location.INTERIOR];this.matrix[Location.BOUNDARY][Location.BOUNDARY]=other.matrix[Location.BOUNDARY][Location.BOUNDARY];this.matrix[Location.BOUNDARY][Location.EXTERIOR]=other.matrix[Location.BOUNDARY][Location.EXTERIOR];this.matrix[Location.EXTERIOR][Location.INTERIOR]=other.matrix[Location.EXTERIOR][Location.INTERIOR];this.matrix[Location.EXTERIOR][Location.BOUNDARY]=other.matrix[Location.EXTERIOR][Location.BOUNDARY];this.matrix[Location.EXTERIOR][Location.EXTERIOR]=other.matrix[Location.EXTERIOR][Location.EXTERIOR];}};jsts.geom.IntersectionMatrix.prototype.matrix=null;jsts.geom.IntersectionMatrix.prototype.add=function(im){var i,j;for(i=0;i<3;i++){for(j=0;j<3;j++){this.setAtLeast(i,j,im.get(i,j));}}};jsts.geom.IntersectionMatrix.matches=function(actualDimensionValue,requiredDimensionSymbol){if(typeof actualDimensionValue==='string'){return jsts.geom.IntersectionMatrix.matches2.call(this,arguments);}
if(requiredDimensionSymbol==='*'){return true;}
if(requiredDimensionSymbol==='T'&&(actualDimensionValue>=0||actualDimensionValue===Dimension.TRUE)){return true;}
if(requiredDimensionSymbol==='F'&&actualDimensionValue===Dimension.FALSE){return true;}
if(requiredDimensionSymbol==='0'&&actualDimensionValue===Dimension.P){return true;}
if(requiredDimensionSymbol==='1'&&actualDimensionValue===Dimension.L){return true;}
if(requiredDimensionSymbol==='2'&&actualDimensionValue===Dimension.A){return true;}
return false;};jsts.geom.IntersectionMatrix.matches2=function(actualDimensionSymbols,requiredDimensionSymbols){var m=new jsts.geom.IntersectionMatrix(actualDimensionSymbols);return m.matches(requiredDimensionSymbols);};jsts.geom.IntersectionMatrix.prototype.set=function(row,column,dimensionValue){if(typeof row==='string'){this.set2(row);return;}
this.matrix[row][column]=dimensionValue;};jsts.geom.IntersectionMatrix.prototype.set2=function(dimensionSymbols){for(var i=0;i<dimensionSymbols.length();i++){var row=i/3;var col=i%3;this.matrix[row][col]=Dimension.toDimensionValue(dimensionSymbols.charAt(i));}};jsts.geom.IntersectionMatrix.prototype.setAtLeast=function(row,column,minimumDimensionValue){if(arguments.length===1){this.setAtLeast2(arguments[0]);return;}
if(this.matrix[row][column]<minimumDimensionValue){this.matrix[row][column]=minimumDimensionValue;}};jsts.geom.IntersectionMatrix.prototype.setAtLeastIfValid=function(row,column,minimumDimensionValue){if(row>=0&&column>=0){this.setAtLeast(row,column,minimumDimensionValue);}};jsts.geom.IntersectionMatrix.prototype.setAtLeast2=function(minimumDimensionSymbols){var i;for(i=0;i<minimumDimensionSymbols.length;i++){var row=parseInt(i/3);var col=parseInt(i%3);this.setAtLeast(row,col,jsts.geom.Dimension.toDimensionValue(minimumDimensionSymbols.charAt(i)));}};jsts.geom.IntersectionMatrix.prototype.setAll=function(dimensionValue){var ai,bi;for(ai=0;ai<3;ai++){for(bi=0;bi<3;bi++){this.matrix[ai][bi]=dimensionValue;}}};jsts.geom.IntersectionMatrix.prototype.get=function(row,column){return this.matrix[row][column];};jsts.geom.IntersectionMatrix.prototype.isDisjoint=function(){return this.matrix[Location.INTERIOR][Location.INTERIOR]===Dimension.FALSE&&this.matrix[Location.INTERIOR][Location.BOUNDARY]===Dimension.FALSE&&this.matrix[Location.BOUNDARY][Location.INTERIOR]===Dimension.FALSE&&this.matrix[Location.BOUNDARY][Location.BOUNDARY]===Dimension.FALSE;};jsts.geom.IntersectionMatrix.prototype.isIntersects=function(){return!this.isDisjoint();};jsts.geom.IntersectionMatrix.prototype.isTouches=function(dimensionOfGeometryA,dimensionOfGeometryB){if(dimensionOfGeometryA>dimensionOfGeometryB){return this.isTouches(dimensionOfGeometryB,dimensionOfGeometryA);}
if((dimensionOfGeometryA==Dimension.A&&dimensionOfGeometryB==Dimension.A)||(dimensionOfGeometryA==Dimension.L&&dimensionOfGeometryB==Dimension.L)||(dimensionOfGeometryA==Dimension.L&&dimensionOfGeometryB==Dimension.A)||(dimensionOfGeometryA==Dimension.P&&dimensionOfGeometryB==Dimension.A)||(dimensionOfGeometryA==Dimension.P&&dimensionOfGeometryB==Dimension.L)){return this.matrix[Location.INTERIOR][Location.INTERIOR]===Dimension.FALSE&&(jsts.geom.IntersectionMatrix.matches(this.matrix[Location.INTERIOR][Location.BOUNDARY],'T')||jsts.geom.IntersectionMatrix.matches(this.matrix[Location.BOUNDARY][Location.INTERIOR],'T')||jsts.geom.IntersectionMatrix.matches(this.matrix[Location.BOUNDARY][Location.BOUNDARY],'T'));}
return false;};jsts.geom.IntersectionMatrix.prototype.isCrosses=function(dimensionOfGeometryA,dimensionOfGeometryB){if((dimensionOfGeometryA==Dimension.P&&dimensionOfGeometryB==Dimension.L)||(dimensionOfGeometryA==Dimension.P&&dimensionOfGeometryB==Dimension.A)||(dimensionOfGeometryA==Dimension.L&&dimensionOfGeometryB==Dimension.A)){return jsts.geom.IntersectionMatrix.matches(this.matrix[Location.INTERIOR][Location.INTERIOR],'T')&&jsts.geom.IntersectionMatrix.matches(this.matrix[Location.INTERIOR][Location.EXTERIOR],'T');}
if((dimensionOfGeometryA==Dimension.L&&dimensionOfGeometryB==Dimension.P)||(dimensionOfGeometryA==Dimension.A&&dimensionOfGeometryB==Dimension.P)||(dimensionOfGeometryA==Dimension.A&&dimensionOfGeometryB==Dimension.L)){return jsts.geom.IntersectionMatrix.matches(matrix[Location.INTERIOR][Location.INTERIOR],'T')&&jsts.geom.IntersectionMatrix.matches(this.matrix[Location.EXTERIOR][Location.INTERIOR],'T');}
if(dimensionOfGeometryA===Dimension.L&&dimensionOfGeometryB===Dimension.L){return this.matrix[Location.INTERIOR][Location.INTERIOR]===0;}
return false;};jsts.geom.IntersectionMatrix.prototype.isWithin=function(){return jsts.geom.IntersectionMatrix.matches(this.matrix[Location.INTERIOR][Location.INTERIOR],'T')&&this.matrix[Location.INTERIOR][Location.EXTERIOR]==Dimension.FALSE&&this.matrix[Location.BOUNDARY][Location.EXTERIOR]==Dimension.FALSE;};jsts.geom.IntersectionMatrix.prototype.isContains=function(){return jsts.geom.IntersectionMatrix.matches(this.matrix[Location.INTERIOR][Location.INTERIOR],'T')&&this.matrix[Location.EXTERIOR][Location.INTERIOR]==Dimension.FALSE&&this.matrix[Location.EXTERIOR][Location.BOUNDARY]==Dimension.FALSE;};jsts.geom.IntersectionMatrix.prototype.isCovers=function(){var hasPointInCommon=jsts.geom.IntersectionMatrix.matches(this.matrix[Location.INTERIOR][Location.INTERIOR],'T')||jsts.geom.IntersectionMatrix.matches(this.matrix[Location.INTERIOR][Location.BOUNDARY],'T')||jsts.geom.IntersectionMatrix.matches(this.matrix[Location.BOUNDARY][Location.INTERIOR],'T')||jsts.geom.IntersectionMatrix.matches(this.matrix[Location.BOUNDARY][Location.BOUNDARY],'T');return hasPointInCommon&&this.matrix[Location.EXTERIOR][Location.INTERIOR]==Dimension.FALSE&&this.matrix[Location.EXTERIOR][Location.BOUNDARY]==Dimension.FALSE;};jsts.geom.IntersectionMatrix.prototype.isCoveredBy=function(){var hasPointInCommon=jsts.geom.IntersectionMatrix.matches(this.matrix[Location.INTERIOR][Location.INTERIOR],'T')||jsts.geom.IntersectionMatrix.matches(this.matrix[Location.INTERIOR][Location.BOUNDARY],'T')||jsts.geom.IntersectionMatrix.matches(this.matrix[Location.BOUNDARY][Location.INTERIOR],'T')||jsts.geom.IntersectionMatrix.matches(this.matrix[Location.BOUNDARY][Location.BOUNDARY],'T');return hasPointInCommon&&this.matrix[Location.INTERIOR][Location.EXTERIOR]===Dimension.FALSE&&this.matrix[Location.BOUNDARY][Location.EXTERIOR]===Dimension.FALSE;};jsts.geom.IntersectionMatrix.prototype.isEquals=function(dimensionOfGeometryA,dimensionOfGeometryB){if(dimensionOfGeometryA!==dimensionOfGeometryB){return false;}
return jsts.geom.IntersectionMatrix.matches(this.matrix[Location.INTERIOR][Location.INTERIOR],'T')&&this.matrix[Location.EXTERIOR][Location.INTERIOR]===Dimension.FALSE&&this.matrix[Location.INTERIOR][Location.EXTERIOR]===Dimension.FALSE&&this.matrix[Location.EXTERIOR][Location.BOUNDARY]===Dimension.FALSE&&this.matrix[Location.BOUNDARY][Location.EXTERIOR]===Dimension.FALSE;};jsts.geom.IntersectionMatrix.prototype.isOverlaps=function(dimensionOfGeometryA,dimensionOfGeometryB){if((dimensionOfGeometryA==Dimension.P&&dimensionOfGeometryB===Dimension.P)||(dimensionOfGeometryA==Dimension.A&&dimensionOfGeometryB===Dimension.A)){return jsts.geom.IntersectionMatrix.matches(this.matrix[Location.INTERIOR][Location.INTERIOR],'T')&&jsts.geom.IntersectionMatrix.matches(this.matrix[Location.INTERIOR][Location.EXTERIOR],'T')&&jsts.geom.IntersectionMatrix.matches(this.matrix[Location.EXTERIOR][Location.INTERIOR],'T');}
if(dimensionOfGeometryA===Dimension.L&&dimensionOfGeometryB===Dimension.L){return this.matrix[Location.INTERIOR][Location.INTERIOR]==1&&jsts.geom.IntersectionMatrix.matches(this.matrix[Location.INTERIOR][Location.EXTERIOR],'T')&&jsts.geom.IntersectionMatrix.matches(this.matrix[Location.EXTERIOR][Location.INTERIOR],'T');}
return false;};jsts.geom.IntersectionMatrix.prototype.matches=function(requiredDimensionSymbols){if(requiredDimensionSymbols.length!=9){throw new jsts.error.IllegalArgumentException('Should be length 9: '+
requiredDimensionSymbols);}
for(var ai=0;ai<3;ai++){for(var bi=0;bi<3;bi++){if(!jsts.geom.IntersectionMatrix.matches(this.matrix[ai][bi],requiredDimensionSymbols.charAt(3*ai+bi))){return false;}}}
return true;};jsts.geom.IntersectionMatrix.prototype.transpose=function(){var temp=matrix[1][0];this.matrix[1][0]=this.matrix[0][1];this.matrix[0][1]=temp;temp=this.matrix[2][0];this.matrix[2][0]=this.matrix[0][2];this.matrix[0][2]=temp;temp=this.matrix[2][1];this.matrix[2][1]=this.matrix[1][2];this.matrix[1][2]=temp;return this;};jsts.geom.IntersectionMatrix.prototype.toString=function(){var ai,bi,buf='';for(ai=0;ai<3;ai++){for(bi=0;bi<3;bi++){buf+=Dimension.toDimensionSymbol(this.matrix[ai][bi]);}}
return buf;};})();jsts.triangulate.quadedge.LastFoundQuadEdgeLocator=function(subdiv){this.subdiv=subdiv;this.lastEdge=null;this.init();};jsts.triangulate.quadedge.LastFoundQuadEdgeLocator.prototype.init=function(){this.lastEdge=this.findEdge();};jsts.triangulate.quadedge.LastFoundQuadEdgeLocator.prototype.findEdge=function(){var edges=this.subdiv.getEdges();return edges[0];};jsts.triangulate.quadedge.LastFoundQuadEdgeLocator.prototype.locate=function(v){if(!this.lastEdge.isLive()){this.init();}
var e=this.subdiv.locateFromEdge(v,this.lastEdge);this.lastEdge=e;return e;};jsts.noding.SegmentNodeList=function(edge){this.nodeMap=new javascript.util.TreeMap();this.edge=edge;};jsts.noding.SegmentNodeList.prototype.nodeMap=null;jsts.noding.SegmentNodeList.prototype.iterator=function(){return this.nodeMap.values().iterator();};jsts.noding.SegmentNodeList.prototype.edge=null;jsts.noding.SegmentNodeList.prototype.getEdge=function(){return this.edge;};jsts.noding.SegmentNodeList.prototype.add=function(intPt,segmentIndex){var eiNew=new jsts.noding.SegmentNode(this.edge,intPt,segmentIndex,this.edge.getSegmentOctant(segmentIndex));var ei=this.nodeMap.get(eiNew);if(ei!==null){jsts.util.Assert.isTrue(ei.coord.equals2D(intPt),'Found equal nodes with different coordinates');return ei;}
this.nodeMap.put(eiNew,eiNew);return eiNew;};jsts.noding.SegmentNodeList.prototype.addEndpoints=function(){var maxSegIndex=this.edge.size()-1;this.add(this.edge.getCoordinate(0),0);this.add(this.edge.getCoordinate(maxSegIndex),maxSegIndex);};jsts.noding.SegmentNodeList.prototype.addCollapsedNodes=function(){var collapsedVertexIndexes=[];this.findCollapsesFromInsertedNodes(collapsedVertexIndexes);this.findCollapsesFromExistingVertices(collapsedVertexIndexes);for(var i=0;i<collapsedVertexIndexes.length;i++){var vertexIndex=collapsedVertexIndexes[i];this.add(this.edge.getCoordinate(vertexIndex),vertexIndex);}};jsts.noding.SegmentNodeList.prototype.findCollapsesFromExistingVertices=function(collapsedVertexIndexes){for(var i=0;i<this.edge.size()-2;i++){var p0=this.edge.getCoordinate(i);var p1=this.edge.getCoordinate(i+1);var p2=this.edge.getCoordinate(i+2);if(p0.equals2D(p2)){collapsedVertexIndexes.push(i+1);}}};jsts.noding.SegmentNodeList.prototype.findCollapsesFromInsertedNodes=function(collapsedVertexIndexes){var collapsedVertexIndex=[null];var it=this.iterator();var eiPrev=it.next();while(it.hasNext()){var ei=it.next();var isCollapsed=this.findCollapseIndex(eiPrev,ei,collapsedVertexIndex);if(isCollapsed)
collapsedVertexIndexes.push(collapsedVertexIndex[0]);eiPrev=ei;}};jsts.noding.SegmentNodeList.prototype.findCollapseIndex=function(ei0,ei1,collapsedVertexIndex){if(!ei0.coord.equals2D(ei1.coord))
return false;var numVerticesBetween=ei1.segmentIndex-ei0.segmentIndex;if(!ei1.isInterior()){numVerticesBetween--;}
if(numVerticesBetween===1){collapsedVertexIndex[0]=ei0.segmentIndex+1;return true;}
return false;};jsts.noding.SegmentNodeList.prototype.addSplitEdges=function(edgeList){this.addEndpoints();this.addCollapsedNodes();var it=this.iterator();var eiPrev=it.next();while(it.hasNext()){var ei=it.next();var newEdge=this.createSplitEdge(eiPrev,ei);edgeList.add(newEdge);eiPrev=ei;}};jsts.noding.SegmentNodeList.prototype.checkSplitEdgesCorrectness=function(splitEdges){var edgePts=edge.getCoordinates();var split0=splitEdges[0];var pt0=split0.getCoordinate(0);if(!pt0.equals2D(edgePts[0]))
throw new Error('bad split edge start point at '+pt0);var splitn=splitEdges[splitEdges.length-1];var splitnPts=splitn.getCoordinates();var ptn=splitnPts[splitnPts.length-1];if(!ptn.equals2D(edgePts[edgePts.length-1]))
throw new Error('bad split edge end point at '+ptn);};jsts.noding.SegmentNodeList.prototype.createSplitEdge=function(ei0,ei1){var npts=ei1.segmentIndex-ei0.segmentIndex+2;var lastSegStartPt=this.edge.getCoordinate(ei1.segmentIndex);var useIntPt1=ei1.isInterior()||!ei1.coord.equals2D(lastSegStartPt);if(!useIntPt1){npts--;}
var pts=[];var ipt=0;pts[ipt++]=new jsts.geom.Coordinate(ei0.coord);for(var i=ei0.segmentIndex+1;i<=ei1.segmentIndex;i++){pts[ipt++]=this.edge.getCoordinate(i);}
if(useIntPt1)
pts[ipt]=ei1.coord;return new jsts.noding.NodedSegmentString(pts,this.edge.getData());};jsts.io.WKTWriter=function(){this.parser=new jsts.io.WKTParser(this.geometryFactory);};jsts.io.WKTWriter.prototype.write=function(geometry){var wkt=this.parser.write(geometry);return wkt;};jsts.io.WKTWriter.toLineString=function(p0,p1){if(arguments.length!==2){throw new jsts.error.NotImplementedError();}
return'LINESTRING ( '+p0.x+' '+p0.y+', '+p1.x+' '+p1.y+' )';};jsts.io.WKTReader=function(geometryFactory){this.geometryFactory=geometryFactory||new jsts.geom.GeometryFactory();this.precisionModel=this.geometryFactory.getPrecisionModel();this.parser=new jsts.io.WKTParser(this.geometryFactory);};jsts.io.WKTReader.prototype.read=function(wkt){var geometry=this.parser.read(wkt);if(this.precisionModel.getType()===jsts.geom.PrecisionModel.FIXED){this.reducePrecision(geometry);}
return geometry;};jsts.io.WKTReader.prototype.reducePrecision=function(geometry){var i,len;if(geometry.coordinate){this.precisionModel.makePrecise(geometry.coordinate);}else if(geometry.points){for(i=0,len=geometry.points.length;i<len;i++){this.precisionModel.makePrecise(geometry.points[i]);}}else if(geometry.geometries){for(i=0,len=geometry.geometries.length;i<len;i++){this.reducePrecision(geometry.geometries[i]);}}};jsts.triangulate.quadedge.QuadEdgeSubdivision=function(env,tolerance){this.tolerance=tolerance;this.edgeCoincidenceTolerance=tolerance/jsts.triangulate.quadedge.QuadEdgeSubdivision.EDGE_COINCIDENCE_TOL_FACTOR;this.visitedKey=0;this.quadEdges=[];this.startingEdge;this.tolerance;this.edgeCoincidenceTolerance;this.frameEnv;this.locator=null;this.seg=new jsts.geom.LineSegment();this.triEdges=new Array(3);this.frameVertex=new Array(3);this.createFrame(env);this.startingEdge=this.initSubdiv();this.locator=new jsts.triangulate.quadedge.LastFoundQuadEdgeLocator(this);};jsts.triangulate.quadedge.QuadEdgeSubdivision.EDGE_COINCIDENCE_TOL_FACTOR=1000;jsts.triangulate.quadedge.QuadEdgeSubdivision.getTriangleEdges=function(startQE,triEdge){triEdge[0]=startQE;triEdge[1]=triEdge[0].lNext();triEdge[2]=triEdge[1].lNext();if(triEdge[2].lNext()!=triEdge[0]){throw new jsts.IllegalArgumentError('Edges do not form a triangle');}};jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.createFrame=function(env){var deltaX,deltaY,offset;deltaX=env.getWidth();deltaY=env.getHeight();offset=0.0;if(deltaX>deltaY){offset=deltaX*10.0;}else{offset=deltaY*10.0;}
this.frameVertex[0]=new jsts.triangulate.quadedge.Vertex((env.getMaxX()+env.getMinX())/2.0,env.getMaxY()
+offset);this.frameVertex[1]=new jsts.triangulate.quadedge.Vertex(env.getMinX()-offset,env.getMinY()-offset);this.frameVertex[2]=new jsts.triangulate.quadedge.Vertex(env.getMaxX()+offset,env.getMinY()-offset);this.frameEnv=new jsts.geom.Envelope(this.frameVertex[0].getCoordinate(),this.frameVertex[1].getCoordinate());this.frameEnv.expandToInclude(this.frameVertex[2].getCoordinate());};jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.initSubdiv=function(){var ea,eb,ec;ea=this.makeEdge(this.frameVertex[0],this.frameVertex[1]);eb=this.makeEdge(this.frameVertex[1],this.frameVertex[2]);jsts.triangulate.quadedge.QuadEdge.splice(ea.sym(),eb);ec=this.makeEdge(this.frameVertex[2],this.frameVertex[0]);jsts.triangulate.quadedge.QuadEdge.splice(eb.sym(),ec);jsts.triangulate.quadedge.QuadEdge.splice(ec.sym(),ea);return ea;};jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getTolerance=function(){return this.tolerance;};jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getEnvelope=function(){return new jsts.geom.Envelope(this.frameEnv);};jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getEdges=function(){if(arguments.length>0){return this.getEdgesByFactory(arguments[0]);}else{return this.quadEdges;}};jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.setLocator=function(locator){this.locator=locator;};jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.makeEdge=function(o,d){var q=jsts.triangulate.quadedge.QuadEdge.makeEdge(o,d);this.quadEdges.push(q);return q;};jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.connect=function(a,b){var q=jsts.triangulate.quadedge.QuadEdge.connect(a,b);this.quadEdges.push(q);return q;};jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.delete_jsts=function(e){jsts.triangulate.quadedge.QuadEdge.splice(e,e.oPrev());jsts.triangulate.quadedge.QuadEdge.splice(e.sym(),e.sym().oPrev());var eSym,eRot,eRotSym;e.eSym=e.sym();eRot=e.rot;eRotSym=e.rot.sym();var idx=this.quadEdges.indexOf(e);if(idx!==-1){this.quadEdges.splice(idx,1);}
idx=this.quadEdges.indexOf(eSym);if(idx!==-1){this.quadEdges.splice(idx,1);}
idx=this.quadEdges.indexOf(eRot);if(idx!==-1){this.quadEdges.splice(idx,1);}
idx=this.quadEdges.indexOf(eRotSym);if(idx!==-1){this.quadEdges.splice(idx,1);}
e.delete_jsts();eSym.delete_jsts();eRot.delete_jsts();eRotSym.delete_jsts();};jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.locateFromEdge=function(v,startEdge){var iter=0,maxIter=this.quadEdges.length,e;e=startEdge;while(true){iter++;if(iter>maxIter){throw new jsts.error.LocateFailureError(e.toLineSegment());}
if((v.equals(e.orig()))||(v.equals(e.dest()))){break;}else if(v.rightOf(e)){e=e.sym();}else if(!v.rightOf(e.oNext())){e=e.oNext();}else if(!v.rightOf(e.dPrev())){e=e.dPrev();}else{break;}}
return e;};jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.locate=function(){if(arguments.length===1){if(arguments[0]instanceof jsts.triangulate.quadedge.Vertex){return this.locateByVertex(arguments[0]);}else{return this.locateByCoordinate(arguments[0]);}}else{return this.locateByCoordinates(arguments[0],arguments[1]);}};jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.locateByVertex=function(v){return this.locator.locate(v);};jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.locateByCoordinate=function(p){return this.locator.locate(new jsts.triangulate.quadedge.Vertex(p));};jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.locateByCoordinates=function(p0,p1){var e,base,locEdge;var e=this.locator.locate(new jsts.triangulate.quadedge.Vertex(p0));if(e===null){return null;}
base=e;if(e.dest().getCoordinate().equals2D(p0)){base=e.sym();}
locEdge=base;do{if(locEdge.dest().getCoordinate().equals2D(p1)){return locEdge;}
locEdge=locEdge.oNext();}while(locEdge!=base);return null;};jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.insertSite=function(v){var e,base,startEdge;e=this.locate(v);if((v.equals(e.orig(),this.tolerance))||(v.equals(e.dest(),this.tolerance))){return e;}
base=this.makeEdge(e.orig(),v);jsts.triangulate.quadedge.QuadEdge.splice(base,e);startEdge=base;do{base=this.connect(e,base.sym());e=base.oPrev();}while(e.lNext()!=startEdge);return startEdge;};jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.isFrameEdge=function(e){if(this.isFrameVertex(e.orig())||this.isFrameVertex(e.dest())){return true;}
return false;};jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.isFrameBorderEdge=function(e){var leftTri,rightTri,vLeftTriOther,vRightTriOther;leftTri=new Array(3);this.getTriangleEdges(e,leftTri);rightTri=new Array(3);this.getTriangleEdges(e.sym(),rightTri);vLeftTriOther=e.lNext().dest();if(this.isFrameVertex(vLeftTriOther)){return true;}
vRightTriOther=e.sym().lNext().dest();if(this.isFrameVertex(vRightTriOther)){return true;}
return false;};jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.isFrameVertex=function(v){if(v.equals(this.frameVertex[0])){return true;}
if(v.equals(this.frameVertex[1])){return true;}
if(v.equals(this.frameVertex[2])){return true;}
return false;};jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.isOnEdge=function(e,p){this.seg.setCoordinates(e.orig().getCoordinate(),e.dest().getCoordinate());var dist=this.seg.distance(p);return dist<this.edgeCoincidenceTolerance;};jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.isVertexOfEdge=function(e,v){if((v.equals(e.orig(),this.tolerance))||(v.equals(e.dest(),this.tolerance))){return true;}
return false;};jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getVertices=function(includeFrame)
{var vertices=[],i,il,qe,v,vd;i=0,il=this.quadEdges.length;for(i;i<il;i++){qe=this.quadEdges[i];v=qe.orig();if(includeFrame||!this.isFrameVertex(v)){vertices.push(v);}
vd=qe.dest();if(includeFrame||!this.isFrameVertex(vd)){vertices.push(vd);}}
return vertices;};jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getVertexUniqueEdges=function(includeFrame)
{var edges,visitedVertices,i,il,qe,v,qd,vd;edges=[];visitedVertices=[];i=0,il=this.quadEdges.length;for(i;i<il;i++){qe=this.quadEdges[i];v=qe.orig();if(visitedVertices.indexOf(v)===-1){visitedVertices.push(v);if(includeFrame||!this.isFrameVertex(v)){edges.push(qe);}}
qd=qe.sym();vd=qd.orig();if(visitedVertices.indexOf(vd)===-1){visitedVertices.push(vd);if(includeFrame||!this.isFrameVertex(vd)){edges.push(qd);}}}
return edges;};jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getPrimaryEdges=function(includeFrame){this.visitedKey++;var edges,edgeStack,visitedEdges,edge,priQE;edges=[];edgeStack=[];edgeStack.push(this.startingEdge);visitedEdges=[];while(edgeStack.length>0){edge=edgeStack.pop();if(visitedEdges.indexOf(edge)===-1){priQE=edge.getPrimary();if(includeFrame||!this.isFrameEdge(priQE)){edges.push(priQE);}
edgeStack.push(edge.oNext());edgeStack.push(edge.sym().oNext());visitedEdges.push(edge);visitedEdges.push(edge.sym());}}
return edges;};jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.visitTriangles=function(triVisitor,includeFrame){this.visitedKey++;var edgeStack,visitedEdges,edge,triEdges;edgeStack=[];edgeStack.push(this.startingEdge);visitedEdges=[];while(edgeStack.length>0){edge=edgeStack.pop();if(visitedEdges.indexOf(edge)===-1){triEdges=this.fetchTriangleToVisit(edge,edgeStack,includeFrame,visitedEdges);if(triEdges!==null)
triVisitor.visit(triEdges);}}};jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.fetchTriangleToVisit=function(edge,edgeStack,includeFrame,visitedEdges){var curr,edgeCount,isFrame,sym;curr=edge;edgeCount=0;isFrame=false;do{this.triEdges[edgeCount]=curr;if(this.isFrameEdge(curr)){isFrame=true;}
sym=curr.sym();if(visitedEdges.indexOf(sym)===-1){edgeStack.push(sym);}
visitedEdges.push(curr);edgeCount++;curr=curr.lNext();}while(curr!==edge);if(isFrame&&!includeFrame){return null;}
return this.triEdges;};jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getTriangleEdges=function(includeFrame){var visitor=new jsts.triangulate.quadedge.TriangleEdgesListVisitor();this.visitTriangles(visitor,includeFrame);return visitor.getTriangleEdges();};jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getTriangleVertices=function(includeFrame){var visitor=new TriangleVertexListVisitor();this.visitTriangles(visitor,includeFrame);return visitor.getTriangleVertices();};jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getTriangleCoordinates=function(includeFrame){var visitor=new jsts.triangulate.quadedge.TriangleCoordinatesVisitor();this.visitTriangles(visitor,includeFrame);return visitor.getTriangles();};jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getEdgesByFactory=function(geomFact){var quadEdges,edges,i,il,qe,coords;quadEdges=this.getPrimaryEdges(false);edges=[];i=0;il=quadEdges.length;for(i;i<il;i++){qe=quadEdges[i];coords=[];coords[0]=(qe.orig().getCoordinate());coords[1]=(qe.dest().getCoordinate());edges[i]=geomFact.createLineString(coords);}
return geomFact.createMultiLineString(edges);};jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getTriangles=function(geomFact){var triPtsList,tris,triPt,i,il;triPtsList=this.getTriangleCoordinates(false);tris=new Array(triPtsList.length);i=0,il=triPtsList.length;for(i;i<il;i++){triPt=triPtsList[i];tris[i]=geomFact.createPolygon(geomFact.createLinearRing(triPt,null));}
return geomFact.createGeometryCollection(tris);};jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getVoronoiDiagram=function(geomFact)
{var vorCells=this.getVoronoiCellPolygons(geomFact);return geomFact.createGeometryCollection(vorCells);};jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getVoronoiCellPolygons=function(geomFact)
{this.visitTriangles(new jsts.triangulate.quadedge.TriangleCircumcentreVisitor(),true);var cells,edges,i,il,qe;cells=[];edges=this.getVertexUniqueEdges(false);i=0,il=edges.length;for(i;i<il;i++){qe=edges[i];cells.push(this.getVoronoiCellPolygon(qe,geomFact));}
return cells;};jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getVoronoiCellPolygon=function(qe,geomFact)
{var cellPts,startQe,cc,coordList,cellPoly,v;cellPts=[];startQE=qe;do{cc=qe.rot.orig().getCoordinate();cellPts.push(cc);qe=qe.oPrev();}while(qe!==startQE);coordList=new jsts.geom.CoordinateList([],false);coordList.add(cellPts,false);coordList.closeRing();if(coordList.size()<4){coordList.add(coordList.get(coordList.size()-1),true);}
cellPoly=geomFact.createPolygon(geomFact.createLinearRing(coordList.toArray()),null);v=startQE.orig();return cellPoly;};jsts.triangulate.quadedge.TriangleCircumcentreVisitor=function(){};jsts.triangulate.quadedge.TriangleCircumcentreVisitor.prototype.visit=function(triEdges){var a,b,c,cc,ccVertex,i;a=triEdges[0].orig().getCoordinate();b=triEdges[1].orig().getCoordinate();c=triEdges[2].orig().getCoordinate();cc=jsts.geom.Triangle.circumcentre(a,b,c);ccVertex=new jsts.triangulate.quadedge.Vertex(cc);i=0;for(i;i<3;i++){triEdges[i].rot.setOrig(ccVertex);}};jsts.triangulate.quadedge.TriangleEdgesListVisitor=function(){this.triList=[];};jsts.triangulate.quadedge.TriangleEdgesListVisitor.prototype.visit=function(triEdges){var clone=triEdges.concat();this.triList.push(clone);};jsts.triangulate.quadedge.TriangleEdgesListVisitor.prototype.getTriangleEdges=function(){return this.triList;};jsts.triangulate.quadedge.TriangleVertexListVisitor=function(){this.triList=[];};jsts.triangulate.quadedge.TriangleVertexListVisitor.prototype.visit=function(triEdges){var vertices=[];vertices.push(trieEdges[0].orig());vertices.push(trieEdges[1].orig());vertices.push(trieEdges[2].orig());this.triList.push(vertices);};jsts.triangulate.quadedge.TriangleVertexListVisitor.prototype.getTriangleVertices=function(){return this.triList;};jsts.triangulate.quadedge.TriangleCoordinatesVisitor=function(){this.coordList=new jsts.geom.CoordinateList([],false);this.triCoords=[];};jsts.triangulate.quadedge.TriangleCoordinatesVisitor.prototype.visit=function(triEdges){this.coordList=new jsts.geom.CoordinateList([],false);var i=0,v,pts;for(i;i<3;i++){v=triEdges[i].orig();this.coordList.add(v.getCoordinate());}
if(this.coordList.size()>0){this.coordList.closeRing();pts=this.coordList.toArray();if(pts.length!==4){return;}
this.triCoords.push(pts);}};jsts.triangulate.quadedge.TriangleCoordinatesVisitor.prototype.getTriangles=function(){return this.triCoords;};jsts.operation.relate.EdgeEndBundle=function(){this.edgeEnds=[];var e=arguments[0]instanceof jsts.geomgraph.EdgeEnd?arguments[0]:arguments[1];var edge=e.getEdge();var coord=e.getCoordinate();var dirCoord=e.getDirectedCoordinate();var label=new jsts.geomgraph.Label(e.getLabel());jsts.geomgraph.EdgeEnd.call(this,edge,coord,dirCoord,label);this.insert(e);};jsts.operation.relate.EdgeEndBundle.prototype=new jsts.geomgraph.EdgeEnd();jsts.operation.relate.EdgeEndBundle.prototype.edgeEnds=null;jsts.operation.relate.EdgeEndBundle.prototype.getLabel=function(){return this.label;};jsts.operation.relate.EdgeEndBundle.prototype.getEdgeEnds=function(){return this.edgeEnds;};jsts.operation.relate.EdgeEndBundle.prototype.insert=function(e){this.edgeEnds.push(e);};jsts.operation.relate.EdgeEndBundle.prototype.computeLabel=function(boundaryNodeRule){var isArea=false;for(var i=0;i<this.edgeEnds.length;i++){var e=this.edgeEnds[i];if(e.getLabel().isArea())
isArea=true;}
if(isArea)
this.label=new jsts.geomgraph.Label(jsts.geom.Location.NONE,jsts.geom.Location.NONE,jsts.geom.Location.NONE);else
this.label=new jsts.geomgraph.Label(jsts.geom.Location.NONE);for(var i=0;i<2;i++){this.computeLabelOn(i,boundaryNodeRule);if(isArea)
this.computeLabelSides(i);}};jsts.operation.relate.EdgeEndBundle.prototype.computeLabelOn=function(geomIndex,boundaryNodeRule){var boundaryCount=0;var foundInterior=false;for(var i=0;i<this.edgeEnds.length;i++){var e=this.edgeEnds[i];var loc=e.getLabel().getLocation(geomIndex);if(loc==jsts.geom.Location.BOUNDARY)
boundaryCount++;if(loc==jsts.geom.Location.INTERIOR)
foundInterior=true;}
var loc=jsts.geom.Location.NONE;if(foundInterior)
loc=jsts.geom.Location.INTERIOR;if(boundaryCount>0){loc=jsts.geomgraph.GeometryGraph.determineBoundary(boundaryNodeRule,boundaryCount);}
this.label.setLocation(geomIndex,loc);};jsts.operation.relate.EdgeEndBundle.prototype.computeLabelSides=function(geomIndex){this.computeLabelSide(geomIndex,jsts.geomgraph.Position.LEFT);this.computeLabelSide(geomIndex,jsts.geomgraph.Position.RIGHT);};jsts.operation.relate.EdgeEndBundle.prototype.computeLabelSide=function(geomIndex,side){for(var i=0;i<this.edgeEnds.length;i++){var e=this.edgeEnds[i];if(e.getLabel().isArea()){var loc=e.getLabel().getLocation(geomIndex,side);if(loc===jsts.geom.Location.INTERIOR){this.label.setLocation(geomIndex,side,jsts.geom.Location.INTERIOR);return;}else if(loc===jsts.geom.Location.EXTERIOR)
this.label.setLocation(geomIndex,side,jsts.geom.Location.EXTERIOR);}}};jsts.operation.relate.EdgeEndBundle.prototype.updateIM=function(im){jsts.geomgraph.Edge.updateIM(this.label,im);};jsts.index.kdtree.KdTree=function(tolerance){var tol=0.0;if(tolerance!==undefined){tol=tolerance;}
this.root=null;this.last=null;this.numberOfNodes=0;this.tolerance=tol;};jsts.index.kdtree.KdTree.prototype.insert=function(){if(arguments.length===1){return this.insertCoordinate.apply(this,arguments[0]);}else{return this.insertWithData.apply(this,arguments[0],arguments[1]);}};jsts.index.kdtree.KdTree.prototype.insertCoordinate=function(p){return this.insertWithData(p,null);};jsts.index.kdtree.KdTree.prototype.insertWithData=function(p,data){if(this.root===null){this.root=new jsts.index.kdtree.KdNode(p,data);return this.root;}
var currentNode=this.root,leafNode=this.root,isOddLevel=true,isLessThan=true;while(currentNode!==last){if(isOddLevel){isLessThan=p.x<currentNode.getX();}else{isLessThan=p.y<currentNode.getY();}
leafNode=currentNode;if(isLessThan){currentNode=currentNode.getLeft();}else{currentNode=currentNode.getRight();}
if(currentNode!==null){var isInTolerance=p.distance(currentNode.getCoordinate())<=this.tolerance;if(isInTolerance){currentNode.increment();return currentNode;}}
isOddLevel=!isOddLevel;}
this.numberOfNodes=numberOfNodes+1;var node=new jsts.index.kdtree.KdNode(p,data);node.setLeft(this.last);node.setRight(this.last);if(isLessThan){leafNode.setLeft(node);}else{leafNode.setRight(node);}
return node;};jsts.index.kdtree.KdTree.prototype.queryNode=function(currentNode,bottomNode,queryEnv,odd,result){if(currentNode===bottomNode){return;}
var min,max,discriminant;if(odd){min=queryEnv.getMinX();max=queryEnv.getMaxX();discriminant=currentNode.getX();}else{min=queryEnv.getMinY();max=queryEnv.getMaxY();discriminant=currentNode.getY();}
var searchLeft=min<discriminant;var searchRight=discriminant<=max;if(searchLeft){this.queryNode(currentNode.getLeft(),bottomNode,queryEnv,!odd,result);}
if(queryEnv.contains(currentNode.getCoordinate())){result.add(currentNode);}
if(searchRight){this.queryNode(currentNode.getRight(),bottomNode,queryEnv,!odd,result);}};jsts.index.kdtree.KdTree.prototype.query=function(){if(arguments.length===1){return this.queryByEnvelope.apply(this,arguments[0]);}else{return this.queryWithArray.apply(this,arguments[0],arguments[1]);}};jsts.index.kdtree.KdTree.prototype.queryByEnvelope=function(queryEnv){var result=[];this.queryNode(this.root,this.last,queryEnv,true,result);return result;};jsts.index.kdtree.KdTree.prototype.queryWithArray=function(queryEnv,result){this.queryNode(this.root,this.last,queryEnv,true,result);};jsts.geom.Triangle=function(p0,p1,p2){this.p0=p0;this.p1=p1;this.p2=p2;};jsts.geom.Triangle.isAcute=function(a,b,c){if(!jsts.algorithm.Angle.isAcute(a,b,c)){return false;}
if(!jsts.algorithm.Angle.isAcute(b,c,a)){return false;}
if(!jsts.algorithm.Angle.isAcute(c,a,b)){return false;}
return true;};jsts.geom.Triangle.perpendicularBisector=function(a,b){var dx,dy,l1,l2;dx=b.x-a.x;dy=b.y-a.y;l1=new jsts.algorithm.HCoordinate(a.x+dx/2.0,a.y+dy/2.0,1.0);l2=new jsts.algorithm.HCoordinate(a.x-dy+dx/2.0,a.y+dx+dy/2.0,1.0);return new jsts.algorithm.HCoordinate(l1,l2);};jsts.geom.Triangle.circumcentre=function(a,b,c){var cx,cy,ax,ay,bx,by,denom,numx,numy,ccx,ccy;cx=c.x;cy=c.y;ax=a.x-cx;ay=a.y-cy;bx=b.x-cx;by=b.y-cy;denom=2*jsts.geom.Triangle.det(ax,ay,bx,by);numx=jsts.geom.Triangle.det(ay,ax*ax+ay*ay,by,bx*bx+by*by);numy=jsts.geom.Triangle.det(ax,ax*ax+ay*ay,bx,bx*bx+by*by);ccx=cx-numx/denom;ccy=cy+numy/denom;return new jsts.geom.Coordinate(ccx,ccy);};jsts.geom.Triangle.det=function(m00,m01,m10,m11){return m00*m11-m01*m10;};jsts.geom.Triangle.inCentre=function(a,b,c){var len0,len1,len2,circum,inCentreX,inCentreY;len0=b.distance(c);len1=a.distance(c);len2=a.distance(b);circum=len0+len1+len2;inCentreX=(len0*a.x+len1*b.x+len2*c.x)/circum;inCentreY=(len0*a.y+len1*b.y+len2*c.y)/circum;return new jsts.geom.Coordinate(inCentreX,inCentreY);};jsts.geom.Triangle.centroid=function(a,b,c){var x,y;x=(a.x+b.x+c.x)/3;y=(a.y+b.y+c.y)/3;return new jsts.geom.Coordinate(x,y);};jsts.geom.Triangle.longestSideLength=function(a,b,c){var lenAB,lenBC,lenCA,maxLen;lenAB=a.distance(b);lenBC=b.distance(c);lenCA=c.distance(a);maxLen=lenAB;if(lenBC>maxLen){maxLen=lenBC;}
if(lenCA>maxLen){maxLen=lenCA;}
return maxLen;};jsts.geom.Triangle.angleBisector=function(a,b,c){var len0,len2,frac,dx,dy,splitPt;len0=b.distance(a);len2=b.distance(c);frac=len0/(len0+len2);dx=c.x-a.x;dy=c.y-a.y;splitPt=new jsts.geom.Coordinate(a.x+frac*dx,a.y+frac*dy);return splitPt;};jsts.geom.Triangle.area=function(a,b,c){return Math.abs(((c.x-a.x)*(b.y-a.y)-(b.x-a.x)*(c.y-a.y))/2.0);};jsts.geom.Triangle.signedArea=function(a,b,c){return((c.x-a.x)*(b.y-a.y)-(b.x-a.x)*(c.y-a.y))/2.0;};jsts.geom.Triangle.prototype.inCentre=function(){return jsts.geom.Triangle.inCentre(this.p0,this.p1,this.p2);};jsts.noding.OrientedCoordinateArray=function(pts){this.pts=pts;this._orientation=jsts.noding.OrientedCoordinateArray.orientation(pts);};jsts.noding.OrientedCoordinateArray.prototype.pts=null;jsts.noding.OrientedCoordinateArray.prototype._orientation=undefined;jsts.noding.OrientedCoordinateArray.orientation=function(pts){return jsts.geom.CoordinateArrays.increasingDirection(pts)===1;};jsts.noding.OrientedCoordinateArray.prototype.compareTo=function(o1){var oca=o1;var comp=jsts.noding.OrientedCoordinateArray.compareOriented(this.pts,this._orientation,oca.pts,oca._orientation);return comp;};jsts.noding.OrientedCoordinateArray.compareOriented=function(pts1,orientation1,pts2,orientation2){var dir1=orientation1?1:-1;var dir2=orientation2?1:-1;var limit1=orientation1?pts1.length:-1;var limit2=orientation2?pts2.length:-1;var i1=orientation1?0:pts1.length-1;var i2=orientation2?0:pts2.length-1;var comp=0;while(true){var compPt=pts1[i1].compareTo(pts2[i2]);if(compPt!==0)
return compPt;i1+=dir1;i2+=dir2;var done1=i1===limit1;var done2=i2===limit2;if(done1&&!done2)
return-1;if(!done1&&done2)
return 1;if(done1&&done2)
return 0;}};jsts.algorithm.CentralEndpointIntersector=function(p00,p01,p10,p11){this.pts=[p00,p01,p10,p11];this.compute();};jsts.algorithm.CentralEndpointIntersector.getIntersection=function(p00,p01,p10,p11){var intor=new jsts.algorithm.CentralEndpointIntersector(p00,p01,p10,p11);return intor.getIntersection();};jsts.algorithm.CentralEndpointIntersector.prototype.pts=null;jsts.algorithm.CentralEndpointIntersector.prototype.intPt=null;jsts.algorithm.CentralEndpointIntersector.prototype.compute=function(){var centroid=jsts.algorithm.CentralEndpointIntersector.average(this.pts);this.intPt=this.findNearestPoint(centroid,this.pts);};jsts.algorithm.CentralEndpointIntersector.prototype.getIntersection=function(){return this.intPt;};jsts.algorithm.CentralEndpointIntersector.average=function(pts){var avg=new jsts.geom.Coordinate();var i,n=pts.length;for(i=0;i<n;i++){avg.x+=pts[i].x;avg.y+=pts[i].y;}
if(n>0){avg.x/=n;avg.y/=n;}
return avg;};jsts.algorithm.CentralEndpointIntersector.prototype.findNearestPoint=function(p,pts){var minDist=Number.MAX_VALUE;var i,result=null,dist;for(i=0;i<pts.length;i++){dist=p.distance(pts[i]);if(dist<minDist){minDist=dist;result=pts[i];}}
return result;};jsts.operation.buffer.BufferOp=function(g,bufParams){this.argGeom=g;this.bufParams=bufParams?bufParams:new jsts.operation.buffer.BufferParameters();};jsts.operation.buffer.BufferOp.MAX_PRECISION_DIGITS=12;jsts.operation.buffer.BufferOp.precisionScaleFactor=function(g,distance,maxPrecisionDigits){var env=g.getEnvelopeInternal();var envSize=Math.max(env.getHeight(),env.getWidth());var expandByDistance=distance>0.0?distance:0.0;var bufEnvSize=envSize+2*expandByDistance;var bufEnvLog10=(Math.log(bufEnvSize)/Math.log(10)+1.0);var minUnitLog10=bufEnvLog10-maxPrecisionDigits;var scaleFactor=Math.pow(10.0,-minUnitLog10);return scaleFactor;};jsts.operation.buffer.BufferOp.bufferOp=function(g,distance){if(arguments.length>2){return jsts.operation.buffer.BufferOp.bufferOp2.apply(this,arguments);}
var gBuf=new jsts.operation.buffer.BufferOp(g);var geomBuf=gBuf.getResultGeometry(distance);return geomBuf;};jsts.operation.buffer.BufferOp.bufferOp2=function(g,distance,params){if(arguments.length>3){return jsts.operation.buffer.BufferOp.bufferOp3.apply(this,arguments);}
var bufOp=new jsts.operation.buffer.BufferOp(g,params);var geomBuf=bufOp.getResultGeometry(distance);return geomBuf;};jsts.operation.buffer.BufferOp.bufferOp3=function(g,distance,quadrantSegments){if(arguments.length>4){return jsts.operation.buffer.BufferOp.bufferOp4.apply(this,arguments);}
var bufOp=new jsts.operation.buffer.BufferOp(g);bufOp.setQuadrantSegments(quadrantSegments);var geomBuf=bufOp.getResultGeometry(distance);return geomBuf;};jsts.operation.buffer.BufferOp.bufferOp4=function(g,distance,quadrantSegments,endCapStyle){var bufOp=new jsts.operation.buffer.BufferOp(g);bufOp.setQuadrantSegments(quadrantSegments);bufOp.setEndCapStyle(endCapStyle);var geomBuf=bufOp.getResultGeometry(distance);return geomBuf;};jsts.operation.buffer.BufferOp.prototype.argGeom=null;jsts.operation.buffer.BufferOp.prototype.distance=null;jsts.operation.buffer.BufferOp.prototype.bufParams=null;jsts.operation.buffer.BufferOp.prototype.resultGeometry=null;jsts.operation.buffer.BufferOp.prototype.setEndCapStyle=function(endCapStyle){this.bufParams.setEndCapStyle(endCapStyle);};jsts.operation.buffer.BufferOp.prototype.setQuadrantSegments=function(quadrantSegments){this.bufParams.setQuadrantSegments(quadrantSegments);};jsts.operation.buffer.BufferOp.prototype.getResultGeometry=function(dist){this.distance=dist;this.computeGeometry();return this.resultGeometry;};jsts.operation.buffer.BufferOp.prototype.computeGeometry=function(){this.bufferOriginalPrecision();if(this.resultGeometry!==null){return;}
var argPM=this.argGeom.getPrecisionModel();if(argPM.getType()===jsts.geom.PrecisionModel.FIXED){this.bufferFixedPrecision(argPM);}else{this.bufferReducedPrecision();}};jsts.operation.buffer.BufferOp.prototype.bufferReducedPrecision=function(){var precDigits;var saveException=null;for(precDigits=jsts.operation.buffer.BufferOp.MAX_PRECISION_DIGITS;precDigits>=0;precDigits--){try{this.bufferReducedPrecision2(precDigits);}catch(ex){saveException=ex;}
if(this.resultGeometry!==null){return;}}
throw saveException;};jsts.operation.buffer.BufferOp.prototype.bufferOriginalPrecision=function(){try{var bufBuilder=new jsts.operation.buffer.BufferBuilder(this.bufParams);this.resultGeometry=bufBuilder.buffer(this.argGeom,this.distance);}catch(e){}};jsts.operation.buffer.BufferOp.prototype.bufferReducedPrecision2=function(precisionDigits){var sizeBasedScaleFactor=jsts.operation.buffer.BufferOp.precisionScaleFactor(this.argGeom,this.distance,precisionDigits);var fixedPM=new jsts.geom.PrecisionModel(sizeBasedScaleFactor);this.bufferFixedPrecision(fixedPM);};jsts.operation.buffer.BufferOp.prototype.bufferFixedPrecision=function(fixedPM){var noder=new jsts.noding.ScaledNoder(new jsts.noding.snapround.MCIndexSnapRounder(new jsts.geom.PrecisionModel(1.0)),fixedPM.getScale());var bufBuilder=new jsts.operation.buffer.BufferBuilder(this.bufParams);bufBuilder.setWorkingPrecisionModel(fixedPM);bufBuilder.setNoder(noder);this.resultGeometry=bufBuilder.buffer(this.argGeom,this.distance);};(function(){var Location=jsts.geom.Location;var Position=jsts.geomgraph.Position;var Assert=jsts.util.Assert;jsts.geomgraph.GeometryGraph=function(argIndex,parentGeom,boundaryNodeRule){jsts.geomgraph.PlanarGraph.call(this);this.lineEdgeMap=new javascript.util.HashMap();this.ptLocator=new jsts.algorithm.PointLocator();this.argIndex=argIndex;this.parentGeom=parentGeom;this.boundaryNodeRule=boundaryNodeRule||jsts.algorithm.BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;if(parentGeom!==null){this.add(parentGeom);}};jsts.geomgraph.GeometryGraph.prototype=new jsts.geomgraph.PlanarGraph();jsts.geomgraph.GeometryGraph.constructor=jsts.geomgraph.GeometryGraph;jsts.geomgraph.GeometryGraph.prototype.createEdgeSetIntersector=function(){return new jsts.geomgraph.index.SimpleMCSweepLineIntersector();};jsts.geomgraph.GeometryGraph.determineBoundary=function(boundaryNodeRule,boundaryCount){return boundaryNodeRule.isInBoundary(boundaryCount)?Location.BOUNDARY:Location.INTERIOR;};jsts.geomgraph.GeometryGraph.prototype.parentGeom=null;jsts.geomgraph.GeometryGraph.prototype.lineEdgeMap=null;jsts.geomgraph.GeometryGraph.prototype.boundaryNodeRule=null;jsts.geomgraph.GeometryGraph.prototype.useBoundaryDeterminationRule=true;jsts.geomgraph.GeometryGraph.prototype.argIndex=null;jsts.geomgraph.GeometryGraph.prototype.boundaryNodes=null;jsts.geomgraph.GeometryGraph.prototype.hasTooFewPoints=false;jsts.geomgraph.GeometryGraph.prototype.invalidPoint=null;jsts.geomgraph.GeometryGraph.prototype.areaPtLocator=null;jsts.geomgraph.GeometryGraph.prototype.ptLocator=null;jsts.geomgraph.GeometryGraph.prototype.getGeometry=function(){return this.parentGeom;};jsts.geomgraph.GeometryGraph.prototype.getBoundaryNodes=function(){if(this.boundaryNodes===null)
this.boundaryNodes=this.nodes.getBoundaryNodes(this.argIndex);return this.boundaryNodes;};jsts.geomgraph.GeometryGraph.prototype.getBoundaryNodeRule=function(){return this.boundaryNodeRule;};jsts.geomgraph.GeometryGraph.prototype.findEdge=function(line){return this.lineEdgeMap.get(line);};jsts.geomgraph.GeometryGraph.prototype.computeSplitEdges=function(edgelist){for(var i=this.edges.iterator();i.hasNext();){var e=i.next();e.eiList.addSplitEdges(edgelist);}}
jsts.geomgraph.GeometryGraph.prototype.add=function(g){if(g.isEmpty()){return;}
if(g instanceof jsts.geom.MultiPolygon)
this.useBoundaryDeterminationRule=false;if(g instanceof jsts.geom.Polygon)
this.addPolygon(g);else if(g instanceof jsts.geom.LineString)
this.addLineString(g);else if(g instanceof jsts.geom.Point)
this.addPoint(g);else if(g instanceof jsts.geom.MultiPoint)
this.addCollection(g);else if(g instanceof jsts.geom.MultiLineString)
this.addCollection(g);else if(g instanceof jsts.geom.MultiPolygon)
this.addCollection(g);else if(g instanceof jsts.geom.GeometryCollection)
this.addCollection(g);else
throw new jsts.error.IllegalArgumentError('Geometry type not supported.');};jsts.geomgraph.GeometryGraph.prototype.addCollection=function(gc){for(var i=0;i<gc.getNumGeometries();i++){var g=gc.getGeometryN(i);this.add(g);}};jsts.geomgraph.GeometryGraph.prototype.addEdge=function(e){this.insertEdge(e);var coord=e.getCoordinates();this.insertPoint(this.argIndex,coord[0],Location.BOUNDARY);this.insertPoint(this.argIndex,coord[coord.length-1],Location.BOUNDARY);};jsts.geomgraph.GeometryGraph.prototype.addPoint=function(p){var coord=p.getCoordinate();this.insertPoint(this.argIndex,coord,Location.INTERIOR);};jsts.geomgraph.GeometryGraph.prototype.addLineString=function(line){var coord=jsts.geom.CoordinateArrays.removeRepeatedPoints(line.getCoordinates());if(coord.length<2){this.hasTooFewPoints=true;this.invalidPoint=coords[0];return;}
var e=new jsts.geomgraph.Edge(coord,new jsts.geomgraph.Label(this.argIndex,Location.INTERIOR));this.lineEdgeMap.put(line,e);this.insertEdge(e);Assert.isTrue(coord.length>=2,'found LineString with single point');this.insertBoundaryPoint(this.argIndex,coord[0]);this.insertBoundaryPoint(this.argIndex,coord[coord.length-1]);};jsts.geomgraph.GeometryGraph.prototype.addPolygonRing=function(lr,cwLeft,cwRight){if(lr.isEmpty())
return;var coord=jsts.geom.CoordinateArrays.removeRepeatedPoints(lr.getCoordinates());if(coord.length<4){this.hasTooFewPoints=true;this.invalidPoint=coord[0];return;}
var left=cwLeft;var right=cwRight;if(jsts.algorithm.CGAlgorithms.isCCW(coord)){left=cwRight;right=cwLeft;}
var e=new jsts.geomgraph.Edge(coord,new jsts.geomgraph.Label(this.argIndex,Location.BOUNDARY,left,right));this.lineEdgeMap.put(lr,e);this.insertEdge(e);this.insertPoint(this.argIndex,coord[0],Location.BOUNDARY);};jsts.geomgraph.GeometryGraph.prototype.addPolygon=function(p){this.addPolygonRing(p.getExteriorRing(),Location.EXTERIOR,Location.INTERIOR);for(var i=0;i<p.getNumInteriorRing();i++){var hole=p.getInteriorRingN(i);this.addPolygonRing(hole,Location.INTERIOR,Location.EXTERIOR);}};jsts.geomgraph.GeometryGraph.prototype.computeEdgeIntersections=function(g,li,includeProper){var si=new jsts.geomgraph.index.SegmentIntersector(li,includeProper,true);si.setBoundaryNodes(this.getBoundaryNodes(),g.getBoundaryNodes());var esi=this.createEdgeSetIntersector();esi.computeIntersections(this.edges,g.edges,si);return si;};jsts.geomgraph.GeometryGraph.prototype.computeSelfNodes=function(li,computeRingSelfNodes){var si=new jsts.geomgraph.index.SegmentIntersector(li,true,false);var esi=this.createEdgeSetIntersector();if(!computeRingSelfNodes&&(this.parentGeom instanceof jsts.geom.LinearRing||this.parentGeom instanceof jsts.geom.Polygon||this.parentGeom instanceof jsts.geom.MultiPolygon)){esi.computeIntersections(this.edges,si,false);}else{esi.computeIntersections(this.edges,si,true);}
this.addSelfIntersectionNodes(this.argIndex);return si;};jsts.geomgraph.GeometryGraph.prototype.insertPoint=function(argIndex,coord,onLocation){var n=this.nodes.addNode(coord);var lbl=n.getLabel();if(lbl==null){n.label=new jsts.geomgraph.Label(argIndex,onLocation);}else
lbl.setLocation(argIndex,onLocation);};jsts.geomgraph.GeometryGraph.prototype.insertBoundaryPoint=function(argIndex,coord){var n=this.nodes.addNode(coord);var lbl=n.getLabel();var boundaryCount=1;var loc=Location.NONE;if(lbl!==null)
loc=lbl.getLocation(argIndex,Position.ON);if(loc===Location.BOUNDARY)
boundaryCount++;var newLoc=jsts.geomgraph.GeometryGraph.determineBoundary(this.boundaryNodeRule,boundaryCount);lbl.setLocation(argIndex,newLoc);};jsts.geomgraph.GeometryGraph.prototype.addSelfIntersectionNodes=function(argIndex){for(var i=this.edges.iterator();i.hasNext();){var e=i.next();var eLoc=e.getLabel().getLocation(argIndex);for(var eiIt=e.eiList.iterator();eiIt.hasNext();){var ei=eiIt.next();this.addSelfIntersectionNode(argIndex,ei.coord,eLoc);}}};jsts.geomgraph.GeometryGraph.prototype.addSelfIntersectionNode=function(argIndex,coord,loc){if(this.isBoundaryNode(argIndex,coord))
return;if(loc===Location.BOUNDARY&&this.useBoundaryDeterminationRule)
this.insertBoundaryPoint(argIndex,coord);else
this.insertPoint(argIndex,coord,loc);};jsts.geomgraph.GeometryGraph.prototype.getInvalidPoint=function(){return this.invalidPoint;};})();jsts.operation.buffer.OffsetSegmentString=function(){this.ptList=[];};jsts.operation.buffer.OffsetSegmentString.prototype.ptList=null;jsts.operation.buffer.OffsetSegmentString.prototype.precisionModel=null;jsts.operation.buffer.OffsetSegmentString.prototype.minimimVertexDistance=0.0;jsts.operation.buffer.OffsetSegmentString.prototype.setPrecisionModel=function(precisionModel){this.precisionModel=precisionModel;};jsts.operation.buffer.OffsetSegmentString.prototype.setMinimumVertexDistance=function(minimimVertexDistance){this.minimimVertexDistance=minimimVertexDistance;};jsts.operation.buffer.OffsetSegmentString.prototype.addPt=function(pt){var bufPt=new jsts.geom.Coordinate(pt);this.precisionModel.makePrecise(bufPt);if(this.isRedundant(bufPt))
return;this.ptList.push(bufPt);};jsts.operation.buffer.OffsetSegmentString.prototype.addPts=function(pt,isForward){if(isForward){for(var i=0;i<pt.length;i++){this.addPt(pt[i]);}}else{for(var i=pt.length-1;i>=0;i--){this.addPt(pt[i]);}}};jsts.operation.buffer.OffsetSegmentString.prototype.isRedundant=function(pt){if(this.ptList.length<1)
return false;var lastPt=this.ptList[this.ptList.length-1];var ptDist=pt.distance(lastPt);if(ptDist<this.minimimVertexDistance)
return true;return false;};jsts.operation.buffer.OffsetSegmentString.prototype.closeRing=function(){if(this.ptList.length<1)
return;var startPt=new jsts.geom.Coordinate(this.ptList[0]);var lastPt=this.ptList[this.ptList.length-1];var last2Pt=null;if(this.ptList.length>=2)
last2Pt=this.ptList[this.ptList.length-2];if(startPt.equals(lastPt))
return;this.ptList.push(startPt);};jsts.operation.buffer.OffsetSegmentString.prototype.reverse=function(){};jsts.operation.buffer.OffsetSegmentString.prototype.getCoordinates=function(){return this.ptList;};jsts.algorithm.distance.PointPairDistance=function(){this.pt=[new jsts.geom.Coordinate(),new jsts.geom.Coordinate()];};jsts.algorithm.distance.PointPairDistance.prototype.pt=null;jsts.algorithm.distance.PointPairDistance.prototype.distance=NaN;jsts.algorithm.distance.PointPairDistance.prototype.isNull=true;jsts.algorithm.distance.PointPairDistance.prototype.initialize=function(p0,p1,distance){if(p0===undefined){this.isNull=true;return;}
this.pt[0].setCoordinate(p0);this.pt[1].setCoordinate(p1);this.distance=distance!==undefined?distance:p0.distance(p1);this.isNull=false;};jsts.algorithm.distance.PointPairDistance.prototype.getDistance=function(){return this.distance;};jsts.algorithm.distance.PointPairDistance.prototype.getCoordinates=function(){return this.pt;};jsts.algorithm.distance.PointPairDistance.prototype.getCoordinate=function(i){return this.pt[i];};jsts.algorithm.distance.PointPairDistance.prototype.setMaximum=function(ptDist){if(arguments.length===2){this.setMaximum2.apply(this,arguments);return;}
this.setMaximum(ptDist.pt[0],ptDist.pt[1]);};jsts.algorithm.distance.PointPairDistance.prototype.setMaximum2=function(p0,p1){if(this.isNull){this.initialize(p0,p1);return;}
var dist=p0.distance(p1);if(dist>this.distance)
this.initialize(p0,p1,dist);};jsts.algorithm.distance.PointPairDistance.prototype.setMinimum=function(ptDist){if(arguments.length===2){this.setMinimum2.apply(this,arguments);return;}
this.setMinimum(ptDist.pt[0],ptDist.pt[1]);};jsts.algorithm.distance.PointPairDistance.prototype.setMinimum2=function(p0,p1){if(this.isNull){this.initialize(p0,p1);return;}
var dist=p0.distance(p1);if(dist<this.distance)
this.initialize(p0,p1,dist);};(function(){var PointPairDistance=jsts.algorithm.distance.PointPairDistance;var DistanceToPoint=jsts.algorithm.distance.DistanceToPoint;var MaxPointDistanceFilter=function(geom){this.maxPtDist=new PointPairDistance();this.minPtDist=new PointPairDistance();this.euclideanDist=new DistanceToPoint();this.geom=geom;};MaxPointDistanceFilter.prototype=new jsts.geom.CoordinateFilter();MaxPointDistanceFilter.prototype.maxPtDist=new PointPairDistance();MaxPointDistanceFilter.prototype.minPtDist=new PointPairDistance();MaxPointDistanceFilter.prototype.euclideanDist=new DistanceToPoint();MaxPointDistanceFilter.prototype.geom;MaxPointDistanceFilter.prototype.filter=function(pt){this.minPtDist.initialize();DistanceToPoint.computeDistance(this.geom,pt,this.minPtDist);this.maxPtDist.setMaximum(this.minPtDist);};MaxPointDistanceFilter.prototype.getMaxPointDistance=function(){return this.maxPtDist;};var MaxDensifiedByFractionDistanceFilter=function(geom,fraction){this.maxPtDist=new PointPairDistance();this.minPtDist=new PointPairDistance();this.geom=geom;this.numSubSegs=Math.round(1.0/fraction);};MaxDensifiedByFractionDistanceFilter.prototype=new jsts.geom.CoordinateSequenceFilter();MaxDensifiedByFractionDistanceFilter.prototype.maxPtDist=new PointPairDistance();MaxDensifiedByFractionDistanceFilter.prototype.minPtDist=new PointPairDistance();MaxDensifiedByFractionDistanceFilter.prototype.geom;MaxDensifiedByFractionDistanceFilter.prototype.numSubSegs=0;MaxDensifiedByFractionDistanceFilter.prototype.filter=function(seq,index){if(index==0)
return;var p0=seq[index-1];var p1=seq[index];var delx=(p1.x-p0.x)/this.numSubSegs;var dely=(p1.y-p0.y)/this.numSubSegs;for(var i=0;i<this.numSubSegs;i++){var x=p0.x+i*delx;var y=p0.y+i*dely;var pt=new jsts.geom.Coordinate(x,y);this.minPtDist.initialize();DistanceToPoint.computeDistance(this.geom,pt,this.minPtDist);this.maxPtDist.setMaximum(this.minPtDist);}};MaxDensifiedByFractionDistanceFilter.prototype.isGeometryChanged=function(){return false;};MaxDensifiedByFractionDistanceFilter.prototype.isDone=function(){return false;};MaxDensifiedByFractionDistanceFilter.prototype.getMaxPointDistance=function(){return this.maxPtDist;};jsts.algorithm.distance.DiscreteHausdorffDistance=function(g0,g1){this.g0=g0;this.g1=g1;this.ptDist=new jsts.algorithm.distance.PointPairDistance();};jsts.algorithm.distance.DiscreteHausdorffDistance.prototype.g0=null;jsts.algorithm.distance.DiscreteHausdorffDistance.prototype.g1=null;jsts.algorithm.distance.DiscreteHausdorffDistance.prototype.ptDist=null;jsts.algorithm.distance.DiscreteHausdorffDistance.prototype.densifyFrac=0.0;jsts.algorithm.distance.DiscreteHausdorffDistance.distance=function(g0,g1,densifyFrac){var dist=new jsts.algorithm.distance.DiscreteHausdorffDistance(g0,g1);if(densifyFrac!==undefined)
dist.setDensifyFraction(densifyFrac);return dist.distance();};jsts.algorithm.distance.DiscreteHausdorffDistance.prototype.setDensifyFraction=function(densifyFrac){if(densifyFrac>1.0||densifyFrac<=0.0)
throw new jsts.error.IllegalArgumentError('Fraction is not in range (0.0 - 1.0]');this.densifyFrac=densifyFrac;};jsts.algorithm.distance.DiscreteHausdorffDistance.prototype.distance=function(){this.compute(this.g0,this.g1);return ptDist.getDistance();};jsts.algorithm.distance.DiscreteHausdorffDistance.prototype.orientedDistance=function(){this.computeOrientedDistance(this.g0,this.g1,this.ptDist);return this.ptDist.getDistance();};jsts.algorithm.distance.DiscreteHausdorffDistance.prototype.getCoordinates=function(){return ptDist.getCoordinates();};jsts.algorithm.distance.DiscreteHausdorffDistance.prototype.compute=function(g0,g1){this.computeOrientedDistance(g0,g1,this.ptDist);this.computeOrientedDistance(g1,g0,this.ptDist);};jsts.algorithm.distance.DiscreteHausdorffDistance.prototype.computeOrientedDistance=function(discreteGeom,geom,ptDist){var distFilter=new MaxPointDistanceFilter(geom);discreteGeom.apply(distFilter);ptDist.setMaximum(distFilter.getMaxPointDistance());if(this.densifyFrac>0){var fracFilter=new MaxDensifiedByFractionDistanceFilter(geom,this.densifyFrac);discreteGeom.apply(fracFilter);ptDist.setMaximum(fracFilter.getMaxPointDistance());}};})();jsts.algorithm.MinimumBoundingCircle=function(geom){this.input=null;this.extremalPts=null;this.centre=null;this.radius=0;this.input=geom;};jsts.algorithm.MinimumBoundingCircle.prototype.getCircle=function(){this.compute();if(this.centre===null){return this.input.getFactory().createPolygon(null,null);}
var centrePoint=this.input.getFactory().createPoint(this.centre);if(this.radius===0){return centrePoint;}
return centrePoint.buffer(this.radius);};jsts.algorithm.MinimumBoundingCircle.prototype.getExtremalPoints=function(){this.compute();return this.extremalPts;};jsts.algorithm.MinimumBoundingCircle.prototype.getCentre=function(){this.compute();return this.centre;};jsts.algorithm.MinimumBoundingCircle.prototype.getRadius=function(){this.compute();return this.radius;};jsts.algorithm.MinimumBoundingCircle.prototype.computeCentre=function(){switch(this.extremalPts.length){case 0:this.centre=null;break;case 1:this.centre=this.extremalPts[0];break;case 2:this.centre=new jsts.geom.Coordinate((this.extremalPts[0].x+this.extremalPts[1].x)/2,(this.extremalPts[0].y+this.extremalPts[1].y)/2);break;case 3:this.centre=jsts.geom.Triangle.circumcentre(this.extremalPts[0],this.extremalPts[1],this.extremalPts[2]);break;}};jsts.algorithm.MinimumBoundingCircle.prototype.compute=function(){if(this.extremalPts!==null){return;}
this.computeCirclePoints();this.computeCentre();if(this.centre!==null){this.radius=this.centre.distance(this.extremalPts[0]);}};jsts.algorithm.MinimumBoundingCircle.prototype.computeCirclePoints=function(){if(this.input.isEmpty()){this.extremalPts=[];return;}
var pts;if(this.input.getNumPoints()===1){pts=this.input.getCoordinates();this.extremalPts=[new jsts.geom.Coordinate(pts[0])];return;}
var convexHull=this.input.convexHull();var hullPts=convexHull.getCoordinates();pts=hullPts;if(hullPts[0].equals2D(hullPts[hullPts.length-1])){pts=[];jsts.geom.CoordinateArrays.copyDeep(hullPts,0,pts,0,hullPts.length-1);}
if(pts.length<=2){this.extremalPts=jsts.geom.CoordinateArrays.copyDeep(pts);return;}
var P=jsts.algorithm.MinimumBoundingCircle.lowestPoint(pts);var Q=jsts.algorithm.MinimumBoundingCircle.pointWitMinAngleWithX(pts,P);for(var i=0;i<pts.length;i++){var R=jsts.algorithm.MinimumBoundingCircle.pointWithMinAngleWithSegment(pts,P,Q);if(jsts.algorithm.Angle.isObtuse(P,R,Q)){this.extremalPts=[new jsts.geom.Coordinate(P),new jsts.geom.Coordinate(Q)];return;}
if(jsts.algorithm.Angle.isObtuse(R,P,Q)){P=R;continue;}
if(jsts.algorithm.Angle.isObtuse(R,Q,P)){Q=R;continue;}
this.extremalPts=[new jsts.geom.Coordinate(P),new jsts.geom.Coordinate(Q),new jsts.geom.Coordinate(R)];return;}
throw new Error("Logic failure in Minimum Bounding Circle algorithm!");};jsts.algorithm.MinimumBoundingCircle.lowestPoint=function(pts){var min=pts[0];for(var i=1;i<pts.length;i++){if(pts[i].y<min.y){min=pts[i];}}
return min;};jsts.algorithm.MinimumBoundingCircle.pointWitMinAngleWithX=function(pts,P){var minSin=Number.MAX_VALUE;var minAngPt=null;for(var i=0;i<pts.length;i++){var p=pts[i];if(p===P)continue;var dx=p.x-P.x;var dy=p.y-P.y;if(dy<0)dy=-dy;var len=Math.sqrt(dx*dx+dy*dy);var sin=dy/len;if(sin<minSin){minSin=sin;minAngPt=p;}}
return minAngPt;};jsts.algorithm.MinimumBoundingCircle.pointWithMinAngleWithSegment=function(pts,P,Q){var minAng=Number.MAX_VALUE;var minAngPt=null;for(var i=0;i<pts.length;i++){var p=pts[i];if(p===P)continue;if(p===Q)continue;var ang=jsts.algorithm.Angle.angleBetween(P,p,Q);if(ang<minAng){minAng=ang;minAngPt=p;}}
return minAngPt;};jsts.noding.ScaledNoder=function(noder,scaleFactor,offsetX,offsetY){this.offsetX=offsetX?offsetX:0;this.offsetY=offsetY?offsetY:0;this.noder=noder;this.scaleFactor=scaleFactor;this.isScaled=!this.isIntegerPrecision();};jsts.noding.ScaledNoder.prototype=new jsts.noding.Noder();jsts.noding.ScaledNoder.constructor=jsts.noding.ScaledNoder;jsts.noding.ScaledNoder.prototype.noder=null;jsts.noding.ScaledNoder.prototype.scaleFactor=undefined;jsts.noding.ScaledNoder.prototype.offsetX=undefined;jsts.noding.ScaledNoder.prototype.offsetY=undefined;jsts.noding.ScaledNoder.prototype.isScaled=false;jsts.noding.ScaledNoder.prototype.isIntegerPrecision=function(){return this.scaleFactor===1.0;};jsts.noding.ScaledNoder.prototype.getNodedSubstrings=function(){var splitSS=this.noder.getNodedSubstrings();if(this.isScaled)
this.rescale(splitSS);return splitSS;};jsts.noding.ScaledNoder.prototype.computeNodes=function(inputSegStrings){var intSegStrings=inputSegStrings;if(this.isScaled)
intSegStrings=this.scale(inputSegStrings);this.noder.computeNodes(intSegStrings);};jsts.noding.ScaledNoder.prototype.scale=function(segStrings){if(segStrings instanceof Array){return this.scale2(segStrings);}
var transformed=new javascript.util.ArrayList();for(var i=segStrings.iterator();i.hasNext();){var ss=i.next();transformed.add(new jsts.noding.NodedSegmentString(this.scale(ss.getCoordinates()),ss.getData()));}
return transformed;};jsts.noding.ScaledNoder.prototype.scale2=function(pts){var roundPts=[];for(var i=0;i<pts.length;i++){roundPts[i]=new jsts.geom.Coordinate(Math.round((pts[i].x-this.offsetX)*this.scaleFactor),Math.round((pts[i].y-this.offsetY)*this.scaleFactor));}
var roundPtsNoDup=jsts.geom.CoordinateArrays.removeRepeatedPoints(roundPts);return roundPtsNoDup;};jsts.noding.ScaledNoder.prototype.rescale=function(segStrings){if(segStrings instanceof Array){this.rescale2(segStrings);return;}
for(var i=segStrings.iterator();i.hasNext();){var ss=i.next();this.rescale(ss.getCoordinates());}};jsts.noding.ScaledNoder.prototype.rescale2=function(pts){for(var i=0;i<pts.length;i++){pts[i].x=pts[i].x/this.scaleFactor+this.offsetX;pts[i].y=pts[i].y/this.scaleFactor+this.offsetY;}};(function(){var ArrayList=javascript.util.ArrayList;jsts.geomgraph.index.SegmentIntersector=function(li,includeProper,recordIsolated){this.li=li;this.includeProper=includeProper;this.recordIsolated=recordIsolated;};jsts.geomgraph.index.SegmentIntersector.isAdjacentSegments=function(i1,i2){return Math.abs(i1-i2)===1;};jsts.geomgraph.index.SegmentIntersector.prototype._hasIntersection=false;jsts.geomgraph.index.SegmentIntersector.prototype.hasProper=false;jsts.geomgraph.index.SegmentIntersector.prototype.hasProperInterior=false;jsts.geomgraph.index.SegmentIntersector.prototype.properIntersectionPoint=null;jsts.geomgraph.index.SegmentIntersector.prototype.li=null;jsts.geomgraph.index.SegmentIntersector.prototype.includeProper=null;jsts.geomgraph.index.SegmentIntersector.prototype.recordIsolated=null;jsts.geomgraph.index.SegmentIntersector.prototype.isSelfIntersection=null;jsts.geomgraph.index.SegmentIntersector.prototype.numIntersections=0;jsts.geomgraph.index.SegmentIntersector.prototype.numTests=0;jsts.geomgraph.index.SegmentIntersector.prototype.bdyNodes=null;jsts.geomgraph.index.SegmentIntersector.prototype.setBoundaryNodes=function(bdyNodes0,bdyNodes1){this.bdyNodes=[];this.bdyNodes[0]=bdyNodes0;this.bdyNodes[1]=bdyNodes1;};jsts.geomgraph.index.SegmentIntersector.prototype.getProperIntersectionPoint=function(){return this.properIntersectionPoint;};jsts.geomgraph.index.SegmentIntersector.prototype.hasIntersection=function(){return this._hasIntersection;};jsts.geomgraph.index.SegmentIntersector.prototype.hasProperIntersection=function(){return this.hasProper;};jsts.geomgraph.index.SegmentIntersector.prototype.hasProperInteriorIntersection=function(){return this.hasProperInterior;};jsts.geomgraph.index.SegmentIntersector.prototype.isTrivialIntersection=function(e0,segIndex0,e1,segIndex1){if(e0===e1){if(this.li.getIntersectionNum()===1){if(jsts.geomgraph.index.SegmentIntersector.isAdjacentSegments(segIndex0,segIndex1))
return true;if(e0.isClosed()){var maxSegIndex=e0.getNumPoints()-1;if((segIndex0===0&&segIndex1===maxSegIndex)||(segIndex1===0&&segIndex0===maxSegIndex)){return true;}}}}
return false;};jsts.geomgraph.index.SegmentIntersector.prototype.addIntersections=function(e0,segIndex0,e1,segIndex1){if(e0===e1&&segIndex0===segIndex1)
return;this.numTests++;var p00=e0.getCoordinates()[segIndex0];var p01=e0.getCoordinates()[segIndex0+1];var p10=e1.getCoordinates()[segIndex1];var p11=e1.getCoordinates()[segIndex1+1];this.li.computeIntersection(p00,p01,p10,p11);if(this.li.hasIntersection()){if(this.recordIsolated){e0.setIsolated(false);e1.setIsolated(false);}
this.numIntersections++;if(!this.isTrivialIntersection(e0,segIndex0,e1,segIndex1)){this._hasIntersection=true;if(this.includeProper||!this.li.isProper()){e0.addIntersections(this.li,segIndex0,0);e1.addIntersections(this.li,segIndex1,1);}
if(this.li.isProper()){this.properIntersectionPoint=this.li.getIntersection(0).clone();this.hasProper=true;if(!this.isBoundaryPoint(this.li,this.bdyNodes))
this.hasProperInterior=true;}}}};jsts.geomgraph.index.SegmentIntersector.prototype.isBoundaryPoint=function(li,bdyNodes){if(bdyNodes===null)
return false;if(bdyNodes instanceof Array){if(this.isBoundaryPoint(li,bdyNodes[0]))
return true;if(this.isBoundaryPoint(li,bdyNodes[1]))
return true;return false;}else{for(var i=bdyNodes.iterator();i.hasNext();){var node=i.next();var pt=node.getCoordinate();if(li.isIntersection(pt))
return true;}
return false;}};})();
},{}],73:[function(require,module,exports){
(function (global){
/*
  javascript.util is a port of selected parts of java.util to JavaScript which
  main purpose is to ease porting Java code to JavaScript.
  
  The MIT License (MIT)

  Copyright (C) 2011-2014 by The Authors

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
*/
;(function(){var e=this;function f(a,b){var c=a.split("."),d=e;c[0]in d||!d.execScript||d.execScript("var "+c[0]);for(var t;c.length&&(t=c.shift());)c.length||void 0===b?d=d[t]?d[t]:d[t]={}:d[t]=b}function g(a,b){function c(){}c.prototype=b.prototype;a.q=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.p=function(a,c,O){var M=Array.prototype.slice.call(arguments,2);return b.prototype[c].apply(a,M)}};function h(a){this.message=a||""}g(h,Error);f("javascript.util.EmptyStackException",h);h.prototype.name="EmptyStackException";function k(a){this.message=a||""}g(k,Error);f("javascript.util.IndexOutOfBoundsException",k);k.prototype.name="IndexOutOfBoundsException";function l(){}f("javascript.util.Iterator",l);l.prototype.hasNext=l.prototype.c;l.prototype.next=l.prototype.next;l.prototype.remove=l.prototype.remove;function m(){}f("javascript.util.Collection",m);function n(){}g(n,m);f("javascript.util.List",n);function p(){}f("javascript.util.Map",p);function q(a){this.message=a||""}g(q,Error);f("javascript.util.NoSuchElementException",q);q.prototype.name="NoSuchElementException";function r(a){this.message=a||""}g(r,Error);r.prototype.name="OperationNotSupported";function s(a){this.a=[];a instanceof m&&this.e(a)}g(s,n);f("javascript.util.ArrayList",s);s.prototype.a=null;s.prototype.add=function(a){this.a.push(a);return!0};s.prototype.add=s.prototype.add;s.prototype.e=function(a){for(a=a.f();a.c();)this.add(a.next());return!0};s.prototype.addAll=s.prototype.e;s.prototype.set=function(a,b){var c=this.a[a];this.a[a]=b;return c};s.prototype.set=s.prototype.set;s.prototype.f=function(){return new u(this)};s.prototype.iterator=s.prototype.f;
s.prototype.get=function(a){if(0>a||a>=this.size())throw new k;return this.a[a]};s.prototype.get=s.prototype.get;s.prototype.g=function(){return 0===this.a.length};s.prototype.isEmpty=s.prototype.g;s.prototype.size=function(){return this.a.length};s.prototype.size=s.prototype.size;s.prototype.h=function(){for(var a=[],b=0,c=this.a.length;b<c;b++)a.push(this.a[b]);return a};s.prototype.toArray=s.prototype.h;
s.prototype.remove=function(a){for(var b=!1,c=0,d=this.a.length;c<d;c++)if(this.a[c]===a){this.a.splice(c,1);b=!0;break}return b};s.prototype.remove=s.prototype.remove;function u(a){this.j=a}f("$jscomp.scope.Iterator_",u);u.prototype.j=null;u.prototype.b=0;u.prototype.next=function(){if(this.b===this.j.size())throw new q;return this.j.get(this.b++)};u.prototype.next=u.prototype.next;u.prototype.c=function(){return this.b<this.j.size()?!0:!1};u.prototype.hasNext=u.prototype.c;
u.prototype.remove=function(){throw new r;};u.prototype.remove=u.prototype.remove;function v(){}f("javascript.util.Arrays",v);
v.sort=function(){var a=arguments[0],b,c,d;if(1===arguments.length)a.sort();else if(2===arguments.length)c=arguments[1],d=function(a,b){return c.compare(a,b)},a.sort(d);else if(3===arguments.length)for(b=a.slice(arguments[1],arguments[2]),b.sort(),d=a.slice(0,arguments[1]).concat(b,a.slice(arguments[2],a.length)),a.splice(0,a.length),b=0;b<d.length;b++)a.push(d[b]);else if(4===arguments.length)for(b=a.slice(arguments[1],arguments[2]),c=arguments[3],d=function(a,b){return c.compare(a,b)},b.sort(d),
d=a.slice(0,arguments[1]).concat(b,a.slice(arguments[2],a.length)),a.splice(0,a.length),b=0;b<d.length;b++)a.push(d[b])};v.asList=function(a){for(var b=new s,c=0,d=a.length;c<d;c++)b.add(a[c]);return b};function w(){this.i={}}g(w,p);f("javascript.util.HashMap",w);w.prototype.i=null;w.prototype.get=function(a){return this.i[a]||null};w.prototype.get=w.prototype.get;w.prototype.put=function(a,b){return this.i[a]=b};w.prototype.put=w.prototype.put;w.prototype.m=function(){var a=new s,b;for(b in this.i)this.i.hasOwnProperty(b)&&a.add(this.i[b]);return a};w.prototype.values=w.prototype.m;w.prototype.size=function(){return this.m().size()};w.prototype.size=w.prototype.size;function x(){}g(x,m);f("javascript.util.Set",x);function y(a){this.a=[];a instanceof m&&this.e(a)}g(y,x);f("javascript.util.HashSet",y);y.prototype.a=null;y.prototype.contains=function(a){for(var b=0,c=this.a.length;b<c;b++)if(this.a[b]===a)return!0;return!1};y.prototype.contains=y.prototype.contains;y.prototype.add=function(a){if(this.contains(a))return!1;this.a.push(a);return!0};y.prototype.add=y.prototype.add;y.prototype.e=function(a){for(a=a.f();a.c();)this.add(a.next());return!0};y.prototype.addAll=y.prototype.e;
y.prototype.remove=function(){throw new r;};y.prototype.remove=y.prototype.remove;y.prototype.size=function(){return this.a.length};y.prototype.g=function(){return 0===this.a.length};y.prototype.isEmpty=y.prototype.g;y.prototype.h=function(){for(var a=[],b=0,c=this.a.length;b<c;b++)a.push(this.a[b]);return a};y.prototype.toArray=y.prototype.h;y.prototype.f=function(){return new z(this)};y.prototype.iterator=y.prototype.f;function z(a){this.k=a}f("$jscomp.scope.Iterator_$1",z);z.prototype.k=null;
z.prototype.b=0;z.prototype.next=function(){if(this.b===this.k.size())throw new q;return this.k.a[this.b++]};z.prototype.next=z.prototype.next;z.prototype.c=function(){return this.b<this.k.size()?!0:!1};z.prototype.hasNext=z.prototype.c;z.prototype.remove=function(){throw new r;};z.prototype.remove=z.prototype.remove;function A(){}g(A,p);f("javascript.util.SortedMap",A);function B(){}g(B,x);f("javascript.util.SortedSet",B);function C(){this.a=[]}g(C,n);f("javascript.util.Stack",C);C.prototype.a=null;C.prototype.push=function(a){this.a.push(a);return a};C.prototype.push=C.prototype.push;C.prototype.pop=function(){if(0===this.a.length)throw new h;return this.a.pop()};C.prototype.pop=C.prototype.pop;C.prototype.o=function(){if(0===this.a.length)throw new h;return this.a[this.a.length-1]};C.prototype.peek=C.prototype.o;C.prototype.empty=function(){return 0===this.a.length?!0:!1};C.prototype.empty=C.prototype.empty;
C.prototype.g=function(){return this.empty()};C.prototype.isEmpty=C.prototype.g;C.prototype.search=function(a){return this.a.indexOf(a)};C.prototype.search=C.prototype.search;C.prototype.size=function(){return this.a.length};C.prototype.size=C.prototype.size;C.prototype.h=function(){for(var a=[],b=0,c=this.a.length;b<c;b++)a.push(this.a[b]);return a};C.prototype.toArray=C.prototype.h;function D(a){return null==a?null:a.parent}function E(a,b){null!==a&&(a.color=b)}function F(a){return null==a?null:a.left}function G(a){return null==a?null:a.right}function H(){this.d=null;this.n=0}g(H,A);f("javascript.util.TreeMap",H);H.prototype.get=function(a){for(var b=this.d;null!==b;){var c=a.compareTo(b.key);if(0>c)b=b.left;else if(0<c)b=b.right;else return b.value}return null};H.prototype.get=H.prototype.get;
H.prototype.put=function(a,b){if(null===this.d)return this.d={key:a,value:b,left:null,right:null,parent:null,color:0},this.n=1,null;var c=this.d,d,t;do if(d=c,t=a.compareTo(c.key),0>t)c=c.left;else if(0<t)c=c.right;else return d=c.value,c.value=b,d;while(null!==c);c={key:a,left:null,right:null,value:b,parent:d,color:0};0>t?d.left=c:d.right=c;for(c.color=1;null!=c&&c!=this.d&&1==c.parent.color;)D(c)==F(D(D(c)))?(d=G(D(D(c))),1==(null==d?0:d.color)?(E(D(c),0),E(d,0),E(D(D(c)),1),c=D(D(c))):(c==G(D(c))&&
(c=D(c),I(this,c)),E(D(c),0),E(D(D(c)),1),J(this,D(D(c))))):(d=F(D(D(c))),1==(null==d?0:d.color)?(E(D(c),0),E(d,0),E(D(D(c)),1),c=D(D(c))):(c==F(D(c))&&(c=D(c),J(this,c)),E(D(c),0),E(D(D(c)),1),I(this,D(D(c)))));this.d.color=0;this.n++;return null};H.prototype.put=H.prototype.put;H.prototype.m=function(){var a=new s,b;b=this.d;if(null!=b)for(;null!=b.left;)b=b.left;if(null!==b)for(a.add(b.value);null!==(b=K(b));)a.add(b.value);return a};H.prototype.values=H.prototype.m;
function I(a,b){if(null!=b){var c=b.right;b.right=c.left;null!=c.left&&(c.left.parent=b);c.parent=b.parent;null==b.parent?a.d=c:b.parent.left==b?b.parent.left=c:b.parent.right=c;c.left=b;b.parent=c}}function J(a,b){if(null!=b){var c=b.left;b.left=c.right;null!=c.right&&(c.right.parent=b);c.parent=b.parent;null==b.parent?a.d=c:b.parent.right==b?b.parent.right=c:b.parent.left=c;c.right=b;b.parent=c}}
function K(a){if(null===a)return null;if(null!==a.right)for(var b=a.right;null!==b.left;)b=b.left;else for(b=a.parent;null!==b&&a===b.right;)a=b,b=b.parent;return b}H.prototype.size=function(){return this.n};H.prototype.size=H.prototype.size;function L(a){this.a=[];a instanceof m&&this.e(a)}g(L,B);f("javascript.util.TreeSet",L);L.prototype.a=null;L.prototype.contains=function(a){for(var b=0,c=this.a.length;b<c;b++)if(0===this.a[b].compareTo(a))return!0;return!1};L.prototype.contains=L.prototype.contains;L.prototype.add=function(a){if(this.contains(a))return!1;for(var b=0,c=this.a.length;b<c;b++)if(1===this.a[b].compareTo(a))return this.a.splice(b,0,a),!0;this.a.push(a);return!0};L.prototype.add=L.prototype.add;
L.prototype.e=function(a){for(a=a.f();a.c();)this.add(a.next());return!0};L.prototype.addAll=L.prototype.e;L.prototype.remove=function(){throw new r;};L.prototype.remove=L.prototype.remove;L.prototype.size=function(){return this.a.length};L.prototype.size=L.prototype.size;L.prototype.g=function(){return 0===this.a.length};L.prototype.isEmpty=L.prototype.g;L.prototype.h=function(){for(var a=[],b=0,c=this.a.length;b<c;b++)a.push(this.a[b]);return a};L.prototype.toArray=L.prototype.h;L.prototype.f=function(){return new N(this)};
L.prototype.iterator=L.prototype.f;function N(a){this.l=a}f("$jscomp.scope.Iterator_$2",N);N.prototype.l=null;N.prototype.b=0;N.prototype.next=function(){if(this.b===this.l.size())throw new q;return this.l.a[this.b++]};N.prototype.next=N.prototype.next;N.prototype.c=function(){return this.b<this.l.size()?!0:!1};N.prototype.hasNext=N.prototype.c;N.prototype.remove=function(){throw new r;};N.prototype.remove=N.prototype.remove;"undefined"!==typeof global&&(global.javascript={},global.javascript.util={},global.javascript.util.ArrayList=s,global.javascript.util.Arrays=v,global.javascript.util.Collection=m,global.javascript.util.EmptyStackException=h,global.javascript.util.HashMap=w,global.javascript.util.HashSet=y,global.javascript.util.IndexOutOfBoundsException=k,global.javascript.util.Iterator=l,global.javascript.util.List=n,global.javascript.util.Map=p,global.javascript.util.NoSuchElementException=q,global.javascript.util.OperationNotSupported=
r,global.javascript.util.Set=x,global.javascript.util.SortedMap=A,global.javascript.util.SortedSet=B,global.javascript.util.Stack=C,global.javascript.util.TreeMap=H,global.javascript.util.TreeSet=L);}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],74:[function(require,module,exports){
require('./dist/javascript.util-node.min.js');

},{"./dist/javascript.util-node.min.js":73}],75:[function(require,module,exports){
var extent = require('turf-extent'),
    point = require('turf-point');

/**
 * Takes a {@link FeatureCollection} of any type and returns the absolute center point of all features.
 *
 * @module turf/center
 * @category measurement
 * @param {FeatureCollection} features a FeatureCollection of any type
 * @return {Point} a Point feature at the
 * absolute center point of all input features
 * @example
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.522259, 35.4691]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.502754, 35.463455]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.508269, 35.463245]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.516809, 35.465779]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.515372, 35.467072]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.509363, 35.463053]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.511123, 35.466601]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.518547, 35.469327]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.519706, 35.469659]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.517839, 35.466998]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.508678, 35.464942]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.514914, 35.463453]
 *       }
 *     }
 *   ]
 * };
 *
 * var centerPt = turf.center(features);
 * centerPt.properties['marker-size'] = 'large';
 * centerPt.properties['marker-color'] = '#000';
 *
 * var resultFeatures = features.features.concat(centerPt);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */

module.exports = function(layer, done){
  var ext = extent(layer);
  var x = (ext[0] + ext[2])/2;
  var y = (ext[1] + ext[3])/2;
  return point([x, y]);
};

},{"turf-extent":124,"turf-point":156}],76:[function(require,module,exports){
var each = require('turf-meta').coordEach;
var point = require('turf-point');

/**
 * Takes a {@link Feature} or {@link FeatureCollection} of any type and calculates the centroid using the arithmetic mean of all vertices.
 * This lessens the effect of small islands and artifacts when calculating
 * the centroid of a set of polygons.
 *
 * @module turf/centroid
 * @category measurement
 * @param {GeoJSON} features a {@link Feature} or FeatureCollection of any type
 * @return {Point} a Point feature at the centroid of the input feature(s)
 * @example
 * var poly = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [105.818939,21.004714],
 *       [105.818939,21.061754],
 *       [105.890007,21.061754],
 *       [105.890007,21.004714],
 *       [105.818939,21.004714]
 *     ]]
 *   }
 * };
 *
 * var centroidPt = turf.centroid(poly);
 *
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": [poly, centroidPt]
 * };
 *
 * //=result
 */
module.exports = function(features){
  var xSum = 0, ySum = 0, len = 0;
  each(features, function(coord) {
    xSum += coord[0];
    ySum += coord[1];
    len++;
  }, true);
  return point([xSum / len, ySum / len]);
};

},{"turf-meta":77,"turf-point":156}],77:[function(require,module,exports){
/**
 * Lazily iterate over coordinates in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (value)
 * @param {boolean=} excludeWrapCoord whether or not to include
 * the final coordinate of LinearRings that wraps the ring in its iteration.
 * @example
 * var point = { type: 'Point', coordinates: [0, 0] };
 * coordEach(point, function(coords) {
 *   // coords is equal to [0, 0]
 * });
 */
function coordEach(layer, callback, excludeWrapCoord) {
  var i, j, k, g, geometry, stopG, coords,
    geometryMaybeCollection,
    wrapShrink = 0,
    isGeometryCollection,
    isFeatureCollection = layer.type === 'FeatureCollection',
    isFeature = layer.type === 'Feature',
    stop = isFeatureCollection ? layer.features.length : 1;

  // This logic may look a little weird. The reason why it is that way
  // is because it's trying to be fast. GeoJSON supports multiple kinds
  // of objects at its root: FeatureCollection, Features, Geometries.
  // This function has the responsibility of handling all of them, and that
  // means that some of the `for` loops you see below actually just don't apply
  // to certain inputs. For instance, if you give this just a
  // Point geometry, then both loops are short-circuited and all we do
  // is gradually rename the input until it's called 'geometry'.
  //
  // This also aims to allocate as few resources as possible: just a
  // few numbers and booleans, rather than any temporary arrays as would
  // be required with the normalization approach.
  for (i = 0; i < stop; i++) {

    geometryMaybeCollection = (isFeatureCollection ? layer.features[i].geometry :
        (isFeature ? layer.geometry : layer));
    isGeometryCollection = geometryMaybeCollection.type === 'GeometryCollection';
    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

    for (g = 0; g < stopG; g++) {

      geometry = isGeometryCollection ?
          geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
      coords = geometry.coordinates;

      wrapShrink = (excludeWrapCoord &&
        (geometry.type === 'Polygon' || geometry.type === 'MultiPolygon')) ?
        1 : 0;

      if (geometry.type === 'Point') {
        callback(coords);
      } else if (geometry.type === 'LineString' || geometry.type === 'MultiPoint') {
        for (j = 0; j < coords.length; j++) callback(coords[j]);
      } else if (geometry.type === 'Polygon' || geometry.type === 'MultiLineString') {
        for (j = 0; j < coords.length; j++)
          for (k = 0; k < coords[j].length - wrapShrink; k++)
            callback(coords[j][k]);
      } else if (geometry.type === 'MultiPolygon') {
        for (j = 0; j < coords.length; j++)
          for (k = 0; k < coords[j].length; k++)
            for (l = 0; l < coords[j][k].length - wrapShrink; l++)
              callback(coords[j][k][l]);
      } else {
        throw new Error('Unknown Geometry Type');
      }
    }
  }
}
module.exports.coordEach = coordEach;

/**
 * Lazily reduce coordinates in any GeoJSON object into a single value,
 * similar to how Array.reduce works. However, in this case we lazily run
 * the reduction, so an array of all coordinates is unnecessary.
 *
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (memo, value) and returns
 * a new memo
 * @param {boolean=} excludeWrapCoord whether or not to include
 * the final coordinate of LinearRings that wraps the ring in its iteration.
 * @param {*} memo the starting value of memo: can be any type.
 */
function coordReduce(layer, callback, memo, excludeWrapCoord) {
  coordEach(layer, function(coord) {
    memo = callback(memo, coord);
  }, excludeWrapCoord);
  return memo;
}
module.exports.coordReduce = coordReduce;

/**
 * Lazily iterate over property objects in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (value)
 * @example
 * var point = { type: 'Feature', geometry: null, properties: { foo: 1 } };
 * propEach(point, function(props) {
 *   // props is equal to { foo: 1}
 * });
 */
function propEach(layer, callback) {
  var i;
  switch (layer.type) {
      case 'FeatureCollection':
        features = layer.features;
        for (i = 0; i < layer.features.length; i++) {
            callback(layer.features[i].properties);
        }
        break;
      case 'Feature':
        callback(layer.properties);
        break;
  }
}
module.exports.propEach = propEach;

/**
 * Lazily reduce properties in any GeoJSON object into a single value,
 * similar to how Array.reduce works. However, in this case we lazily run
 * the reduction, so an array of all properties is unnecessary.
 *
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (memo, coord) and returns
 * a new memo
 * @param {*} memo the starting value of memo: can be any type.
 */
function propReduce(layer, callback, memo) {
  propEach(layer, function(prop) {
    memo = callback(memo, prop);
  });
  return memo;
}
module.exports.propReduce = propReduce;

},{}],78:[function(require,module,exports){
/**
 * Combines a {@link FeatureCollection} of {@link Point}, {@link LineString}, or {@link Polygon} features into {@link MultiPoint}, {@link MultiLineString}, or {@link MultiPolygon} features.
 *
 * @module turf/combine
 * @category misc
 * @param {FeatureCollection} fc a FeatureCollection of any type
 * @return {FeatureCollection} a FeatureCollection of corresponding type to input
 * @example
 * var fc = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [19.026432, 47.49134]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [19.074497, 47.509548]
 *       }
 *     }
 *   ]
 * };
 *
 * var combined = turf.combine(fc);
 *
 * //=combined
 */

module.exports = function(fc) {
  var type = fc.features[0].geometry.type;
  var geometries = fc.features.map(function(f) {
    return f.geometry;
  });

  switch (type) {
    case 'Point':
      return {
        type: 'Feature',
        properties: {},
        geometry: {
          type: 'MultiPoint',
          coordinates: pluckCoods(geometries)
        }
      };
    case 'LineString':
      return {
        type: 'Feature',
        properties: {},
        geometry: {
          type: 'MultiLineString',
          coordinates: pluckCoods(geometries)
        }
      };
    case 'Polygon':
      return {
        type: 'Feature',
        properties: {},
        geometry: {
          type: 'MultiPolygon',
          coordinates: pluckCoods(geometries)
        }
      };
    default:
      return fc;
  }
};

function pluckCoods(multi){
  return multi.map(function(geom){
    return geom.coordinates;
  });
}

},{}],79:[function(require,module,exports){
// 1. run tin on points
// 2. calculate lenth of all edges and area of all triangles
// 3. remove triangles that fail the max length test
// 4. buffer the results slightly
// 5. merge the results
var t = {};
t.tin = require('turf-tin');
t.merge = require('turf-merge');
t.distance = require('turf-distance');
t.point = require('turf-point');

/**
 * Takes a {@link FeatureCollection} of {@link Point} features and
 * returns a concave hull.
 *
 * Internally, this implements
 * a [Monotone chain algorithm](http://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain#JavaScript).
 *
 * @module turf/concave
 * @category transformation
 * @param {FeatureCollection} points a FeatureCollection of {@link Point} features
 * @param {number} maxEdge the size of an edge necessary for part of the
 * hull to become concave (in miles)
 * @param {String} units used for maxEdge distance (miles or kilometers)
 * @returns {Feature} a {@link Polygon} feature
 * @throws {Error} if maxEdge parameter is missing
 * @example
 * var points = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-63.601226, 44.642643]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-63.591442, 44.651436]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-63.580799, 44.648749]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-63.573589, 44.641788]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-63.587665, 44.64533]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-63.595218, 44.64765]
 *       }
 *     }
 *   ]
 * };
 *
 * var hull = turf.concave(points, 1, 'miles');
 *
 * var resultFeatures = points.features.concat(hull);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */


module.exports = function(points, maxEdge, units) {
  if (typeof maxEdge !== 'number') throw new Error('maxEdge parameter is required');
  if (typeof units !== 'string') throw new Error('units parameter is required');

  var tinPolys = t.tin(points);
  var filteredPolys = tinPolys.features.filter(filterTriangles);
  tinPolys.features = filteredPolys;

  function filterTriangles(triangle) {
    var pt1 = t.point(triangle.geometry.coordinates[0][0]);
    var pt2 = t.point(triangle.geometry.coordinates[0][1]);
    var pt3 = t.point(triangle.geometry.coordinates[0][2]);
    var dist1 = t.distance(pt1, pt2, units);
    var dist2 = t.distance(pt2, pt3, units);
    var dist3 = t.distance(pt1, pt3, units);
    return (dist1 <= maxEdge && dist2 <= maxEdge && dist3 <= maxEdge);
  }

  return t.merge(tinPolys);
};

},{"turf-distance":114,"turf-merge":147,"turf-point":156,"turf-tin":172}],80:[function(require,module,exports){
var each = require('turf-meta').coordEach,
    convexHull = require('convex-hull'),
    polygon = require('turf-polygon');

/**
 * Takes any {@link GeoJSON} object and returns a
 * [convex hull](http://en.wikipedia.org/wiki/Convex_hull) polygon.
 *
 * Internally this uses
 * the [convex-hull](https://github.com/mikolalysenko/convex-hull) module that
 * implements a [monotone chain hull](http://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain).
 *
 * @module turf/convex
 * @category transformation
 * @param {GeoJSON} input any GeoJSON object
 * @returns {Feature} a {@link Polygon} feature
 * @example
 * var points = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [10.195312, 43.755225]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [10.404052, 43.8424511]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [10.579833, 43.659924]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [10.360107, 43.516688]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [10.14038, 43.588348]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [10.195312, 43.755225]
 *       }
 *     }
 *   ]
 * };
 *
 * var hull = turf.convex(points);
 *
 * var resultFeatures = points.features.concat(hull);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */
module.exports = function(fc) {
  var points = [];
  each(fc, function(coord) { points.push(coord); });
  var hull = convexHull(points);
  var ring = [];
  for (var i = 0; i < hull.length; i++) {
      ring.push(points[hull[i][0]]);
  }
  ring.push(points[hull[hull.length - 1][1]]);
  return polygon([ring]);
};

},{"convex-hull":81,"turf-meta":109,"turf-polygon":157}],81:[function(require,module,exports){
"use strict"

var convexHull1d = require('./lib/ch1d')
var convexHull2d = require('./lib/ch2d')
var convexHullnd = require('./lib/chnd')

module.exports = convexHull

function convexHull(points) {
  var n = points.length
  if(n === 0) {
    return []
  } else if(n === 1) {
    return [[0]]
  }
  var d = points[0].length
  if(d === 0) {
    return []
  } else if(d === 1) {
    return convexHull1d(points)
  } else if(d === 2) {
    return convexHull2d(points)
  }
  return convexHullnd(points, d)
}
},{"./lib/ch1d":82,"./lib/ch2d":83,"./lib/chnd":84}],82:[function(require,module,exports){
"use strict"

module.exports = convexHull1d

function convexHull1d(points) {
  var lo = 0
  var hi = 0
  for(var i=1; i<points.length; ++i) {
    if(points[i][0] < points[lo][0]) {
      lo = i
    }
    if(points[i][0] > points[hi][0]) {
      hi = i
    }
  }
  if(lo < hi) {
    return [[lo], [hi]]
  } else if(lo > hi) {
    return [[hi], [lo]]
  } else {
    return [[lo]]
  }
}
},{}],83:[function(require,module,exports){
'use strict'

module.exports = convexHull2D

var monotoneHull = require('monotone-convex-hull-2d')

function convexHull2D(points) {
  var hull = monotoneHull(points)
  var h = hull.length
  if(h <= 2) {
    return []
  }
  var edges = new Array(h)
  var a = hull[h-1]
  for(var i=0; i<h; ++i) {
    var b = hull[i]
    edges[i] = [a,b]
    a = b
  }
  return edges
}

},{"monotone-convex-hull-2d":102}],84:[function(require,module,exports){
'use strict'

module.exports = convexHullnD

var ich = require('incremental-convex-hull')
var aff = require('affine-hull')

function permute(points, front) {
  var n = points.length
  var npoints = new Array(n)
  for(var i=0; i<front.length; ++i) {
    npoints[i] = points[front[i]]
  }
  var ptr = front.length
  for(var i=0; i<n; ++i) {
    if(front.indexOf(i) < 0) {
      npoints[ptr++] = points[i]
    }
  }
  return npoints
}

function invPermute(cells, front) {
  var nc = cells.length
  var nf = front.length
  for(var i=0; i<nc; ++i) {
    var c = cells[i]
    for(var j=0; j<c.length; ++j) {
      var x = c[j]
      if(x < nf) {
        c[j] = front[x]
      } else {
        x = x - nf
        for(var k=0; k<nf; ++k) {
          if(x >= front[k]) {
            x += 1
          }
        }
        c[j] = x
      }
    }
  }
  return cells
}

function convexHullnD(points, d) {
  try {
    return ich(points, true)
  } catch(e) {
    //If point set is degenerate, try to find a basis and rerun it
    var ah = aff(points)
    if(ah.length <= d) {
      //No basis, no try
      return []
    }
    var npoints = permute(points, ah)
    var nhull   = ich(npoints, true)
    return invPermute(nhull, ah)
  }
}
},{"affine-hull":85,"incremental-convex-hull":92}],85:[function(require,module,exports){
'use strict'

module.exports = affineHull

var orient = require('robust-orientation')

function linearlyIndependent(points, d) {
  var nhull = new Array(d+1)
  for(var i=0; i<points.length; ++i) {
    nhull[i] = points[i]
  }
  for(var i=0; i<=points.length; ++i) {
    for(var j=points.length; j<=d; ++j) {
      var x = new Array(d)
      for(var k=0; k<d; ++k) {
        x[k] = Math.pow(j+1-i, k)
      }
      nhull[j] = x
    }
    var o = orient.apply(void 0, nhull)
    if(o) {
      return true
    }
  }
  return false
}

function affineHull(points) {
  var n = points.length
  if(n === 0) {
    return []
  }
  if(n === 1) {
    return [0]
  }
  var d = points[0].length
  var frame = [ points[0] ]
  var index = [ 0 ]
  for(var i=1; i<n; ++i) {
    frame.push(points[i])
    if(!linearlyIndependent(frame, d)) {
      frame.pop()
      continue
    }
    index.push(i)
    if(index.length === d+1) {
      return index
    }
  }
  return index
}
},{"robust-orientation":91}],86:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"dup":31}],87:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32,"two-product":90,"two-sum":86}],88:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],89:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],90:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],91:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"dup":36,"robust-scale":87,"robust-subtract":88,"robust-sum":89,"two-product":90}],92:[function(require,module,exports){
"use strict"

//High level idea:
// 1. Use Clarkson's incremental construction to find convex hull
// 2. Point location in triangulation by jump and walk

module.exports = incrementalConvexHull

var orient = require("robust-orientation")
var compareCell = require("simplicial-complex").compareCells

function compareInt(a, b) {
  return a - b
}

function Simplex(vertices, adjacent, boundary) {
  this.vertices = vertices
  this.adjacent = adjacent
  this.boundary = boundary
  this.lastVisited = -1
}

Simplex.prototype.flip = function() {
  var t = this.vertices[0]
  this.vertices[0] = this.vertices[1]
  this.vertices[1] = t
  var u = this.adjacent[0]
  this.adjacent[0] = this.adjacent[1]
  this.adjacent[1] = u
}

function GlueFacet(vertices, cell, index) {
  this.vertices = vertices
  this.cell = cell
  this.index = index
}

function compareGlue(a, b) {
  return compareCell(a.vertices, b.vertices)
}

function bakeOrient(d) {
  var code = ["function orient(){var tuple=this.tuple;return test("]
  for(var i=0; i<=d; ++i) {
    if(i > 0) {
      code.push(",")
    }
    code.push("tuple[", i, "]")
  }
  code.push(")}return orient")
  var proc = new Function("test", code.join(""))
  var test = orient[d+1]
  if(!test) {
    test = orient
  }
  return proc(test)
}

var BAKED = []

function Triangulation(dimension, vertices, simplices) {
  this.dimension = dimension
  this.vertices = vertices
  this.simplices = simplices
  this.interior = simplices.filter(function(c) {
    return !c.boundary
  })

  this.tuple = new Array(dimension+1)
  for(var i=0; i<=dimension; ++i) {
    this.tuple[i] = this.vertices[i]
  }

  var o = BAKED[dimension]
  if(!o) {
    o = BAKED[dimension] = bakeOrient(dimension)
  }
  this.orient = o
}

var proto = Triangulation.prototype

//Degenerate situation where we are on boundary, but coplanar to face
proto.handleBoundaryDegeneracy = function(cell, point) {
  var d = this.dimension
  var n = this.vertices.length - 1
  var tuple = this.tuple
  var verts = this.vertices

  //Dumb solution: Just do dfs from boundary cell until we find any peak, or terminate
  var toVisit = [ cell ]
  cell.lastVisited = -n
  while(toVisit.length > 0) {
    cell = toVisit.pop()
    var cellVerts = cell.vertices
    var cellAdj = cell.adjacent
    for(var i=0; i<=d; ++i) {
      var neighbor = cellAdj[i]
      if(!neighbor.boundary || neighbor.lastVisited <= -n) {
        continue
      }
      var nv = neighbor.vertices
      for(var j=0; j<=d; ++j) {
        var vv = nv[j]
        if(vv < 0) {
          tuple[j] = point
        } else {
          tuple[j] = verts[vv]
        }
      }
      var o = this.orient()
      if(o > 0) {
        return neighbor
      }
      neighbor.lastVisited = -n
      if(o === 0) {
        toVisit.push(neighbor)
      }
    }
  }
  return null
}

proto.walk = function(point, random) {
  //Alias local properties
  var n = this.vertices.length - 1
  var d = this.dimension
  var verts = this.vertices
  var tuple = this.tuple

  //Compute initial jump cell
  var initIndex = random ? (this.interior.length * Math.random())|0 : (this.interior.length-1)
  var cell = this.interior[ initIndex ]

  //Start walking
outerLoop:
  while(!cell.boundary) {
    var cellVerts = cell.vertices
    var cellAdj = cell.adjacent

    for(var i=0; i<=d; ++i) {
      tuple[i] = verts[cellVerts[i]]
    }
    cell.lastVisited = n

    //Find farthest adjacent cell
    for(var i=0; i<=d; ++i) {
      var neighbor = cellAdj[i]
      if(neighbor.lastVisited >= n) {
        continue
      }
      var prev = tuple[i]
      tuple[i] = point
      var o = this.orient()
      tuple[i] = prev
      if(o < 0) {
        cell = neighbor
        continue outerLoop
      } else {
        if(!neighbor.boundary) {
          neighbor.lastVisited = n
        } else {
          neighbor.lastVisited = -n
        }
      }
    }
    return
  }

  return cell
}

proto.addPeaks = function(point, cell) {
  var n = this.vertices.length - 1
  var d = this.dimension
  var verts = this.vertices
  var tuple = this.tuple
  var interior = this.interior
  var simplices = this.simplices

  //Walking finished at boundary, time to add peaks
  var tovisit = [ cell ]

  //Stretch initial boundary cell into a peak
  cell.lastVisited = n
  cell.vertices[cell.vertices.indexOf(-1)] = n
  cell.boundary = false
  interior.push(cell)

  //Record a list of all new boundaries created by added peaks so we can glue them together when we are all done
  var glueFacets = []

  //Do a traversal of the boundary walking outward from starting peak
  while(tovisit.length > 0) {
    //Pop off peak and walk over adjacent cells
    var cell = tovisit.pop()
    var cellVerts = cell.vertices
    var cellAdj = cell.adjacent
    var indexOfN = cellVerts.indexOf(n)
    if(indexOfN < 0) {
      continue
    }

    for(var i=0; i<=d; ++i) {
      if(i === indexOfN) {
        continue
      }

      //For each boundary neighbor of the cell
      var neighbor = cellAdj[i]
      if(!neighbor.boundary || neighbor.lastVisited >= n) {
        continue
      }

      var nv = neighbor.vertices

      //Test if neighbor is a peak
      if(neighbor.lastVisited !== -n) {      
        //Compute orientation of p relative to each boundary peak
        var indexOfNeg1 = 0
        for(var j=0; j<=d; ++j) {
          if(nv[j] < 0) {
            indexOfNeg1 = j
            tuple[j] = point
          } else {
            tuple[j] = verts[nv[j]]
          }
        }
        var o = this.orient()

        //Test if neighbor cell is also a peak
        if(o > 0) {
          nv[indexOfNeg1] = n
          neighbor.boundary = false
          interior.push(neighbor)
          tovisit.push(neighbor)
          neighbor.lastVisited = n
          continue
        } else {
          neighbor.lastVisited = -n
        }
      }

      var na = neighbor.adjacent

      //Otherwise, replace neighbor with new face
      var vverts = cellVerts.slice()
      var vadj = cellAdj.slice()
      var ncell = new Simplex(vverts, vadj, true)
      simplices.push(ncell)

      //Connect to neighbor
      var opposite = na.indexOf(cell)
      if(opposite < 0) {
        continue
      }
      na[opposite] = ncell
      vadj[indexOfN] = neighbor

      //Connect to cell
      vverts[i] = -1
      vadj[i] = cell
      cellAdj[i] = ncell

      //Flip facet
      ncell.flip()

      //Add to glue list
      for(var j=0; j<=d; ++j) {
        var uu = vverts[j]
        if(uu < 0 || uu === n) {
          continue
        }
        var nface = new Array(d-1)
        var nptr = 0
        for(var k=0; k<=d; ++k) {
          var vv = vverts[k]
          if(vv < 0 || k === j) {
            continue
          }
          nface[nptr++] = vv
        }
        glueFacets.push(new GlueFacet(nface, ncell, j))
      }
    }
  }

  //Glue boundary facets together
  glueFacets.sort(compareGlue)

  for(var i=0; i+1<glueFacets.length; i+=2) {
    var a = glueFacets[i]
    var b = glueFacets[i+1]
    var ai = a.index
    var bi = b.index
    if(ai < 0 || bi < 0) {
      continue
    }
    a.cell.adjacent[a.index] = b.cell
    b.cell.adjacent[b.index] = a.cell
  }
}

proto.insert = function(point, random) {
  //Add point
  var verts = this.vertices
  verts.push(point)

  var cell = this.walk(point, random)
  if(!cell) {
    return
  }

  //Alias local properties
  var d = this.dimension
  var tuple = this.tuple

  //Degenerate case: If point is coplanar to cell, then walk until we find a non-degenerate boundary
  for(var i=0; i<=d; ++i) {
    var vv = cell.vertices[i]
    if(vv < 0) {
      tuple[i] = point
    } else {
      tuple[i] = verts[vv]
    }
  }
  var o = this.orient(tuple)
  if(o < 0) {
    return
  } else if(o === 0) {
    cell = this.handleBoundaryDegeneracy(cell, point)
    if(!cell) {
      return
    }
  }

  //Add peaks
  this.addPeaks(point, cell)
}

//Extract all boundary cells
proto.boundary = function() {
  var d = this.dimension
  var boundary = []
  var cells = this.simplices
  var nc = cells.length
  for(var i=0; i<nc; ++i) {
    var c = cells[i]
    if(c.boundary) {
      var bcell = new Array(d)
      var cv = c.vertices
      var ptr = 0
      var parity = 0
      for(var j=0; j<=d; ++j) {
        if(cv[j] >= 0) {
          bcell[ptr++] = cv[j]
        } else {
          parity = j&1
        }
      }
      if(parity === (d&1)) {
        var t = bcell[0]
        bcell[0] = bcell[1]
        bcell[1] = t
      }
      boundary.push(bcell)
    }
  }
  return boundary
}

function incrementalConvexHull(points, randomSearch) {
  var n = points.length
  if(n === 0) {
    throw new Error("Must have at least d+1 points")
  }
  var d = points[0].length
  if(n <= d) {
    throw new Error("Must input at least d+1 points")
  }

  //FIXME: This could be degenerate, but need to select d+1 non-coplanar points to bootstrap process
  var initialSimplex = points.slice(0, d+1)

  //Make sure initial simplex is positively oriented
  var o = orient.apply(void 0, initialSimplex)
  if(o === 0) {
    throw new Error("Input not in general position")
  }
  var initialCoords = new Array(d+1)
  for(var i=0; i<=d; ++i) {
    initialCoords[i] = i
  }
  if(o < 0) {
    initialCoords[0] = 1
    initialCoords[1] = 0
  }

  //Create initial topological index, glue pointers together (kind of messy)
  var initialCell = new Simplex(initialCoords, new Array(d+1), false)
  var boundary = initialCell.adjacent
  var list = new Array(d+2)
  for(var i=0; i<=d; ++i) {
    var verts = initialCoords.slice()
    for(var j=0; j<=d; ++j) {
      if(j === i) {
        verts[j] = -1
      }
    }
    var t = verts[0]
    verts[0] = verts[1]
    verts[1] = t
    var cell = new Simplex(verts, new Array(d+1), true)
    boundary[i] = cell
    list[i] = cell
  }
  list[d+1] = initialCell
  for(var i=0; i<=d; ++i) {
    var verts = boundary[i].vertices
    var adj = boundary[i].adjacent
    for(var j=0; j<=d; ++j) {
      var v = verts[j]
      if(v < 0) {
        adj[j] = initialCell
        continue
      }
      for(var k=0; k<=d; ++k) {
        if(boundary[k].vertices.indexOf(v) < 0) {
          adj[j] = boundary[k]
        }
      }
    }
  }

  //Initialize triangles
  var triangles = new Triangulation(d, initialSimplex, list)

  //Insert remaining points
  var useRandom = !!randomSearch
  for(var i=d+1; i<n; ++i) {
    triangles.insert(points[i], useRandom)
  }
  
  //Extract boundary cells
  return triangles.boundary()
}
},{"robust-orientation":98,"simplicial-complex":101}],93:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"dup":31}],94:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32,"two-product":97,"two-sum":93}],95:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],96:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],97:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],98:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"dup":36,"robust-scale":94,"robust-subtract":95,"robust-sum":96,"two-product":97}],99:[function(require,module,exports){
/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */

"use strict"; "use restrict";

//Number of bits in an integer
var INT_BITS = 32;

//Constants
exports.INT_BITS  = INT_BITS;
exports.INT_MAX   =  0x7fffffff;
exports.INT_MIN   = -1<<(INT_BITS-1);

//Returns -1, 0, +1 depending on sign of x
exports.sign = function(v) {
  return (v > 0) - (v < 0);
}

//Computes absolute value of integer
exports.abs = function(v) {
  var mask = v >> (INT_BITS-1);
  return (v ^ mask) - mask;
}

//Computes minimum of integers x and y
exports.min = function(x, y) {
  return y ^ ((x ^ y) & -(x < y));
}

//Computes maximum of integers x and y
exports.max = function(x, y) {
  return x ^ ((x ^ y) & -(x < y));
}

//Checks if a number is a power of two
exports.isPow2 = function(v) {
  return !(v & (v-1)) && (!!v);
}

//Computes log base 2 of v
exports.log2 = function(v) {
  var r, shift;
  r =     (v > 0xFFFF) << 4; v >>>= r;
  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;
  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;
  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;
  return r | (v >> 1);
}

//Computes log base 10 of v
exports.log10 = function(v) {
  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :
          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :
          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;
}

//Counts number of bits
exports.popCount = function(v) {
  v = v - ((v >>> 1) & 0x55555555);
  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;
}

//Counts number of trailing zeros
function countTrailingZeros(v) {
  var c = 32;
  v &= -v;
  if (v) c--;
  if (v & 0x0000FFFF) c -= 16;
  if (v & 0x00FF00FF) c -= 8;
  if (v & 0x0F0F0F0F) c -= 4;
  if (v & 0x33333333) c -= 2;
  if (v & 0x55555555) c -= 1;
  return c;
}
exports.countTrailingZeros = countTrailingZeros;

//Rounds to next power of 2
exports.nextPow2 = function(v) {
  v += v === 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
}

//Rounds down to previous power of 2
exports.prevPow2 = function(v) {
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v - (v>>>1);
}

//Computes parity of word
exports.parity = function(v) {
  v ^= v >>> 16;
  v ^= v >>> 8;
  v ^= v >>> 4;
  v &= 0xf;
  return (0x6996 >>> v) & 1;
}

var REVERSE_TABLE = new Array(256);

(function(tab) {
  for(var i=0; i<256; ++i) {
    var v = i, r = i, s = 7;
    for (v >>>= 1; v; v >>>= 1) {
      r <<= 1;
      r |= v & 1;
      --s;
    }
    tab[i] = (r << s) & 0xff;
  }
})(REVERSE_TABLE);

//Reverse bits in a 32 bit word
exports.reverse = function(v) {
  return  (REVERSE_TABLE[ v         & 0xff] << 24) |
          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |
          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |
           REVERSE_TABLE[(v >>> 24) & 0xff];
}

//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2 = function(x, y) {
  x &= 0xFFFF;
  x = (x | (x << 8)) & 0x00FF00FF;
  x = (x | (x << 4)) & 0x0F0F0F0F;
  x = (x | (x << 2)) & 0x33333333;
  x = (x | (x << 1)) & 0x55555555;

  y &= 0xFFFF;
  y = (y | (y << 8)) & 0x00FF00FF;
  y = (y | (y << 4)) & 0x0F0F0F0F;
  y = (y | (y << 2)) & 0x33333333;
  y = (y | (y << 1)) & 0x55555555;

  return x | (y << 1);
}

//Extracts the nth interleaved component
exports.deinterleave2 = function(v, n) {
  v = (v >>> n) & 0x55555555;
  v = (v | (v >>> 1))  & 0x33333333;
  v = (v | (v >>> 2))  & 0x0F0F0F0F;
  v = (v | (v >>> 4))  & 0x00FF00FF;
  v = (v | (v >>> 16)) & 0x000FFFF;
  return (v << 16) >> 16;
}


//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3 = function(x, y, z) {
  x &= 0x3FF;
  x  = (x | (x<<16)) & 4278190335;
  x  = (x | (x<<8))  & 251719695;
  x  = (x | (x<<4))  & 3272356035;
  x  = (x | (x<<2))  & 1227133513;

  y &= 0x3FF;
  y  = (y | (y<<16)) & 4278190335;
  y  = (y | (y<<8))  & 251719695;
  y  = (y | (y<<4))  & 3272356035;
  y  = (y | (y<<2))  & 1227133513;
  x |= (y << 1);
  
  z &= 0x3FF;
  z  = (z | (z<<16)) & 4278190335;
  z  = (z | (z<<8))  & 251719695;
  z  = (z | (z<<4))  & 3272356035;
  z  = (z | (z<<2))  & 1227133513;
  
  return x | (z << 2);
}

//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3 = function(v, n) {
  v = (v >>> n)       & 1227133513;
  v = (v | (v>>>2))   & 3272356035;
  v = (v | (v>>>4))   & 251719695;
  v = (v | (v>>>8))   & 4278190335;
  v = (v | (v>>>16))  & 0x3FF;
  return (v<<22)>>22;
}

//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination = function(v) {
  var t = v | (v - 1);
  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));
}


},{}],100:[function(require,module,exports){
"use strict"; "use restrict";

module.exports = UnionFind;

function UnionFind(count) {
  this.roots = new Array(count);
  this.ranks = new Array(count);
  
  for(var i=0; i<count; ++i) {
    this.roots[i] = i;
    this.ranks[i] = 0;
  }
}

var proto = UnionFind.prototype

Object.defineProperty(proto, "length", {
  "get": function() {
    return this.roots.length
  }
})

proto.makeSet = function() {
  var n = this.roots.length;
  this.roots.push(n);
  this.ranks.push(0);
  return n;
}

proto.find = function(x) {
  var x0 = x
  var roots = this.roots;
  while(roots[x] !== x) {
    x = roots[x]
  }
  while(roots[x0] !== x) {
    var y = roots[x0]
    roots[x0] = x
    x0 = y
  }
  return x;
}

proto.link = function(x, y) {
  var xr = this.find(x)
    , yr = this.find(y);
  if(xr === yr) {
    return;
  }
  var ranks = this.ranks
    , roots = this.roots
    , xd    = ranks[xr]
    , yd    = ranks[yr];
  if(xd < yd) {
    roots[xr] = yr;
  } else if(yd < xd) {
    roots[yr] = xr;
  } else {
    roots[yr] = xr;
    ++ranks[xr];
  }
}
},{}],101:[function(require,module,exports){
"use strict"; "use restrict";

var bits      = require("bit-twiddle")
  , UnionFind = require("union-find")

//Returns the dimension of a cell complex
function dimension(cells) {
  var d = 0
    , max = Math.max
  for(var i=0, il=cells.length; i<il; ++i) {
    d = max(d, cells[i].length)
  }
  return d-1
}
exports.dimension = dimension

//Counts the number of vertices in faces
function countVertices(cells) {
  var vc = -1
    , max = Math.max
  for(var i=0, il=cells.length; i<il; ++i) {
    var c = cells[i]
    for(var j=0, jl=c.length; j<jl; ++j) {
      vc = max(vc, c[j])
    }
  }
  return vc+1
}
exports.countVertices = countVertices

//Returns a deep copy of cells
function cloneCells(cells) {
  var ncells = new Array(cells.length)
  for(var i=0, il=cells.length; i<il; ++i) {
    ncells[i] = cells[i].slice(0)
  }
  return ncells
}
exports.cloneCells = cloneCells

//Ranks a pair of cells up to permutation
function compareCells(a, b) {
  var n = a.length
    , t = a.length - b.length
    , min = Math.min
  if(t) {
    return t
  }
  switch(n) {
    case 0:
      return 0;
    case 1:
      return a[0] - b[0];
    case 2:
      var d = a[0]+a[1]-b[0]-b[1]
      if(d) {
        return d
      }
      return min(a[0],a[1]) - min(b[0],b[1])
    case 3:
      var l1 = a[0]+a[1]
        , m1 = b[0]+b[1]
      d = l1+a[2] - (m1+b[2])
      if(d) {
        return d
      }
      var l0 = min(a[0], a[1])
        , m0 = min(b[0], b[1])
        , d  = min(l0, a[2]) - min(m0, b[2])
      if(d) {
        return d
      }
      return min(l0+a[2], l1) - min(m0+b[2], m1)
    
    //TODO: Maybe optimize n=4 as well?
    
    default:
      var as = a.slice(0)
      as.sort()
      var bs = b.slice(0)
      bs.sort()
      for(var i=0; i<n; ++i) {
        t = as[i] - bs[i]
        if(t) {
          return t
        }
      }
      return 0
  }
}
exports.compareCells = compareCells

function compareZipped(a, b) {
  return compareCells(a[0], b[0])
}

//Puts a cell complex into normal order for the purposes of findCell queries
function normalize(cells, attr) {
  if(attr) {
    var len = cells.length
    var zipped = new Array(len)
    for(var i=0; i<len; ++i) {
      zipped[i] = [cells[i], attr[i]]
    }
    zipped.sort(compareZipped)
    for(var i=0; i<len; ++i) {
      cells[i] = zipped[i][0]
      attr[i] = zipped[i][1]
    }
    return cells
  } else {
    cells.sort(compareCells)
    return cells
  }
}
exports.normalize = normalize

//Removes all duplicate cells in the complex
function unique(cells) {
  if(cells.length === 0) {
    return []
  }
  var ptr = 1
    , len = cells.length
  for(var i=1; i<len; ++i) {
    var a = cells[i]
    if(compareCells(a, cells[i-1])) {
      if(i === ptr) {
        ptr++
        continue
      }
      cells[ptr++] = a
    }
  }
  cells.length = ptr
  return cells
}
exports.unique = unique;

//Finds a cell in a normalized cell complex
function findCell(cells, c) {
  var lo = 0
    , hi = cells.length-1
    , r  = -1
  while (lo <= hi) {
    var mid = (lo + hi) >> 1
      , s   = compareCells(cells[mid], c)
    if(s <= 0) {
      if(s === 0) {
        r = mid
      }
      lo = mid + 1
    } else if(s > 0) {
      hi = mid - 1
    }
  }
  return r
}
exports.findCell = findCell;

//Builds an index for an n-cell.  This is more general than dual, but less efficient
function incidence(from_cells, to_cells) {
  var index = new Array(from_cells.length)
  for(var i=0, il=index.length; i<il; ++i) {
    index[i] = []
  }
  var b = []
  for(var i=0, n=to_cells.length; i<n; ++i) {
    var c = to_cells[i]
    var cl = c.length
    for(var k=1, kn=(1<<cl); k<kn; ++k) {
      b.length = bits.popCount(k)
      var l = 0
      for(var j=0; j<cl; ++j) {
        if(k & (1<<j)) {
          b[l++] = c[j]
        }
      }
      var idx=findCell(from_cells, b)
      if(idx < 0) {
        continue
      }
      while(true) {
        index[idx++].push(i)
        if(idx >= from_cells.length || compareCells(from_cells[idx], b) !== 0) {
          break
        }
      }
    }
  }
  return index
}
exports.incidence = incidence

//Computes the dual of the mesh.  This is basically an optimized version of buildIndex for the situation where from_cells is just the list of vertices
function dual(cells, vertex_count) {
  if(!vertex_count) {
    return incidence(unique(skeleton(cells, 0)), cells, 0)
  }
  var res = new Array(vertex_count)
  for(var i=0; i<vertex_count; ++i) {
    res[i] = []
  }
  for(var i=0, len=cells.length; i<len; ++i) {
    var c = cells[i]
    for(var j=0, cl=c.length; j<cl; ++j) {
      res[c[j]].push(i)
    }
  }
  return res
}
exports.dual = dual

//Enumerates all cells in the complex
function explode(cells) {
  var result = []
  for(var i=0, il=cells.length; i<il; ++i) {
    var c = cells[i]
      , cl = c.length|0
    for(var j=1, jl=(1<<cl); j<jl; ++j) {
      var b = []
      for(var k=0; k<cl; ++k) {
        if((j >>> k) & 1) {
          b.push(c[k])
        }
      }
      result.push(b)
    }
  }
  return normalize(result)
}
exports.explode = explode

//Enumerates all of the n-cells of a cell complex
function skeleton(cells, n) {
  if(n < 0) {
    return []
  }
  var result = []
    , k0     = (1<<(n+1))-1
  for(var i=0; i<cells.length; ++i) {
    var c = cells[i]
    for(var k=k0; k<(1<<c.length); k=bits.nextCombination(k)) {
      var b = new Array(n+1)
        , l = 0
      for(var j=0; j<c.length; ++j) {
        if(k & (1<<j)) {
          b[l++] = c[j]
        }
      }
      result.push(b)
    }
  }
  return normalize(result)
}
exports.skeleton = skeleton;

//Computes the boundary of all cells, does not remove duplicates
function boundary(cells) {
  var res = []
  for(var i=0,il=cells.length; i<il; ++i) {
    var c = cells[i]
    for(var j=0,cl=c.length; j<cl; ++j) {
      var b = new Array(c.length-1)
      for(var k=0, l=0; k<cl; ++k) {
        if(k !== j) {
          b[l++] = c[k]
        }
      }
      res.push(b)
    }
  }
  return normalize(res)
}
exports.boundary = boundary;

//Computes connected components for a dense cell complex
function connectedComponents_dense(cells, vertex_count) {
  var labels = new UnionFind(vertex_count)
  for(var i=0; i<cells.length; ++i) {
    var c = cells[i]
    for(var j=0; j<c.length; ++j) {
      for(var k=j+1; k<c.length; ++k) {
        labels.link(c[j], c[k])
      }
    }
  }
  var components = []
    , component_labels = labels.ranks
  for(var i=0; i<component_labels.length; ++i) {
    component_labels[i] = -1
  }
  for(var i=0; i<cells.length; ++i) {
    var l = labels.find(cells[i][0])
    if(component_labels[l] < 0) {
      component_labels[l] = components.length
      components.push([cells[i].slice(0)])
    } else {
      components[component_labels[l]].push(cells[i].slice(0))
    }
  }
  return components
}

//Computes connected components for a sparse graph
function connectedComponents_sparse(cells) {
  var vertices  = unique(normalize(skeleton(cells, 0)))
    , labels    = new UnionFind(vertices.length)
  for(var i=0; i<cells.length; ++i) {
    var c = cells[i]
    for(var j=0; j<c.length; ++j) {
      var vj = findCell(vertices, [c[j]])
      for(var k=j+1; k<c.length; ++k) {
        labels.link(vj, findCell(vertices, [c[k]]))
      }
    }
  }
  var components        = []
    , component_labels  = labels.ranks
  for(var i=0; i<component_labels.length; ++i) {
    component_labels[i] = -1
  }
  for(var i=0; i<cells.length; ++i) {
    var l = labels.find(findCell(vertices, [cells[i][0]]));
    if(component_labels[l] < 0) {
      component_labels[l] = components.length
      components.push([cells[i].slice(0)])
    } else {
      components[component_labels[l]].push(cells[i].slice(0))
    }
  }
  return components
}

//Computes connected components for a cell complex
function connectedComponents(cells, vertex_count) {
  if(vertex_count) {
    return connectedComponents_dense(cells, vertex_count)
  }
  return connectedComponents_sparse(cells)
}
exports.connectedComponents = connectedComponents

},{"bit-twiddle":99,"union-find":100}],102:[function(require,module,exports){
'use strict'

module.exports = monotoneConvexHull2D

var orient = require('robust-orientation')[3]

function monotoneConvexHull2D(points) {
  var n = points.length

  if(n < 3) {
    var result = new Array(n)
    for(var i=0; i<n; ++i) {
      result[i] = i
    }

    if(n === 2 &&
       points[0][0] === points[1][0] &&
       points[0][1] === points[1][1]) {
      return [0]
    }

    return result
  }

  //Sort point indices along x-axis
  var sorted = new Array(n)
  for(var i=0; i<n; ++i) {
    sorted[i] = i
  }
  sorted.sort(function(a,b) {
    var d = points[a][0]-points[b][0]
    if(d) {
      return d
    }
    return points[a][1] - points[b][1]
  })

  //Construct upper and lower hulls
  var lower = [sorted[0], sorted[1]]
  var upper = [sorted[0], sorted[1]]

  for(var i=2; i<n; ++i) {
    var idx = sorted[i]
    var p   = points[idx]

    //Insert into lower list
    var m = lower.length
    while(m > 1 && orient(
        points[lower[m-2]], 
        points[lower[m-1]], 
        p) <= 0) {
      m -= 1
      lower.pop()
    }
    lower.push(idx)

    //Insert into upper list
    m = upper.length
    while(m > 1 && orient(
        points[upper[m-2]], 
        points[upper[m-1]], 
        p) >= 0) {
      m -= 1
      upper.pop()
    }
    upper.push(idx)
  }

  //Merge lists together
  var result = new Array(upper.length + lower.length - 2)
  var ptr    = 0
  for(var i=0, nl=lower.length; i<nl; ++i) {
    result[ptr++] = lower[i]
  }
  for(var j=upper.length-2; j>0; --j) {
    result[ptr++] = upper[j]
  }

  //Return result
  return result
}
},{"robust-orientation":108}],103:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"dup":31}],104:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32,"two-product":107,"two-sum":103}],105:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],106:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],107:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],108:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"dup":36,"robust-scale":104,"robust-subtract":105,"robust-sum":106,"two-product":107}],109:[function(require,module,exports){
arguments[4][77][0].apply(exports,arguments)
},{"dup":77}],110:[function(require,module,exports){
var inside = require('turf-inside');

/**
 * Takes a {@link FeatureCollection} of {@link Point} features and a {@link FeatureCollection} of {@link Polygon} features and calculates the number of points that fall within the set of polygons.
 *
 * @module turf/count
 * @category aggregation
 * @param {FeatureCollection} polygons a FeatureCollection of {@link Polygon} features
 * @param {FeatureCollection} points a FeatureCollection of {@link Point} features
 * @param {String} countField a field to append to the attributes of the Polygon features representing Point counts
 * @return {FeatureCollection} a FeatureCollection of Polygon features with `countField` appended
 * @example
* var polygons = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [[
 *           [-112.072391,46.586591],
 *           [-112.072391,46.61761],
 *           [-112.028102,46.61761],
 *           [-112.028102,46.586591],
 *           [-112.072391,46.586591]
 *         ]]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [[
 *           [-112.023983,46.570426],
 *           [-112.023983,46.615016],
 *           [-111.966133,46.615016],
 *           [-111.966133,46.570426],
 *           [-112.023983,46.570426]
 *         ]]
 *       }
 *     }
 *   ]
 * };
 * var points = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "population": 200
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-112.0372, 46.608058]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "population": 600
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-112.045955, 46.596264]
 *       }
 *     }
 *   ]
 * };
 *
 * var counted = turf.count(polygons, points, 'pt_count');
 *
 * var resultFeatures = points.features.concat(counted.features);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */

module.exports = function(polyFC, ptFC, outField, done){
  for (var i = 0; i < polyFC.features.length; i++) {
    var poly = polyFC.features[i];
    if(!poly.properties) poly.properties = {};
    var values = 0;
    for (var j = 0; j < ptFC.features.length; j++) {
      var pt = ptFC.features[j];
      if (inside(pt, poly)) {
        values++;
      }
    }
    poly.properties[outField] = values;
  }

  return polyFC;
};

},{"turf-inside":130}],111:[function(require,module,exports){
//http://en.wikipedia.org/wiki/Haversine_formula
//http://www.movable-type.co.uk/scripts/latlong.html
var point = require('turf-point');

/**
 * Takes a {@link Point} feature and calculates the location of a destination point given a distance in degrees, radians, miles, or kilometers; and bearing in degrees. This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.
 *
 * @module turf/destination
 * @category measurement
 * @param {Point} start a Point feature at the starting point
 * @param {Number} distance distance from the starting point
 * @param {Number} bearing ranging from -180 to 180
 * @param {String} units miles, kilometers, degrees, or radians
 * @returns {Point} a Point feature at the destination
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {
 *     "marker-color": "#0f0"
 *   },
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-75.343, 39.984]
 *   }
 * };
 * var distance = 50;
 * var bearing = 90;
 * var units = 'miles';
 *
 * var destination = turf.destination(point, distance, bearing, units);
 * destination.properties['marker-color'] = '#f00';
 *
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": [point, destination]
 * };
 *
 * //=result
 */
module.exports = function (point1, distance, bearing, units) {
    var coordinates1 = point1.geometry.coordinates;
    var longitude1 = toRad(coordinates1[0]);
    var latitude1 = toRad(coordinates1[1]);
    var bearing_rad = toRad(bearing);

    var R = 0;
    switch (units) {
    case 'miles':
        R = 3960;
        break
    case 'kilometers':
        R = 6373;
        break
    case 'degrees':
        R = 57.2957795;
        break
    case 'radians':
        R = 1;
        break
    }

    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(distance / R) +
        Math.cos(latitude1) * Math.sin(distance / R) * Math.cos(bearing_rad));
    var longitude2 = longitude1 + Math.atan2(Math.sin(bearing_rad) * Math.sin(distance / R) * Math.cos(latitude1),
        Math.cos(distance / R) - Math.sin(latitude1) * Math.sin(latitude2));

    return point([toDeg(longitude2), toDeg(latitude2)]);
};

function toRad(degree) {
    return degree * Math.PI / 180;
}

function toDeg(rad) {
    return rad * 180 / Math.PI;
}

},{"turf-point":156}],112:[function(require,module,exports){
var ss = require('simple-statistics');
var inside = require('turf-inside');

/**
 * Calculates the standard deviation value of a field for points within a set of polygons.
 *
 * @module turf/deviation
 * @category aggregation
 * @param {FeatureCollection} polygons a FeatureCollection of {@link Polygon} features
 * @param {FeatureCollection} points a FeatureCollection of {@link Point} features
 * @param {String} inField the field in `points` from which to aggregate
 * @param {String} outField the field to append to `polygons` representing deviation
 * @return {FeatureCollection} a FeatureCollection of Polygon features with appended field representing deviation
 * @example
 * var polygons = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [[
 *           [-97.807159, 30.270335],
 *           [-97.807159, 30.369913],
 *           [-97.612838, 30.369913],
 *           [-97.612838, 30.270335],
 *           [-97.807159, 30.270335]
 *         ]]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [[
 *           [-97.825698, 30.175405],
 *           [-97.825698, 30.264404],
 *           [-97.630691, 30.264404],
 *           [-97.630691, 30.175405],
 *           [-97.825698, 30.175405]
 *         ]]
 *       }
 *     }
 *   ]
 * };
 * var points = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "population": 500
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.709655, 30.311245]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "population": 400
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.766647, 30.345028]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "population": 600
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.765274, 30.294646]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "population": 500
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.753601, 30.216355]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "population": 200
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.667083, 30.208047]
 *       }
 *     }
 *   ]
 * };
 *
 * var inField = "population";
 * var outField = "pop_deviation";
 *
 * var deviated = turf.deviation(
 *   polygons, points, inField, outField);
 *
 * var resultFeatures = points.features.concat(
 *   deviated.features);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */

module.exports = function(polyFC, ptFC, inField, outField, done){
  polyFC.features.forEach(function(poly){
    if(!poly.properties){
      poly.properties = {};
    }
    var values = [];
    ptFC.features.forEach(function(pt){
      if (inside(pt, poly)) {
        values.push(pt.properties[inField]);
      }
    });
    poly.properties[outField] = ss.standard_deviation(values);
  })

  return polyFC;
}

},{"simple-statistics":113,"turf-inside":130}],113:[function(require,module,exports){
/* global module */
// # simple-statistics
//
// A simple, literate statistics system. The code below uses the
// [Javascript module pattern](http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth),
// eventually assigning `simple-statistics` to `ss` in browsers or the
// `exports` object for node.js
(function() {
    var ss = {};

    if (typeof module !== 'undefined') {
        // Assign the `ss` object to exports, so that you can require
        // it in [node.js](http://nodejs.org/)
        module.exports = ss;
    } else {
        // Otherwise, in a browser, we assign `ss` to the window object,
        // so you can simply refer to it as `ss`.
        this.ss = ss;
    }

    // # [Linear Regression](http://en.wikipedia.org/wiki/Linear_regression)
    //
    // [Simple linear regression](http://en.wikipedia.org/wiki/Simple_linear_regression)
    // is a simple way to find a fitted line
    // between a set of coordinates.
    function linear_regression() {
        var linreg = {},
            data = [];

        // Assign data to the model. Data is assumed to be an array.
        linreg.data = function(x) {
            if (!arguments.length) return data;
            data = x.slice();
            return linreg;
        };

        // Calculate the slope and y-intercept of the regression line
        // by calculating the least sum of squares
        linreg.mb = function() {
            var m, b;

            // Store data length in a local variable to reduce
            // repeated object property lookups
            var data_length = data.length;

            //if there's only one point, arbitrarily choose a slope of 0
            //and a y-intercept of whatever the y of the initial point is
            if (data_length === 1) {
                m = 0;
                b = data[0][1];
            } else {
                // Initialize our sums and scope the `m` and `b`
                // variables that define the line.
                var sum_x = 0, sum_y = 0,
                    sum_xx = 0, sum_xy = 0;

                // Use local variables to grab point values
                // with minimal object property lookups
                var point, x, y;

                // Gather the sum of all x values, the sum of all
                // y values, and the sum of x^2 and (x*y) for each
                // value.
                //
                // In math notation, these would be SS_x, SS_y, SS_xx, and SS_xy
                for (var i = 0; i < data_length; i++) {
                    point = data[i];
                    x = point[0];
                    y = point[1];

                    sum_x += x;
                    sum_y += y;

                    sum_xx += x * x;
                    sum_xy += x * y;
                }

                // `m` is the slope of the regression line
                m = ((data_length * sum_xy) - (sum_x * sum_y)) /
                    ((data_length * sum_xx) - (sum_x * sum_x));

                // `b` is the y-intercept of the line.
                b = (sum_y / data_length) - ((m * sum_x) / data_length);
            }

            // Return both values as an object.
            return { m: m, b: b };
        };

        // a shortcut for simply getting the slope of the regression line
        linreg.m = function() {
            return linreg.mb().m;
        };

        // a shortcut for simply getting the y-intercept of the regression
        // line.
        linreg.b = function() {
            return linreg.mb().b;
        };

        // ## Fitting The Regression Line
        //
        // This is called after `.data()` and returns the
        // equation `y = f(x)` which gives the position
        // of the regression line at each point in `x`.
        linreg.line = function() {

            // Get the slope, `m`, and y-intercept, `b`, of the line.
            var mb = linreg.mb(),
                m = mb.m,
                b = mb.b;

            // Return a function that computes a `y` value for each
            // x value it is given, based on the values of `b` and `a`
            // that we just computed.
            return function(x) {
                return b + (m * x);
            };
        };

        return linreg;
    }

    // # [R Squared](http://en.wikipedia.org/wiki/Coefficient_of_determination)
    //
    // The r-squared value of data compared with a function `f`
    // is the sum of the squared differences between the prediction
    // and the actual value.
    function r_squared(data, f) {
        if (data.length < 2) return 1;

        // Compute the average y value for the actual
        // data set in order to compute the
        // _total sum of squares_
        var sum = 0, average;
        for (var i = 0; i < data.length; i++) {
            sum += data[i][1];
        }
        average = sum / data.length;

        // Compute the total sum of squares - the
        // squared difference between each point
        // and the average of all points.
        var sum_of_squares = 0;
        for (var j = 0; j < data.length; j++) {
            sum_of_squares += Math.pow(average - data[j][1], 2);
        }

        // Finally estimate the error: the squared
        // difference between the estimate and the actual data
        // value at each point.
        var err = 0;
        for (var k = 0; k < data.length; k++) {
            err += Math.pow(data[k][1] - f(data[k][0]), 2);
        }

        // As the error grows larger, its ratio to the
        // sum of squares increases and the r squared
        // value grows lower.
        return 1 - (err / sum_of_squares);
    }


    // # [Bayesian Classifier](http://en.wikipedia.org/wiki/Naive_Bayes_classifier)
    //
    // This is a naïve bayesian classifier that takes
    // singly-nested objects.
    function bayesian() {
        // The `bayes_model` object is what will be exposed
        // by this closure, with all of its extended methods, and will
        // have access to all scope variables, like `total_count`.
        var bayes_model = {},
            // The number of items that are currently
            // classified in the model
            total_count = 0,
            // Every item classified in the model
            data = {};

        // ## Train
        // Train the classifier with a new item, which has a single
        // dimension of Javascript literal keys and values.
        bayes_model.train = function(item, category) {
            // If the data object doesn't have any values
            // for this category, create a new object for it.
            if (!data[category]) data[category] = {};

            // Iterate through each key in the item.
            for (var k in item) {
                var v = item[k];
                // Initialize the nested object `data[category][k][item[k]]`
                // with an object of keys that equal 0.
                if (data[category][k] === undefined) data[category][k] = {};
                if (data[category][k][v] === undefined) data[category][k][v] = 0;

                // And increment the key for this key/value combination.
                data[category][k][item[k]]++;
            }
            // Increment the number of items classified
            total_count++;
        };

        // ## Score
        // Generate a score of how well this item matches all
        // possible categories based on its attributes
        bayes_model.score = function(item) {
            // Initialize an empty array of odds per category.
            var odds = {}, category;
            // Iterate through each key in the item,
            // then iterate through each category that has been used
            // in previous calls to `.train()`
            for (var k in item) {
                var v = item[k];
                for (category in data) {
                    // Create an empty object for storing key - value combinations
                    // for this category.
                    if (odds[category] === undefined) odds[category] = {};

                    // If this item doesn't even have a property, it counts for nothing,
                    // but if it does have the property that we're looking for from
                    // the item to categorize, it counts based on how popular it is
                    // versus the whole population.
                    if (data[category][k]) {
                        odds[category][k + '_' + v] = (data[category][k][v] || 0) / total_count;
                    } else {
                        odds[category][k + '_' + v] = 0;
                    }
                }
            }

            // Set up a new object that will contain sums of these odds by category
            var odds_sums = {};

            for (category in odds) {
                // Tally all of the odds for each category-combination pair -
                // the non-existence of a category does not add anything to the
                // score.
                for (var combination in odds[category]) {
                    if (odds_sums[category] === undefined) odds_sums[category] = 0;
                    odds_sums[category] += odds[category][combination];
                }
            }

            return odds_sums;
        };

        // Return the completed model.
        return bayes_model;
    }

    // # sum
    //
    // is simply the result of adding all numbers
    // together, starting from zero.
    //
    // This runs on `O(n)`, linear time in respect to the array
    function sum(x) {
        var value = 0;
        for (var i = 0; i < x.length; i++) {
            value += x[i];
        }
        return value;
    }

    // # mean
    //
    // is the sum over the number of values
    //
    // This runs on `O(n)`, linear time in respect to the array
    function mean(x) {
        // The mean of no numbers is null
        if (x.length === 0) return null;

        return sum(x) / x.length;
    }

    // # geometric mean
    //
    // a mean function that is more useful for numbers in different
    // ranges.
    //
    // this is the nth root of the input numbers multiplied by each other
    //
    // This runs on `O(n)`, linear time in respect to the array
    function geometric_mean(x) {
        // The mean of no numbers is null
        if (x.length === 0) return null;

        // the starting value.
        var value = 1;

        for (var i = 0; i < x.length; i++) {
            // the geometric mean is only valid for positive numbers
            if (x[i] <= 0) return null;

            // repeatedly multiply the value by each number
            value *= x[i];
        }

        return Math.pow(value, 1 / x.length);
    }


    // # harmonic mean
    //
    // a mean function typically used to find the average of rates
    //
    // this is the reciprocal of the arithmetic mean of the reciprocals
    // of the input numbers
    //
    // This runs on `O(n)`, linear time in respect to the array
    function harmonic_mean(x) {
        // The mean of no numbers is null
        if (x.length === 0) return null;

        var reciprocal_sum = 0;

        for (var i = 0; i < x.length; i++) {
            // the harmonic mean is only valid for positive numbers
            if (x[i] <= 0) return null;

            reciprocal_sum += 1 / x[i];
        }

        // divide n by the the reciprocal sum
        return x.length / reciprocal_sum;
    }

    // root mean square (RMS)
    //
    // a mean function used as a measure of the magnitude of a set
    // of numbers, regardless of their sign
    //
    // this is the square root of the mean of the squares of the 
    // input numbers
    //
    // This runs on `O(n)`, linear time in respect to the array
    function root_mean_square(x) {
        if (x.length === 0) return null;

        var sum_of_squares = 0;
        for (var i = 0; i < x.length; i++) {
            sum_of_squares += Math.pow(x[i], 2);
        }

        return Math.sqrt(sum_of_squares / x.length);
    }

    // # min
    //
    // This is simply the minimum number in the set.
    //
    // This runs on `O(n)`, linear time in respect to the array
    function min(x) {
        var value;
        for (var i = 0; i < x.length; i++) {
            // On the first iteration of this loop, min is
            // undefined and is thus made the minimum element in the array
            if (x[i] < value || value === undefined) value = x[i];
        }
        return value;
    }

    // # max
    //
    // This is simply the maximum number in the set.
    //
    // This runs on `O(n)`, linear time in respect to the array
    function max(x) {
        var value;
        for (var i = 0; i < x.length; i++) {
            // On the first iteration of this loop, max is
            // undefined and is thus made the maximum element in the array
            if (x[i] > value || value === undefined) value = x[i];
        }
        return value;
    }

    // # [variance](http://en.wikipedia.org/wiki/Variance)
    //
    // is the sum of squared deviations from the mean
    //
    // depends on `mean()`
    function variance(x) {
        // The variance of no numbers is null
        if (x.length === 0) return null;

        var mean_value = mean(x),
            deviations = [];

        // Make a list of squared deviations from the mean.
        for (var i = 0; i < x.length; i++) {
            deviations.push(Math.pow(x[i] - mean_value, 2));
        }

        // Find the mean value of that list
        return mean(deviations);
    }

    // # [standard deviation](http://en.wikipedia.org/wiki/Standard_deviation)
    //
    // is just the square root of the variance.
    //
    // depends on `variance()`
    function standard_deviation(x) {
        // The standard deviation of no numbers is null
        if (x.length === 0) return null;

        return Math.sqrt(variance(x));
    }

    // The sum of deviations to the Nth power.
    // When n=2 it's the sum of squared deviations.
    // When n=3 it's the sum of cubed deviations.
    //
    // depends on `mean()`
    function sum_nth_power_deviations(x, n) {
        var mean_value = mean(x),
            sum = 0;

        for (var i = 0; i < x.length; i++) {
            sum += Math.pow(x[i] - mean_value, n);
        }

        return sum;
    }

    // # [variance](http://en.wikipedia.org/wiki/Variance)
    //
    // is the sum of squared deviations from the mean
    //
    // depends on `sum_nth_power_deviations`
    function sample_variance(x) {
        // The variance of no numbers is null
        if (x.length <= 1) return null;

        var sum_squared_deviations_value = sum_nth_power_deviations(x, 2);

        // Find the mean value of that list
        return sum_squared_deviations_value / (x.length - 1);
    }

    // # [standard deviation](http://en.wikipedia.org/wiki/Standard_deviation)
    //
    // is just the square root of the variance.
    //
    // depends on `sample_variance()`
    function sample_standard_deviation(x) {
        // The standard deviation of no numbers is null
        if (x.length <= 1) return null;

        return Math.sqrt(sample_variance(x));
    }

    // # [covariance](http://en.wikipedia.org/wiki/Covariance)
    //
    // sample covariance of two datasets:
    // how much do the two datasets move together?
    // x and y are two datasets, represented as arrays of numbers.
    //
    // depends on `mean()`
    function sample_covariance(x, y) {

        // The two datasets must have the same length which must be more than 1
        if (x.length <= 1 || x.length != y.length){
            return null;
        }

        // determine the mean of each dataset so that we can judge each
        // value of the dataset fairly as the difference from the mean. this
        // way, if one dataset is [1, 2, 3] and [2, 3, 4], their covariance
        // does not suffer because of the difference in absolute values
        var xmean = mean(x),
            ymean = mean(y),
            sum = 0;

        // for each pair of values, the covariance increases when their
        // difference from the mean is associated - if both are well above
        // or if both are well below
        // the mean, the covariance increases significantly.
        for (var i = 0; i < x.length; i++){
            sum += (x[i] - xmean) * (y[i] - ymean);
        }

        // the covariance is weighted by the length of the datasets.
        return sum / (x.length - 1);
    }

    // # [correlation](http://en.wikipedia.org/wiki/Correlation_and_dependence)
    //
    // Gets a measure of how correlated two datasets are, between -1 and 1
    //
    // depends on `sample_standard_deviation()` and `sample_covariance()`
    function sample_correlation(x, y) {
        var cov = sample_covariance(x, y),
            xstd = sample_standard_deviation(x),
            ystd = sample_standard_deviation(y);

        if (cov === null || xstd === null || ystd === null) {
            return null;
        }

        return cov / xstd / ystd;
    }

    // # [median](http://en.wikipedia.org/wiki/Median)
    //
    // The middle number of a list. This is often a good indicator of 'the middle'
    // when there are outliers that skew the `mean()` value.
    function median(x) {
        // The median of an empty list is null
        if (x.length === 0) return null;

        // Sorting the array makes it easy to find the center, but
        // use `.slice()` to ensure the original array `x` is not modified
        var sorted = x.slice().sort(function (a, b) { return a - b; });

        // If the length of the list is odd, it's the central number
        if (sorted.length % 2 === 1) {
            return sorted[(sorted.length - 1) / 2];
        // Otherwise, the median is the average of the two numbers
        // at the center of the list
        } else {
            var a = sorted[(sorted.length / 2) - 1];
            var b = sorted[(sorted.length / 2)];
            return (a + b) / 2;
        }
    }

    // # [mode](http://bit.ly/W5K4Yt)
    //
    // The mode is the number that appears in a list the highest number of times.
    // There can be multiple modes in a list: in the event of a tie, this
    // algorithm will return the most recently seen mode.
    //
    // This implementation is inspired by [science.js](https://github.com/jasondavies/science.js/blob/master/src/stats/mode.js)
    //
    // This runs on `O(n)`, linear time in respect to the array
    function mode(x) {

        // Handle edge cases:
        // The median of an empty list is null
        if (x.length === 0) return null;
        else if (x.length === 1) return x[0];

        // Sorting the array lets us iterate through it below and be sure
        // that every time we see a new number it's new and we'll never
        // see the same number twice
        var sorted = x.slice().sort(function (a, b) { return a - b; });

        // This assumes it is dealing with an array of size > 1, since size
        // 0 and 1 are handled immediately. Hence it starts at index 1 in the
        // array.
        var last = sorted[0],
            // store the mode as we find new modes
            value,
            // store how many times we've seen the mode
            max_seen = 0,
            // how many times the current candidate for the mode
            // has been seen
            seen_this = 1;

        // end at sorted.length + 1 to fix the case in which the mode is
        // the highest number that occurs in the sequence. the last iteration
        // compares sorted[i], which is undefined, to the highest number
        // in the series
        for (var i = 1; i < sorted.length + 1; i++) {
            // we're seeing a new number pass by
            if (sorted[i] !== last) {
                // the last number is the new mode since we saw it more
                // often than the old one
                if (seen_this > max_seen) {
                    max_seen = seen_this;
                    value = last;
                }
                seen_this = 1;
                last = sorted[i];
            // if this isn't a new number, it's one more occurrence of
            // the potential mode
            } else { seen_this++; }
        }
        return value;
    }

    // # [t-test](http://en.wikipedia.org/wiki/Student's_t-test)
    //
    // This is to compute a one-sample t-test, comparing the mean
    // of a sample to a known value, x.
    //
    // in this case, we're trying to determine whether the
    // population mean is equal to the value that we know, which is `x`
    // here. usually the results here are used to look up a
    // [p-value](http://en.wikipedia.org/wiki/P-value), which, for
    // a certain level of significance, will let you determine that the
    // null hypothesis can or cannot be rejected.
    //
    // Depends on `standard_deviation()` and `mean()`
    function t_test(sample, x) {
        // The mean of the sample
        var sample_mean = mean(sample);

        // The standard deviation of the sample
        var sd = standard_deviation(sample);

        // Square root the length of the sample
        var rootN = Math.sqrt(sample.length);

        // Compute the known value against the sample,
        // returning the t value
        return (sample_mean - x) / (sd / rootN);
    }

    // # [2-sample t-test](http://en.wikipedia.org/wiki/Student's_t-test)
    //
    // This is to compute two sample t-test.
    // Tests whether "mean(X)-mean(Y) = difference", (
    // in the most common case, we often have `difference == 0` to test if two samples
    // are likely to be taken from populations with the same mean value) with
    // no prior knowledge on standard deviations of both samples
    // other than the fact that they have the same standard deviation.
    //
    // Usually the results here are used to look up a
    // [p-value](http://en.wikipedia.org/wiki/P-value), which, for
    // a certain level of significance, will let you determine that the
    // null hypothesis can or cannot be rejected.
    //
    // `diff` can be omitted if it equals 0.
    //
    // [This is used to confirm or deny](http://www.monarchlab.org/Lab/Research/Stats/2SampleT.aspx)
    // a null hypothesis that the two populations that have been sampled into
    // `sample_x` and `sample_y` are equal to each other.
    //
    // Depends on `sample_variance()` and `mean()`
    function t_test_two_sample(sample_x, sample_y, difference) {
        var n = sample_x.length,
            m = sample_y.length;

        // If either sample doesn't actually have any values, we can't
        // compute this at all, so we return `null`.
        if (!n || !m) return null ;

        // default difference (mu) is zero
        if (!difference) difference = 0;

        var meanX = mean(sample_x),
            meanY = mean(sample_y);

        var weightedVariance = ((n - 1) * sample_variance(sample_x) +
            (m - 1) * sample_variance(sample_y)) / (n + m - 2);

        return (meanX - meanY - difference) /
            Math.sqrt(weightedVariance * (1 / n + 1 / m));
    }

    // # chunk
    //
    // Split an array into chunks of a specified size. This function
    // has the same behavior as [PHP's array_chunk](http://php.net/manual/en/function.array-chunk.php)
    // function, and thus will insert smaller-sized chunks at the end if
    // the input size is not divisible by the chunk size.
    //
    // `sample` is expected to be an array, and `chunkSize` a number.
    // The `sample` array can contain any kind of data.
    function chunk(sample, chunkSize) {

        // a list of result chunks, as arrays in an array
        var output = [];

        // `chunkSize` must be zero or higher - otherwise the loop below,
        // in which we call `start += chunkSize`, will loop infinitely.
        // So, we'll detect and return null in that case to indicate
        // invalid input.
        if (chunkSize <= 0) {
            return null;
        }

        // `start` is the index at which `.slice` will start selecting
        // new array elements
        for (var start = 0; start < sample.length; start += chunkSize) {

            // for each chunk, slice that part of the array and add it
            // to the output. The `.slice` function does not change
            // the original array.
            output.push(sample.slice(start, start + chunkSize));
        }
        return output;
    }

    // # shuffle_in_place
    //
    // A [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)
    // in-place - which means that it will change the order of the original
    // array by reference.
    function shuffle_in_place(sample, randomSource) {

        // a custom random number source can be provided if you want to use
        // a fixed seed or another random number generator, like
        // [random-js](https://www.npmjs.org/package/random-js)
        randomSource = randomSource || Math.random;

        // store the current length of the sample to determine
        // when no elements remain to shuffle.
        var length = sample.length;

        // temporary is used to hold an item when it is being
        // swapped between indices.
        var temporary;

        // The index to swap at each stage.
        var index;

        // While there are still items to shuffle
        while (length > 0) {
            // chose a random index within the subset of the array
            // that is not yet shuffled
            index = Math.floor(randomSource() * length--);

            // store the value that we'll move temporarily
            temporary = sample[length];

            // swap the value at `sample[length]` with `sample[index]`
            sample[length] = sample[index];
            sample[index] = temporary;
        }

        return sample;
    }

    // # shuffle
    //
    // A [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)
    // is a fast way to create a random permutation of a finite set.
    function shuffle(sample, randomSource) {
        // slice the original array so that it is not modified
        sample = sample.slice();

        // and then shuffle that shallow-copied array, in place
        return shuffle_in_place(sample.slice(), randomSource);
    }

    // # sample
    //
    // Create a [simple random sample](http://en.wikipedia.org/wiki/Simple_random_sample)
    // from a given array of `n` elements.
    function sample(array, n, randomSource) {
        // shuffle the original array using a fisher-yates shuffle
        var shuffled = shuffle(array, randomSource);

        // and then return a subset of it - the first `n` elements.
        return shuffled.slice(0, n);
    }

    // # quantile
    //
    // This is a population quantile, since we assume to know the entire
    // dataset in this library. Thus I'm trying to follow the
    // [Quantiles of a Population](http://en.wikipedia.org/wiki/Quantile#Quantiles_of_a_population)
    // algorithm from wikipedia.
    //
    // Sample is a one-dimensional array of numbers,
    // and p is either a decimal number from 0 to 1 or an array of decimal
    // numbers from 0 to 1.
    // In terms of a k/q quantile, p = k/q - it's just dealing with fractions or dealing
    // with decimal values.
    // When p is an array, the result of the function is also an array containing the appropriate
    // quantiles in input order
    function quantile(sample, p) {

        // We can't derive quantiles from an empty list
        if (sample.length === 0) return null;

        // Sort a copy of the array. We'll need a sorted array to index
        // the values in sorted order.
        var sorted = sample.slice().sort(function (a, b) { return a - b; });

        if (p.length) {
            // Initialize the result array
            var results = [];
            // For each requested quantile
            for (var i = 0; i < p.length; i++) {
                results[i] = quantile_sorted(sorted, p[i]);
            }
            return results;
        } else {
            return quantile_sorted(sorted, p);
        }
    }

    // # quantile
    //
    // This is the internal implementation of quantiles: when you know
    // that the order is sorted, you don't need to re-sort it, and the computations
    // are much faster.
    function quantile_sorted(sample, p) {
        var idx = (sample.length) * p;
        if (p < 0 || p > 1) {
            return null;
        } else if (p === 1) {
            // If p is 1, directly return the last element
            return sample[sample.length - 1];
        } else if (p === 0) {
            // If p is 0, directly return the first element
            return sample[0];
        } else if (idx % 1 !== 0) {
            // If p is not integer, return the next element in array
            return sample[Math.ceil(idx) - 1];
        } else if (sample.length % 2 === 0) {
            // If the list has even-length, we'll take the average of this number
            // and the next value, if there is one
            return (sample[idx - 1] + sample[idx]) / 2;
        } else {
            // Finally, in the simple case of an integer value
            // with an odd-length list, return the sample value at the index.
            return sample[idx];
        }
    }

    // # [Interquartile range](http://en.wikipedia.org/wiki/Interquartile_range)
    //
    // A measure of statistical dispersion, or how scattered, spread, or
    // concentrated a distribution is. It's computed as the difference between
    // the third quartile and first quartile.
    function iqr(sample) {
        // We can't derive quantiles from an empty list
        if (sample.length === 0) return null;

        // Interquartile range is the span between the upper quartile,
        // at `0.75`, and lower quartile, `0.25`
        return quantile(sample, 0.75) - quantile(sample, 0.25);
    }

    // # [Median Absolute Deviation](http://en.wikipedia.org/wiki/Median_absolute_deviation)
    //
    // The Median Absolute Deviation (MAD) is a robust measure of statistical
    // dispersion. It is more resilient to outliers than the standard deviation.
    function mad(x) {
        // The mad of nothing is null
        if (!x || x.length === 0) return null;

        var median_value = median(x),
            median_absolute_deviations = [];

        // Make a list of absolute deviations from the median
        for (var i = 0; i < x.length; i++) {
            median_absolute_deviations.push(Math.abs(x[i] - median_value));
        }

        // Find the median value of that list
        return median(median_absolute_deviations);
    }

    // ## Compute Matrices for Jenks
    //
    // Compute the matrices required for Jenks breaks. These matrices
    // can be used for any classing of data with `classes <= n_classes`
    function jenksMatrices(data, n_classes) {

        // in the original implementation, these matrices are referred to
        // as `LC` and `OP`
        //
        // * lower_class_limits (LC): optimal lower class limits
        // * variance_combinations (OP): optimal variance combinations for all classes
        var lower_class_limits = [],
            variance_combinations = [],
            // loop counters
            i, j,
            // the variance, as computed at each step in the calculation
            variance = 0;

        // Initialize and fill each matrix with zeroes
        for (i = 0; i < data.length + 1; i++) {
            var tmp1 = [], tmp2 = [];
            // despite these arrays having the same values, we need
            // to keep them separate so that changing one does not change
            // the other
            for (j = 0; j < n_classes + 1; j++) {
                tmp1.push(0);
                tmp2.push(0);
            }
            lower_class_limits.push(tmp1);
            variance_combinations.push(tmp2);
        }

        for (i = 1; i < n_classes + 1; i++) {
            lower_class_limits[1][i] = 1;
            variance_combinations[1][i] = 0;
            // in the original implementation, 9999999 is used but
            // since Javascript has `Infinity`, we use that.
            for (j = 2; j < data.length + 1; j++) {
                variance_combinations[j][i] = Infinity;
            }
        }

        for (var l = 2; l < data.length + 1; l++) {

            // `SZ` originally. this is the sum of the values seen thus
            // far when calculating variance.
            var sum = 0,
                // `ZSQ` originally. the sum of squares of values seen
                // thus far
                sum_squares = 0,
                // `WT` originally. This is the number of
                w = 0,
                // `IV` originally
                i4 = 0;

            // in several instances, you could say `Math.pow(x, 2)`
            // instead of `x * x`, but this is slower in some browsers
            // introduces an unnecessary concept.
            for (var m = 1; m < l + 1; m++) {

                // `III` originally
                var lower_class_limit = l - m + 1,
                    val = data[lower_class_limit - 1];

                // here we're estimating variance for each potential classing
                // of the data, for each potential number of classes. `w`
                // is the number of data points considered so far.
                w++;

                // increase the current sum and sum-of-squares
                sum += val;
                sum_squares += val * val;

                // the variance at this point in the sequence is the difference
                // between the sum of squares and the total x 2, over the number
                // of samples.
                variance = sum_squares - (sum * sum) / w;

                i4 = lower_class_limit - 1;

                if (i4 !== 0) {
                    for (j = 2; j < n_classes + 1; j++) {
                        // if adding this element to an existing class
                        // will increase its variance beyond the limit, break
                        // the class at this point, setting the `lower_class_limit`
                        // at this point.
                        if (variance_combinations[l][j] >=
                            (variance + variance_combinations[i4][j - 1])) {
                            lower_class_limits[l][j] = lower_class_limit;
                            variance_combinations[l][j] = variance +
                                variance_combinations[i4][j - 1];
                        }
                    }
                }
            }

            lower_class_limits[l][1] = 1;
            variance_combinations[l][1] = variance;
        }

        // return the two matrices. for just providing breaks, only
        // `lower_class_limits` is needed, but variances can be useful to
        // evaluate goodness of fit.
        return {
            lower_class_limits: lower_class_limits,
            variance_combinations: variance_combinations
        };
    }

    // ## Pull Breaks Values for Jenks
    //
    // the second part of the jenks recipe: take the calculated matrices
    // and derive an array of n breaks.
    function jenksBreaks(data, lower_class_limits, n_classes) {

        var k = data.length,
            kclass = [],
            countNum = n_classes;

        // the calculation of classes will never include the upper
        // bound, so we need to explicitly set it
        kclass[n_classes] = data[data.length - 1];

        // the lower_class_limits matrix is used as indices into itself
        // here: the `k` variable is reused in each iteration.
        while (countNum > 0) {
            kclass[countNum - 1] = data[lower_class_limits[k][countNum] - 1];
            k = lower_class_limits[k][countNum] - 1;
            countNum--;
        }

        return kclass;
    }

    // # [Jenks natural breaks optimization](http://en.wikipedia.org/wiki/Jenks_natural_breaks_optimization)
    //
    // Implementations: [1](http://danieljlewis.org/files/2010/06/Jenks.pdf) (python),
    // [2](https://github.com/vvoovv/djeo-jenks/blob/master/main.js) (buggy),
    // [3](https://github.com/simogeo/geostats/blob/master/lib/geostats.js#L407) (works)
    //
    // Depends on `jenksBreaks()` and `jenksMatrices()`
    function jenks(data, n_classes) {

        if (n_classes > data.length) return null;

        // sort data in numerical order, since this is expected
        // by the matrices function
        data = data.slice().sort(function (a, b) { return a - b; });

        // get our basic matrices
        var matrices = jenksMatrices(data, n_classes),
            // we only need lower class limits here
            lower_class_limits = matrices.lower_class_limits;

        // extract n_classes out of the computed matrices
        return jenksBreaks(data, lower_class_limits, n_classes);

    }

    // # [Skewness](http://en.wikipedia.org/wiki/Skewness)
    //
    // A measure of the extent to which a probability distribution of a
    // real-valued random variable "leans" to one side of the mean.
    // The skewness value can be positive or negative, or even undefined.
    //
    // Implementation is based on the adjusted Fisher-Pearson standardized
    // moment coefficient, which is the version found in Excel and several
    // statistical packages including Minitab, SAS and SPSS.
    //
    // Depends on `sum_nth_power_deviations()` and `sample_standard_deviation`
    function sample_skewness(x) {
        // The skewness of less than three arguments is null
        if (x.length < 3) return null;

        var n = x.length,
            cubed_s = Math.pow(sample_standard_deviation(x), 3),
            sum_cubed_deviations = sum_nth_power_deviations(x, 3);

        return n * sum_cubed_deviations / ((n - 1) * (n - 2) * cubed_s);
    }

    // # Standard Normal Table
    // A standard normal table, also called the unit normal table or Z table,
    // is a mathematical table for the values of Φ (phi), which are the values of
    // the cumulative distribution function of the normal distribution.
    // It is used to find the probability that a statistic is observed below,
    // above, or between values on the standard normal distribution, and by
    // extension, any normal distribution.
    //
    // The probabilities are taken from http://en.wikipedia.org/wiki/Standard_normal_table
    // The table used is the cumulative, and not cumulative from 0 to mean
    // (even though the latter has 5 digits precision, instead of 4).
    var standard_normal_table = [
        /*  z      0.00    0.01    0.02    0.03    0.04    0.05    0.06    0.07    0.08    0.09 */
        /* 0.0 */
        0.5000, 0.5040, 0.5080, 0.5120, 0.5160, 0.5199, 0.5239, 0.5279, 0.5319, 0.5359,
        /* 0.1 */
        0.5398, 0.5438, 0.5478, 0.5517, 0.5557, 0.5596, 0.5636, 0.5675, 0.5714, 0.5753,
        /* 0.2 */
        0.5793, 0.5832, 0.5871, 0.5910, 0.5948, 0.5987, 0.6026, 0.6064, 0.6103, 0.6141,
        /* 0.3 */
        0.6179, 0.6217, 0.6255, 0.6293, 0.6331, 0.6368, 0.6406, 0.6443, 0.6480, 0.6517,
        /* 0.4 */
        0.6554, 0.6591, 0.6628, 0.6664, 0.6700, 0.6736, 0.6772, 0.6808, 0.6844, 0.6879,
        /* 0.5 */
        0.6915, 0.6950, 0.6985, 0.7019, 0.7054, 0.7088, 0.7123, 0.7157, 0.7190, 0.7224,
        /* 0.6 */
        0.7257, 0.7291, 0.7324, 0.7357, 0.7389, 0.7422, 0.7454, 0.7486, 0.7517, 0.7549,
        /* 0.7 */
        0.7580, 0.7611, 0.7642, 0.7673, 0.7704, 0.7734, 0.7764, 0.7794, 0.7823, 0.7852,
        /* 0.8 */
        0.7881, 0.7910, 0.7939, 0.7967, 0.7995, 0.8023, 0.8051, 0.8078, 0.8106, 0.8133,
        /* 0.9 */
        0.8159, 0.8186, 0.8212, 0.8238, 0.8264, 0.8289, 0.8315, 0.8340, 0.8365, 0.8389,
        /* 1.0 */
        0.8413, 0.8438, 0.8461, 0.8485, 0.8508, 0.8531, 0.8554, 0.8577, 0.8599, 0.8621,
        /* 1.1 */
        0.8643, 0.8665, 0.8686, 0.8708, 0.8729, 0.8749, 0.8770, 0.8790, 0.8810, 0.8830,
        /* 1.2 */
        0.8849, 0.8869, 0.8888, 0.8907, 0.8925, 0.8944, 0.8962, 0.8980, 0.8997, 0.9015,
        /* 1.3 */
        0.9032, 0.9049, 0.9066, 0.9082, 0.9099, 0.9115, 0.9131, 0.9147, 0.9162, 0.9177,
        /* 1.4 */
        0.9192, 0.9207, 0.9222, 0.9236, 0.9251, 0.9265, 0.9279, 0.9292, 0.9306, 0.9319,
        /* 1.5 */
        0.9332, 0.9345, 0.9357, 0.9370, 0.9382, 0.9394, 0.9406, 0.9418, 0.9429, 0.9441,
        /* 1.6 */
        0.9452, 0.9463, 0.9474, 0.9484, 0.9495, 0.9505, 0.9515, 0.9525, 0.9535, 0.9545,
        /* 1.7 */
        0.9554, 0.9564, 0.9573, 0.9582, 0.9591, 0.9599, 0.9608, 0.9616, 0.9625, 0.9633,
        /* 1.8 */
        0.9641, 0.9649, 0.9656, 0.9664, 0.9671, 0.9678, 0.9686, 0.9693, 0.9699, 0.9706,
        /* 1.9 */
        0.9713, 0.9719, 0.9726, 0.9732, 0.9738, 0.9744, 0.9750, 0.9756, 0.9761, 0.9767,
        /* 2.0 */
        0.9772, 0.9778, 0.9783, 0.9788, 0.9793, 0.9798, 0.9803, 0.9808, 0.9812, 0.9817,
        /* 2.1 */
        0.9821, 0.9826, 0.9830, 0.9834, 0.9838, 0.9842, 0.9846, 0.9850, 0.9854, 0.9857,
        /* 2.2 */
        0.9861, 0.9864, 0.9868, 0.9871, 0.9875, 0.9878, 0.9881, 0.9884, 0.9887, 0.9890,
        /* 2.3 */
        0.9893, 0.9896, 0.9898, 0.9901, 0.9904, 0.9906, 0.9909, 0.9911, 0.9913, 0.9916,
        /* 2.4 */
        0.9918, 0.9920, 0.9922, 0.9925, 0.9927, 0.9929, 0.9931, 0.9932, 0.9934, 0.9936,
        /* 2.5 */
        0.9938, 0.9940, 0.9941, 0.9943, 0.9945, 0.9946, 0.9948, 0.9949, 0.9951, 0.9952,
        /* 2.6 */
        0.9953, 0.9955, 0.9956, 0.9957, 0.9959, 0.9960, 0.9961, 0.9962, 0.9963, 0.9964,
        /* 2.7 */
        0.9965, 0.9966, 0.9967, 0.9968, 0.9969, 0.9970, 0.9971, 0.9972, 0.9973, 0.9974,
        /* 2.8 */
        0.9974, 0.9975, 0.9976, 0.9977, 0.9977, 0.9978, 0.9979, 0.9979, 0.9980, 0.9981,
        /* 2.9 */
        0.9981, 0.9982, 0.9982, 0.9983, 0.9984, 0.9984, 0.9985, 0.9985, 0.9986, 0.9986,
        /* 3.0 */
        0.9987, 0.9987, 0.9987, 0.9988, 0.9988, 0.9989, 0.9989, 0.9989, 0.9990, 0.9990
    ];

    // # [Gaussian error function](http://en.wikipedia.org/wiki/Error_function)
    //
    // The error_function(x/(sd * Math.sqrt(2))) is the probability that a value in a
    // normal distribution with standard deviation sd is within x of the mean.
    //
    // This function returns a numerical approximation to the exact value.
    function error_function(x) {
        var t = 1 / (1 + 0.5 * Math.abs(x));
        var tau = t * Math.exp(-Math.pow(x, 2) -
            1.26551223 +
            1.00002368 * t +
            0.37409196 * Math.pow(t, 2) +
            0.09678418 * Math.pow(t, 3) -
            0.18628806 * Math.pow(t, 4) +
            0.27886807 * Math.pow(t, 5) -
            1.13520398 * Math.pow(t, 6) +
            1.48851587 * Math.pow(t, 7) -
            0.82215223 * Math.pow(t, 8) +
            0.17087277 * Math.pow(t, 9));
        if (x >= 0) {
            return 1 - tau;
        } else {
            return tau - 1;
        }
    }

    // # [Cumulative Standard Normal Probability](http://en.wikipedia.org/wiki/Standard_normal_table)
    //
    // Since probability tables cannot be
    // printed for every normal distribution, as there are an infinite variety
    // of normal distributions, it is common practice to convert a normal to a
    // standard normal and then use the standard normal table to find probabilities.
    //
    // You can use .5 + .5 * error_function(x / Math.sqrt(2)) to calculate the probability
    // instead of looking it up in a table.
    function cumulative_std_normal_probability(z) {

        // Calculate the position of this value.
        var absZ = Math.abs(z),
            // Each row begins with a different
            // significant digit: 0.5, 0.6, 0.7, and so on. Each value in the table
            // corresponds to a range of 0.01 in the input values, so the value is
            // multiplied by 100.
            index = Math.min(Math.round(absZ * 100), standard_normal_table.length - 1);

        // The index we calculate must be in the table as a positive value,
        // but we still pay attention to whether the input is positive
        // or negative, and flip the output value as a last step.
        if (z >= 0) {
            return standard_normal_table[index];
        } else {
            // due to floating-point arithmetic, values in the table with
            // 4 significant figures can nevertheless end up as repeating
            // fractions when they're computed here.
            return +(1 - standard_normal_table[index]).toFixed(4);
        }
    }

    // # [Z-Score, or Standard Score](http://en.wikipedia.org/wiki/Standard_score)
    //
    // The standard score is the number of standard deviations an observation
    // or datum is above or below the mean. Thus, a positive standard score
    // represents a datum above the mean, while a negative standard score
    // represents a datum below the mean. It is a dimensionless quantity
    // obtained by subtracting the population mean from an individual raw
    // score and then dividing the difference by the population standard
    // deviation.
    //
    // The z-score is only defined if one knows the population parameters;
    // if one only has a sample set, then the analogous computation with
    // sample mean and sample standard deviation yields the
    // Student's t-statistic.
    function z_score(x, mean, standard_deviation) {
        return (x - mean) / standard_deviation;
    }

    // We use `ε`, epsilon, as a stopping criterion when we want to iterate
    // until we're "close enough".
    var epsilon = 0.0001;

    // # [Factorial](https://en.wikipedia.org/wiki/Factorial)
    //
    // A factorial, usually written n!, is the product of all positive
    // integers less than or equal to n. Often factorial is implemented
    // recursively, but this iterative approach is significantly faster
    // and simpler.
    function factorial(n) {

        // factorial is mathematically undefined for negative numbers
        if (n < 0 ) { return null; }

        // typically you'll expand the factorial function going down, like
        // 5! = 5 * 4 * 3 * 2 * 1. This is going in the opposite direction,
        // counting from 2 up to the number in question, and since anything
        // multiplied by 1 is itself, the loop only needs to start at 2.
        var accumulator = 1;
        for (var i = 2; i <= n; i++) {
            // for each number up to and including the number `n`, multiply
            // the accumulator my that number.
            accumulator *= i;
        }
        return accumulator;
    }

    // # Bernoulli Distribution
    //
    // The [Bernoulli distribution](http://en.wikipedia.org/wiki/Bernoulli_distribution)
    // is the probability discrete
    // distribution of a random variable which takes value 1 with success
    // probability `p` and value 0 with failure
    // probability `q` = 1 - `p`. It can be used, for example, to represent the
    // toss of a coin, where "1" is defined to mean "heads" and "0" is defined
    // to mean "tails" (or vice versa). It is
    // a special case of a Binomial Distribution
    // where `n` = 1.
    function bernoulli_distribution(p) {
        // Check that `p` is a valid probability (0 ≤ p ≤ 1)
        if (p < 0 || p > 1 ) { return null; }

        return binomial_distribution(1, p);
    }

    // # Binomial Distribution
    //
    // The [Binomial Distribution](http://en.wikipedia.org/wiki/Binomial_distribution) is the discrete probability
    // distribution of the number of successes in a sequence of n independent yes/no experiments, each of which yields
    // success with probability `probability`. Such a success/failure experiment is also called a Bernoulli experiment or
    // Bernoulli trial; when trials = 1, the Binomial Distribution is a Bernoulli Distribution.
    function binomial_distribution(trials, probability) {
        // Check that `p` is a valid probability (0 ≤ p ≤ 1),
        // that `n` is an integer, strictly positive.
        if (probability < 0 || probability > 1 ||
            trials <= 0 || trials % 1 !== 0) {
            return null;
        }

        // a [probability mass function](https://en.wikipedia.org/wiki/Probability_mass_function)
        function probability_mass(x, trials, probability) {
            return factorial(trials) /
                (factorial(x) * factorial(trials - x)) *
                (Math.pow(probability, x) * Math.pow(1 - probability, trials - x));
        }

        // We initialize `x`, the random variable, and `accumulator`, an accumulator
        // for the cumulative distribution function to 0. `distribution_functions`
        // is the object we'll return with the `probability_of_x` and the
        // `cumulative_probability_of_x`, as well as the calculated mean &
        // variance. We iterate until the `cumulative_probability_of_x` is
        // within `epsilon` of 1.0.
        var x = 0,
            cumulative_probability = 0,
            cells = {};

        // This algorithm iterates through each potential outcome,
        // until the `cumulative_probability` is very close to 1, at
        // which point we've defined the vast majority of outcomes
        do {
            cells[x] = probability_mass(x, trials, probability);
            cumulative_probability += cells[x];
            x++;
        // when the cumulative_probability is nearly 1, we've calculated
        // the useful range of this distribution
        } while (cumulative_probability < 1 - epsilon);

        return cells;
    }

    // # Poisson Distribution
    //
    // The [Poisson Distribution](http://en.wikipedia.org/wiki/Poisson_distribution)
    // is a discrete probability distribution that expresses the probability
    // of a given number of events occurring in a fixed interval of time
    // and/or space if these events occur with a known average rate and
    // independently of the time since the last event.
    //
    // The Poisson Distribution is characterized by the strictly positive
    // mean arrival or occurrence rate, `λ`.
    function poisson_distribution(lambda) {
        // Check that lambda is strictly positive
        if (lambda <= 0) { return null; }

        // our current place in the distribution
        var x = 0,
            // and we keep track of the current cumulative probability, in
            // order to know when to stop calculating chances.
            cumulative_probability = 0,
            // the calculated cells to be returned
            cells = {};

        // a [probability mass function](https://en.wikipedia.org/wiki/Probability_mass_function)
        function probability_mass(x, lambda) {
            return (Math.pow(Math.E, -lambda) * Math.pow(lambda, x)) /
                factorial(x);
        }

        // This algorithm iterates through each potential outcome,
        // until the `cumulative_probability` is very close to 1, at
        // which point we've defined the vast majority of outcomes
        do {
            cells[x] = probability_mass(x, lambda);
            cumulative_probability += cells[x];
            x++;
        // when the cumulative_probability is nearly 1, we've calculated
        // the useful range of this distribution
        } while (cumulative_probability < 1 - epsilon);

        return cells;
    }

    // # Percentage Points of the χ2 (Chi-Squared) Distribution
    // The [χ2 (Chi-Squared) Distribution](http://en.wikipedia.org/wiki/Chi-squared_distribution) is used in the common
    // chi-squared tests for goodness of fit of an observed distribution to a theoretical one, the independence of two
    // criteria of classification of qualitative data, and in confidence interval estimation for a population standard
    // deviation of a normal distribution from a sample standard deviation.
    //
    // Values from Appendix 1, Table III of William W. Hines & Douglas C. Montgomery, "Probability and Statistics in
    // Engineering and Management Science", Wiley (1980).
    var chi_squared_distribution_table = {
        1: { 0.995:  0.00, 0.99:  0.00, 0.975:  0.00, 0.95:  0.00, 0.9:  0.02, 0.5:  0.45, 0.1:  2.71, 0.05:  3.84, 0.025:  5.02, 0.01:  6.63, 0.005:  7.88 },
        2: { 0.995:  0.01, 0.99:  0.02, 0.975:  0.05, 0.95:  0.10, 0.9:  0.21, 0.5:  1.39, 0.1:  4.61, 0.05:  5.99, 0.025:  7.38, 0.01:  9.21, 0.005: 10.60 },
        3: { 0.995:  0.07, 0.99:  0.11, 0.975:  0.22, 0.95:  0.35, 0.9:  0.58, 0.5:  2.37, 0.1:  6.25, 0.05:  7.81, 0.025:  9.35, 0.01: 11.34, 0.005: 12.84 },
        4: { 0.995:  0.21, 0.99:  0.30, 0.975:  0.48, 0.95:  0.71, 0.9:  1.06, 0.5:  3.36, 0.1:  7.78, 0.05:  9.49, 0.025: 11.14, 0.01: 13.28, 0.005: 14.86 },
        5: { 0.995:  0.41, 0.99:  0.55, 0.975:  0.83, 0.95:  1.15, 0.9:  1.61, 0.5:  4.35, 0.1:  9.24, 0.05: 11.07, 0.025: 12.83, 0.01: 15.09, 0.005: 16.75 },
        6: { 0.995:  0.68, 0.99:  0.87, 0.975:  1.24, 0.95:  1.64, 0.9:  2.20, 0.5:  5.35, 0.1: 10.65, 0.05: 12.59, 0.025: 14.45, 0.01: 16.81, 0.005: 18.55 },
        7: { 0.995:  0.99, 0.99:  1.25, 0.975:  1.69, 0.95:  2.17, 0.9:  2.83, 0.5:  6.35, 0.1: 12.02, 0.05: 14.07, 0.025: 16.01, 0.01: 18.48, 0.005: 20.28 },
        8: { 0.995:  1.34, 0.99:  1.65, 0.975:  2.18, 0.95:  2.73, 0.9:  3.49, 0.5:  7.34, 0.1: 13.36, 0.05: 15.51, 0.025: 17.53, 0.01: 20.09, 0.005: 21.96 },
        9: { 0.995:  1.73, 0.99:  2.09, 0.975:  2.70, 0.95:  3.33, 0.9:  4.17, 0.5:  8.34, 0.1: 14.68, 0.05: 16.92, 0.025: 19.02, 0.01: 21.67, 0.005: 23.59 },
        10: { 0.995:  2.16, 0.99:  2.56, 0.975:  3.25, 0.95:  3.94, 0.9:  4.87, 0.5:  9.34, 0.1: 15.99, 0.05: 18.31, 0.025: 20.48, 0.01: 23.21, 0.005: 25.19 },
        11: { 0.995:  2.60, 0.99:  3.05, 0.975:  3.82, 0.95:  4.57, 0.9:  5.58, 0.5: 10.34, 0.1: 17.28, 0.05: 19.68, 0.025: 21.92, 0.01: 24.72, 0.005: 26.76 },
        12: { 0.995:  3.07, 0.99:  3.57, 0.975:  4.40, 0.95:  5.23, 0.9:  6.30, 0.5: 11.34, 0.1: 18.55, 0.05: 21.03, 0.025: 23.34, 0.01: 26.22, 0.005: 28.30 },
        13: { 0.995:  3.57, 0.99:  4.11, 0.975:  5.01, 0.95:  5.89, 0.9:  7.04, 0.5: 12.34, 0.1: 19.81, 0.05: 22.36, 0.025: 24.74, 0.01: 27.69, 0.005: 29.82 },
        14: { 0.995:  4.07, 0.99:  4.66, 0.975:  5.63, 0.95:  6.57, 0.9:  7.79, 0.5: 13.34, 0.1: 21.06, 0.05: 23.68, 0.025: 26.12, 0.01: 29.14, 0.005: 31.32 },
        15: { 0.995:  4.60, 0.99:  5.23, 0.975:  6.27, 0.95:  7.26, 0.9:  8.55, 0.5: 14.34, 0.1: 22.31, 0.05: 25.00, 0.025: 27.49, 0.01: 30.58, 0.005: 32.80 },
        16: { 0.995:  5.14, 0.99:  5.81, 0.975:  6.91, 0.95:  7.96, 0.9:  9.31, 0.5: 15.34, 0.1: 23.54, 0.05: 26.30, 0.025: 28.85, 0.01: 32.00, 0.005: 34.27 },
        17: { 0.995:  5.70, 0.99:  6.41, 0.975:  7.56, 0.95:  8.67, 0.9: 10.09, 0.5: 16.34, 0.1: 24.77, 0.05: 27.59, 0.025: 30.19, 0.01: 33.41, 0.005: 35.72 },
        18: { 0.995:  6.26, 0.99:  7.01, 0.975:  8.23, 0.95:  9.39, 0.9: 10.87, 0.5: 17.34, 0.1: 25.99, 0.05: 28.87, 0.025: 31.53, 0.01: 34.81, 0.005: 37.16 },
        19: { 0.995:  6.84, 0.99:  7.63, 0.975:  8.91, 0.95: 10.12, 0.9: 11.65, 0.5: 18.34, 0.1: 27.20, 0.05: 30.14, 0.025: 32.85, 0.01: 36.19, 0.005: 38.58 },
        20: { 0.995:  7.43, 0.99:  8.26, 0.975:  9.59, 0.95: 10.85, 0.9: 12.44, 0.5: 19.34, 0.1: 28.41, 0.05: 31.41, 0.025: 34.17, 0.01: 37.57, 0.005: 40.00 },
        21: { 0.995:  8.03, 0.99:  8.90, 0.975: 10.28, 0.95: 11.59, 0.9: 13.24, 0.5: 20.34, 0.1: 29.62, 0.05: 32.67, 0.025: 35.48, 0.01: 38.93, 0.005: 41.40 },
        22: { 0.995:  8.64, 0.99:  9.54, 0.975: 10.98, 0.95: 12.34, 0.9: 14.04, 0.5: 21.34, 0.1: 30.81, 0.05: 33.92, 0.025: 36.78, 0.01: 40.29, 0.005: 42.80 },
        23: { 0.995:  9.26, 0.99: 10.20, 0.975: 11.69, 0.95: 13.09, 0.9: 14.85, 0.5: 22.34, 0.1: 32.01, 0.05: 35.17, 0.025: 38.08, 0.01: 41.64, 0.005: 44.18 },
        24: { 0.995:  9.89, 0.99: 10.86, 0.975: 12.40, 0.95: 13.85, 0.9: 15.66, 0.5: 23.34, 0.1: 33.20, 0.05: 36.42, 0.025: 39.36, 0.01: 42.98, 0.005: 45.56 },
        25: { 0.995: 10.52, 0.99: 11.52, 0.975: 13.12, 0.95: 14.61, 0.9: 16.47, 0.5: 24.34, 0.1: 34.28, 0.05: 37.65, 0.025: 40.65, 0.01: 44.31, 0.005: 46.93 },
        26: { 0.995: 11.16, 0.99: 12.20, 0.975: 13.84, 0.95: 15.38, 0.9: 17.29, 0.5: 25.34, 0.1: 35.56, 0.05: 38.89, 0.025: 41.92, 0.01: 45.64, 0.005: 48.29 },
        27: { 0.995: 11.81, 0.99: 12.88, 0.975: 14.57, 0.95: 16.15, 0.9: 18.11, 0.5: 26.34, 0.1: 36.74, 0.05: 40.11, 0.025: 43.19, 0.01: 46.96, 0.005: 49.65 },
        28: { 0.995: 12.46, 0.99: 13.57, 0.975: 15.31, 0.95: 16.93, 0.9: 18.94, 0.5: 27.34, 0.1: 37.92, 0.05: 41.34, 0.025: 44.46, 0.01: 48.28, 0.005: 50.99 },
        29: { 0.995: 13.12, 0.99: 14.26, 0.975: 16.05, 0.95: 17.71, 0.9: 19.77, 0.5: 28.34, 0.1: 39.09, 0.05: 42.56, 0.025: 45.72, 0.01: 49.59, 0.005: 52.34 },
        30: { 0.995: 13.79, 0.99: 14.95, 0.975: 16.79, 0.95: 18.49, 0.9: 20.60, 0.5: 29.34, 0.1: 40.26, 0.05: 43.77, 0.025: 46.98, 0.01: 50.89, 0.005: 53.67 },
        40: { 0.995: 20.71, 0.99: 22.16, 0.975: 24.43, 0.95: 26.51, 0.9: 29.05, 0.5: 39.34, 0.1: 51.81, 0.05: 55.76, 0.025: 59.34, 0.01: 63.69, 0.005: 66.77 },
        50: { 0.995: 27.99, 0.99: 29.71, 0.975: 32.36, 0.95: 34.76, 0.9: 37.69, 0.5: 49.33, 0.1: 63.17, 0.05: 67.50, 0.025: 71.42, 0.01: 76.15, 0.005: 79.49 },
        60: { 0.995: 35.53, 0.99: 37.48, 0.975: 40.48, 0.95: 43.19, 0.9: 46.46, 0.5: 59.33, 0.1: 74.40, 0.05: 79.08, 0.025: 83.30, 0.01: 88.38, 0.005: 91.95 },
        70: { 0.995: 43.28, 0.99: 45.44, 0.975: 48.76, 0.95: 51.74, 0.9: 55.33, 0.5: 69.33, 0.1: 85.53, 0.05: 90.53, 0.025: 95.02, 0.01: 100.42, 0.005: 104.22 },
        80: { 0.995: 51.17, 0.99: 53.54, 0.975: 57.15, 0.95: 60.39, 0.9: 64.28, 0.5: 79.33, 0.1: 96.58, 0.05: 101.88, 0.025: 106.63, 0.01: 112.33, 0.005: 116.32 },
        90: { 0.995: 59.20, 0.99: 61.75, 0.975: 65.65, 0.95: 69.13, 0.9: 73.29, 0.5: 89.33, 0.1: 107.57, 0.05: 113.14, 0.025: 118.14, 0.01: 124.12, 0.005: 128.30 },
        100: { 0.995: 67.33, 0.99: 70.06, 0.975: 74.22, 0.95: 77.93, 0.9: 82.36, 0.5: 99.33, 0.1: 118.50, 0.05: 124.34, 0.025: 129.56, 0.01: 135.81, 0.005: 140.17 }
    };

    // # χ2 (Chi-Squared) Goodness-of-Fit Test
    //
    // The [χ2 (Chi-Squared) Goodness-of-Fit Test](http://en.wikipedia.org/wiki/Goodness_of_fit#Pearson.27s_chi-squared_test)
    // uses a measure of goodness of fit which is the sum of differences between observed and expected outcome frequencies
    // (that is, counts of observations), each squared and divided by the number of observations expected given the
    // hypothesized distribution. The resulting χ2 statistic, `chi_squared`, can be compared to the chi-squared distribution
    // to determine the goodness of fit. In order to determine the degrees of freedom of the chi-squared distribution, one
    // takes the total number of observed frequencies and subtracts the number of estimated parameters. The test statistic
    // follows, approximately, a chi-square distribution with (k − c) degrees of freedom where `k` is the number of non-empty
    // cells and `c` is the number of estimated parameters for the distribution.
    function chi_squared_goodness_of_fit(data, distribution_type, significance) {
        // Estimate from the sample data, a weighted mean.
        var input_mean = mean(data),
            // Calculated value of the χ2 statistic.
            chi_squared = 0,
            // Degrees of freedom, calculated as (number of class intervals -
            // number of hypothesized distribution parameters estimated - 1)
            degrees_of_freedom,
            // Number of hypothesized distribution parameters estimated, expected to be supplied in the distribution test.
            // Lose one degree of freedom for estimating `lambda` from the sample data.
            c = 1,
            // The hypothesized distribution.
            // Generate the hypothesized distribution.
            hypothesized_distribution = distribution_type(input_mean),
            observed_frequencies = [],
            expected_frequencies = [],
            k;

        // Create an array holding a histogram from the sample data, of
        // the form `{ value: numberOfOcurrences }`
        for (var i = 0; i < data.length; i++) {
            if (observed_frequencies[data[i]] === undefined) {
                observed_frequencies[data[i]] = 0;
            }
            observed_frequencies[data[i]]++;
        }

        // The histogram we created might be sparse - there might be gaps
        // between values. So we iterate through the histogram, making
        // sure that instead of undefined, gaps have 0 values.
        for (i = 0; i < observed_frequencies.length; i++) {
            if (observed_frequencies[i] === undefined) {
                observed_frequencies[i] = 0;
            }
        }

        // Create an array holding a histogram of expected data given the
        // sample size and hypothesized distribution.
        for (k in hypothesized_distribution) {
            if (k in observed_frequencies) {
                expected_frequencies[k] = hypothesized_distribution[k] * data.length;
            }
        }

        // Working backward through the expected frequencies, collapse classes
        // if less than three observations are expected for a class.
        // This transformation is applied to the observed frequencies as well.
        for (k = expected_frequencies.length - 1; k >= 0; k--) {
            if (expected_frequencies[k] < 3) {
                expected_frequencies[k - 1] += expected_frequencies[k];
                expected_frequencies.pop();

                observed_frequencies[k - 1] += observed_frequencies[k];
                observed_frequencies.pop();
            }
        }

        // Iterate through the squared differences between observed & expected
        // frequencies, accumulating the `chi_squared` statistic.
        for (k = 0; k < observed_frequencies.length; k++) {
            chi_squared += Math.pow(
                observed_frequencies[k] - expected_frequencies[k], 2) /
                expected_frequencies[k];
        }

        // Calculate degrees of freedom for this test and look it up in the
        // `chi_squared_distribution_table` in order to
        // accept or reject the goodness-of-fit of the hypothesized distribution.
        degrees_of_freedom = observed_frequencies.length - c - 1;
        return chi_squared_distribution_table[degrees_of_freedom][significance] < chi_squared;
    }

    // # Mixin
    //
    // Mixin simple_statistics to a single Array instance if provided
    // or the Array native object if not. This is an optional
    // feature that lets you treat simple_statistics as a native feature
    // of Javascript.
    function mixin(array) {
        var support = !!(Object.defineProperty && Object.defineProperties);
        if (!support) throw new Error('without defineProperty, simple-statistics cannot be mixed in');

        // only methods which work on basic arrays in a single step
        // are supported
        var arrayMethods = ['median', 'standard_deviation', 'sum',
            'sample_skewness',
            'mean', 'min', 'max', 'quantile', 'geometric_mean',
            'harmonic_mean', 'root_mean_square'];

        // create a closure with a method name so that a reference
        // like `arrayMethods[i]` doesn't follow the loop increment
        function wrap(method) {
            return function() {
                // cast any arguments into an array, since they're
                // natively objects
                var args = Array.prototype.slice.apply(arguments);
                // make the first argument the array itself
                args.unshift(this);
                // return the result of the ss method
                return ss[method].apply(ss, args);
            };
        }

        // select object to extend
        var extending;
        if (array) {
            // create a shallow copy of the array so that our internal
            // operations do not change it by reference
            extending = array.slice();
        } else {
            extending = Array.prototype;
        }

        // for each array function, define a function that gets
        // the array as the first argument.
        // We use [defineProperty](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/defineProperty)
        // because it allows these properties to be non-enumerable:
        // `for (var in x)` loops will not run into problems with this
        // implementation.
        for (var i = 0; i < arrayMethods.length; i++) {
            Object.defineProperty(extending, arrayMethods[i], {
                value: wrap(arrayMethods[i]),
                configurable: true,
                enumerable: false,
                writable: true
            });
        }

        return extending;
    }

    ss.linear_regression = linear_regression;
    ss.standard_deviation = standard_deviation;
    ss.r_squared = r_squared;
    ss.median = median;
    ss.mean = mean;
    ss.mode = mode;
    ss.min = min;
    ss.max = max;
    ss.sum = sum;
    ss.quantile = quantile;
    ss.quantile_sorted = quantile_sorted;
    ss.iqr = iqr;
    ss.mad = mad;

    ss.chunk = chunk;
    ss.shuffle = shuffle;
    ss.shuffle_in_place = shuffle_in_place;

    ss.sample = sample;

    ss.sample_covariance = sample_covariance;
    ss.sample_correlation = sample_correlation;
    ss.sample_variance = sample_variance;
    ss.sample_standard_deviation = sample_standard_deviation;
    ss.sample_skewness = sample_skewness;

    ss.geometric_mean = geometric_mean;
    ss.harmonic_mean = harmonic_mean;
    ss.root_mean_square = root_mean_square;
    ss.variance = variance;
    ss.t_test = t_test;
    ss.t_test_two_sample = t_test_two_sample;

    // jenks
    ss.jenksMatrices = jenksMatrices;
    ss.jenksBreaks = jenksBreaks;
    ss.jenks = jenks;

    ss.bayesian = bayesian;

    // Distribution-related methods
    ss.epsilon = epsilon; // We make ε available to the test suite.
    ss.factorial = factorial;
    ss.bernoulli_distribution = bernoulli_distribution;
    ss.binomial_distribution = binomial_distribution;
    ss.poisson_distribution = poisson_distribution;
    ss.chi_squared_goodness_of_fit = chi_squared_goodness_of_fit;

    // Normal distribution
    ss.z_score = z_score;
    ss.cumulative_std_normal_probability = cumulative_std_normal_probability;
    ss.standard_normal_table = standard_normal_table;
    ss.error_function = error_function;

    // Alias this into its common name
    ss.average = mean;
    ss.interquartile_range = iqr;
    ss.mixin = mixin;
    ss.median_absolute_deviation = mad;
    ss.rms = root_mean_square;
    ss.erf = error_function;

})(this);

},{}],114:[function(require,module,exports){
var invariant = require('turf-invariant');
//http://en.wikipedia.org/wiki/Haversine_formula
//http://www.movable-type.co.uk/scripts/latlong.html

/**
 * Takes two {@link Point} features and calculates
 * the distance between them in degress, radians,
 * miles, or kilometers. This uses the
 * [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula)
 * to account for global curvature.
 *
 * @module turf/distance
 * @category measurement
 * @param {Feature} from origin point
 * @param {Feature} to destination point
 * @param {String} [units=kilometers] can be degrees, radians, miles, or kilometers
 * @return {Number} distance between the two points
 * @example
 * var point1 = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-75.343, 39.984]
 *   }
 * };
 * var point2 = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-75.534, 39.123]
 *   }
 * };
 * var units = "miles";
 *
 * var points = {
 *   "type": "FeatureCollection",
 *   "features": [point1, point2]
 * };
 *
 * //=points
 *
 * var distance = turf.distance(point1, point2, units);
 *
 * //=distance
 */
module.exports = function(point1, point2, units){
  invariant.featureOf(point1, 'Point', 'distance');
  invariant.featureOf(point2, 'Point', 'distance');
  var coordinates1 = point1.geometry.coordinates;
  var coordinates2 = point2.geometry.coordinates;

  var dLat = toRad(coordinates2[1] - coordinates1[1]);
  var dLon = toRad(coordinates2[0] - coordinates1[0]);
  var lat1 = toRad(coordinates1[1]);
  var lat2 = toRad(coordinates2[1]);
  var a = Math.sin(dLat/2) * Math.sin(dLat/2) +
          Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2);
  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

  var R;
  switch(units){
    case 'miles':
      R = 3960;
      break;
    case 'kilometers':
      R = 6373;
      break;
    case 'degrees':
      R = 57.2957795;
      break;
    case 'radians':
      R = 1;
      break;
    case undefined:
      R = 6373;
      break;
    default:
      throw new Error('unknown option given to "units"');
  }

  var distance = R * c;
  return distance;
};

function toRad(degree) {
  return degree * Math.PI / 180;
}

},{"turf-invariant":115}],115:[function(require,module,exports){
module.exports.geojsonType = geojsonType;
module.exports.collectionOf = collectionOf;
module.exports.featureOf = featureOf;

/**
 * Enforce expectations about types of GeoJSON objects for Turf.
 *
 * @alias geojsonType
 * @param {GeoJSON} value any GeoJSON object
 * @param {string} type expected GeoJSON type
 * @param {String} name name of calling function
 * @throws Error if value is not the expected type.
 */
function geojsonType(value, type, name) {
    if (!type || !name) throw new Error('type and name required');

    if (!value || value.type !== type) {
        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);
    }
}

/**
 * Enforce expectations about types of {@link Feature} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @alias featureOf
 * @param {Feature} feature a feature with an expected geometry type
 * @param {string} type expected GeoJSON type
 * @param {String} name name of calling function
 * @throws Error if value is not the expected type.
 */
function featureOf(value, type, name) {
    if (!name) throw new Error('.featureOf() requires a name');
    if (!value || value.type !== 'Feature' || !value.geometry) {
        throw new Error('Invalid input to ' + name + ', Feature with geometry required');
    }
    if (!value.geometry || value.geometry.type !== type) {
        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.geometry.type);
    }
}

/**
 * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @alias collectionOf
 * @param {FeatureCollection} featurecollection a featurecollection for which features will be judged
 * @param {string} type expected GeoJSON type
 * @param {String} name name of calling function
 * @throws Error if value is not the expected type.
 */
function collectionOf(value, type, name) {
    if (!name) throw new Error('.collectionOf() requires a name');
    if (!value || value.type !== 'FeatureCollection') {
        throw new Error('Invalid input to ' + name + ', FeatureCollection required');
    }
    for (var i = 0; i < value.features.length; i++) {
        var feature = value.features[i];
        if (!feature || feature.type !== 'Feature' || !feature.geometry) {
            throw new Error('Invalid input to ' + name + ', Feature with geometry required');
        }
        if (!feature.geometry || feature.geometry.type !== type) {
            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);
        }
    }
}

},{}],116:[function(require,module,exports){
var extent = require('turf-extent');
var bboxPolygon = require('turf-bbox-polygon');

/**
 * Takes a {@link Feature} or {@link FeatureCollection} and returns a rectangular {@link Polygon} feature that encompasses all vertices.
 *
 * @module turf/envelope
 * @category measurement
 * @param {FeatureCollection} fc a FeatureCollection of any type
 * @return {Polygon} a rectangular Polygon feature that encompasses all vertices
 * @example
 * var fc = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "name": "Location A"
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-75.343, 39.984]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "name": "Location B"
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-75.833, 39.284]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "name": "Location C"
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-75.534, 39.123]
 *       }
 *     }
 *   ]
 * };
 *
 * var enveloped = turf.envelope(fc);
 *
 * var resultFeatures = fc.features.concat(enveloped);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */

module.exports = function(features, done){
  var bbox = extent(features);
  var poly = bboxPolygon(bbox);
  return poly;
}

},{"turf-bbox-polygon":66,"turf-extent":124}],117:[function(require,module,exports){
// depend on jsts for now https://github.com/bjornharrtell/jsts/blob/master/examples/overlay.html
var jsts = require('jsts');

/**
 * Finds the difference between two polygons by clipping the second
 * polygon from the first.
 *
 * @module turf/erase
 * @category transformation
 * @param {Polygon} poly1 input Polygon feaure
 * @param {Polygon} poly2 Polygon feature to erase from `poly1`
 * @return {Polygon} a Polygon feature showing the area of `poly1` excluding the area of `poly2`
 * @example
 * var poly1 = {
 *   "type": "Feature",
 *   "properties": {
 *     "fill": "#0f0"
 *   },
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-46.738586, -23.596711],
 *       [-46.738586, -23.458207],
 *       [-46.560058, -23.458207],
 *       [-46.560058, -23.596711],
 *       [-46.738586, -23.596711]
 *     ]]
 *   }
 * };
 * var poly2 = {
 *   "type": "Feature",
 *   "properties": {
 *     "fill": "#00f"
 *   },
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-46.650009, -23.631314],
 *       [-46.650009, -23.5237],
 *       [-46.509246, -23.5237],
 *       [-46.509246, -23.631314],
 *       [-46.650009, -23.631314]
 *     ]]
 *   }
 * };
 *
 * var erased = turf.erase(poly1, poly2);
 * erased.properties.fill = '#f00';
 *
 * var polygons = {
 *   "type": "FeatureCollection",
 *   "features": [poly1, poly2]
 * };
 *
 * //=polygons
 *
 * //=erased
 */

module.exports = function(p1, p2, done){
  var poly1 = JSON.parse(JSON.stringify(p1));
  var poly2 = JSON.parse(JSON.stringify(p2));
  if(poly1.type !== 'Feature') {
    poly1 = {
      type: 'Feature',
      properties: {},
      geometry: poly1
    };
  }
  if(poly2.type !== 'Feature') {
    poly2 = {
      type: 'Feature',
      properties: {},
      geometry: poly2
    };
  }

  var reader = new jsts.io.GeoJSONReader();
  var a = reader.read(JSON.stringify(poly1.geometry));
  var b = reader.read(JSON.stringify(poly2.geometry));
  var erased = a.difference(b);
  var parser = new jsts.io.GeoJSONParser();
  erased = parser.write(erased);

  poly1.geometry = erased;

  if (poly1.geometry.type === 'GeometryCollection' && poly1.geometry.geometries.length === 0) {
    return;
  } else {
    return {
      type: 'Feature',
      properties: poly1.properties,
      geometry: erased
    };
  }
};

},{"jsts":118}],118:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"./lib/jsts":119,"dup":19,"javascript.util":121}],119:[function(require,module,exports){
arguments[4][72][0].apply(exports,arguments)
},{"dup":72}],120:[function(require,module,exports){
(function (global){
/*
  javascript.util is a port of selected parts of java.util to JavaScript which
  main purpose is to ease porting Java code to JavaScript.
  
  The MIT License (MIT)

  Copyright (C) 2011-2014 by The Authors

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
*/
;(function(){var e=this;function f(a,b){var c=a.split("."),d=e;c[0]in d||!d.execScript||d.execScript("var "+c[0]);for(var t;c.length&&(t=c.shift());)c.length||void 0===b?d=d[t]?d[t]:d[t]={}:d[t]=b}function g(a,b){function c(){}c.prototype=b.prototype;a.q=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.p=function(a,c,O){var M=Array.prototype.slice.call(arguments,2);return b.prototype[c].apply(a,M)}};function h(a){this.message=a||""}g(h,Error);f("javascript.util.EmptyStackException",h);h.prototype.name="EmptyStackException";function k(a){this.message=a||""}g(k,Error);f("javascript.util.IndexOutOfBoundsException",k);k.prototype.name="IndexOutOfBoundsException";function l(){}f("javascript.util.Iterator",l);l.prototype.hasNext=l.prototype.c;l.prototype.next=l.prototype.next;l.prototype.remove=l.prototype.remove;function m(){}f("javascript.util.Collection",m);function n(){}g(n,m);f("javascript.util.List",n);function p(){}f("javascript.util.Map",p);function q(a){this.message=a||""}g(q,Error);f("javascript.util.NoSuchElementException",q);q.prototype.name="NoSuchElementException";function r(a){this.message=a||""}g(r,Error);r.prototype.name="OperationNotSupported";function s(a){this.a=[];a instanceof m&&this.e(a)}g(s,n);f("javascript.util.ArrayList",s);s.prototype.a=null;s.prototype.add=function(a){this.a.push(a);return!0};s.prototype.add=s.prototype.add;s.prototype.e=function(a){for(a=a.f();a.c();)this.add(a.next());return!0};s.prototype.addAll=s.prototype.e;s.prototype.set=function(a,b){var c=this.a[a];this.a[a]=b;return c};s.prototype.set=s.prototype.set;s.prototype.f=function(){return new u(this)};s.prototype.iterator=s.prototype.f;
s.prototype.get=function(a){if(0>a||a>=this.size())throw new k;return this.a[a]};s.prototype.get=s.prototype.get;s.prototype.g=function(){return 0===this.a.length};s.prototype.isEmpty=s.prototype.g;s.prototype.size=function(){return this.a.length};s.prototype.size=s.prototype.size;s.prototype.h=function(){for(var a=[],b=0,c=this.a.length;b<c;b++)a.push(this.a[b]);return a};s.prototype.toArray=s.prototype.h;
s.prototype.remove=function(a){for(var b=!1,c=0,d=this.a.length;c<d;c++)if(this.a[c]===a){this.a.splice(c,1);b=!0;break}return b};s.prototype.remove=s.prototype.remove;function u(a){this.j=a}f("$jscomp.scope.Iterator_",u);u.prototype.j=null;u.prototype.b=0;u.prototype.next=function(){if(this.b===this.j.size())throw new q;return this.j.get(this.b++)};u.prototype.next=u.prototype.next;u.prototype.c=function(){return this.b<this.j.size()?!0:!1};u.prototype.hasNext=u.prototype.c;
u.prototype.remove=function(){throw new r;};u.prototype.remove=u.prototype.remove;function v(){}f("javascript.util.Arrays",v);
v.sort=function(){var a=arguments[0],b,c,d;if(1===arguments.length)a.sort();else if(2===arguments.length)c=arguments[1],d=function(a,b){return c.compare(a,b)},a.sort(d);else if(3===arguments.length)for(b=a.slice(arguments[1],arguments[2]),b.sort(),d=a.slice(0,arguments[1]).concat(b,a.slice(arguments[2],a.length)),a.splice(0,a.length),b=0;b<d.length;b++)a.push(d[b]);else if(4===arguments.length)for(b=a.slice(arguments[1],arguments[2]),c=arguments[3],d=function(a,b){return c.compare(a,b)},b.sort(d),
d=a.slice(0,arguments[1]).concat(b,a.slice(arguments[2],a.length)),a.splice(0,a.length),b=0;b<d.length;b++)a.push(d[b])};v.asList=function(a){for(var b=new s,c=0,d=a.length;c<d;c++)b.add(a[c]);return b};function w(){this.i={}}g(w,p);f("javascript.util.HashMap",w);w.prototype.i=null;w.prototype.get=function(a){return this.i[a]||null};w.prototype.get=w.prototype.get;w.prototype.put=function(a,b){return this.i[a]=b};w.prototype.put=w.prototype.put;w.prototype.m=function(){var a=new s,b;for(b in this.i)this.i.hasOwnProperty(b)&&a.add(this.i[b]);return a};w.prototype.values=w.prototype.m;w.prototype.size=function(){return this.m().size()};w.prototype.size=w.prototype.size;function x(){}g(x,m);f("javascript.util.Set",x);function y(a){this.a=[];a instanceof m&&this.e(a)}g(y,x);f("javascript.util.HashSet",y);y.prototype.a=null;y.prototype.contains=function(a){for(var b=0,c=this.a.length;b<c;b++)if(this.a[b]===a)return!0;return!1};y.prototype.contains=y.prototype.contains;y.prototype.add=function(a){if(this.contains(a))return!1;this.a.push(a);return!0};y.prototype.add=y.prototype.add;y.prototype.e=function(a){for(a=a.f();a.c();)this.add(a.next());return!0};y.prototype.addAll=y.prototype.e;
y.prototype.remove=function(){throw new r;};y.prototype.remove=y.prototype.remove;y.prototype.size=function(){return this.a.length};y.prototype.g=function(){return 0===this.a.length};y.prototype.isEmpty=y.prototype.g;y.prototype.h=function(){for(var a=[],b=0,c=this.a.length;b<c;b++)a.push(this.a[b]);return a};y.prototype.toArray=y.prototype.h;y.prototype.f=function(){return new z(this)};y.prototype.iterator=y.prototype.f;function z(a){this.k=a}f("$jscomp.scope.Iterator_$1",z);z.prototype.k=null;
z.prototype.b=0;z.prototype.next=function(){if(this.b===this.k.size())throw new q;return this.k.a[this.b++]};z.prototype.next=z.prototype.next;z.prototype.c=function(){return this.b<this.k.size()?!0:!1};z.prototype.hasNext=z.prototype.c;z.prototype.remove=function(){throw new r;};z.prototype.remove=z.prototype.remove;function A(){}g(A,p);f("javascript.util.SortedMap",A);function B(){}g(B,x);f("javascript.util.SortedSet",B);function C(){this.a=[]}g(C,n);f("javascript.util.Stack",C);C.prototype.a=null;C.prototype.push=function(a){this.a.push(a);return a};C.prototype.push=C.prototype.push;C.prototype.pop=function(){if(0===this.a.length)throw new h;return this.a.pop()};C.prototype.pop=C.prototype.pop;C.prototype.o=function(){if(0===this.a.length)throw new h;return this.a[this.a.length-1]};C.prototype.peek=C.prototype.o;C.prototype.empty=function(){return 0===this.a.length?!0:!1};C.prototype.empty=C.prototype.empty;
C.prototype.g=function(){return this.empty()};C.prototype.isEmpty=C.prototype.g;C.prototype.search=function(a){return this.a.indexOf(a)};C.prototype.search=C.prototype.search;C.prototype.size=function(){return this.a.length};C.prototype.size=C.prototype.size;C.prototype.h=function(){for(var a=[],b=0,c=this.a.length;b<c;b++)a.push(this.a[b]);return a};C.prototype.toArray=C.prototype.h;function D(a){return null==a?null:a.parent}function E(a,b){null!==a&&(a.color=b)}function F(a){return null==a?null:a.left}function G(a){return null==a?null:a.right}function H(){this.d=null;this.n=0}g(H,A);f("javascript.util.TreeMap",H);H.prototype.get=function(a){for(var b=this.d;null!==b;){var c=a.compareTo(b.key);if(0>c)b=b.left;else if(0<c)b=b.right;else return b.value}return null};H.prototype.get=H.prototype.get;
H.prototype.put=function(a,b){if(null===this.d)return this.d={key:a,value:b,left:null,right:null,parent:null,color:0},this.n=1,null;var c=this.d,d,t;do if(d=c,t=a.compareTo(c.key),0>t)c=c.left;else if(0<t)c=c.right;else return d=c.value,c.value=b,d;while(null!==c);c={key:a,left:null,right:null,value:b,parent:d,color:0};0>t?d.left=c:d.right=c;for(c.color=1;null!=c&&c!=this.d&&1==c.parent.color;)D(c)==F(D(D(c)))?(d=G(D(D(c))),1==(null==d?0:d.color)?(E(D(c),0),E(d,0),E(D(D(c)),1),c=D(D(c))):(c==G(D(c))&&
(c=D(c),I(this,c)),E(D(c),0),E(D(D(c)),1),J(this,D(D(c))))):(d=F(D(D(c))),1==(null==d?0:d.color)?(E(D(c),0),E(d,0),E(D(D(c)),1),c=D(D(c))):(c==F(D(c))&&(c=D(c),J(this,c)),E(D(c),0),E(D(D(c)),1),I(this,D(D(c)))));this.d.color=0;this.n++;return null};H.prototype.put=H.prototype.put;H.prototype.m=function(){var a=new s,b;b=this.d;if(null!=b)for(;null!=b.left;)b=b.left;if(null!==b)for(a.add(b.value);null!==(b=K(b));)a.add(b.value);return a};H.prototype.values=H.prototype.m;
function I(a,b){if(null!=b){var c=b.right;b.right=c.left;null!=c.left&&(c.left.parent=b);c.parent=b.parent;null==b.parent?a.d=c:b.parent.left==b?b.parent.left=c:b.parent.right=c;c.left=b;b.parent=c}}function J(a,b){if(null!=b){var c=b.left;b.left=c.right;null!=c.right&&(c.right.parent=b);c.parent=b.parent;null==b.parent?a.d=c:b.parent.right==b?b.parent.right=c:b.parent.left=c;c.right=b;b.parent=c}}
function K(a){if(null===a)return null;if(null!==a.right)for(var b=a.right;null!==b.left;)b=b.left;else for(b=a.parent;null!==b&&a===b.right;)a=b,b=b.parent;return b}H.prototype.size=function(){return this.n};H.prototype.size=H.prototype.size;function L(a){this.a=[];a instanceof m&&this.e(a)}g(L,B);f("javascript.util.TreeSet",L);L.prototype.a=null;L.prototype.contains=function(a){for(var b=0,c=this.a.length;b<c;b++)if(0===this.a[b].compareTo(a))return!0;return!1};L.prototype.contains=L.prototype.contains;L.prototype.add=function(a){if(this.contains(a))return!1;for(var b=0,c=this.a.length;b<c;b++)if(1===this.a[b].compareTo(a))return this.a.splice(b,0,a),!0;this.a.push(a);return!0};L.prototype.add=L.prototype.add;
L.prototype.e=function(a){for(a=a.f();a.c();)this.add(a.next());return!0};L.prototype.addAll=L.prototype.e;L.prototype.remove=function(){throw new r;};L.prototype.remove=L.prototype.remove;L.prototype.size=function(){return this.a.length};L.prototype.size=L.prototype.size;L.prototype.g=function(){return 0===this.a.length};L.prototype.isEmpty=L.prototype.g;L.prototype.h=function(){for(var a=[],b=0,c=this.a.length;b<c;b++)a.push(this.a[b]);return a};L.prototype.toArray=L.prototype.h;L.prototype.f=function(){return new N(this)};
L.prototype.iterator=L.prototype.f;function N(a){this.l=a}f("$jscomp.scope.Iterator_$2",N);N.prototype.l=null;N.prototype.b=0;N.prototype.next=function(){if(this.b===this.l.size())throw new q;return this.l.a[this.b++]};N.prototype.next=N.prototype.next;N.prototype.c=function(){return this.b<this.l.size()?!0:!1};N.prototype.hasNext=N.prototype.c;N.prototype.remove=function(){throw new r;};N.prototype.remove=N.prototype.remove;"undefined"!==typeof global&&(global.javascript={},global.javascript.util={},global.javascript.util.ArrayList=s,global.javascript.util.Arrays=v,global.javascript.util.Collection=m,global.javascript.util.EmptyStackException=h,global.javascript.util.HashMap=w,global.javascript.util.HashSet=y,global.javascript.util.IndexOutOfBoundsException=k,global.javascript.util.Iterator=l,global.javascript.util.List=n,global.javascript.util.Map=p,global.javascript.util.NoSuchElementException=q,global.javascript.util.OperationNotSupported=
r,global.javascript.util.Set=x,global.javascript.util.SortedMap=A,global.javascript.util.SortedSet=B,global.javascript.util.Stack=C,global.javascript.util.TreeMap=H,global.javascript.util.TreeSet=L);}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],121:[function(require,module,exports){
arguments[4][74][0].apply(exports,arguments)
},{"./dist/javascript.util-node.min.js":120,"dup":74}],122:[function(require,module,exports){
var featureCollection = require('turf-featurecollection');
var each = require('turf-meta').coordEach;
var point = require('turf-point');

/**
 * Takes any {@link GeoJSON} object and return all positions as
 * a {@link FeatureCollection} of {@link Point} features.
 *
 * @module turf/explode
 * @category misc
 * @param {GeoJSON} input input features
 * @return {FeatureCollection} a FeatureCollection of {@link Point} features representing the exploded input features
 * @throws {Error} if it encounters an unknown geometry type
 * @example
 * var poly = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [177.434692, -17.77517],
 *       [177.402076, -17.779093],
 *       [177.38079, -17.803937],
 *       [177.40242, -17.826164],
 *       [177.438468, -17.824857],
 *       [177.454948, -17.796746],
 *       [177.434692, -17.77517]
 *     ]]
 *   }
 * };
 *
 * var points = turf.explode(poly);
 *
 * //=poly
 *
 * //=points
 */
module.exports = function(layer) {
  var points = [];
  each(layer, function(coord) {
    points.push(point(coord));
  });
  return featureCollection(points);
};

},{"turf-featurecollection":126,"turf-meta":123,"turf-point":156}],123:[function(require,module,exports){
arguments[4][77][0].apply(exports,arguments)
},{"dup":77}],124:[function(require,module,exports){
var each = require('turf-meta').coordEach;

/**
 * Takes any {@link GeoJSON} object, calculates the extent of all input features, and returns a bounding box.
 *
 * @module turf/extent
 * @category measurement
 * @param {GeoJSON} input any valid GeoJSON Object
 * @return {Array<number>} the bounding box of `input` given
 * as an array in WSEN order (west, south, east, north)
 * @example
 * var input = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [114.175329, 22.2524]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [114.170007, 22.267969]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [114.200649, 22.274641]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [114.186744, 22.265745]
 *       }
 *     }
 *   ]
 * };
 *
 * var bbox = turf.extent(input);
 *
 * var bboxPolygon = turf.bboxPolygon(bbox);
 *
 * var resultFeatures = input.features.concat(bboxPolygon);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */
module.exports = function(layer) {
    var extent = [Infinity, Infinity, -Infinity, -Infinity];
    each(layer, function(coord) {
      if (extent[0] > coord[0]) extent[0] = coord[0];
      if (extent[1] > coord[1]) extent[1] = coord[1];
      if (extent[2] < coord[0]) extent[2] = coord[0];
      if (extent[3] < coord[1]) extent[3] = coord[1];
    });
    return extent;
};

},{"turf-meta":125}],125:[function(require,module,exports){
arguments[4][77][0].apply(exports,arguments)
},{"dup":77}],126:[function(require,module,exports){
/**
 * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}
 *
 * @module turf/featurecollection
 * @category helper
 * @param {Feature} features input Features
 * @returns {FeatureCollection} a FeatureCollection of input features
 * @example
 * var features = [
 *  turf.point([-75.343, 39.984], {name: 'Location A'}),
 *  turf.point([-75.833, 39.284], {name: 'Location B'}),
 *  turf.point([-75.534, 39.123], {name: 'Location C'})
 * ];
 *
 * var fc = turf.featurecollection(features);
 *
 * //=fc
 */
module.exports = function(features){
  return {
    type: "FeatureCollection",
    features: features
  };
};

},{}],127:[function(require,module,exports){
var featureCollection = require('turf-featurecollection');

/**
 * Takes a {@link FeatureCollection} and filters it by a given property and value
 *
 * @module turf/filter
 * @category data
 * @param {FeatureCollection} features input FeatureCollection of any type
 * @param {String} key the property on which to filter
 * @param {String} value the value of that property on which to filter
 * @return {FeatureCollection} a filtered collection with only features that match input `key` and `value`
 * @example
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "species": "oak"
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-72.581777, 44.260875]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "species": "birch"
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-72.570018, 44.260691]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "species": "oak"
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-72.576284, 44.257925]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "species": "redwood"
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-72.56916, 44.254605]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "species": "maple"
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-72.581691, 44.24858]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "species": "oak"
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-72.583837, 44.255773]
 *       }
 *     }
 *   ]
 * };
 *
 * var key = "species";
 * var value = "oak";
 *
 * var filtered = turf.filter(features, key, value);
 *
 * //=features
 *
 * //=filtered
 */
module.exports = function(collection, key, val) {
  var newFC = featureCollection([]);
  for(var i = 0; i < collection.features.length; i++) {
    if(collection.features[i].properties[key] === val) {
      newFC.features.push(collection.features[i]);
    }
  }
  return newFC;
};

},{"turf-featurecollection":126}],128:[function(require,module,exports){
/**
 * Takes a {@link GeoJSON} object of any type and flips all of its coordinates
 * from `[x, y]` to `[y, x]`.
 *
 * @module turf/flip
 * @category misc
 * @param {GeoJSON} input input GeoJSON object
 * @returns {GeoJSON} a GeoJSON object of the same type as `input` with flipped coordinates
 * @example
 * var serbia = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [20.566406, 43.421008]
 *   }
 * };
 *
 * //=serbia
 *
 * var saudiArabia = turf.flip(serbia);
 *
 * //=saudiArabia
 */
module.exports = flipAny;

function flipAny(_) {
    // ensure that we don't modify features in-place and changes to the
    // output do not change the previous feature, including changes to nested
    // properties.
    var input = JSON.parse(JSON.stringify(_));
    switch (input.type) {
        case 'FeatureCollection':
            for (var i = 0; i < input.features.length; i++)
                flipGeometry(input.features[i].geometry);
            return input;
        case 'Feature':
            flipGeometry(input.geometry);
            return input;
        default:
            flipGeometry(input);
            return input;
    }
}

function flipGeometry(geometry) {
    var coords = geometry.coordinates;
    switch(geometry.type) {
      case 'Point':
        flip0(coords);
        break;
      case 'LineString':
      case 'MultiPoint':
        flip1(coords);
        break;
      case 'Polygon':
      case 'MultiLineString':
        flip2(coords);
        break;
      case 'MultiPolygon':
        flip3(coords);
        break;
      case 'GeometryCollection':
        geometry.geometries.forEach(flipGeometry);
        break;
    }
}

function flip0(coord) {
    coord.reverse();
}

function flip1(coords) {
  for(var i = 0; i < coords.length; i++) coords[i].reverse();
}

function flip2(coords) {
  for(var i = 0; i < coords.length; i++)
    for(var j = 0; j < coords[i].length; j++) coords[i][j].reverse();
}

function flip3(coords) {
  for(var i = 0; i < coords.length; i++)
    for(var j = 0; j < coords[i].length; j++)
      for(var k = 0; k < coords[i][j].length; k++) coords[i][j][k].reverse();
}

},{}],129:[function(require,module,exports){
var point = require('turf-point');
var polygon = require('turf-polygon');
var distance = require('turf-distance');
var featurecollection = require('turf-featurecollection');

/**
 * Takes a bounding box and a cell size in degrees and returns a {@link FeatureCollection} of flat-topped
 * hexagons ({@link Polygon} features) aligned in an "odd-q" vertical grid as
 * described in [Hexagonal Grids](http://www.redblobgames.com/grids/hexagons/)
 *
 * @module turf/hex-grid
 * @category interpolation
 * @param {Array<number>} bbox bounding box in [minX, minY, maxX, maxY] order
 * @param {Number} cellWidth width of cell in specified units
 * @param {String} units used in calculating cellWidth ('miles' or 'kilometers')
 * @return {FeatureCollection} units used in calculating cellWidth ('miles' or 'kilometers')
 * @example
 * var bbox = [-96,31,-84,40];
 * var cellWidth = 50;
 * var units = 'miles';
 *
 * var hexgrid = turf.hexGrid(bbox, cellWidth, units);
 *
 * //=hexgrid
 */

//Precompute cosines and sines of angles used in hexagon creation
// for performance gain
var cosines = [];
var sines = [];
for (var i = 0; i < 6; i++) {
  var angle = 2 * Math.PI/6 * i;
  cosines.push(Math.cos(angle));
  sines.push(Math.sin(angle));
}

module.exports = function hexgrid(bbox, cell, units) {
  var xFraction = cell / (distance(point([bbox[0], bbox[1]]), point([bbox[2], bbox[1]]), units));
  var cellWidth = xFraction * (bbox[2] - bbox[0]);
  var yFraction = cell / (distance(point([bbox[0], bbox[1]]), point([bbox[0], bbox[3]]), units));
  var cellHeight = yFraction * (bbox[3] - bbox[1]);
  var radius = cellWidth / 2;

  var hex_width = radius * 2;
  var hex_height = Math.sqrt(3)/2 * hex_width;

  var box_width = bbox[2] - bbox[0];
  var box_height = bbox[3] - bbox[1];

  var x_interval = 3/4 * hex_width;
  var y_interval = hex_height;

  var x_span = box_width / (hex_width - radius/2);
  var x_count = Math.ceil(x_span);
  if (Math.round(x_span) === x_count) {
    x_count++;
  }

  var x_adjust = ((x_count * x_interval - radius/2) - box_width)/2 - radius/2;

  var y_count = Math.ceil(box_height / hex_height);

  var y_adjust = (box_height - y_count * hex_height)/2;

  var hasOffsetY = y_count * hex_height - box_height > hex_height/2;
  if (hasOffsetY) {
    y_adjust -= hex_height/4;
  }

  var fc = featurecollection([]);
  for (var x = 0; x < x_count; x++) {
    for (var y = 0; y <= y_count; y++) {

      var isOdd = x % 2 === 1;
      if (y === 0 && isOdd) {
        continue;
      }

      if (y === 0 && hasOffsetY) {
        continue;
      }

      var center_x = x * x_interval + bbox[0] - x_adjust;
      var center_y = y * y_interval + bbox[1] + y_adjust;

      if (isOdd) {
        center_y -= hex_height/2;
      }
      fc.features.push(hexagon([center_x, center_y], radius));
    }
  }

  return fc;
};

//Center should be [x, y]
function hexagon(center, radius) {
  var vertices = [];
  for (var i = 0; i < 6; i++) {
    var x = center[0] + radius * cosines[i];
    var y = center[1] + radius * sines[i];
    vertices.push([x,y]);
  }
  //first and last vertex must be the same
  vertices.push(vertices[0]);
  return polygon([vertices]);
}
},{"turf-distance":114,"turf-featurecollection":126,"turf-point":156,"turf-polygon":157}],130:[function(require,module,exports){
// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule
// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js
// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html

/**
 * Takes a {@link Point} feature and a {@link Polygon} feature and determines if the Point resides inside the Polygon. The Polygon can
 * be convex or concave. The function accepts any valid Polygon or {@link MultiPolygon}
 * and accounts for holes.
 *
 * @module turf/inside
 * @category joins
 * @param {Point} point a Point feature
 * @param {Polygon} polygon a Polygon feature
 * @return {Boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon
 * @example
 * var pt1 = {
 *   "type": "Feature",
 *   "properties": {
 *     "marker-color": "#f00"
 *   },
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-111.467285, 40.75766]
 *   }
 * };
 * var pt2 = {
 *   "type": "Feature",
 *   "properties": {
 *     "marker-color": "#0f0"
 *   },
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-111.873779, 40.647303]
 *   }
 * };
 * var poly = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-112.074279, 40.52215],
 *       [-112.074279, 40.853293],
 *       [-111.610107, 40.853293],
 *       [-111.610107, 40.52215],
 *       [-112.074279, 40.52215]
 *     ]]
 *   }
 * };
 *
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [pt1, pt2, poly]
 * };
 *
 * //=features
 *
 * var isInside1 = turf.inside(pt1, poly);
 * //=isInside1
 *
 * var isInside2 = turf.inside(pt2, poly);
 * //=isInside2
 */
module.exports = function(point, polygon) {
  var polys = polygon.geometry.coordinates;
  var pt = [point.geometry.coordinates[0], point.geometry.coordinates[1]];
  // normalize to multipolygon
  if(polygon.geometry.type === 'Polygon') polys = [polys];

  var insidePoly = false;
  var i = 0;
  while (i < polys.length && !insidePoly) {
    // check if it is in the outer ring first
    if(inRing(pt, polys[i][0])) {
      var inHole = false;
      var k = 1;
      // check for the point in any of the holes
      while(k < polys[i].length && !inHole) {
        if(inRing(pt, polys[i][k])) {
          inHole = true;
        }
        k++;
      }
      if(!inHole) insidePoly = true;
    }
    i++;
  }
  return insidePoly;
}

// pt is [x,y] and ring is [[x,y], [x,y],..]
function inRing (pt, ring) {
  var isInside = false;
  for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
    var xi = ring[i][0], yi = ring[i][1];
    var xj = ring[j][0], yj = ring[j][1];
    
    var intersect = ((yi > pt[1]) != (yj > pt[1]))
        && (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi);
    if (intersect) isInside = !isInside;
  }
  return isInside;
}


},{}],131:[function(require,module,exports){
// depend on jsts for now https://github.com/bjornharrtell/jsts/blob/master/examples/overlay.html
var jsts = require('jsts');
var featurecollection = require('turf-featurecollection');

/**
 * Takes two {@link Polygon} features and finds their intersection.
 *
 * @module turf/intersect
 * @category transformation
 * @param {Polygon} poly1 the first Polygon
 * @param {Polygon} poly2 the second Polygon
 * @return {Polygon} a Polygon feature representing the area where `poly1` and `poly2` overlap
 * @example
 * var poly1 = turf.polygon([[
 *  [-122.801742, 45.48565],
 *  [-122.801742, 45.60491],
 *  [-122.584762, 45.60491],
 *  [-122.584762, 45.48565],
 *  [-122.801742, 45.48565]
 * ]]);
 * poly1.properties.fill = '#0f0';
 * var poly2 = turf.polygon([[
 *  [-122.520217, 45.535693],
 *  [-122.64038, 45.553967],
 *  [-122.720031, 45.526554],
 *  [-122.669906, 45.507309],
 *  [-122.723464, 45.446643],
 *  [-122.532577, 45.408574],
 *  [-122.487258, 45.477466],
 *  [-122.520217, 45.535693]
 * ]]);
 * poly2.properties.fill = '#00f';
 * var polygons = turf.featurecollection([poly1, poly2]);
 *
 * var intersection = turf.intersect(poly1, poly2);
 *
 * //=polygons
 *
 * //=intersection
 */
module.exports = function(poly1, poly2){
  var geom1;
  if(poly1.type === 'Feature') geom1 = poly1.geometry;
  else geom1 = poly1;
  if(poly2.type === 'Feature') geom2 = poly2.geometry;
  else geom2 = poly2;
  var reader = new jsts.io.GeoJSONReader();
  var a = reader.read(JSON.stringify(geom1));
  var b = reader.read(JSON.stringify(geom2));
  var intersection = a.intersection(b);
  var parser = new jsts.io.GeoJSONParser();

  intersection = parser.write(intersection);
  if(intersection.type === 'GeometryCollection' && intersection.geometries.length === 0) {
    return;
  } else {
    return {
      type: 'Feature',
      properties: {},
      geometry: intersection
    };
  }
};

},{"jsts":132,"turf-featurecollection":126}],132:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"./lib/jsts":133,"dup":19,"javascript.util":135}],133:[function(require,module,exports){
arguments[4][72][0].apply(exports,arguments)
},{"dup":72}],134:[function(require,module,exports){
(function (global){
/*
  javascript.util is a port of selected parts of java.util to JavaScript which
  main purpose is to ease porting Java code to JavaScript.
  
  The MIT License (MIT)

  Copyright (C) 2011-2014 by The Authors

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
*/
;(function(){var e=this;function f(a,b){var c=a.split("."),d=e;c[0]in d||!d.execScript||d.execScript("var "+c[0]);for(var t;c.length&&(t=c.shift());)c.length||void 0===b?d=d[t]?d[t]:d[t]={}:d[t]=b}function g(a,b){function c(){}c.prototype=b.prototype;a.q=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.p=function(a,c,O){var M=Array.prototype.slice.call(arguments,2);return b.prototype[c].apply(a,M)}};function h(a){this.message=a||""}g(h,Error);f("javascript.util.EmptyStackException",h);h.prototype.name="EmptyStackException";function k(a){this.message=a||""}g(k,Error);f("javascript.util.IndexOutOfBoundsException",k);k.prototype.name="IndexOutOfBoundsException";function l(){}f("javascript.util.Iterator",l);l.prototype.hasNext=l.prototype.c;l.prototype.next=l.prototype.next;l.prototype.remove=l.prototype.remove;function m(){}f("javascript.util.Collection",m);function n(){}g(n,m);f("javascript.util.List",n);function p(){}f("javascript.util.Map",p);function q(a){this.message=a||""}g(q,Error);f("javascript.util.NoSuchElementException",q);q.prototype.name="NoSuchElementException";function r(a){this.message=a||""}g(r,Error);r.prototype.name="OperationNotSupported";function s(a){this.a=[];a instanceof m&&this.e(a)}g(s,n);f("javascript.util.ArrayList",s);s.prototype.a=null;s.prototype.add=function(a){this.a.push(a);return!0};s.prototype.add=s.prototype.add;s.prototype.e=function(a){for(a=a.f();a.c();)this.add(a.next());return!0};s.prototype.addAll=s.prototype.e;s.prototype.set=function(a,b){var c=this.a[a];this.a[a]=b;return c};s.prototype.set=s.prototype.set;s.prototype.f=function(){return new u(this)};s.prototype.iterator=s.prototype.f;
s.prototype.get=function(a){if(0>a||a>=this.size())throw new k;return this.a[a]};s.prototype.get=s.prototype.get;s.prototype.g=function(){return 0===this.a.length};s.prototype.isEmpty=s.prototype.g;s.prototype.size=function(){return this.a.length};s.prototype.size=s.prototype.size;s.prototype.h=function(){for(var a=[],b=0,c=this.a.length;b<c;b++)a.push(this.a[b]);return a};s.prototype.toArray=s.prototype.h;
s.prototype.remove=function(a){for(var b=!1,c=0,d=this.a.length;c<d;c++)if(this.a[c]===a){this.a.splice(c,1);b=!0;break}return b};s.prototype.remove=s.prototype.remove;function u(a){this.j=a}f("$jscomp.scope.Iterator_",u);u.prototype.j=null;u.prototype.b=0;u.prototype.next=function(){if(this.b===this.j.size())throw new q;return this.j.get(this.b++)};u.prototype.next=u.prototype.next;u.prototype.c=function(){return this.b<this.j.size()?!0:!1};u.prototype.hasNext=u.prototype.c;
u.prototype.remove=function(){throw new r;};u.prototype.remove=u.prototype.remove;function v(){}f("javascript.util.Arrays",v);
v.sort=function(){var a=arguments[0],b,c,d;if(1===arguments.length)a.sort();else if(2===arguments.length)c=arguments[1],d=function(a,b){return c.compare(a,b)},a.sort(d);else if(3===arguments.length)for(b=a.slice(arguments[1],arguments[2]),b.sort(),d=a.slice(0,arguments[1]).concat(b,a.slice(arguments[2],a.length)),a.splice(0,a.length),b=0;b<d.length;b++)a.push(d[b]);else if(4===arguments.length)for(b=a.slice(arguments[1],arguments[2]),c=arguments[3],d=function(a,b){return c.compare(a,b)},b.sort(d),
d=a.slice(0,arguments[1]).concat(b,a.slice(arguments[2],a.length)),a.splice(0,a.length),b=0;b<d.length;b++)a.push(d[b])};v.asList=function(a){for(var b=new s,c=0,d=a.length;c<d;c++)b.add(a[c]);return b};function w(){this.i={}}g(w,p);f("javascript.util.HashMap",w);w.prototype.i=null;w.prototype.get=function(a){return this.i[a]||null};w.prototype.get=w.prototype.get;w.prototype.put=function(a,b){return this.i[a]=b};w.prototype.put=w.prototype.put;w.prototype.m=function(){var a=new s,b;for(b in this.i)this.i.hasOwnProperty(b)&&a.add(this.i[b]);return a};w.prototype.values=w.prototype.m;w.prototype.size=function(){return this.m().size()};w.prototype.size=w.prototype.size;function x(){}g(x,m);f("javascript.util.Set",x);function y(a){this.a=[];a instanceof m&&this.e(a)}g(y,x);f("javascript.util.HashSet",y);y.prototype.a=null;y.prototype.contains=function(a){for(var b=0,c=this.a.length;b<c;b++)if(this.a[b]===a)return!0;return!1};y.prototype.contains=y.prototype.contains;y.prototype.add=function(a){if(this.contains(a))return!1;this.a.push(a);return!0};y.prototype.add=y.prototype.add;y.prototype.e=function(a){for(a=a.f();a.c();)this.add(a.next());return!0};y.prototype.addAll=y.prototype.e;
y.prototype.remove=function(){throw new r;};y.prototype.remove=y.prototype.remove;y.prototype.size=function(){return this.a.length};y.prototype.g=function(){return 0===this.a.length};y.prototype.isEmpty=y.prototype.g;y.prototype.h=function(){for(var a=[],b=0,c=this.a.length;b<c;b++)a.push(this.a[b]);return a};y.prototype.toArray=y.prototype.h;y.prototype.f=function(){return new z(this)};y.prototype.iterator=y.prototype.f;function z(a){this.k=a}f("$jscomp.scope.Iterator_$1",z);z.prototype.k=null;
z.prototype.b=0;z.prototype.next=function(){if(this.b===this.k.size())throw new q;return this.k.a[this.b++]};z.prototype.next=z.prototype.next;z.prototype.c=function(){return this.b<this.k.size()?!0:!1};z.prototype.hasNext=z.prototype.c;z.prototype.remove=function(){throw new r;};z.prototype.remove=z.prototype.remove;function A(){}g(A,p);f("javascript.util.SortedMap",A);function B(){}g(B,x);f("javascript.util.SortedSet",B);function C(){this.a=[]}g(C,n);f("javascript.util.Stack",C);C.prototype.a=null;C.prototype.push=function(a){this.a.push(a);return a};C.prototype.push=C.prototype.push;C.prototype.pop=function(){if(0===this.a.length)throw new h;return this.a.pop()};C.prototype.pop=C.prototype.pop;C.prototype.o=function(){if(0===this.a.length)throw new h;return this.a[this.a.length-1]};C.prototype.peek=C.prototype.o;C.prototype.empty=function(){return 0===this.a.length?!0:!1};C.prototype.empty=C.prototype.empty;
C.prototype.g=function(){return this.empty()};C.prototype.isEmpty=C.prototype.g;C.prototype.search=function(a){return this.a.indexOf(a)};C.prototype.search=C.prototype.search;C.prototype.size=function(){return this.a.length};C.prototype.size=C.prototype.size;C.prototype.h=function(){for(var a=[],b=0,c=this.a.length;b<c;b++)a.push(this.a[b]);return a};C.prototype.toArray=C.prototype.h;function D(a){return null==a?null:a.parent}function E(a,b){null!==a&&(a.color=b)}function F(a){return null==a?null:a.left}function G(a){return null==a?null:a.right}function H(){this.d=null;this.n=0}g(H,A);f("javascript.util.TreeMap",H);H.prototype.get=function(a){for(var b=this.d;null!==b;){var c=a.compareTo(b.key);if(0>c)b=b.left;else if(0<c)b=b.right;else return b.value}return null};H.prototype.get=H.prototype.get;
H.prototype.put=function(a,b){if(null===this.d)return this.d={key:a,value:b,left:null,right:null,parent:null,color:0},this.n=1,null;var c=this.d,d,t;do if(d=c,t=a.compareTo(c.key),0>t)c=c.left;else if(0<t)c=c.right;else return d=c.value,c.value=b,d;while(null!==c);c={key:a,left:null,right:null,value:b,parent:d,color:0};0>t?d.left=c:d.right=c;for(c.color=1;null!=c&&c!=this.d&&1==c.parent.color;)D(c)==F(D(D(c)))?(d=G(D(D(c))),1==(null==d?0:d.color)?(E(D(c),0),E(d,0),E(D(D(c)),1),c=D(D(c))):(c==G(D(c))&&
(c=D(c),I(this,c)),E(D(c),0),E(D(D(c)),1),J(this,D(D(c))))):(d=F(D(D(c))),1==(null==d?0:d.color)?(E(D(c),0),E(d,0),E(D(D(c)),1),c=D(D(c))):(c==F(D(c))&&(c=D(c),J(this,c)),E(D(c),0),E(D(D(c)),1),I(this,D(D(c)))));this.d.color=0;this.n++;return null};H.prototype.put=H.prototype.put;H.prototype.m=function(){var a=new s,b;b=this.d;if(null!=b)for(;null!=b.left;)b=b.left;if(null!==b)for(a.add(b.value);null!==(b=K(b));)a.add(b.value);return a};H.prototype.values=H.prototype.m;
function I(a,b){if(null!=b){var c=b.right;b.right=c.left;null!=c.left&&(c.left.parent=b);c.parent=b.parent;null==b.parent?a.d=c:b.parent.left==b?b.parent.left=c:b.parent.right=c;c.left=b;b.parent=c}}function J(a,b){if(null!=b){var c=b.left;b.left=c.right;null!=c.right&&(c.right.parent=b);c.parent=b.parent;null==b.parent?a.d=c:b.parent.right==b?b.parent.right=c:b.parent.left=c;c.right=b;b.parent=c}}
function K(a){if(null===a)return null;if(null!==a.right)for(var b=a.right;null!==b.left;)b=b.left;else for(b=a.parent;null!==b&&a===b.right;)a=b,b=b.parent;return b}H.prototype.size=function(){return this.n};H.prototype.size=H.prototype.size;function L(a){this.a=[];a instanceof m&&this.e(a)}g(L,B);f("javascript.util.TreeSet",L);L.prototype.a=null;L.prototype.contains=function(a){for(var b=0,c=this.a.length;b<c;b++)if(0===this.a[b].compareTo(a))return!0;return!1};L.prototype.contains=L.prototype.contains;L.prototype.add=function(a){if(this.contains(a))return!1;for(var b=0,c=this.a.length;b<c;b++)if(1===this.a[b].compareTo(a))return this.a.splice(b,0,a),!0;this.a.push(a);return!0};L.prototype.add=L.prototype.add;
L.prototype.e=function(a){for(a=a.f();a.c();)this.add(a.next());return!0};L.prototype.addAll=L.prototype.e;L.prototype.remove=function(){throw new r;};L.prototype.remove=L.prototype.remove;L.prototype.size=function(){return this.a.length};L.prototype.size=L.prototype.size;L.prototype.g=function(){return 0===this.a.length};L.prototype.isEmpty=L.prototype.g;L.prototype.h=function(){for(var a=[],b=0,c=this.a.length;b<c;b++)a.push(this.a[b]);return a};L.prototype.toArray=L.prototype.h;L.prototype.f=function(){return new N(this)};
L.prototype.iterator=L.prototype.f;function N(a){this.l=a}f("$jscomp.scope.Iterator_$2",N);N.prototype.l=null;N.prototype.b=0;N.prototype.next=function(){if(this.b===this.l.size())throw new q;return this.l.a[this.b++]};N.prototype.next=N.prototype.next;N.prototype.c=function(){return this.b<this.l.size()?!0:!1};N.prototype.hasNext=N.prototype.c;N.prototype.remove=function(){throw new r;};N.prototype.remove=N.prototype.remove;"undefined"!==typeof global&&(global.javascript={},global.javascript.util={},global.javascript.util.ArrayList=s,global.javascript.util.Arrays=v,global.javascript.util.Collection=m,global.javascript.util.EmptyStackException=h,global.javascript.util.HashMap=w,global.javascript.util.HashSet=y,global.javascript.util.IndexOutOfBoundsException=k,global.javascript.util.Iterator=l,global.javascript.util.List=n,global.javascript.util.Map=p,global.javascript.util.NoSuchElementException=q,global.javascript.util.OperationNotSupported=
r,global.javascript.util.Set=x,global.javascript.util.SortedMap=A,global.javascript.util.SortedSet=B,global.javascript.util.Stack=C,global.javascript.util.TreeMap=H,global.javascript.util.TreeSet=L);}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],135:[function(require,module,exports){
arguments[4][74][0].apply(exports,arguments)
},{"./dist/javascript.util-node.min.js":134,"dup":74}],136:[function(require,module,exports){
/**
 * Copyright (c) 2010, Jason Davies.
 *
 * All rights reserved.  This code is based on Bradley White's Java version,
 * which is in turn based on Nicholas Yue's C++ version, which in turn is based
 * on Paul D. Bourke's original Fortran version.  See below for the respective
 * copyright notices.
 *
 * See http://local.wasp.uwa.edu.au/~pbourke/papers/conrec/ for the original
 * paper by Paul D. Bourke.
 *
 * The vector conversion code is based on http://apptree.net/conrec.htm by
 * Graham Cox.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the <organization> nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1996-1997 Nicholas Yue
 *
 * This software is copyrighted by Nicholas Yue. This code is based on Paul D.
 * Bourke's CONREC.F routine.
 *
 * The authors hereby grant permission to use, copy, and distribute this
 * software and its documentation for any purpose, provided that existing
 * copyright notices are retained in all copies and that this notice is
 * included verbatim in any distributions. Additionally, the authors grant
 * permission to modify this software and its documentation for any purpose,
 * provided that such modifications are not distributed without the explicit
 * consent of the authors and that existing copyright notices are retained in
 * all copies. Some of the algorithms implemented by this software are
 * patented, observe all applicable patent law.
 *
 * IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
 * OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES THEREOF,
 * EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE IS
 * PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE NO
 * OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
 * MODIFICATIONS.
 */


  module.exports = Conrec;

  var EPSILON = 1e-10;

  function pointsEqual(a, b) {
    var x = a.x - b.x, y = a.y - b.y;
    return x * x + y * y < EPSILON;
  }

  function reverseList(list) {
    var pp = list.head;

    while (pp) {
      // swap prev/next pointers
      var temp = pp.next;
      pp.next = pp.prev;
      pp.prev = temp;

      // continue through the list
      pp = temp;
    }

    // swap head/tail pointers
    var temp = list.head;
    list.head = list.tail;
    list.tail = temp;
  }

  function ContourBuilder(level) {
    this.level = level;
    this.s = null;
    this.count = 0;
  }
  ContourBuilder.prototype.remove_seq = function(list) {
    // if list is the first item, static ptr s is updated
    if (list.prev) {
      list.prev.next = list.next;
    } else {
      this.s = list.next;
    }

    if (list.next) {
      list.next.prev = list.prev;
    }
    --this.count;
  }
  ContourBuilder.prototype.addSegment = function(a, b) {
    var ss = this.s;
    var ma = null;
    var mb = null;
    var prependA = false;
    var prependB = false;

    while (ss) {
      if (ma == null) {
        // no match for a yet
        if (pointsEqual(a, ss.head.p)) {
          ma = ss;
          prependA = true;
        } else if (pointsEqual(a, ss.tail.p)) {
          ma = ss;
        }
      }
      if (mb == null) {
        // no match for b yet
        if (pointsEqual(b, ss.head.p)) {
          mb = ss;
          prependB = true;
        } else if (pointsEqual(b, ss.tail.p)) {
          mb = ss;
        }
      }
      // if we matched both no need to continue searching
      if (mb != null && ma != null) {
        break;
      } else {
        ss = ss.next;
      }
    }

    // c is the case selector based on which of ma and/or mb are set
    var c = ((ma != null) ? 1 : 0) | ((mb != null) ? 2 : 0);

    switch(c) {
      case 0:   // both unmatched, add as new sequence
        var aa = {p: a, prev: null};
        var bb = {p: b, next: null};
        aa.next = bb;
        bb.prev = aa;

        // create sequence element and push onto head of main list. The order
        // of items in this list is unimportant
        ma = {head: aa, tail: bb, next: this.s, prev: null, closed: false};
        if (this.s) {
          this.s.prev = ma;
        }
        this.s = ma;

        ++this.count;    // not essential - tracks number of unmerged sequences
      break;

      case 1:   // a matched, b did not - thus b extends sequence ma
        var pp = {p: b};

        if (prependA) {
          pp.next = ma.head;
          pp.prev = null;
          ma.head.prev = pp;
          ma.head = pp;
        } else {
          pp.next = null;
          pp.prev = ma.tail;
          ma.tail.next = pp;
          ma.tail = pp;
        }
      break;

      case 2:   // b matched, a did not - thus a extends sequence mb
        var pp = {p: a};

        if (prependB) {
          pp.next = mb.head;
          pp.prev = null;
          mb.head.prev = pp;
          mb.head = pp;
        } else {
          pp.next = null;
          pp.prev = mb.tail;
          mb.tail.next = pp;
          mb.tail = pp;
        }
      break;

      case 3:   // both matched, can merge sequences
        // if the sequences are the same, do nothing, as we are simply closing this path (could set a flag)

        if (ma === mb) {
          var pp = {p: ma.tail.p, next: ma.head, prev: null};
          ma.head.prev = pp;
          ma.head = pp;
          ma.closed = true;
          break;
        }

        // there are 4 ways the sequence pair can be joined. The current setting of prependA and
        // prependB will tell us which type of join is needed. For head/head and tail/tail joins
        // one sequence needs to be reversed
        switch((prependA ? 1 : 0) | (prependB ? 2 : 0)) {
          case 0:   // tail-tail
            // reverse ma and append to mb
            reverseList(ma);
            // fall through to head/tail case
          case 1:   // head-tail
            // ma is appended to mb and ma discarded
            mb.tail.next = ma.head;
            ma.head.prev = mb.tail;
            mb.tail = ma.tail;

            //discard ma sequence record
            this.remove_seq(ma);
          break;

          case 3:   // head-head
            // reverse ma and append mb to it
            reverseList(ma);
            // fall through to tail/head case
          case 2:   // tail-head
            // mb is appended to ma and mb is discarded
            ma.tail.next = mb.head;
            mb.head.prev = ma.tail;
            ma.tail = mb.tail;

            //discard mb sequence record
            this.remove_seq(mb);
        break;
      }
    }
  }

  /**
   * Implements CONREC.
   *
   * @param {function} drawContour function for drawing contour.  Defaults to a
   *                               custom "contour builder", which populates the
   *                               contours property.
   */
  function Conrec(drawContour) {
    if (!drawContour) {
      var c = this;
      c.contours = {};
      /**
       * drawContour - interface for implementing the user supplied method to
       * render the countours.
       *
       * Draws a line between the start and end coordinates.
       *
       * @param startX    - start coordinate for X
       * @param startY    - start coordinate for Y
       * @param endX      - end coordinate for X
       * @param endY      - end coordinate for Y
       * @param contourLevel - Contour level for line.
       */
      this.drawContour = function(startX, startY, endX, endY, contourLevel, k) {
        var cb = c.contours[k];
        if (!cb) {
          cb = c.contours[k] = new ContourBuilder(contourLevel);
        }
        cb.addSegment({x: startX, y: startY}, {x: endX, y: endY});
      }
      this.contourList = function() {
        var l = [];
        var a = c.contours;
        for (var k in a) {
          var s = a[k].s;
          var level = a[k].level;
          while (s) {
            var h = s.head;
            var l2 = [];
            l2.level = level;
            l2.k = k;
            while (h && h.p) {
              l2.push(h.p);
              h = h.next;
            }
            l.push(l2);
            s = s.next;
          }
        }
        l.sort(function(a, b) { return a.k - b.k });
        return l;
      }
    } else {
      this.drawContour = drawContour;
    }
    this.h  = new Array(5);
    this.sh = new Array(5);
    this.xh = new Array(5);
    this.yh = new Array(5);
  }

  /**
   * contour is a contouring subroutine for rectangularily spaced data
   *
   * It emits calls to a line drawing subroutine supplied by the user which
   * draws a contour map corresponding to real*4data on a randomly spaced
   * rectangular grid. The coordinates emitted are in the same units given in
   * the x() and y() arrays.
   *
   * Any number of contour levels may be specified but they must be in order of
   * increasing value.
   *
   *
   * @param {number[][]} d - matrix of data to contour
   * @param {number} ilb,iub,jlb,jub - index bounds of data matrix
   *
   *             The following two, one dimensional arrays (x and y) contain
   *             the horizontal and vertical coordinates of each sample points.
   * @param {number[]} x  - data matrix column coordinates
   * @param {number[]} y  - data matrix row coordinates
   * @param {number} nc   - number of contour levels
   * @param {number[]} z  - contour levels in increasing order.
   */
  Conrec.prototype.contour = function(d, ilb, iub, jlb, jub, x, y, nc, z) {
    var h = this.h, sh = this.sh, xh = this.xh, yh = this.yh;
    var drawContour = this.drawContour;
    this.contours = {};

    /** private */
    var xsect = function(p1, p2){
      return (h[p2]*xh[p1]-h[p1]*xh[p2])/(h[p2]-h[p1]);
    }

    var ysect = function(p1, p2){
      return (h[p2]*yh[p1]-h[p1]*yh[p2])/(h[p2]-h[p1]);
    }
    var m1;
    var m2;
    var m3;
    var case_value;
    var dmin;
    var dmax;
    var x1 = 0.0;
    var x2 = 0.0;
    var y1 = 0.0;
    var y2 = 0.0;

    // The indexing of im and jm should be noted as it has to start from zero
    // unlike the fortran counter part
    var im = [0, 1, 1, 0];
    var jm = [0, 0, 1, 1];

    // Note that castab is arranged differently from the FORTRAN code because
    // Fortran and C/C++ arrays are transposed of each other, in this case
    // it is more tricky as castab is in 3 dimensions
    var castab = [
      [
        [0, 0, 8], [0, 2, 5], [7, 6, 9]
      ],
      [
        [0, 3, 4], [1, 3, 1], [4, 3, 0]
      ],
      [
        [9, 6, 7], [5, 2, 0], [8, 0, 0]
      ]
    ];

    for (var j=(jub-1);j>=jlb;j--) {
      for (var i=ilb;i<=iub-1;i++) {
        var temp1, temp2;
        temp1 = Math.min(d[i][j],d[i][j+1]);
        temp2 = Math.min(d[i+1][j],d[i+1][j+1]);
        dmin  = Math.min(temp1,temp2);
        temp1 = Math.max(d[i][j],d[i][j+1]);
        temp2 = Math.max(d[i+1][j],d[i+1][j+1]);
        dmax  = Math.max(temp1,temp2);

        if (dmax>=z[0]&&dmin<=z[nc-1]) {
          for (var k=0;k<nc;k++) {
            if (z[k]>=dmin&&z[k]<=dmax) {
              for (var m=4;m>=0;m--) {
                if (m>0) {
                  // The indexing of im and jm should be noted as it has to
                  // start from zero
                  h[m] = d[i+im[m-1]][j+jm[m-1]]-z[k];
                  xh[m] = x[i+im[m-1]];
                  yh[m] = y[j+jm[m-1]];
                } else {
                  h[0] = 0.25*(h[1]+h[2]+h[3]+h[4]);
                  xh[0]=0.5*(x[i]+x[i+1]);
                  yh[0]=0.5*(y[j]+y[j+1]);
                }
                if (h[m]>EPSILON) {
                  sh[m] = 1;
                } else if (h[m]<-EPSILON) {
                  sh[m] = -1;
                } else
                  sh[m] = 0;
              }
              //
              // Note: at this stage the relative heights of the corners and the
              // centre are in the h array, and the corresponding coordinates are
              // in the xh and yh arrays. The centre of the box is indexed by 0
              // and the 4 corners by 1 to 4 as shown below.
              // Each triangle is then indexed by the parameter m, and the 3
              // vertices of each triangle are indexed by parameters m1,m2,and
              // m3.
              // It is assumed that the centre of the box is always vertex 2
              // though this isimportant only when all 3 vertices lie exactly on
              // the same contour level, in which case only the side of the box
              // is drawn.
              //
              //
              //      vertex 4 +-------------------+ vertex 3
              //               | \               / |
              //               |   \    m-3    /   |
              //               |     \       /     |
              //               |       \   /       |
              //               |  m=2    X   m=2   |       the centre is vertex 0
              //               |       /   \       |
              //               |     /       \     |
              //               |   /    m=1    \   |
              //               | /               \ |
              //      vertex 1 +-------------------+ vertex 2
              //
              //
              //
              //               Scan each triangle in the box
              //
              for (m=1;m<=4;m++) {
                m1 = m;
                m2 = 0;
                if (m!=4) {
                    m3 = m+1;
                } else {
                    m3 = 1;
                }
                case_value = castab[sh[m1]+1][sh[m2]+1][sh[m3]+1];
                if (case_value!=0) {
                  switch (case_value) {
                    case 1: // Line between vertices 1 and 2
                      x1=xh[m1];
                      y1=yh[m1];
                      x2=xh[m2];
                      y2=yh[m2];
                      break;
                    case 2: // Line between vertices 2 and 3
                      x1=xh[m2];
                      y1=yh[m2];
                      x2=xh[m3];
                      y2=yh[m3];
                      break;
                    case 3: // Line between vertices 3 and 1
                      x1=xh[m3];
                      y1=yh[m3];
                      x2=xh[m1];
                      y2=yh[m1];
                      break;
                    case 4: // Line between vertex 1 and side 2-3
                      x1=xh[m1];
                      y1=yh[m1];
                      x2=xsect(m2,m3);
                      y2=ysect(m2,m3);
                      break;
                    case 5: // Line between vertex 2 and side 3-1
                      x1=xh[m2];
                      y1=yh[m2];
                      x2=xsect(m3,m1);
                      y2=ysect(m3,m1);
                      break;
                    case 6: //  Line between vertex 3 and side 1-2
                      x1=xh[m3];
                      y1=yh[m3];
                      x2=xsect(m1,m2);
                      y2=ysect(m1,m2);
                      break;
                    case 7: // Line between sides 1-2 and 2-3
                      x1=xsect(m1,m2);
                      y1=ysect(m1,m2);
                      x2=xsect(m2,m3);
                      y2=ysect(m2,m3);
                      break;
                    case 8: // Line between sides 2-3 and 3-1
                      x1=xsect(m2,m3);
                      y1=ysect(m2,m3);
                      x2=xsect(m3,m1);
                      y2=ysect(m3,m1);
                      break;
                    case 9: // Line between sides 3-1 and 1-2
                      x1=xsect(m3,m1);
                      y1=ysect(m3,m1);
                      x2=xsect(m1,m2);
                      y2=ysect(m1,m2);
                      break;
                    default:
                      break;
                  }
                  // Put your processing code here and comment out the printf
                  //printf("%f %f %f %f %f\n",x1,y1,x2,y2,z[k]);
                  drawContour(x1,y1,x2,y2,z[k],k);
                }
              }
            }
          }
        }
      }
    }
  }

},{}],137:[function(require,module,exports){
//https://github.com/jasondavies/conrec.js
//http://stackoverflow.com/questions/263305/drawing-a-topographical-map
var tin = require('turf-tin');
var inside = require('turf-inside');
var grid = require('turf-grid');
var extent = require('turf-extent');
var planepoint = require('turf-planepoint');
var featurecollection = require('turf-featurecollection');
var linestring = require('turf-linestring');
var square = require('turf-square');
var Conrec = require('./conrec');

/**
 * Takes a {@link FeatureCollection} of {@link Point} features with z-values and an array of
 * value breaks and generates [isolines](http://en.wikipedia.org/wiki/Isoline).
 *
 * @module turf/isolines
 * @category interpolation
 * @param {FeatureCollection} points a FeatureCollection of {@link Point} features
 * @param {string} z the property name in `points` from which z-values will be pulled
 * @param {number} resolution resolution of the underlying grid
 * @param {number[]} breaks where to draw contours
 * @returns {FeatureCollection} a FeatureCollection of {@link LineString} features representing isolines
 * @example
 * // create random points with random
 * // z-values in their properties
 * var points = turf.random('point', 100, {
 *   bbox: [0, 30, 20, 50]
 * });
 * for (var i = 0; i < points.features.length; i++) {
 *   points.features[i].properties.z = Math.random() * 10;
 * }
 * var breaks = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
 * var isolined = turf.isolines(points, 'z', 15, breaks);
 * //=isolined
 */
module.exports = function(points, z, resolution, breaks, done){
  var tinResult = tin(points, z);
  var extentBBox = extent(points);
  var squareBBox = square(extentBBox);
  var gridResult = grid(squareBBox, resolution);
  var data = [];

  for (var i = 0; i < gridResult.features.length; i++) {
    var pt = gridResult.features[i];
    for (var j = 0; j < tinResult.features.length; j++) {
      var triangle = tinResult.features[j];
      if (inside(pt, triangle)) {
        pt.properties = {};
        pt.properties[z] = planepoint(pt, triangle);
      }
    }
  }

  var depth = Math.sqrt(gridResult.features.length);
  for (var x=0; x<depth; x++){
    var xGroup = gridResult.features.slice(x * depth, (x + 1) * depth);
    var xFlat = [];
    xGroup.forEach(function(verticalPoint){
      if(verticalPoint.properties){
        xFlat.push(verticalPoint.properties[z]);
      } else{
        xFlat.push(0);
      }
    });
    data.push(xFlat);
  }
  var interval = (squareBBox[2] - squareBBox[0]) / depth;
  var xCoordinates = [];
  var yCoordinates = [];
  for (var x = 0; x < depth; x++) {
    xCoordinates.push(x * interval + squareBBox[0]);
    yCoordinates.push(x * interval + squareBBox[1]);
  }

  var c = new Conrec();
  c.contour(data, 0, resolution, 0, resolution, xCoordinates, yCoordinates, breaks.length, breaks);
  var contourList = c.contourList();

  var fc = featurecollection([]);
  contourList.forEach(function(c){
    if(c.length > 2){
      var polyCoordinates = [];
      c.forEach(function(coord){
        polyCoordinates.push([coord.x, coord.y]);
      });
      var poly = linestring(polyCoordinates);
      poly.properties = {};
      poly.properties[z] = c.level;

      fc.features.push(poly);
    }
  });

  return fc;
}




},{"./conrec":136,"turf-extent":124,"turf-featurecollection":126,"turf-grid":138,"turf-inside":130,"turf-linestring":144,"turf-planepoint":152,"turf-square":169,"turf-tin":172}],138:[function(require,module,exports){
var point = require('turf-point');

/**
 * Takes a bounding box and a cell depth and returns a {@link FeatureCollection} of {@link Point} features in a grid.
 *
 * @module turf/grid
 * @category interpolation
 * @param {Array<number>} extent extent in [minX, minY, maxX, maxY] order
 * @param {Number} depth how many cells to output
 * @return {FeatureCollection} grid as FeatureCollection with {@link Point} features
 * @example
 * var extent = [-70.823364, -33.553984, -70.473175, -33.302986];
 * var depth = 10;
 *
 * var grid = turf.grid(extent, depth);
 *
 * //=grid
 */
module.exports = function(extents, depth) {
  var xmin = extents[0];
  var ymin = extents[1];
  var xmax = extents[2];
  var ymax = extents[3];
  var interval = (xmax - xmin) / depth;
  var coords = [];
  var fc = {
    type: 'FeatureCollection',
    features: []
  };

  for (var x=0; x<=depth; x++){
    for (var y=0;y<=depth; y++){
      fc.features.push(point([(x * interval) + xmin, (y * interval) + ymin]));
    }
  }
  return fc;
}

},{"turf-point":156}],139:[function(require,module,exports){
var ss = require('simple-statistics');

/**
* Takes a {@FeatureCollection} of any type and returns an array of the [Jenks Natural breaks](http://en.wikipedia.org/wiki/Jenks_natural_breaks_optimization)
* for a given property
* @module turf/jenks
* @param {FeatureCollection} input a FeatureCollection of any type
* @param {string} field the property in `input` on which to calculate Jenks natural breaks
* @param {number} numberOfBreaks number of classes in which to group the data
* @return {Array<number>} the break number for each class plus the minimum and maximum values
* @example
* var points = {
*   "type": "FeatureCollection",
*   "features": [
*     {
*       "type": "Feature",
*       "properties": {
*         "population": 200
*       },
*       "geometry": {
*         "type": "Point",
*         "coordinates": [49.859733, 40.400424]
*       }
*     }, {
*       "type": "Feature",
*       "properties": {
*         "population": 600
*       },
*       "geometry": {
*         "type": "Point",
*         "coordinates": [49.83879, 40.401209]
*       }
*     }, {
*       "type": "Feature",
*       "properties": {
*         "population": 100
*       },
*       "geometry": {
*         "type": "Point",
*         "coordinates": [49.817848, 40.376889]
*       }
*     }, {
*       "type": "Feature",
*       "properties": {
*         "population": 200
*       },
*       "geometry": {
*         "type": "Point",
*         "coordinates": [49.840507, 40.386043]
*       }
*     }, {
*       "type": "Feature",
*       "properties": {
*         "population": 300
*       },
*       "geometry": {
*         "type": "Point",
*         "coordinates": [49.854583, 40.37532]
*       }
*     }
*   ]
* };
*
* var breaks = turf.jenks(points, 'population', 3);
*
* //=breaks
*/
module.exports = function(fc, field, num){
  var vals = [];
  var breaks = [];

  fc.features.forEach(function(feature){
    if(feature.properties[field]!==undefined){
      vals.push(feature.properties[field]);
    }
  });
  breaks = ss.jenks(vals, num);

  return breaks;
};

},{"simple-statistics":140}],140:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113}],141:[function(require,module,exports){
/**
 * Takes a {@link Polygon} feature and returns a {@link FeatureCollection} of {@link Point} features at all self-intersections.
 *
 * @module turf/kinks
 * @category misc
 * @param {Polygon} polygon a Polygon feature
 * @returns {FeatureCollection} a FeatureCollection of {@link Point} features representing self-intersections
 * @example
 * var poly = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-12.034835, 8.901183],
 *       [-12.060413, 8.899826],
 *       [-12.03638, 8.873199],
 *       [-12.059383, 8.871418],
 *       [-12.034835, 8.901183]
 *     ]]
 *   }
 * };
 * 
 * var kinks = turf.kinks(poly);
 *
 * var resultFeatures = kinks.intersections.features.concat(poly);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */

var polygon = require('turf-polygon');
var point = require('turf-point');
var fc = require('turf-featurecollection');

module.exports = function(polyIn) {
  var poly;
  var results = {intersections: fc([]), fixed: null};
  if (polyIn.type === 'Feature') {
    poly = polyIn.geometry;
  } else {
    poly = polyIn;
  }
  var intersectionHash = {};
  poly.coordinates.forEach(function(ring1){
    poly.coordinates.forEach(function(ring2){
      for(var i = 0; i < ring1.length-1; i++) {
        for(var k = 0; k < ring2.length-1; k++) {
          var intersection = lineIntersects(ring1[i][0],ring1[i][1],ring1[i+1][0],ring1[i+1][1],
            ring2[k][0],ring2[k][1],ring2[k+1][0],ring2[k+1][1]);
          if(intersection) {
            results.intersections.features.push(point([intersection[0], intersection[1]]));
          }
        }
      }
    })
  })
  return results;
}


// modified from http://jsfiddle.net/justin_c_rounds/Gd2S2/light/
function lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {
  // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point
  var denominator, a, b, numerator1, numerator2, result = {
    x: null,
    y: null,
    onLine1: false,
    onLine2: false
  };
  denominator = ((line2EndY - line2StartY) * (line1EndX - line1StartX)) - ((line2EndX - line2StartX) * (line1EndY - line1StartY));
  if (denominator == 0) {
    if(result.x != null && result.y != null) {
      return result;
    } else {
      return false;
    }
  }
  a = line1StartY - line2StartY;
  b = line1StartX - line2StartX;
  numerator1 = ((line2EndX - line2StartX) * a) - ((line2EndY - line2StartY) * b);
  numerator2 = ((line1EndX - line1StartX) * a) - ((line1EndY - line1StartY) * b);
  a = numerator1 / denominator;
  b = numerator2 / denominator;

  // if we cast these lines infinitely in both directions, they intersect here:
  result.x = line1StartX + (a * (line1EndX - line1StartX));
  result.y = line1StartY + (a * (line1EndY - line1StartY));

  // if line1 is a segment and line2 is infinite, they intersect if:
  if (a > 0 && a < 1) {
    result.onLine1 = true;
  }
  // if line2 is a segment and line1 is infinite, they intersect if:
  if (b > 0 && b < 1) {
    result.onLine2 = true;
  }
  // if line1 and line2 are segments, they intersect if both of the above are true
  if(result.onLine1 && result.onLine2){
    return [result.x, result.y];
  }
  else {
    return false;
  }
}

},{"turf-featurecollection":126,"turf-point":156,"turf-polygon":157}],142:[function(require,module,exports){
var distance = require('turf-distance');
var point = require('turf-point');

/**
 * Takes a {@link LineString} feature and measures its length in the specified units.
 *
 * @module turf/line-distance
 * @category measurement
 * @param {LineString} Line to measure
 * @param {String} [units=miles] can be degrees, radians, miles, or kilometers
 * @return {Number} length of the LineString
 * @example
 * var line = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "LineString",
 *     "coordinates": [
 *       [-77.031669, 38.878605],
 *       [-77.029609, 38.881946],
 *       [-77.020339, 38.884084],
 *       [-77.025661, 38.885821],
 *       [-77.021884, 38.889563],
 *       [-77.019824, 38.892368]
 *     ]
 *   }
 * };
 *
 * var length = turf.lineDistance(line, 'miles');
 *
 * //=line
 *
 * //=length
 */

module.exports = function (line, units) {
  var coords;
  if(line.type === 'Feature') coords = line.geometry.coordinates;
  else if(line.type === 'LineString') coords = line.geometry.coordinates;
  else throw new Error('input must be a LineString Feature or Geometry');

  var travelled = 0;
  for(var i = 0; i < coords.length - 1; i++) {
    travelled += distance(point(coords[i]), point(coords[i+1]), units);
  }
  return travelled;
}

},{"turf-distance":114,"turf-point":156}],143:[function(require,module,exports){
var distance = require('turf-distance');
var point = require('turf-point');
var linestring = require('turf-linestring');
var bearing = require('turf-bearing');
var destination = require('turf-destination');

/**
 * Slices a LineString at start and stop Points
 *
 * @module turf/line-slice
 *
 * @param {Point} Point to start the slice
 * @param {Point} Point to stop the slice
 * @param {LineString} Line to slice
 * @return {LineString} Sliced LineString
 * @example
 * var line = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "LineString",
 *     "coordinates": [
 *       [-77.031669, 38.878605],
 *       [-77.029609, 38.881946],
 *       [-77.020339, 38.884084],
 *       [-77.025661, 38.885821],
 *       [-77.021884, 38.889563],
 *       [-77.019824, 38.892368]
 *     ]
 *   }
 * };
 * var start = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-77.029609, 38.881946]
 *   }
 * };
 * var stop = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-77.021884, 38.889563]
 *   }
 * };
 * 
 * var sliced = turf.lineSlice(start, stop, line);
 *
 * //=line
 *
 * //=sliced
 */

module.exports = function (startPt, stopPt, line) {  
  var coords;
  if(line.type === 'Feature') coords = line.geometry.coordinates;
  else if(line.type === 'LineString') coords = line.geometry.coordinates;
  else throw new Error('input must be a LineString Feature or Geometry');

  var startVertex = pointOnLine(startPt, coords);
  var stopVertex = pointOnLine(stopPt, coords);
  var ends;
  if(startVertex.properties.index <= stopVertex.properties.index) {
    ends = [startVertex, stopVertex];
  } else {
    ends = [stopVertex, startVertex];
  }
  var clipLine = linestring([ends[0].geometry.coordinates], {});
  for(var i = ends[0].properties.index+1; i < ends[1].properties.index+1; i++) {
    clipLine.geometry.coordinates.push(coords[i]);
  }
  clipLine.geometry.coordinates.push(ends[1].geometry.coordinates);
  return clipLine;
}

function pointOnLine (pt, coords) {
  var units = 'miles'
  var closestPt = point([Infinity, Infinity], {dist: Infinity});
  for(var i = 0; i < coords.length - 1; i++) {
    var start = point(coords[i])
    var stop = point(coords[i+1])
    //start
    start.properties.dist = distance(pt, start, units);
    //stop
    stop.properties.dist = distance(pt, stop, units);
    //perpendicular
    var direction = bearing(start, stop)
    var perpendicularPt = destination(pt, 1000 , direction + 90, units) // 1000 = gross
    var intersect = lineIntersects(
      pt.geometry.coordinates[0],
      pt.geometry.coordinates[1],
      perpendicularPt.geometry.coordinates[0],
      perpendicularPt.geometry.coordinates[1],
      start.geometry.coordinates[0],
      start.geometry.coordinates[1],
      stop.geometry.coordinates[0],
      stop.geometry.coordinates[1]
      );
    if(!intersect) {
      perpendicularPt = destination(pt, 1000 , direction - 90, units) // 1000 = gross
      intersect = lineIntersects(
        pt.geometry.coordinates[0],
        pt.geometry.coordinates[1],
        perpendicularPt.geometry.coordinates[0],
        perpendicularPt.geometry.coordinates[1],
        start.geometry.coordinates[0],
        start.geometry.coordinates[1],
        stop.geometry.coordinates[0],
        stop.geometry.coordinates[1]
        );
    }
    perpendicularPt.properties.dist = Infinity;
    var intersectPt;
    if(intersect) {
      var intersectPt = point(intersect);
      intersectPt.properties.dist = distance(pt, intersectPt, units);
    }
    
    if(start.properties.dist < closestPt.properties.dist) {
      closestPt = start;
      closestPt.properties.index = i;
    }
    if(stop.properties.dist < closestPt.properties.dist) {
     closestPt = stop;
     closestPt.properties.index = i;
    }
    if(intersectPt && intersectPt.properties.dist < closestPt.properties.dist){ 
      closestPt = intersectPt;
      closestPt.properties.index = i;
    }
  }
  
  return closestPt;
}

// modified from http://jsfiddle.net/justin_c_rounds/Gd2S2/light/
function lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {
  // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point
  var denominator, a, b, numerator1, numerator2, result = {
    x: null,
    y: null,
    onLine1: false,
    onLine2: false
  };
  denominator = ((line2EndY - line2StartY) * (line1EndX - line1StartX)) - ((line2EndX - line2StartX) * (line1EndY - line1StartY));
  if (denominator == 0) {
    if(result.x != null && result.y != null) {
      return result;
    } else {
      return false;
    }
  }
  a = line1StartY - line2StartY;
  b = line1StartX - line2StartX;
  numerator1 = ((line2EndX - line2StartX) * a) - ((line2EndY - line2StartY) * b);
  numerator2 = ((line1EndX - line1StartX) * a) - ((line1EndY - line1StartY) * b);
  a = numerator1 / denominator;
  b = numerator2 / denominator;

  // if we cast these lines infinitely in both directions, they intersect here:
  result.x = line1StartX + (a * (line1EndX - line1StartX));
  result.y = line1StartY + (a * (line1EndY - line1StartY));

  // if line1 is a segment and line2 is infinite, they intersect if:
  if (a > 0 && a < 1) {
    result.onLine1 = true;
  }
  // if line2 is a segment and line1 is infinite, they intersect if:
  if (b > 0 && b < 1) {
    result.onLine2 = true;
  }
  // if line1 and line2 are segments, they intersect if both of the above are true
  if(result.onLine1 && result.onLine2){
    return [result.x, result.y];
  }
  else {
    return false;
  }
}

},{"turf-bearing":67,"turf-destination":111,"turf-distance":114,"turf-linestring":144,"turf-point":156}],144:[function(require,module,exports){
/**
 * Creates a {@link LineString} {@link Feature} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @module turf/linestring
 * @category helper
 * @param {Array<Array<Number>>} coordinates an array of Positions
 * @param {Object} properties an Object of key-value pairs to add as properties
 * @return {LineString} a LineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var linestring1 = turf.linestring([
 *	[-21.964416, 64.148203],
 *	[-21.956176, 64.141316],
 *	[-21.93901, 64.135924],
 *	[-21.927337, 64.136673]
 * ]);
 * var linestring2 = turf.linestring([
 *	[-21.929054, 64.127985],
 *	[-21.912918, 64.134726],
 *	[-21.916007, 64.141016],
 * 	[-21.930084, 64.14446]
 * ], {name: 'line 1', distance: 145});
 *
 * //=linestring1
 *
 * //=linestring2
 */
module.exports = function(coordinates, properties){
  if (!coordinates) {
      throw new Error('No coordinates passed');
  }
  return {
    "type": "Feature",
    "geometry": {
      "type": "LineString",
      "coordinates": coordinates
    },
    "properties": properties || {}
  };
};

},{}],145:[function(require,module,exports){
var inside = require('turf-inside');

/**
 * Calculates the maximum value of a field for a set of {@link Point} features within a set of {@link Polygon} features.
 *
 * @module turf/max
 * @category aggregation
 * @param {FeatureCollection} polygons a FeatureCollection of {@link Polygon} features
 * @param {FeatureCollection} points a FeatureCollection of {@link Point} features
 * @param {string} inField the field in input data to analyze
 * @param {string} outField the field in which to store results
 * @return {FeatureCollection} a FeatureCollection of {@link Polygon} features
 * with properties listed as `outField` values
 * @example
 * var polygons = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [[
 *           [101.551437, 3.150114],
 *           [101.551437, 3.250208],
 *           [101.742324, 3.250208],
 *           [101.742324, 3.150114],
 *           [101.551437, 3.150114]
 *         ]]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [[
 *           [101.659927, 3.011612],
 *           [101.659927, 3.143944],
 *           [101.913986, 3.143944],
 *           [101.913986, 3.011612],
 *           [101.659927, 3.011612]
 *         ]]
 *       }
 *     }
 *   ]
 * };
 * var points = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "population": 200
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [101.56105, 3.213874]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "population": 600
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [101.709365, 3.211817]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "population": 100
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [101.645507, 3.169311]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "population": 200
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [101.708679, 3.071266]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "population": 300
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [101.826782, 3.081551]
 *       }
 *     }
 *   ]
 * };
 *
 * var aggregated = turf.max(
 *   polygons, points, 'population', 'max');
 *
 * var resultFeatures = points.features.concat(
 *   aggregated.features);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */
module.exports = function(polyFC, ptFC, inField, outField){
  polyFC.features.forEach(function(poly){
    if(!poly.properties){
      poly.properties = {};
    }
    var values = [];
    ptFC.features.forEach(function(pt){
      if (inside(pt, poly)) {
        values.push(pt.properties[inField]);
      }
    });
    poly.properties[outField] = max(values);
  });

  return polyFC;
}

function max(x) {
    var value;
    for (var i = 0; i < x.length; i++) {
        // On the first iteration of this loop, max is
        // undefined and is thus made the maximum element in the array
        if (x[i] > value || value === undefined) value = x[i];
    }
    return value;
}

},{"turf-inside":130}],146:[function(require,module,exports){
var inside = require('turf-inside');

/**
 * Calculates the median value of a field for a set of {@link Point} features within a set of {@link Polygon} features.
 *
 * @module turf/median
 * @category aggregation
 * @param {FeatureCollection} polygons a FeatureCollection of {@link Polygon} features
 * @param {FeatureCollection} points a FeatureCollection of {@link Point} features
 * @param {string} inField the field in input data to analyze
 * @param {string} outField the field in which to store results
 * @return {FeatureCollection} a FeatureCollection of {@link Polygon} features
 * with properties listed as `outField` values
 * @example
 * var polygons = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [[
 *           [18.400039, -33.970697],
 *           [18.400039, -33.818518],
 *           [18.665771, -33.818518],
 *           [18.665771, -33.970697],
 *           [18.400039, -33.970697]
 *         ]]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [[
 *           [18.538742, -34.050383],
 *           [18.538742, -33.98721],
 *           [18.703536, -33.98721],
 *           [18.703536, -34.050383],
 *           [18.538742, -34.050383]
 *         ]]
 *       }
 *     }
 *   ]
 * };
 * var points = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "population": 200
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [18.514022, -33.860152]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "population": 600
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [18.48999, -33.926269]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "population": 100
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [18.583374, -33.905755]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "population": 200
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [18.591613, -34.024778]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "population": 300
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [18.653411, -34.017949]
 *       }
 *     }
 *   ]
 * };
 *
 * var medians = turf.median(
 *  polygons, points, 'population', 'median');
 *
 * var resultFeatures = points.features.concat(
 *   medians.features);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */
module.exports = function(polyFC, ptFC, inField, outField){
  polyFC.features.forEach(function(poly){
    if(!poly.properties){
      poly.properties = {};
    }
    var values = [];
    ptFC.features.forEach(function(pt){
      if (inside(pt, poly)) {
        values.push(pt.properties[inField]);
      }
    });
    poly.properties[outField] = median(values);
  });

  return polyFC;
};

function median(x) {
    // The median of an empty list is null
    if (x.length === 0) return null;

    // Sorting the array makes it easy to find the center, but
    // use `.slice()` to ensure the original array `x` is not modified
    var sorted = x.slice().sort(function (a, b) { return a - b; });

    // If the length of the list is odd, it's the central number
    if (sorted.length % 2 === 1) {
        return sorted[(sorted.length - 1) / 2];
    // Otherwise, the median is the average of the two numbers
    // at the center of the list
    } else {
        var a = sorted[(sorted.length / 2) - 1];
        var b = sorted[(sorted.length / 2)];
        return (a + b) / 2;
    }
}

},{"turf-inside":130}],147:[function(require,module,exports){
var clone = require('clone');
var union = require('turf-union');

/**
 * Takes a {@link FeatureCollection} of {@link Polygon} features and returns a single merged
 * polygon feature. If the input Polygon features are not contiguous, this function returns a {@link MultiPolygon} feature.
 * @module turf/merge
 * @category transformation
 * @param {FeatureCollection} fc a FeatureCollection of {@link Polygon} features
 * @return {Feature} a {@link Polygon} or {@link MultiPolygon} feature
 * @example
 * var polygons = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "fill": "#0f0"
 *       },
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [[
 *           [9.994812, 53.549487],
 *           [10.046997, 53.598209],
 *           [10.117721, 53.531737],
 *           [9.994812, 53.549487]
 *         ]]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "fill": "#00f"
 *       },
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [[
 *           [10.000991, 53.50418],
 *           [10.03807, 53.562539],
 *           [9.926834, 53.551731],
 *           [10.000991, 53.50418]
 *         ]]
 *       }
 *     }
 *   ]
 * };
 *
 * var merged = turf.merge(polygons);
 *
 * //=polygons
 *
 * //=merged
 */
module.exports = function(polygons, done){

  var merged = clone(polygons.features[0]),
    features = polygons.features;

  for (var i = 0, len = features.length; i < len; i++) {
    var poly = features[i];

    if(poly.geometry){
      merged = union(merged, poly);
    }
  }

  return merged;
};

},{"clone":148,"turf-union":174}],148:[function(require,module,exports){
(function (Buffer){
'use strict';

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

// shim for Node's 'util' package
// DO NOT REMOVE THIS! It is required for compatibility with EnderJS (http://enderjs.com/).
var util = {
  isArray: function (ar) {
    return Array.isArray(ar) || (typeof ar === 'object' && objectToString(ar) === '[object Array]');
  },
  isDate: function (d) {
    return typeof d === 'object' && objectToString(d) === '[object Date]';
  },
  isRegExp: function (re) {
    return typeof re === 'object' && objectToString(re) === '[object RegExp]';
  },
  getRegExpFlags: function (re) {
    var flags = '';
    re.global && (flags += 'g');
    re.ignoreCase && (flags += 'i');
    re.multiline && (flags += 'm');
    return flags;
  }
};


if (typeof module === 'object')
  module.exports = clone;

/**
 * Clones (copies) an Object using deep copying.
 *
 * This function supports circular references by default, but if you are certain
 * there are no circular references in your object, you can save some CPU time
 * by calling clone(obj, false).
 *
 * Caution: if `circular` is false and `parent` contains circular references,
 * your program may enter an infinite loop and crash.
 *
 * @param `parent` - the object to be cloned
 * @param `circular` - set to true if the object to be cloned may contain
 *    circular references. (optional - true by default)
 * @param `depth` - set to a number if the object is only to be cloned to
 *    a particular depth. (optional - defaults to Infinity)
 * @param `prototype` - sets the prototype to be used when cloning an object.
 *    (optional - defaults to parent prototype).
*/

function clone(parent, circular, depth, prototype) {
  // maintain two arrays for circular references, where corresponding parents
  // and children have the same index
  var allParents = [];
  var allChildren = [];

  var useBuffer = typeof Buffer != 'undefined';

  if (typeof circular == 'undefined')
    circular = true;

  if (typeof depth == 'undefined')
    depth = Infinity;

  // recurse this function so we don't reset allParents and allChildren
  function _clone(parent, depth) {
    // cloning null always returns null
    if (parent === null)
      return null;

    if (depth == 0)
      return parent;

    var child;
    var proto;
    if (typeof parent != 'object') {
      return parent;
    }

    if (util.isArray(parent)) {
      child = [];
    } else if (util.isRegExp(parent)) {
      child = new RegExp(parent.source, util.getRegExpFlags(parent));
      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
    } else if (util.isDate(parent)) {
      child = new Date(parent.getTime());
    } else if (useBuffer && Buffer.isBuffer(parent)) {
      child = new Buffer(parent.length);
      parent.copy(child);
      return child;
    } else {
      if (typeof prototype == 'undefined') {
        proto = Object.getPrototypeOf(parent);
        child = Object.create(proto);
      }
      else {
        child = Object.create(prototype);
        proto = prototype;
      }
    }

    if (circular) {
      var index = allParents.indexOf(parent);

      if (index != -1) {
        return allChildren[index];
      }
      allParents.push(parent);
      allChildren.push(child);
    }

    for (var i in parent) {
      var attrs;
      if (proto) {
        attrs = Object.getOwnPropertyDescriptor(proto, i);
      }
      
      if (attrs && attrs.set == null) {
        continue;
      }
      child[i] = _clone(parent[i], depth - 1);
    }

    return child;
  }

  return _clone(parent, depth);
}

/**
 * Simple flat clone using prototype, accepts only objects, usefull for property
 * override on FLAT configuration object (no nested props).
 *
 * USE WITH CAUTION! This may not behave as you wish if you do not know how this
 * works.
 */
clone.clonePrototype = function(parent) {
  if (parent === null)
    return null;

  var c = function () {};
  c.prototype = parent;
  return new c();
};

}).call(this,require("buffer").Buffer)

},{"buffer":9}],149:[function(require,module,exports){
// http://cs.selu.edu/~rbyrd/math/midpoint/
// ((x1+x2)/2), ((y1+y2)/2)
var point = require('turf-point');

/**
 * Takes two {@link Point} features and returns a Point midway between the two.
 *
 * @module turf/midpoint
 * @category measurement
 * @param {Point} pt1 first point
 * @param {Point} pt2 second point
 * @return {Point} a point between the two
 * @example
 * var pt1 = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [144.834823, -37.771257]
 *   }
 * };
 * var pt2 = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [145.14244, -37.830937]
 *   }
 * };
 *
 * var midpointed = turf.midpoint(pt1, pt2);
 * midpointed.properties['marker-color'] = '#f00';
 *
 *
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": [pt1, pt2, midpointed]
 * };
 *
 * //=result
 */
module.exports = function(point1, point2) {
  if (point1 === null || point2 === null){
    throw new Error('Less than two points passed.');
  }

  var x1 = point1.geometry.coordinates[0];
  var x2 = point2.geometry.coordinates[0];
  var y1 = point1.geometry.coordinates[1];
  var y2 = point2.geometry.coordinates[1];

  var x3 = x1 + x2;
  var midX = x3/2;
  var y3 = y1 + y2;
  var midY = y3/2;

  return point([midX, midY]);
};

},{"turf-point":156}],150:[function(require,module,exports){
var inside = require('turf-inside');

/**
* Calculates the minimum value of a field for {@link Point} features within a set of {@link Polygon} features.
*
* @module turf/min
* @category aggregation
* @param {FeatureCollection} polygons a FeatureCollection of {@link Polygon} features
* @param {FeatureCollection} points a FeatureCollection of {@link Point} features
* @param {string} inField the field in input data to analyze
* @param {string} outField the field in which to store results
* @return {FeatureCollection} a FeatureCollection of {@link Polygon} features
* with properties listed as `outField` values
* @example
* var polygons = {
*   "type": "FeatureCollection",
*   "features": [
*     {
*       "type": "Feature",
*       "properties": {},
*       "geometry": {
*         "type": "Polygon",
*         "coordinates": [[
*           [72.809658, 18.961818],
*           [72.809658, 18.974805],
*           [72.827167, 18.974805],
*           [72.827167, 18.961818],
*           [72.809658, 18.961818]
*         ]]
*       }
*     }, {
*       "type": "Feature",
*       "properties": {},
*       "geometry": {
*         "type": "Polygon",
*         "coordinates": [[
*           [72.820987, 18.947043],
*           [72.820987, 18.95922],
*           [72.841243, 18.95922],
*           [72.841243, 18.947043],
*           [72.820987, 18.947043]
*         ]]
*       }
*     }
*   ]
* };
* var points = {
*   "type": "FeatureCollection",
*   "features": [
*     {
*       "type": "Feature",
*       "properties": {
*         "population": 200
*       },
*       "geometry": {
*         "type": "Point",
*         "coordinates": [72.814464, 18.971396]
*       }
*     }, {
*       "type": "Feature",
*       "properties": {
*         "population": 600
*       },
*       "geometry": {
*         "type": "Point",
*         "coordinates": [72.820043, 18.969772]
*       }
*     }, {
*       "type": "Feature",
*       "properties": {
*         "population": 100
*       },
*       "geometry": {
*         "type": "Point",
*         "coordinates": [72.817296, 18.964253]
*       }
*     }, {
*       "type": "Feature",
*       "properties": {
*         "population": 200
*       },
*       "geometry": {
*         "type": "Point",
*         "coordinates": [72.83575, 18.954837]
*       }
*     }, {
*       "type": "Feature",
*       "properties": {
*         "population": 300
*       },
*       "geometry": {
*         "type": "Point",
*         "coordinates": [72.828197, 18.95094]
*       }
*     }
*   ]
* };
*
* var minimums = turf.min(
*   polygons, points, 'population', 'min');
*
* var resultFeatures = points.features.concat(
*   minimums.features);
* var result = {
*   "type": "FeatureCollection",
*   "features": resultFeatures
* };
*
* //=result
*/
module.exports = function(polyFC, ptFC, inField, outField){
  polyFC.features.forEach(function(poly){
    if(!poly.properties){
      poly.properties = {};
    }
    var values = [];
    ptFC.features.forEach(function(pt){
      if (inside(pt, poly)) {
        values.push(pt.properties[inField]);
      }
    });
    poly.properties[outField] = min(values);
  });

  return polyFC;
};

function min(x) {
    var value;
    for (var i = 0; i < x.length; i++) {
        // On the first iteration of this loop, min is
        // undefined and is thus made the minimum element in the array
        if (x[i] < value || value === undefined) value = x[i];
    }
    return value;
}

},{"turf-inside":130}],151:[function(require,module,exports){
var distance = require('turf-distance');

/**
 * Takes a {@link Point} feature and a {@link FeatureCollection} of Point features and returns the Point feature from the FeatureCollection closest to the input point.
 *
 * @module turf/nearest
 * @category classification
 * @param {Point} point the reference point
 * @param {FeatureCollection} against a FeatureCollection of Point features
 * @return {Feature} the closest Point feature in `against` to `point`
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {
 *     "marker-color": "#0f0"
 *   },
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [28.965797, 41.010086]
 *   }
 * };
 * var against = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [28.973865, 41.011122]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [28.948459, 41.024204]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [28.938674, 41.013324]
 *       }
 *     }
 *   ]
 * };
 *
 * var nearest = turf.nearest(point, against);
 * nearest.properties['marker-color'] = '#f00';
 *
 * var resultFeatures = against.features.concat(point);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */
module.exports = function(targetPoint, points){
  var nearestPoint;
  var count = 0;
  var dist = Infinity;
  points.features.forEach(function(pt){
    if(!nearestPoint){
      nearestPoint = pt;
      var dist = distance(targetPoint, pt, 'miles');
      nearestPoint.properties.distance = dist;
    }
    else{
      var dist = distance(targetPoint, pt, 'miles');
      if(dist < nearestPoint.properties.distance){
        nearestPoint = pt;
        nearestPoint.properties.distance = dist;
      }
    }
  });
  delete nearestPoint.properties.distance;
  return nearestPoint;
}

},{"turf-distance":114}],152:[function(require,module,exports){
/**
 * Takes a triangular plane as a {@link Polygon} feature
 * and a {@link Point} feature within that triangle and returns the z-value
 * at that point. The Polygon needs to have properties `a`, `b`, and `c`
 * that define the values at its three corners.
 *
 * @module turf/planepoint
 * @category interpolation
 * @param {Point} interpolatedPoint the Point for which a z-value will be calculated
 * @param {Polygon} triangle a Polygon feature with three vertices
 * @return {number} the z-value for `interpolatedPoint`
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-75.3221, 39.529]
 *   }
 * };
 * var point = turf.point([-75.3221, 39.529]);
 * // triangle is a polygon with "a", "b",
 * // and "c" values representing
 * // the values of the coordinates in order.
 * var triangle = {
 *   "type": "Feature",
 *   "properties": {
 *     "a": 11,
 *     "b": 122,
 *     "c": 44
 *   },
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-75.1221, 39.57],
 *       [-75.58, 39.18],
 *       [-75.97, 39.86],
 *       [-75.1221, 39.57]
 *     ]]
 *   }
 * };
 *
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [triangle, point]
 * };
 *
 * var zValue = turf.planepoint(point, triangle);
 *
 * //=features
 *
 * //=zValue
 */
module.exports = function(point, triangle){
  var x = point.geometry.coordinates[0],
      y = point.geometry.coordinates[1],
      x1 = triangle.geometry.coordinates[0][0][0],
      y1 = triangle.geometry.coordinates[0][0][1],
      z1 = triangle.properties.a,
      x2 = triangle.geometry.coordinates[0][1][0],
      y2 = triangle.geometry.coordinates[0][1][1],
      z2 = triangle.properties.b,
      x3 = triangle.geometry.coordinates[0][2][0],
      y3 = triangle.geometry.coordinates[0][2][1],
      z3 = triangle.properties.c;

  var z = (z3 * (x-x1) * (y-y2) + z1 * (x-x2) * (y-y3) + z2 * (x-x3) * (y-y1) -
      z2 * (x-x1) * (y-y3) - z3 * (x-x2) * (y-y1) - z1 * (x-x3) * (y-y2)) /
      ((x-x1) * (y-y2) + (x-x2) * (y-y3) +(x-x3) * (y-y1) -
       (x-x1) * (y-y3) - (x-x2) * (y-y1) - (x-x3) * (y-y2));

  return z;
};

},{}],153:[function(require,module,exports){
var point = require('turf-point');
var featurecollection = require('turf-featurecollection');
var distance = require('turf-distance');
/**
 * Takes a bounding box and a cell depth and returns a {@link FeatureCollection} of {@link Point} features in a grid.
 *
 * @module turf/point-grid
 * @category interpolation
 * @param {Array<number>} extent extent in [minX, minY, maxX, maxY] order
 * @param {Number} depth how many cells to output
 * @return {FeatureCollection} grid as FeatureCollection with {@link Point} features
 * @example
 * var extent = [-70.823364, -33.553984, -70.473175, -33.302986];
 * var depth = 10;
 *
 * var grid = turf.pointGrid(extent, depth);
 *
 * //=grid
 */
module.exports = function (bbox, cell, units) {
  var fc = featurecollection([]);
  var xFraction = cell / (distance(point([bbox[0], bbox[1]]), point([bbox[2], bbox[1]]), units));
  var cellWidth = xFraction * (bbox[2] - bbox[0]);
  var yFraction = cell / (distance(point([bbox[0], bbox[1]]), point([bbox[0], bbox[3]]), units));
  var cellHeight = yFraction * (bbox[3] - bbox[1]);

  var currentX = bbox[0];
  while (currentX <= bbox[2]) {
    var currentY = bbox[1];
    while (currentY <= bbox[3]) {
      fc.features.push(point([currentX, currentY]));

      currentY += cellHeight;
    }
    currentX += cellWidth;
  }
  
  return fc;
}
},{"turf-distance":114,"turf-featurecollection":126,"turf-point":156}],154:[function(require,module,exports){
var distance = require('turf-distance');
var point = require('turf-point');
var linestring = require('turf-linestring');
var bearing = require('turf-bearing');
var destination = require('turf-destination');

/**
 * Takes a Point and a LineString and calculates the closest Point on the LineString
 *
 * @module turf/point-on-line
 *
 * @param {LineString} Line to snap to
 * @param {Point} Point to snap from
 * @return {Point} Closest Point on the Line
 * @example
 * var line = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "LineString",
 *     "coordinates": [
 *       [-77.031669, 38.878605],
 *       [-77.029609, 38.881946],
 *       [-77.020339, 38.884084],
 *       [-77.025661, 38.885821],
 *       [-77.021884, 38.889563],
 *       [-77.019824, 38.892368]
 *     ]
 *   }
 * };
 * var pt = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-77.037076, 38.884017]
 *   }
 * };
 * 
 * var snapped = turf.pointOnLine(line, pt);
 * snapped.properties['marker-color'] = '#00f'
 *
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": [line, pt, snapped]
 * };
 *
 * //=result
 */

module.exports = function (line, pt) {  
  var coords;
  if(line.type === 'Feature') coords = line.geometry.coordinates;
  else if(line.type === 'LineString') coords = line.geometry.coordinates;
  else throw new Error('input must be a LineString Feature or Geometry');

  return pointOnLine(pt, coords);
}

function pointOnLine (pt, coords) {
  var units = 'miles'
  var closestPt = point([Infinity, Infinity], {dist: Infinity});
  for(var i = 0; i < coords.length - 1; i++) {
    var start = point(coords[i])
    var stop = point(coords[i+1])
    //start
    start.properties.dist = distance(pt, start, units);
    //stop
    stop.properties.dist = distance(pt, stop, units);
    //perpendicular
    var direction = bearing(start, stop)
    var perpendicularPt = destination(pt, 1000 , direction + 90, units) // 1000 = gross
    var intersect = lineIntersects(
      pt.geometry.coordinates[0],
      pt.geometry.coordinates[1],
      perpendicularPt.geometry.coordinates[0],
      perpendicularPt.geometry.coordinates[1],
      start.geometry.coordinates[0],
      start.geometry.coordinates[1],
      stop.geometry.coordinates[0],
      stop.geometry.coordinates[1]
      );
    if(!intersect) {
      perpendicularPt = destination(pt, 1000 , direction - 90, units) // 1000 = gross
      intersect = lineIntersects(
        pt.geometry.coordinates[0],
        pt.geometry.coordinates[1],
        perpendicularPt.geometry.coordinates[0],
        perpendicularPt.geometry.coordinates[1],
        start.geometry.coordinates[0],
        start.geometry.coordinates[1],
        stop.geometry.coordinates[0],
        stop.geometry.coordinates[1]
        );
    }
    perpendicularPt.properties.dist = Infinity;
    var intersectPt;
    if(intersect) {
      var intersectPt = point(intersect);
      intersectPt.properties.dist = distance(pt, intersectPt, units);
    }
    
    if(start.properties.dist < closestPt.properties.dist) {
      closestPt = start;
      closestPt.properties.index = i;
    }
    if(stop.properties.dist < closestPt.properties.dist) {
     closestPt = stop;
     closestPt.properties.index = i;
    }
    if(intersectPt && intersectPt.properties.dist < closestPt.properties.dist){ 
      closestPt = intersectPt;
      closestPt.properties.index = i;
    }
  }
  
  return closestPt;
}

// modified from http://jsfiddle.net/justin_c_rounds/Gd2S2/light/
function lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {
  // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point
  var denominator, a, b, numerator1, numerator2, result = {
    x: null,
    y: null,
    onLine1: false,
    onLine2: false
  };
  denominator = ((line2EndY - line2StartY) * (line1EndX - line1StartX)) - ((line2EndX - line2StartX) * (line1EndY - line1StartY));
  if (denominator == 0) {
    if(result.x != null && result.y != null) {
      return result;
    } else {
      return false;
    }
  }
  a = line1StartY - line2StartY;
  b = line1StartX - line2StartX;
  numerator1 = ((line2EndX - line2StartX) * a) - ((line2EndY - line2StartY) * b);
  numerator2 = ((line1EndX - line1StartX) * a) - ((line1EndY - line1StartY) * b);
  a = numerator1 / denominator;
  b = numerator2 / denominator;

  // if we cast these lines infinitely in both directions, they intersect here:
  result.x = line1StartX + (a * (line1EndX - line1StartX));
  result.y = line1StartY + (a * (line1EndY - line1StartY));

  // if line1 is a segment and line2 is infinite, they intersect if:
  if (a > 0 && a < 1) {
    result.onLine1 = true;
  }
  // if line2 is a segment and line1 is infinite, they intersect if:
  if (b > 0 && b < 1) {
    result.onLine2 = true;
  }
  // if line1 and line2 are segments, they intersect if both of the above are true
  if(result.onLine1 && result.onLine2){
    return [result.x, result.y];
  }
  else {
    return false;
  }
}

},{"turf-bearing":67,"turf-destination":111,"turf-distance":114,"turf-linestring":144,"turf-point":156}],155:[function(require,module,exports){
var featureCollection = require('turf-featurecollection');
var centroid = require('turf-center');
var distance = require('turf-distance');
var inside = require('turf-inside');
var explode = require('turf-explode');

/**
 * Finds a {@link Point} guaranteed to be on the surface of
 * {@link GeoJSON} object.
 *
 * * Given a {@link Polygon}, the point will be in the area of the polygon
 * * Given a {@link LineString}, the point will be along the string
 * * Given a {@link Point}, the point will the same as the input
 *
 * @module turf/point-on-surface
 * @category measurement
 * @param {GeoJSON} input any GeoJSON object
 * @returns {Feature} a point on the surface of `input`
 * @example
 * // create a random polygon
 * var polygon = turf.random('polygon');
 *
 * //=polygon
 *
 * var pointOnPolygon = turf.pointOnSurface(polygon);
 *
* var resultFeatures = polygon.features.concat(pointOnPolygon);
* var result = {
*   "type": "FeatureCollection",
*   "features": resultFeatures
* };
 *
 * //=result
 */
module.exports = function(fc) {
  // normalize
  if(fc.type != 'FeatureCollection') {
    if(fc.type != 'Feature') {
      fc = {
        type: 'Feature',
        geometry: fc,
        properties: {}
      };
    }
    fc = featureCollection([fc]);
  }

  //get centroid
  var cent = centroid(fc);

  // check to see if centroid is on surface
  var onSurface = false;
  var i = 0;
  while(!onSurface && i < fc.features.length) {
    var geom = fc.features[i].geometry;
    if (geom.type === 'Point') {
      if (cent.geometry.coordinates[0] === geom.coordinates[0] &&
        cent.geometry.coordinates[1] === geom.coordinates[1]) {
        onSurface = true;
      }
    } else if(geom.type === 'MultiPoint') {
      var onMultiPoint = false;
      var k = 0;
      while(!onMultiPoint && k < geom.coordinates.length) {
        if (cent.geometry.coordinates[0] === geom.coordinates[k][0] &&
          cent.geometry.coordinates[1] === geom.coordinates[k][1]) {
          onSurface = true;
          onMultiPoint = true;
        }
        k++;
      }
    } else if(geom.type === 'LineString') {
      var onLine = false;
      var k = 0;
      while(!onLine && k < geom.coordinates.length - 1) {
        var x = cent.geometry.coordinates[0];
        var y = cent.geometry.coordinates[1];
        var x1 = geom.coordinates[k][0];
        var y1 = geom.coordinates[k][1];
        var x2 = geom.coordinates[k+1][0];
        var y2 = geom.coordinates[k+1][1];
        if(pointOnSegment(x, y, x1, y1, x2, y2)) {
          onLine = true;
          onSurface = true;
        }
        k++;
      }
    } else if(geom.type === 'MultiLineString') {
      var onMultiLine = false;
      var j = 0;
      while(!onMultiLine && j < geom.coordinates.length) {
        var onLine = false;
        var k = 0;
        var line = geom.coordinates[j];
        while(!onLine && k < line.length - 1) {
          var x = cent.geometry.coordinates[0];
          var y = cent.geometry.coordinates[1];
          var x1 = line[k][0];
          var y1 = line[k][1];
          var x2 = line[k+1][0];
          var y2 = line[k+1][1];
          if(pointOnSegment(x, y, x1, y1, x2, y2)) {
            onLine = true;
            onSurface = true;
          }
          k++;
        }
        j++;
      }
    } else if(geom.type === 'Polygon' || geom.type === 'MultiPolygon') {
      var f = {
        type: 'Feature',
        geometry: geom,
        properties: {}
      };
      if(inside(cent, f)) {
        onSurface = true;
      }
    }
    i++;
  }
  if(onSurface) {
    return cent;
  } else {
    var vertices = featureCollection([]);
    for(var i = 0; i < fc.features.length; i++) {
      vertices.features = vertices.features.concat(explode(fc.features[i]).features);
    }
    var closestVertex;
    var closestDistance = Infinity;
    for(var i = 0; i < vertices.features.length; i++) {
      var dist = distance(cent, vertices.features[i], 'miles');
      if(dist < closestDistance) {
        closestDistance = dist;
        closestVertex = vertices.features[i];
      }
    }
    return closestVertex;
  }
};

function pointOnSegment (x, y, x1, y1, x2, y2) {
  var ab = Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));
  var ap = Math.sqrt((x-x1)*(x-x1)+(y-y1)*(y-y1));
  var pb = Math.sqrt((x2-x)*(x2-x)+(y2-y)*(y2-y));
  if(ab === ap + pb) {
    return true;
  }
}

},{"turf-center":75,"turf-distance":114,"turf-explode":122,"turf-featurecollection":126,"turf-inside":130}],156:[function(require,module,exports){
/**
 * Takes coordinates and properties (optional) and returns a new {@link Point} feature.
 *
 * @module turf/point
 * @category helper
 * @param {number} longitude position west to east in decimal degrees
 * @param {number} latitude position south to north in decimal degrees
 * @param {Object} properties an Object that is used as the {@link Feature}'s
 * properties
 * @return {Point} a Point feature
 * @example
 * var pt1 = turf.point([-75.343, 39.984]);
 *
 * //=pt1
 */
var isArray = Array.isArray || function(arg) {
  return Object.prototype.toString.call(arg) === '[object Array]';
};
module.exports = function(coordinates, properties) {
  if (!isArray(coordinates)) throw new Error('Coordinates must be an array');
  if (coordinates.length < 2) throw new Error('Coordinates must be at least 2 numbers long');
  return {
    type: "Feature",
    geometry: {
      type: "Point",
      coordinates: coordinates
    },
    properties: properties || {}
  };
};

},{}],157:[function(require,module,exports){
/**
 * Takes an array of LinearRings and optionally an {@link Object} with properties and returns a GeoJSON {@link Polygon} feature.
 *
 * @module turf/polygon
 * @category helper
 * @param {Array<Array<Number>>} rings an array of LinearRings
 * @param {Object} properties an optional properties object
 * @return {Polygon} a Polygon feature
 * @throws {Error} throw an error if a LinearRing of the polygon has too few positions
 * or if a LinearRing of the Polygon does not have matching Positions at the
 * beginning & end.
 * @example
 * var polygon = turf.polygon([[
 *  [-2.275543, 53.464547],
 *  [-2.275543, 53.489271],
 *  [-2.215118, 53.489271],
 *  [-2.215118, 53.464547],
 *  [-2.275543, 53.464547]
 * ]], { name: 'poly1', population: 400});
 *
 * //=polygon
 */
module.exports = function(coordinates, properties){

  if (coordinates === null) throw new Error('No coordinates passed');

  for (var i = 0; i < coordinates.length; i++) {
    var ring = coordinates[i];
    for (var j = 0; j < ring[ring.length - 1].length; j++) {
      if (ring.length < 4) {
        throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');
      }
      if (ring[ring.length - 1][j] !== ring[0][j]) {
        throw new Error('First and last Position are not equivalent.');
      }
    }
  }

  var polygon = {
    "type": "Feature",
    "geometry": {
      "type": "Polygon",
      "coordinates": coordinates
    },
    "properties": properties
  };

  if (!polygon.properties) {
    polygon.properties = {};
  }

  return polygon;
};

},{}],158:[function(require,module,exports){
var ss = require('simple-statistics');

/**
* Takes a {@link FeatureCollection}, a property name, and a set of percentiles and returns a quantile array.
* @module turf/quantile
* @category classification
* @param {FeatureCollection} input a FeatureCollection of any type
* @param {String} field the property in `input` from which to retrieve quantile values
* @param {Array<number>} percentiles an Array of percentiles on which to calculate quantile values
* @return {Array<number>} an array of the break values
* @example
* var points = {
*   "type": "FeatureCollection",
*   "features": [
*     {
*       "type": "Feature",
*       "properties": {
*         "population": 5
*       },
*       "geometry": {
*         "type": "Point",
*         "coordinates": [5, 5]
*       }
*     }, {
*       "type": "Feature",
*       "properties": {
*         "population": 40
*       },
*       "geometry": {
*         "type": "Point",
*         "coordinates": [1, 3]
*       }
*     }, {
*       "type": "Feature",
*       "properties": {
*         "population": 80
*       },
*       "geometry": {
*         "type": "Point",
*         "coordinates": [14, 2]
*       }
*     }, {
*       "type": "Feature",
*       "properties": {
*         "population": 90
*       },
*       "geometry": {
*         "type": "Point",
*         "coordinates": [13, 1]
*       }
*     }, {
*       "type": "Feature",
*       "properties": {
*         "population": 100
*       },
*       "geometry": {
*         "type": "Point",
*         "coordinates": [19, 7]
*       }
*     }
*   ]
* };
*
* var breaks = turf.quantile(
*   points, 'population', [25, 50, 75, 99]);
*
* //=breaks
*/
module.exports = function(fc, field, percentiles){
  var vals = [];
  var quantiles = [];

  fc.features.forEach(function(feature){
    vals.push(feature.properties[field]);
  });
  percentiles.forEach(function(percentile){
    quantiles.push(ss.quantile(vals, percentile * 0.01));
  });
  return quantiles;
};

},{"simple-statistics":159}],159:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113}],160:[function(require,module,exports){
var random = require('geojson-random');

/**
 * Generates random {@link GeoJSON} data, including {@link Point|Points} and {@link Polygon|Polygons}, for testing
 * and experimentation.
 *
 * @module turf/random
 * @category data
 * @param {String} [type='point'] type of features desired: 'points' or 'polygons'
 * @param {Number} [count=1] how many geometries should be generated.
 * @param {Object} options options relevant to the feature desired. Can include:
 * @param {Array<number>} options.bbox a bounding box inside of which geometries
 * are placed. In the case of {@link Point} features, they are guaranteed to be within this bounds,
 * while {@link Polygon} features have their centroid within the bounds.
 * @param {Number} [options.num_vertices=10] options.vertices the number of vertices added
 * to polygon features.
 * @param {Number} [options.max_radial_length=10] the total number of decimal
 * degrees longitude or latitude that a polygon can extent outwards to
 * from its center.
 * @return {FeatureCollection} generated random features
 * @example
 * var points = turf.random('points', 100, {
 *   bbox: [-70, 40, -60, 60]
 * });
 *
 * //=points
 *
 * var polygons = turf.random('polygons', 4, {
 *   bbox: [-70, 40, -60, 60]
 * });
 *
 * //=polygons
 */
module.exports = function(type, count, options) {
    options = options || {};
    count = count || 1;
    switch (type) {
        case 'point':
        case 'points':
        case undefined:
            return random.point(count, options.bbox);
        case 'polygon':
        case 'polygons':
            return random.polygon(
                count,
                options.num_vertices,
                options.max_radial_length,
                options.bbox);
        default:
            throw new Error('Unknown type given: valid options are points and polygons');
    }
};

},{"geojson-random":161}],161:[function(require,module,exports){
module.exports = function() {
    throw new Error('call .point() or .polygon() instead');
};

function position(bbox) {
    if (bbox) return coordInBBBOX(bbox);
    else return [lon(), lat()];
}

module.exports.position = position;

module.exports.point = function(count, bbox) {
    var features = [];
    for (i = 0; i < count; i++) {
        features.push(feature(bbox ? point(position(bbox)) : point()));
    }
    return collection(features);
};

module.exports.polygon = function(count, num_vertices, max_radial_length, bbox) {
    if (typeof num_vertices !== 'number') num_vertices = 10;
    if (typeof max_radial_length !== 'number') max_radial_length = 10;
    var features = [];
    for (i = 0; i < count; i++) {
        var vertices = [],
            circle_offsets = Array.apply(null,
                new Array(num_vertices + 1)).map(Math.random);

        circle_offsets.forEach(sumOffsets);
        circle_offsets.forEach(scaleOffsets);
        vertices[vertices.length - 1] = vertices[0]; // close the ring

        // center the polygon around something
        vertices = vertices.map(vertexToCoordinate(position(bbox)));
        features.push(feature(polygon([vertices])));
    }

    function sumOffsets(cur, index, arr) {
        arr[index] = (index > 0) ? cur + arr[index - 1] : cur;
    }

    function scaleOffsets(cur, index) {
        cur = cur * 2 * Math.PI / circle_offsets[circle_offsets.length - 1];
        var radial_scaler = Math.random();
        vertices.push([
            radial_scaler * max_radial_length * Math.sin(cur),
            radial_scaler * max_radial_length * Math.cos(cur)
        ]);
    }

    return collection(features);
};


function vertexToCoordinate(hub) {
    return function(cur, index) { return [cur[0] + hub[0], cur[1] + hub[1]]; };
}

function rnd() { return Math.random() - 0.5; }
function lon() { return rnd() * 360; }
function lat() { return rnd() * 180; }

function point(coordinates) {
    return {
        type: 'Point',
        coordinates: coordinates || [lon(), lat()]
    };
}

function coordInBBBOX(bbox) {
    return [
        (Math.random() * (bbox[2] - bbox[0])) + bbox[0],
        (Math.random() * (bbox[3] - bbox[1])) + bbox[1]];
}

function pointInBBBOX() {
    return {
        type: 'Point',
        coordinates: [lon(), lat()]
    };
}

function polygon(coordinates) {
    return {
        type: 'Polygon',
        coordinates: coordinates
    };
}

function feature(geom) {
    return {
        type: 'Feature',
        geometry: geom,
        properties: {}
    };
}

function collection(f) {
    return {
        type: 'FeatureCollection',
        features: f
    };
}

},{}],162:[function(require,module,exports){
var featurecollection = require('turf-featurecollection');
var reclass = require('./index.js');

/**
 * Takes a {@link FeatureCollection}, an input field, an output field, and
 * an array of translations and outputs an identical FeatureCollection with
 * the output field property populated.
* @module turf/reclass
* @category classification
* @param {FeatureCollection} input a FeatureCollection of any type
* @param {string} inField the field to translate
* @param {string} outField the field in which to store translated results
* @param {Array<number>} translations an array of translations
* @return {FeatureCollection} a FeatureCollection with identical geometries to `input` but with `outField` populated.
* @example
* var points = {
*   "type": "FeatureCollection",
*   "features": [
*     {
*       "type": "Feature",
*       "properties": {
*         "population": 200
*       },
*       "geometry": {
*         "type": "Point",
*         "coordinates": [13.170547, 32.888669]
*       }
*     }, {
*       "type": "Feature",
*       "properties": {
*         "population": 600
*       },
*       "geometry": {
*         "type": "Point",
*         "coordinates": [13.182048, 32.889533]
*       }
*     }, {
*       "type": "Feature",
*       "properties": {
*         "population": 100
*       },
*       "geometry": {
*         "type": "Point",
*         "coordinates": [13.17398, 32.882182]
*       }
*     }, {
*       "type": "Feature",
*       "properties": {
*         "population": 200
*       },
*       "geometry": {
*         "type": "Point",
*         "coordinates": [13.174324, 32.895011]
*       }
*     }, {
*       "type": "Feature",
*       "properties": {
*         "population": 300
*       },
*       "geometry": {
*         "type": "Point",
*         "coordinates": [13.185825, 32.884344]
*       }
*     }
*   ]
* };
* // 0 to 200 will map to "small", 200 to 400 will map to "medium", 400 to 600 will map to "large"
* var translations = [
*   [0, 200, "small"],
*   [200, 400, "medium"],
*   [400, 600, "large"]
* ];
*
* var reclassed = turf.reclass(
*   points, 'population', 'size', translations);
*
* //=reclassed
*
*/
module.exports = function(fc, inField, outField, translations, done){
  var reclassed = featurecollection([]);

  fc.features.forEach(function(feature){
    var reclassedFeature;
    var found = false;
    for(var i = 0; i < translations.length; i++){
      if(feature.properties[inField] >= translations[i][0] && feature.properties[inField] <= translations[i][1]) {
        feature.properties[outField] = translations[i][2];
      }
    }
    reclassed.features.push(feature);
  });

  return reclassed;
};

},{"./index.js":162,"turf-featurecollection":126}],163:[function(require,module,exports){
var featureCollection = require('turf-featurecollection');

/**
 * Takes a {@link FeatureCollection} of any type, a property, and a value and
 * returns a FeatureCollection with features matching that
 * property-value pair removed.
 *
 * @module turf/remove
 * @category data
 * @param {FeatureCollection} features a FeatureCollection of any type
 * @param {String} property the property to filter
 * @param {String} value the value to filter
 * @return {FeatureCollection} the resulting FeatureCollection without features that match the property-value pair
 * @example
 * var points = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         'marker-color': '#00f'
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-0.235004, 5.551918]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         'marker-color': '#f00'
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-0.209598, 5.56439]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         'marker-color': '#00f'
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-0.197753, 5.556018]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         'marker-color': '#000'
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-0.217323, 5.549526]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         'marker-color': '#0f0'
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-0.211315, 5.543887]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         'marker-color': '#00f'
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-0.202217, 5.547134]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         'marker-color': '#0f0'
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-0.231227, 5.56644]
 *       }
 *     }
 *   ]
 * };
 *
 * //=points
 *
 * var filtered = turf.remove(points, 'marker-color', '#00f');
 *
 * //=filtered
*/
module.exports = function(collection, key, val) {
  var newFC = featureCollection([]);
  for(var i = 0; i < collection.features.length; i++) {
    if(collection.features[i].properties[key] != val) {
      newFC.features.push(collection.features[i]);
    }
  }
  return newFC;
};

},{"turf-featurecollection":126}],164:[function(require,module,exports){
// http://stackoverflow.com/questions/11935175/sampling-a-random-subset-from-an-array
var featureCollection = require('turf-featurecollection');

/**
 * Takes a {@link FeatureCollection} and returns a FeatureCollection with given number of {@link Feature|features} at random.
 *
 * @module turf/sample
 * @category data
 * @param {FeatureCollection} features a FeatureCollection of any type
 * @param {number} n number of features to select
 * @return {FeatureCollection} a FeatureCollection with `n` features
 * @example
 * var points = turf.random('points', 1000);
 *
 * //=points
 *
 * var sample = turf.sample(points, 10);
 *
 * //=sample
 */
module.exports = function(fc, num){
  var outFC = featureCollection(getRandomSubarray(fc.features, num));
  return outFC;
};

function getRandomSubarray(arr, size) {
  var shuffled = arr.slice(0), i = arr.length, min = i - size, temp, index;
  while (i-- > min) {
      index = Math.floor((i + 1) * Math.random());
      temp = shuffled[index];
      shuffled[index] = shuffled[i];
      shuffled[i] = temp;
  }
  return shuffled.slice(min);
}

},{"turf-featurecollection":126}],165:[function(require,module,exports){
var simplify = require('simplify-js');

/**
 * Takes a {@link LineString} or {@link Polygon} feature and returns a simplified version. Internally uses [simplify-js](http://mourner.github.io/simplify-js/) to perform simplification.
 *
 * @module turf/simplify
 * @category transformation
 * @param {Feature} feature a {@link LineString} or {@link Polygon} feature to be simplified
 * @param {number} tolerance simplification tolerance
 * @param {boolean} highQuality whether or not to spend more time to create
 * a higher-quality simplification with a different algorithm
 * @return {Feature} a simplified feature
 * @example
  * var feature = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-70.603637, -33.399918],
 *       [-70.614624, -33.395332],
 *       [-70.639343, -33.392466],
 *       [-70.659942, -33.394759],
 *       [-70.683975, -33.404504],
 *       [-70.697021, -33.419406],
 *       [-70.701141, -33.434306],
 *       [-70.700454, -33.446339],
 *       [-70.694274, -33.458369],
 *       [-70.682601, -33.465816],
 *       [-70.668869, -33.472117],
 *       [-70.646209, -33.473835],
 *       [-70.624923, -33.472117],
 *       [-70.609817, -33.468107],
 *       [-70.595397, -33.458369],
 *       [-70.587158, -33.442901],
 *       [-70.587158, -33.426283],
 *       [-70.590591, -33.414248],
 *       [-70.594711, -33.406224],
 *       [-70.603637, -33.399918]
 *     ]]
 *   }
 * };

 * var tolerance = 0.01;
 *
 * var simplified = turf.simplify(
 *  feature, tolerance, false);
 *
 * //=feature
 *
 * //=simplified
 */
module.exports = function(feature, tolerance, highQuality){
  if(feature.geometry.type === 'LineString') {
    var line = {
      type: 'LineString',
      coordinates: []
    };
    var pts = feature.geometry.coordinates.map(function(coord) {
      return {x: coord[0], y: coord[1]};
    });
    line.coordinates = simplify(pts, tolerance, highQuality).map(function(coords){
      return [coords.x, coords.y];
    });
    
    return simpleFeature(line, feature.properties);
  } else if(feature.geometry.type === 'Polygon') {
    var poly = {
      type: 'Polygon',
      coordinates: []
    };
    feature.geometry.coordinates.forEach(function(ring){
      var pts = ring.map(function(coord) {
        return {x: coord[0], y: coord[1]};
      });
      var simpleRing = simplify(pts, tolerance, highQuality).map(function(coords){
        return [coords.x, coords.y];
      });
      poly.coordinates.push(simpleRing);
    });
    return simpleFeature(poly, feature.properties)
  }
}

function simpleFeature (geom, properties) {
  return {
    type: 'Feature',
    geometry: geom,
    properties: properties
  };
}

},{"simplify-js":166}],166:[function(require,module,exports){
/*
 (c) 2013, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

(function () { 'use strict';

// to suit your point format, run search/replace for '.x' and '.y';
// for 3D version, see 3d branch (configurability would draw significant performance overhead)

// square distance between 2 points
function getSqDist(p1, p2) {

    var dx = p1.x - p2.x,
        dy = p1.y - p2.y;

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p, p1, p2) {

    var x = p1.x,
        y = p1.y,
        dx = p2.x - x,
        dy = p2.y - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2.x;
            y = p2.y;

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p.x - x;
    dy = p.y - y;

    return dx * dx + dy * dy;
}
// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance) {

    var prevPoint = points[0],
        newPoints = [prevPoint],
        point;

    for (var i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}

// simplification using optimized Douglas-Peucker algorithm with recursion elimination
function simplifyDouglasPeucker(points, sqTolerance) {

    var len = points.length,
        MarkerArray = typeof Uint8Array !== 'undefined' ? Uint8Array : Array,
        markers = new MarkerArray(len),
        first = 0,
        last = len - 1,
        stack = [],
        newPoints = [],
        i, maxSqDist, sqDist, index;

    markers[first] = markers[last] = 1;

    while (last) {

        maxSqDist = 0;

        for (i = first + 1; i < last; i++) {
            sqDist = getSqSegDist(points[i], points[first], points[last]);

            if (sqDist > maxSqDist) {
                index = i;
                maxSqDist = sqDist;
            }
        }

        if (maxSqDist > sqTolerance) {
            markers[index] = 1;
            stack.push(first, index, index, last);
        }

        last = stack.pop();
        first = stack.pop();
    }

    for (i = 0; i < len; i++) {
        if (markers[i]) newPoints.push(points[i]);
    }

    return newPoints;
}

// both algorithms combined for awesome performance
function simplify(points, tolerance, highestQuality) {

    var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;

    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);

    return points;
}

// export as AMD module / Node module / browser or worker variable
if (typeof define === 'function' && define.amd) define(function() { return simplify; });
else if (typeof module !== 'undefined') module.exports = simplify;
else if (typeof self !== 'undefined') self.simplify = simplify;
else window.simplify = simplify;

})();

},{}],167:[function(require,module,exports){
/**
 * Takes a bounding box and returns a new bounding box with a size expanded or contracted
 * by a factor of X.
 *
 * @module turf/size
 * @category measurement
 * @param {Array<number>} bbox a bounding box
 * @param {number} factor the ratio of the new bbox to the input bbox
 * @return {Array<number>} the resized bbox
 * @example
 * var bbox = [0, 0, 10, 10]
 *
 * var resized = turf.size(bbox, 2);
 *
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     turf.bboxPolygon(bbox),
 *     turf.bboxPolygon(resized)
 *   ]
 * };
 *
 * //=features
 */
module.exports = function(bbox, factor){
  var currentXDistance = (bbox[2] - bbox[0]);
  var currentYDistance = (bbox[3] - bbox[1]);
  var newXDistance = currentXDistance * factor;
  var newYDistance = currentYDistance * factor;
  var xChange = newXDistance - currentXDistance;
  var yChange = newYDistance - currentYDistance;

  var lowX = bbox[0] - (xChange / 2);
  var lowY = bbox[1] - (yChange / 2);
  var highX = (xChange / 2) + bbox[2];
  var highY = (yChange / 2) + bbox[3];

  var sized = [lowX, lowY, highX, highY];
  return sized;
}

},{}],168:[function(require,module,exports){
var featurecollection = require('turf-featurecollection');
var point = require('turf-point');
var polygon = require('turf-polygon');
var distance = require('turf-distance');

/**
 * Takes a bounding box and a cell depth and returns a {@link FeatureCollection} of {@link Polygon} features in a grid.
 *
 * @module turf/square-grid
 * @category interpolation
 * @param {Array<number>} extent extent in [minX, minY, maxX, maxY] order
 * @param {Number} cellWidth width of each cell
 * @param {String} units units to use for cellWidth
 * @return {FeatureCollection} grid as FeatureCollection with {@link Polygon} features
 * @example
 * var extent = [-77.3876953125,38.71980474264239,-76.9482421875,39.027718840211605];
 * var cellWidth = 10;
 * var units = 'miles';
 *
 * var squareGrid = turf.squareGrid(extent, cellWidth, units);
 *
 * //=squareGrid
 */
module.exports = function (bbox, cell, units) {
  var fc = featurecollection([]);
  var xFraction = cell / (distance(point([bbox[0], bbox[1]]), point([bbox[2], bbox[1]]), units));
  var cellWidth = xFraction * (bbox[2] - bbox[0]);
  var yFraction = cell / (distance(point([bbox[0], bbox[1]]), point([bbox[0], bbox[3]]), units));
  var cellHeight = yFraction * (bbox[3] - bbox[1]);

  var currentX = bbox[0];
  while (currentX <= bbox[2]) {
    var currentY = bbox[1];
    while (currentY <= bbox[3]) {
      var cellPoly = polygon([[
          [currentX, currentY],
          [currentX, currentY+cellHeight],
          [currentX+cellWidth, currentY+cellHeight],
          [currentX+cellWidth, currentY],
          [currentX, currentY]
        ]]);
      fc.features.push(cellPoly);

      currentY += cellHeight;
    }
    currentX += cellWidth;
  }
  
  return fc;
}

},{"turf-distance":114,"turf-featurecollection":126,"turf-point":156,"turf-polygon":157}],169:[function(require,module,exports){
var midpoint = require('turf-midpoint');
var point = require('turf-point');
var distance = require('turf-distance');

/**
 * Takes a bounding box and calculates the minimum square bounding box that would contain the input.
 *
 * @module turf/square
 * @category measurement
 * @param {Array<number>} bbox a bounding box
 * @return {Array<number>} a square surrounding `bbox`
 * @example
 * var bbox = [-20,-20,-15,0];
 *
 * var squared = turf.square(bbox);
 *
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     turf.bboxPolygon(bbox),
 *     turf.bboxPolygon(squared)
 *   ]
 * };
 *
 * //=features
 */
module.exports = function(bbox){
  var squareBbox = [0,0,0,0];
  var lowLeft = point([bbox[0], bbox[1]]);
  var topLeft = point([bbox[0], bbox[3]]);
  var topRight = point([bbox[2], bbox[3]]);
  var lowRight = point([bbox[2], bbox[1]]);

  var horizontalDistance = distance(lowLeft, lowRight, 'miles');
  var verticalDistance = distance(lowLeft, topLeft, 'miles');
  if(horizontalDistance >= verticalDistance){
    squareBbox[0] = bbox[0];
    squareBbox[2] = bbox[2];
    var verticalMidpoint = midpoint(lowLeft, topLeft);
    squareBbox[1] = verticalMidpoint.geometry.coordinates[1] - ((bbox[2] - bbox[0]) / 2);
    squareBbox[3] = verticalMidpoint.geometry.coordinates[1] + ((bbox[2] - bbox[0]) / 2);
    return squareBbox;
  }
  else {
    squareBbox[1] = bbox[1];
    squareBbox[3] = bbox[3];
    var horzontalMidpoint = midpoint(lowLeft, lowRight);
    squareBbox[0] = horzontalMidpoint.geometry.coordinates[0] - ((bbox[3] - bbox[1]) / 2);
    squareBbox[2] = horzontalMidpoint.geometry.coordinates[0] + ((bbox[3] - bbox[1]) / 2);
    return squareBbox;
  }
}


},{"turf-distance":114,"turf-midpoint":149,"turf-point":156}],170:[function(require,module,exports){
var inside = require('turf-inside');

/**
 * Calculates the sum of a field for {@link Point} features within a set of {@link Polygon} features.
 *
 * @module turf/sum
 * @category aggregation
 * @param {FeatureCollection} polygons a FeatureCollection of {@link Polygon} features
 * @param {FeatureCollection} points a FeatureCollection of {@link Point} features
 * @param {String} inField the field in input data to analyze
 * @param {String} outField the field in which to store results
 * @return {FeatureCollection} a FeatureCollection of {@link Polygon} features
 * with properties listed as `outField`
 * @example
 * var polygons = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [[
 *           [-87.990188, 43.026486],
 *           [-87.990188, 43.062115],
 *           [-87.913284, 43.062115],
 *           [-87.913284, 43.026486],
 *           [-87.990188, 43.026486]
 *         ]]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [[
 *           [-87.973709, 42.962452],
 *           [-87.973709, 43.014689],
 *           [-87.904014, 43.014689],
 *           [-87.904014, 42.962452],
 *           [-87.973709, 42.962452]
 *         ]]
 *       }
 *     }
 *   ]
 * };
 * var points = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "population": 200
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-87.974052, 43.049321]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "population": 600
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-87.957229, 43.037277]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "population": 100
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-87.931137, 43.048568]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "population": 200
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-87.963409, 42.99611]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "population": 300
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-87.94178, 42.974762]
 *       }
 *     }
 *   ]
 * };
 *
 * var aggregated = turf.sum(
 *   polygons, points, 'population', 'sum');
 *
 * var resultFeatures = points.features.concat(
 *   aggregated.features);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */
module.exports = function(polyFC, ptFC, inField, outField){
  polyFC.features.forEach(function(poly){
    if(!poly.properties){
      poly.properties = {};
    }
    var values = [];
    ptFC.features.forEach(function(pt){
      if (inside(pt, poly)) {
        values.push(pt.properties[inField]);
      }
    });
    poly.properties[outField] = sum(values);
  });

  return polyFC;
};

function sum(x) {
    var value = 0;
    for (var i = 0; i < x.length; i++) {
        value += x[i];
    }
    return value;
}

},{"turf-inside":130}],171:[function(require,module,exports){
var inside = require('turf-inside');

/**
 * Takes a {@link FeatureCollection} of {@link Point} features and a FeatureCollection of {@link Polygon} features and performs a spatial join.
 *
 * @module turf/tag
 * @category joins
 * @param {FeatureCollection} points a FeatureCollection of {@link Point} features
 * @param {FeatureCollection} polygons a FeatureCollection of {@link Polygon} features
 * @param {String} polyId property in `polygons` to add to joined Point features
 * @param {String} containingPolyId property in `points` in which to store joined property from `polygons
 * @return {FeatureCollection} a FeatureCollection of point features
 * @example
 * var bbox = [0, 0, 50, 50];
 * // create a triangular grid of polygons
 * var triangleGrid = turf.tin(turf.grid(bbox, 10));
 * triangleGrid.features.forEach(function(f) {
 *   f.properties.fill = '#' +
 *     (~~(Math.random() * 16)).toString(16) +
 *     (~~(Math.random() * 16)).toString(16) +
 *     (~~(Math.random() * 16)).toString(16);
 *   f.properties.stroke = 0;
 *   f.properties['fill-opacity'] = 1;
 * });
 * var randomPoints = turf.random('point', 30, {
 *   bbox: bbox
 * });
 * var both = turf.featurecollection(
 *   triangleGrid.features.concat(randomPoints.features));
 *
 * //=both
 *
 * var tagged = turf.tag(randomPoints, triangleGrid,
 *                       'fill', 'marker-color');
 *
 * //=tagged
 */
module.exports = function(points, polygons, field, outField){
  // prevent mutations
  points = JSON.parse(JSON.stringify(points));
  polygons = JSON.parse(JSON.stringify(polygons));
  points.features.forEach(function(pt) {
    if (!pt.properties) {
      pt.properties = {};
    }
    polygons.features.forEach(function(poly) {
      if (pt.properties[outField] === undefined) {
        var isInside = inside(pt, poly);
        if (isInside) {
          pt.properties[outField] = poly.properties[field];
        }
      }
    });
  });
  return points;
};

},{"turf-inside":130}],172:[function(require,module,exports){
//http://en.wikipedia.org/wiki/Delaunay_triangulation
//https://github.com/ironwallaby/delaunay
var polygon = require('turf-polygon');
var featurecollection = require('turf-featurecollection');

/**
 * Takes a set of points and the name of a z-value property and
 * creates a [Triangulated Irregular Network](http://en.wikipedia.org/wiki/Triangulated_irregular_network),
 * or a TIN for short, returned as a collection of Polygons. These are often used
 * for developing elevation contour maps or stepped heat visualizations.
 *
 * This triangulates the points, as well as adds properties called `a`, `b`,
 * and `c` representing the value of the given `propertyName` at each of
 * the points that represent the corners of the triangle.
 *
 * @module turf/tin
 * @category interpolation
 * @param {FeatureCollection} points - a GeoJSON FeatureCollection containing
 * Features with {@link Point} geometries
 * @param {string=} propertyName - name of the property from which to pull z values.
 * This is optional: if not given, then there will be no extra data added to the derived triangles.
 * @return {FeatureCollection} TIN output
 * @example
 * // generate some random point data
 * var points = turf.random('points', 30, {
 *   bbox: [50, 30, 70, 50]
 * });
 * //=points
 * // add a random property to each point between 0 and 9
 * for (var i = 0; i < points.features.length; i++) {
 *   points.features[i].properties.z = ~~(Math.random() * 9);
 * }
 * var tin = turf.tin(points, 'z')
 * for (var i = 0; i < tin.features.length; i++) {
 *   var properties  = tin.features[i].properties;
 *   // roughly turn the properties of each
 *   // triangle into a fill color
 *   // so we can visualize the result
 *   properties.fill = '#' + properties.a +
 *     properties.b + properties.c;
 * }
 * //=tin
 */
module.exports = function(points, z) {
  //break down points
  return featurecollection(triangulate(points.features.map(function(p) {
    var point = {
      x: p.geometry.coordinates[0],
      y: p.geometry.coordinates[1]
    };
    if (z) point.z = p.properties[z];
    return point;
  })).map(function(triangle) {
    return polygon([[
        [triangle.a.x, triangle.a.y],
        [triangle.b.x, triangle.b.y],
        [triangle.c.x, triangle.c.y],
        [triangle.a.x, triangle.a.y]
    ]], {
        a: triangle.a.z,
        b: triangle.b.z,
        c: triangle.c.z
      });
  }));
};

function Triangle(a, b, c) {
  this.a = a;
  this.b = b;
  this.c = c;

  var A = b.x - a.x,
    B = b.y - a.y,
    C = c.x - a.x,
    D = c.y - a.y,
    E = A * (a.x + b.x) + B * (a.y + b.y),
    F = C * (a.x + c.x) + D * (a.y + c.y),
    G = 2 * (A * (c.y - b.y) - B * (c.x - b.x)),
    minx, miny, dx, dy;

  // If the points of the triangle are collinear, then just find the
  // extremes and use the midpoint as the center of the circumcircle.
  if (Math.abs(G) < 0.000001) {
    minx = Math.min(a.x, b.x, c.x);
    miny = Math.min(a.y, b.y, c.y);
    dx = (Math.max(a.x, b.x, c.x) - minx) * 0.5;
    dy = (Math.max(a.y, b.y, c.y) - miny) * 0.5;

    this.x = minx + dx;
    this.y = miny + dy;
    this.r = dx * dx + dy * dy;
  } else {
    this.x = (D * E - B * F) / G;
    this.y = (A * F - C * E) / G;
    dx = this.x - a.x;
    dy = this.y - a.y;
    this.r = dx * dx + dy * dy;
  }
}

function byX(a, b) {
  return b.x - a.x;
}

function dedup(edges) {
  var j = edges.length,
    a, b, i, m, n;

  outer:
  while (j) {
    b = edges[--j];
    a = edges[--j];
    i = j;
    while (i) {
      n = edges[--i];
      m = edges[--i];
      if ((a === m && b === n) || (a === n && b === m)) {
        edges.splice(j, 2);
        edges.splice(i, 2);
        j -= 2;
        continue outer;
      }
    }
  }
}

function triangulate(vertices) {
  // Bail if there aren't enough vertices to form any triangles.
  if (vertices.length < 3)
    return [];

    // Ensure the vertex array is in order of descending X coordinate
    // (which is needed to ensure a subquadratic runtime), and then find
    // the bounding box around the points. 
  vertices.sort(byX);

  var i = vertices.length - 1,
    xmin = vertices[i].x,
    xmax = vertices[0].x,
    ymin = vertices[i].y,
    ymax = ymin;

  while (i--) {
    if (vertices[i].y < ymin)
      ymin = vertices[i].y;
    if (vertices[i].y > ymax)
      ymax = vertices[i].y;
  }

  //Find a supertriangle, which is a triangle that surrounds all the
  //vertices. This is used like something of a sentinel value to remove
  //cases in the main algorithm, and is removed before we return any
  // results.
 
  // Once found, put it in the "open" list. (The "open" list is for
  // triangles who may still need to be considered; the "closed" list is
  // for triangles which do not.)
  var dx = xmax - xmin,
    dy = ymax - ymin,
    dmax = (dx > dy) ? dx : dy,
    xmid = (xmax + xmin) * 0.5,
    ymid = (ymax + ymin) * 0.5,
    open = [
      new Triangle({
        x: xmid - 20 * dmax,
        y: ymid - dmax,
        __sentinel: true
      },
      {
        x: xmid,
        y: ymid + 20 * dmax,
        __sentinel: true
      },
      {
        x: xmid + 20 * dmax,
        y: ymid - dmax,
        __sentinel: true
      }
    )],
    closed = [],
    edges = [],
    j, a, b;

    // Incrementally add each vertex to the mesh.
  i = vertices.length;
  while (i--) {
    // For each open triangle, check to see if the current point is
    // inside it's circumcircle. If it is, remove the triangle and add
    // it's edges to an edge list.
    edges.length = 0;
    j = open.length;
    while (j--) {
      // If this point is to the right of this triangle's circumcircle,
      // then this triangle should never get checked again. Remove it
      // from the open list, add it to the closed list, and skip.
      dx = vertices[i].x - open[j].x;
      if (dx > 0 && dx * dx > open[j].r) {
        closed.push(open[j]);
        open.splice(j, 1);
        continue;
      }

      // If not, skip this triangle.
      dy = vertices[i].y - open[j].y;
      if (dx * dx + dy * dy > open[j].r)
        continue;

      // Remove the triangle and add it's edges to the edge list.
      edges.push(
        open[j].a, open[j].b,
        open[j].b, open[j].c,
        open[j].c, open[j].a
      );
      open.splice(j, 1);
    }

    // Remove any doubled edges.
    dedup(edges);

    // Add a new triangle for each edge.
    j = edges.length;
    while (j) {
      b = edges[--j];
      a = edges[--j];
      open.push(new Triangle(a, b, vertices[i]));
    }
  }

  // Copy any remaining open triangles to the closed list, and then
  // remove any triangles that share a vertex with the supertriangle.
  Array.prototype.push.apply(closed, open);

  i = closed.length;
  while (i--)
  if (closed[i].a.__sentinel ||
      closed[i].b.__sentinel ||
      closed[i].c.__sentinel)
      closed.splice(i, 1);

  return closed;
}

},{"turf-featurecollection":126,"turf-polygon":157}],173:[function(require,module,exports){
var featurecollection = require('turf-featurecollection');
var point = require('turf-point');
var polygon = require('turf-polygon');
var distance = require('turf-distance');

/**
 * Takes a bounding box and a cell depth and returns a {@link FeatureCollection} of {@link Polygon} features in a grid.
 *
 * @module turf/triangle-grid
 * @category interpolation
 * @param {Array<number>} extent extent in [minX, minY, maxX, maxY] order
 * @param {Number} cellWidth width of each cell
 * @param {String} units units to use for cellWidth
 * @return {FeatureCollection} grid as FeatureCollection with {@link Polygon} features
 * @example
 * var extent = [-77.3876953125,38.71980474264239,-76.9482421875,39.027718840211605];
 * var cellWidth = 10;
 * var units = 'miles';
 *
 * var triangleGrid = turf.triangleGrid(extent, cellWidth, units);
 *
 * //=triangleGrid
 */
module.exports = function (bbox, cell, units) {
  var fc = featurecollection([]);
  var xFraction = cell / (distance(point([bbox[0], bbox[1]]), point([bbox[2], bbox[1]]), units));
  var cellWidth = xFraction * (bbox[2] - bbox[0]);
  var yFraction = cell / (distance(point([bbox[0], bbox[1]]), point([bbox[0], bbox[3]]), units));
  var cellHeight = yFraction * (bbox[3] - bbox[1]);

  var xi = 0;
  var currentX = bbox[0];
  while (currentX <= bbox[2]) {
    var yi = 0;
    var currentY = bbox[1];
    while (currentY <= bbox[3]) {
      if(xi%2===0 && yi%2===0) {
        var cell1 = polygon([[
            [currentX, currentY],
            [currentX, currentY+cellHeight],
            [currentX+cellWidth, currentY],
            [currentX, currentY]
          ]]);
        fc.features.push(cell1);
        var cell2 = polygon([[
            [currentX, currentY+cellHeight],
            [currentX+cellWidth, currentY+cellHeight],
            [currentX+cellWidth, currentY],
            [currentX, currentY+cellHeight]
          ]]);
        fc.features.push(cell2);
      } else if(xi%2===0 && yi%2===1) {
        var cell1 = polygon([[
            [currentX, currentY],
            [currentX+cellWidth, currentY+cellHeight],
            [currentX+cellWidth, currentY],
            [currentX, currentY]
          ]]);
        fc.features.push(cell1);
        var cell2 = polygon([[
            [currentX, currentY],
            [currentX, currentY+cellHeight],
            [currentX+cellWidth, currentY+cellHeight],
            [currentX, currentY]
          ]]);
        fc.features.push(cell2);
      } else if(yi%2===0 && xi%2===1) {
        var cell1 = polygon([[
            [currentX, currentY],
            [currentX, currentY+cellHeight],
            [currentX+cellWidth, currentY+cellHeight],
            [currentX, currentY]
          ]]);
        fc.features.push(cell1);
        var cell2 = polygon([[
            [currentX, currentY],
            [currentX+cellWidth, currentY+cellHeight],
            [currentX+cellWidth, currentY],
            [currentX, currentY]
          ]]);
        fc.features.push(cell2);
      } else if(yi%2===1 && xi%2===1) {
        var cell1 = polygon([[
            [currentX, currentY],
            [currentX, currentY+cellHeight],
            [currentX+cellWidth, currentY],
            [currentX, currentY]
          ]]);
        fc.features.push(cell1);
        var cell2 = polygon([[
            [currentX, currentY+cellHeight],
            [currentX+cellWidth, currentY+cellHeight],
            [currentX+cellWidth, currentY],
            [currentX, currentY+cellHeight]
          ]]);
        fc.features.push(cell2);
      }
      currentY += cellHeight;
      yi++;
    }
    xi++;
    currentX += cellWidth;
  }
  return fc;
};


},{"turf-distance":114,"turf-featurecollection":126,"turf-point":156,"turf-polygon":157}],174:[function(require,module,exports){
// look here for help http://svn.osgeo.org/grass/grass/branches/releasebranch_6_4/vector/v.overlay/main.c
//must be array of polygons

// depend on jsts for now https://github.com/bjornharrtell/jsts/blob/master/examples/overlay.html

var jsts = require('jsts');

/**
 * Takes two {@link Polygon} features and returnes a combined {@link Polygon} feature. If the input Polygon features are not contiguous, this function returns a {@link MultiPolygon} feature.
 *
 * @module turf/union
 * @category transformation
 * @param {Polygon} poly1 an input Polygon
 * @param {Polygon} poly2 another input Polygon
 * @return {Feature} a combined {@link Polygon} or {@link MultiPolygon} feature
 * @example
 * var poly1 = {
 *   "type": "Feature",
 *   "properties": {
 *     "fill": "#0f0"
 *   },
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-82.574787, 35.594087],
 *       [-82.574787, 35.615581],
 *       [-82.545261, 35.615581],
 *       [-82.545261, 35.594087],
 *       [-82.574787, 35.594087]
 *     ]]
 *   }
 * };
 * var poly2 = {
 *   "type": "Feature",
 *   "properties": {
 *     "fill": "#00f"
 *   },
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-82.560024, 35.585153],
 *       [-82.560024, 35.602602],
 *       [-82.52964, 35.602602],
 *       [-82.52964, 35.585153],
 *       [-82.560024, 35.585153]
 *     ]]
 *   }
 * };
 * var polygons = {
 *   "type": "FeatureCollection",
 *   "features": [poly1, poly2]
 * };
 *
 * var union = turf.union(poly1, poly2);
 *
 * //=polygons
 *
 * //=union
 */
module.exports = function(poly1, poly2){
  var reader = new jsts.io.GeoJSONReader();
  var a = reader.read(JSON.stringify(poly1.geometry));
  var b = reader.read(JSON.stringify(poly2.geometry));
  var union = a.union(b);
  var parser = new jsts.io.GeoJSONParser();

  union = parser.write(union);
  return {
    type: 'Feature',
    geometry: union,
    properties: poly1.properties
  };
}

},{"jsts":175}],175:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"./lib/jsts":176,"dup":19,"javascript.util":178}],176:[function(require,module,exports){
arguments[4][72][0].apply(exports,arguments)
},{"dup":72}],177:[function(require,module,exports){
(function (global){
/*
  javascript.util is a port of selected parts of java.util to JavaScript which
  main purpose is to ease porting Java code to JavaScript.
  
  The MIT License (MIT)

  Copyright (C) 2011-2014 by The Authors

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
*/
;(function(){var e=this;function f(a,b){var c=a.split("."),d=e;c[0]in d||!d.execScript||d.execScript("var "+c[0]);for(var t;c.length&&(t=c.shift());)c.length||void 0===b?d=d[t]?d[t]:d[t]={}:d[t]=b}function g(a,b){function c(){}c.prototype=b.prototype;a.q=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.p=function(a,c,O){var M=Array.prototype.slice.call(arguments,2);return b.prototype[c].apply(a,M)}};function h(a){this.message=a||""}g(h,Error);f("javascript.util.EmptyStackException",h);h.prototype.name="EmptyStackException";function k(a){this.message=a||""}g(k,Error);f("javascript.util.IndexOutOfBoundsException",k);k.prototype.name="IndexOutOfBoundsException";function l(){}f("javascript.util.Iterator",l);l.prototype.hasNext=l.prototype.c;l.prototype.next=l.prototype.next;l.prototype.remove=l.prototype.remove;function m(){}f("javascript.util.Collection",m);function n(){}g(n,m);f("javascript.util.List",n);function p(){}f("javascript.util.Map",p);function q(a){this.message=a||""}g(q,Error);f("javascript.util.NoSuchElementException",q);q.prototype.name="NoSuchElementException";function r(a){this.message=a||""}g(r,Error);r.prototype.name="OperationNotSupported";function s(a){this.a=[];a instanceof m&&this.e(a)}g(s,n);f("javascript.util.ArrayList",s);s.prototype.a=null;s.prototype.add=function(a){this.a.push(a);return!0};s.prototype.add=s.prototype.add;s.prototype.e=function(a){for(a=a.f();a.c();)this.add(a.next());return!0};s.prototype.addAll=s.prototype.e;s.prototype.set=function(a,b){var c=this.a[a];this.a[a]=b;return c};s.prototype.set=s.prototype.set;s.prototype.f=function(){return new u(this)};s.prototype.iterator=s.prototype.f;
s.prototype.get=function(a){if(0>a||a>=this.size())throw new k;return this.a[a]};s.prototype.get=s.prototype.get;s.prototype.g=function(){return 0===this.a.length};s.prototype.isEmpty=s.prototype.g;s.prototype.size=function(){return this.a.length};s.prototype.size=s.prototype.size;s.prototype.h=function(){for(var a=[],b=0,c=this.a.length;b<c;b++)a.push(this.a[b]);return a};s.prototype.toArray=s.prototype.h;
s.prototype.remove=function(a){for(var b=!1,c=0,d=this.a.length;c<d;c++)if(this.a[c]===a){this.a.splice(c,1);b=!0;break}return b};s.prototype.remove=s.prototype.remove;function u(a){this.j=a}f("$jscomp.scope.Iterator_",u);u.prototype.j=null;u.prototype.b=0;u.prototype.next=function(){if(this.b===this.j.size())throw new q;return this.j.get(this.b++)};u.prototype.next=u.prototype.next;u.prototype.c=function(){return this.b<this.j.size()?!0:!1};u.prototype.hasNext=u.prototype.c;
u.prototype.remove=function(){throw new r;};u.prototype.remove=u.prototype.remove;function v(){}f("javascript.util.Arrays",v);
v.sort=function(){var a=arguments[0],b,c,d;if(1===arguments.length)a.sort();else if(2===arguments.length)c=arguments[1],d=function(a,b){return c.compare(a,b)},a.sort(d);else if(3===arguments.length)for(b=a.slice(arguments[1],arguments[2]),b.sort(),d=a.slice(0,arguments[1]).concat(b,a.slice(arguments[2],a.length)),a.splice(0,a.length),b=0;b<d.length;b++)a.push(d[b]);else if(4===arguments.length)for(b=a.slice(arguments[1],arguments[2]),c=arguments[3],d=function(a,b){return c.compare(a,b)},b.sort(d),
d=a.slice(0,arguments[1]).concat(b,a.slice(arguments[2],a.length)),a.splice(0,a.length),b=0;b<d.length;b++)a.push(d[b])};v.asList=function(a){for(var b=new s,c=0,d=a.length;c<d;c++)b.add(a[c]);return b};function w(){this.i={}}g(w,p);f("javascript.util.HashMap",w);w.prototype.i=null;w.prototype.get=function(a){return this.i[a]||null};w.prototype.get=w.prototype.get;w.prototype.put=function(a,b){return this.i[a]=b};w.prototype.put=w.prototype.put;w.prototype.m=function(){var a=new s,b;for(b in this.i)this.i.hasOwnProperty(b)&&a.add(this.i[b]);return a};w.prototype.values=w.prototype.m;w.prototype.size=function(){return this.m().size()};w.prototype.size=w.prototype.size;function x(){}g(x,m);f("javascript.util.Set",x);function y(a){this.a=[];a instanceof m&&this.e(a)}g(y,x);f("javascript.util.HashSet",y);y.prototype.a=null;y.prototype.contains=function(a){for(var b=0,c=this.a.length;b<c;b++)if(this.a[b]===a)return!0;return!1};y.prototype.contains=y.prototype.contains;y.prototype.add=function(a){if(this.contains(a))return!1;this.a.push(a);return!0};y.prototype.add=y.prototype.add;y.prototype.e=function(a){for(a=a.f();a.c();)this.add(a.next());return!0};y.prototype.addAll=y.prototype.e;
y.prototype.remove=function(){throw new r;};y.prototype.remove=y.prototype.remove;y.prototype.size=function(){return this.a.length};y.prototype.g=function(){return 0===this.a.length};y.prototype.isEmpty=y.prototype.g;y.prototype.h=function(){for(var a=[],b=0,c=this.a.length;b<c;b++)a.push(this.a[b]);return a};y.prototype.toArray=y.prototype.h;y.prototype.f=function(){return new z(this)};y.prototype.iterator=y.prototype.f;function z(a){this.k=a}f("$jscomp.scope.Iterator_$1",z);z.prototype.k=null;
z.prototype.b=0;z.prototype.next=function(){if(this.b===this.k.size())throw new q;return this.k.a[this.b++]};z.prototype.next=z.prototype.next;z.prototype.c=function(){return this.b<this.k.size()?!0:!1};z.prototype.hasNext=z.prototype.c;z.prototype.remove=function(){throw new r;};z.prototype.remove=z.prototype.remove;function A(){}g(A,p);f("javascript.util.SortedMap",A);function B(){}g(B,x);f("javascript.util.SortedSet",B);function C(){this.a=[]}g(C,n);f("javascript.util.Stack",C);C.prototype.a=null;C.prototype.push=function(a){this.a.push(a);return a};C.prototype.push=C.prototype.push;C.prototype.pop=function(){if(0===this.a.length)throw new h;return this.a.pop()};C.prototype.pop=C.prototype.pop;C.prototype.o=function(){if(0===this.a.length)throw new h;return this.a[this.a.length-1]};C.prototype.peek=C.prototype.o;C.prototype.empty=function(){return 0===this.a.length?!0:!1};C.prototype.empty=C.prototype.empty;
C.prototype.g=function(){return this.empty()};C.prototype.isEmpty=C.prototype.g;C.prototype.search=function(a){return this.a.indexOf(a)};C.prototype.search=C.prototype.search;C.prototype.size=function(){return this.a.length};C.prototype.size=C.prototype.size;C.prototype.h=function(){for(var a=[],b=0,c=this.a.length;b<c;b++)a.push(this.a[b]);return a};C.prototype.toArray=C.prototype.h;function D(a){return null==a?null:a.parent}function E(a,b){null!==a&&(a.color=b)}function F(a){return null==a?null:a.left}function G(a){return null==a?null:a.right}function H(){this.d=null;this.n=0}g(H,A);f("javascript.util.TreeMap",H);H.prototype.get=function(a){for(var b=this.d;null!==b;){var c=a.compareTo(b.key);if(0>c)b=b.left;else if(0<c)b=b.right;else return b.value}return null};H.prototype.get=H.prototype.get;
H.prototype.put=function(a,b){if(null===this.d)return this.d={key:a,value:b,left:null,right:null,parent:null,color:0},this.n=1,null;var c=this.d,d,t;do if(d=c,t=a.compareTo(c.key),0>t)c=c.left;else if(0<t)c=c.right;else return d=c.value,c.value=b,d;while(null!==c);c={key:a,left:null,right:null,value:b,parent:d,color:0};0>t?d.left=c:d.right=c;for(c.color=1;null!=c&&c!=this.d&&1==c.parent.color;)D(c)==F(D(D(c)))?(d=G(D(D(c))),1==(null==d?0:d.color)?(E(D(c),0),E(d,0),E(D(D(c)),1),c=D(D(c))):(c==G(D(c))&&
(c=D(c),I(this,c)),E(D(c),0),E(D(D(c)),1),J(this,D(D(c))))):(d=F(D(D(c))),1==(null==d?0:d.color)?(E(D(c),0),E(d,0),E(D(D(c)),1),c=D(D(c))):(c==F(D(c))&&(c=D(c),J(this,c)),E(D(c),0),E(D(D(c)),1),I(this,D(D(c)))));this.d.color=0;this.n++;return null};H.prototype.put=H.prototype.put;H.prototype.m=function(){var a=new s,b;b=this.d;if(null!=b)for(;null!=b.left;)b=b.left;if(null!==b)for(a.add(b.value);null!==(b=K(b));)a.add(b.value);return a};H.prototype.values=H.prototype.m;
function I(a,b){if(null!=b){var c=b.right;b.right=c.left;null!=c.left&&(c.left.parent=b);c.parent=b.parent;null==b.parent?a.d=c:b.parent.left==b?b.parent.left=c:b.parent.right=c;c.left=b;b.parent=c}}function J(a,b){if(null!=b){var c=b.left;b.left=c.right;null!=c.right&&(c.right.parent=b);c.parent=b.parent;null==b.parent?a.d=c:b.parent.right==b?b.parent.right=c:b.parent.left=c;c.right=b;b.parent=c}}
function K(a){if(null===a)return null;if(null!==a.right)for(var b=a.right;null!==b.left;)b=b.left;else for(b=a.parent;null!==b&&a===b.right;)a=b,b=b.parent;return b}H.prototype.size=function(){return this.n};H.prototype.size=H.prototype.size;function L(a){this.a=[];a instanceof m&&this.e(a)}g(L,B);f("javascript.util.TreeSet",L);L.prototype.a=null;L.prototype.contains=function(a){for(var b=0,c=this.a.length;b<c;b++)if(0===this.a[b].compareTo(a))return!0;return!1};L.prototype.contains=L.prototype.contains;L.prototype.add=function(a){if(this.contains(a))return!1;for(var b=0,c=this.a.length;b<c;b++)if(1===this.a[b].compareTo(a))return this.a.splice(b,0,a),!0;this.a.push(a);return!0};L.prototype.add=L.prototype.add;
L.prototype.e=function(a){for(a=a.f();a.c();)this.add(a.next());return!0};L.prototype.addAll=L.prototype.e;L.prototype.remove=function(){throw new r;};L.prototype.remove=L.prototype.remove;L.prototype.size=function(){return this.a.length};L.prototype.size=L.prototype.size;L.prototype.g=function(){return 0===this.a.length};L.prototype.isEmpty=L.prototype.g;L.prototype.h=function(){for(var a=[],b=0,c=this.a.length;b<c;b++)a.push(this.a[b]);return a};L.prototype.toArray=L.prototype.h;L.prototype.f=function(){return new N(this)};
L.prototype.iterator=L.prototype.f;function N(a){this.l=a}f("$jscomp.scope.Iterator_$2",N);N.prototype.l=null;N.prototype.b=0;N.prototype.next=function(){if(this.b===this.l.size())throw new q;return this.l.a[this.b++]};N.prototype.next=N.prototype.next;N.prototype.c=function(){return this.b<this.l.size()?!0:!1};N.prototype.hasNext=N.prototype.c;N.prototype.remove=function(){throw new r;};N.prototype.remove=N.prototype.remove;"undefined"!==typeof global&&(global.javascript={},global.javascript.util={},global.javascript.util.ArrayList=s,global.javascript.util.Arrays=v,global.javascript.util.Collection=m,global.javascript.util.EmptyStackException=h,global.javascript.util.HashMap=w,global.javascript.util.HashSet=y,global.javascript.util.IndexOutOfBoundsException=k,global.javascript.util.Iterator=l,global.javascript.util.List=n,global.javascript.util.Map=p,global.javascript.util.NoSuchElementException=q,global.javascript.util.OperationNotSupported=
r,global.javascript.util.Set=x,global.javascript.util.SortedMap=A,global.javascript.util.SortedSet=B,global.javascript.util.Stack=C,global.javascript.util.TreeMap=H,global.javascript.util.TreeSet=L);}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],178:[function(require,module,exports){
arguments[4][74][0].apply(exports,arguments)
},{"./dist/javascript.util-node.min.js":177,"dup":74}],179:[function(require,module,exports){
var ss = require('simple-statistics');
var inside = require('turf-inside');

/**
 * Calculates the variance value of a field for {@link Point} features within a set of {@link Polygon} features.
 *
 * @module turf/variance
 * @category aggregation
 * @param {FeatureCollection} polygons a FeatureCollection of {@link Polygon} features
 * @param {FeatureCollection} points a FeatureCollection of {@link Point} features
 * @param {string} inField the field in input data to analyze
 * @param {string} outField the field in which to store results
 * @return {FeatureCollection} a FeatureCollection of {@link Polygon} features
 * with properties listed as `outField`
 * @example
 * var polygons = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [[
 *           [-97.414398, 37.684092],
 *           [-97.414398, 37.731353],
 *           [-97.332344, 37.731353],
 *           [-97.332344, 37.684092],
 *           [-97.414398, 37.684092]
 *         ]]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [[
 *           [-97.333717, 37.606072],
 *           [-97.333717, 37.675397],
 *           [-97.237586, 37.675397],
 *           [-97.237586, 37.606072],
 *           [-97.333717, 37.606072]
 *         ]]
 *       }
 *     }
 *   ]
 * };
 * var points = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "population": 200
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.401351, 37.719676]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "population": 600
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.355346, 37.706639]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "population": 100
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.387962, 37.70012]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "population": 200
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.301788, 37.66507]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "population": 300
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.265052, 37.643325]
 *       }
 *     }
 *   ]
 * };
 *
 * var aggregated = turf.variance(
 *   polygons, points, 'population', 'variance');
 *
 * var resultFeatures = points.features.concat(
 *   aggregated.features);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */
module.exports = function (polyFC, ptFC, inField, outField) {
  polyFC.features.forEach(function(poly){
    if(!poly.properties){
      poly.properties = {};
    }
    var values = [];
    ptFC.features.forEach(function(pt){
      if (inside(pt, poly)) {
        values.push(pt.properties[inField]);
      }
    });
    poly.properties[outField] = ss.variance(values);
  });

  return polyFC;
};

},{"simple-statistics":180,"turf-inside":130}],180:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113}],181:[function(require,module,exports){
var inside = require('turf-inside');
var featureCollection = require('turf-featurecollection');

/**
 * Takes a {@link FeatureCollection} of {@link Point} features and a FeatureCollection of {@link Polygon} features and returns a FeatureCollection of Point features representing all points that fall within a collection of polygons.
 *
 * @module turf/within
 * @category joins
 * @param {FeatureCollection} points a FeatureCollection of {@link Point} features
 * @param {FeatureCollection} polygons a FeatureCollection of {@link Polygon} features
 * @return {FeatureCollection} a collection of all points that land
 * within at least one polygon
 * @example
 * var searchWithin = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [[
 *           [-46.653,-23.543],
 *           [-46.634,-23.5346],
 *           [-46.613,-23.543],
 *           [-46.614,-23.559],
 *           [-46.631,-23.567],
 *           [-46.653,-23.560],
 *           [-46.653,-23.543]
 *         ]]
 *       }
 *     }
 *   ]
 * };
 * var points = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-46.6318, -23.5523]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-46.6246, -23.5325]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-46.6062, -23.5513]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-46.663, -23.554]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-46.643, -23.557]
 *       }
 *     }
 *   ]
 * };
 *
 * var ptsWithin = turf.within(points, searchWithin);
 *
 * //=points
 *
 * //=searchWithin
 *
 * //=ptsWithin
 */
module.exports = function(ptFC, polyFC){
  var pointsWithin = featureCollection([]);
  for (var i = 0; i < polyFC.features.length; i++) {
    for (var j = 0; j < ptFC.features.length; j++) {
      var isInside = inside(ptFC.features[j], polyFC.features[i]);
      if(isInside){
        pointsWithin.features.push(ptFC.features[j]);
      }
    }
  }
  return pointsWithin;
};

},{"turf-featurecollection":126,"turf-inside":130}],182:[function(require,module,exports){
;(function inject(clean, precision, undef) {

  var isArray = function (a) {
    return Object.prototype.toString.call(a) === "[object Array]";
  };

  var defined = function(a) {
    return a !== undef;
  };

  function Vec2(x, y) {
    if (!(this instanceof Vec2)) {
      return new Vec2(x, y);
    }

    if (isArray(x)) {
      y = x[1];
      x = x[0];
    } else if('object' === typeof x && x) {
      y = x.y;
      x = x.x;
    }

    this.x = Vec2.clean(x || 0);
    this.y = Vec2.clean(y || 0);
  }

  Vec2.prototype = {
    change : function(fn) {
      if (typeof fn === 'function') {
        if (this.observers) {
          this.observers.push(fn);
        } else {
          this.observers = [fn];
        }
      } else if (this.observers && this.observers.length) {
        for (var i=this.observers.length-1; i>=0; i--) {
          this.observers[i](this, fn);
        }
      }

      return this;
    },

    ignore : function(fn) {
      if (this.observers) {
        if (!fn) {
          this.observers = [];
        } else {
          var o = this.observers, l = o.length;
          while(l--) {
            o[l] === fn && o.splice(l, 1);
          }
        }
      }
      return this;
    },

    // set x and y
    set: function(x, y, notify) {
      if('number' != typeof x) {
        notify = y;
        y = x.y;
        x = x.x;
      }

      if(this.x === x && this.y === y) {
        return this;
      }

      var orig = null;
      if (notify !== false && this.observers && this.observers.length) {
        orig = this.clone();
      }

      this.x = Vec2.clean(x);
      this.y = Vec2.clean(y);

      if(notify !== false) {
        return this.change(orig);
      }
    },

    // reset x and y to zero
    zero : function() {
      return this.set(0, 0);
    },

    // return a new vector with the same component values
    // as this one
    clone : function() {
      return new (this.constructor)(this.x, this.y);
    },

    // negate the values of this vector
    negate : function(returnNew) {
      if (returnNew) {
        return new (this.constructor)(-this.x, -this.y);
      } else {
        return this.set(-this.x, -this.y);
      }
    },

    // Add the incoming `vec2` vector to this vector
    add : function(x, y, returnNew) {

      if (typeof x != 'number') {
        returnNew = y;
        if (isArray(x)) {
          y = x[1];
          x = x[0];
        } else {
          y = x.y;
          x = x.x;
        }
      }

      x += this.x;
      y += this.y;


      if (!returnNew) {
        return this.set(x, y);
      } else {
        // Return a new vector if `returnNew` is truthy
        return new (this.constructor)(x, y);
      }
    },

    // Subtract the incoming `vec2` from this vector
    subtract : function(x, y, returnNew) {
      if (typeof x != 'number') {
        returnNew = y;
        if (isArray(x)) {
          y = x[1];
          x = x[0];
        } else {
          y = x.y;
          x = x.x;
        }
      }

      x = this.x - x;
      y = this.y - y;

      if (!returnNew) {
        return this.set(x, y);
      } else {
        // Return a new vector if `returnNew` is truthy
        return new (this.constructor)(x, y);
      }
    },

    // Multiply this vector by the incoming `vec2`
    multiply : function(x, y, returnNew) {
      if (typeof x != 'number') {
        returnNew = y;
        if (isArray(x)) {
          y = x[1];
          x = x[0];
        } else {
          y = x.y;
          x = x.x;
        }
      } else if (typeof y != 'number') {
        returnNew = y;
        y = x;
      }

      x *= this.x;
      y *= this.y;

      if (!returnNew) {
        return this.set(x, y);
      } else {
        return new (this.constructor)(x, y);
      }
    },

    // Rotate this vector. Accepts a `Rotation` or angle in radians.
    //
    // Passing a truthy `inverse` will cause the rotation to
    // be reversed.
    //
    // If `returnNew` is truthy, a new
    // `Vec2` will be created with the values resulting from
    // the rotation. Otherwise the rotation will be applied
    // to this vector directly, and this vector will be returned.
    rotate : function(r, inverse, returnNew) {
      var
      x = this.x,
      y = this.y,
      cos = Math.cos(r),
      sin = Math.sin(r),
      rx, ry;

      inverse = (inverse) ? -1 : 1;

      rx = cos * x - (inverse * sin) * y;
      ry = (inverse * sin) * x + cos * y;

      if (returnNew) {
        return new (this.constructor)(rx, ry);
      } else {
        return this.set(rx, ry);
      }
    },

    // Calculate the length of this vector
    length : function() {
      var x = this.x, y = this.y;
      return Math.sqrt(x * x + y * y);
    },

    // Get the length squared. For performance, use this instead of `Vec2#length` (if possible).
    lengthSquared : function() {
      var x = this.x, y = this.y;
      return x*x+y*y;
    },

    // Return the distance betwen this `Vec2` and the incoming vec2 vector
    // and return a scalar
    distance : function(vec2) {
      var x = this.x - vec2.x;
      var y = this.y - vec2.y;
      return Math.sqrt(x*x + y*y);
    },

    // Given Array of Vec2, find closest to this Vec2.
    nearest : function(others) {
      var
      shortestDistance = Number.MAX_VALUE,
      nearest = null,
      currentDistance;

      for (var i = others.length - 1; i >= 0; i--) {
        currentDistance = this.distance(others[i]);
        if (currentDistance <= shortestDistance) {
          shortestDistance = currentDistance;
          nearest = others[i];
        }
      }

      return nearest;
    },

    // Convert this vector into a unit vector.
    // Returns the length.
    normalize : function(returnNew) {
      var length = this.length();

      // Collect a ratio to shrink the x and y coords
      var invertedLength = (length < Number.MIN_VALUE) ? 0 : 1/length;

      if (!returnNew) {
        // Convert the coords to be greater than zero
        // but smaller than or equal to 1.0
        return this.set(this.x * invertedLength, this.y * invertedLength);
      } else {
        return new (this.constructor)(this.x * invertedLength, this.y * invertedLength);
      }
    },

    // Determine if another `Vec2`'s components match this one's
    // also accepts 2 scalars
    equal : function(v, w) {
      if (typeof v != 'number') {
        if (isArray(v)) {
          w = v[1];
          v = v[0];
        } else {
          w = v.y;
          v = v.x;
        }
      }

      return (Vec2.clean(v) === this.x && Vec2.clean(w) === this.y);
    },

    // Return a new `Vec2` that contains the absolute value of
    // each of this vector's parts
    abs : function(returnNew) {
      var x = Math.abs(this.x), y = Math.abs(this.y);

      if (returnNew) {
        return new (this.constructor)(x, y);
      } else {
        return this.set(x, y);
      }
    },

    // Return a new `Vec2` consisting of the smallest values
    // from this vector and the incoming
    //
    // When returnNew is truthy, a new `Vec2` will be returned
    // otherwise the minimum values in either this or `v` will
    // be applied to this vector.
    min : function(v, returnNew) {
      var
      tx = this.x,
      ty = this.y,
      vx = v.x,
      vy = v.y,
      x = tx < vx ? tx : vx,
      y = ty < vy ? ty : vy;

      if (returnNew) {
        return new (this.constructor)(x, y);
      } else {
        return this.set(x, y);
      }
    },

    // Return a new `Vec2` consisting of the largest values
    // from this vector and the incoming
    //
    // When returnNew is truthy, a new `Vec2` will be returned
    // otherwise the minimum values in either this or `v` will
    // be applied to this vector.
    max : function(v, returnNew) {
      var
      tx = this.x,
      ty = this.y,
      vx = v.x,
      vy = v.y,
      x = tx > vx ? tx : vx,
      y = ty > vy ? ty : vy;

      if (returnNew) {
        return new (this.constructor)(x, y);
      } else {
        return this.set(x, y);
      }
    },

    // Clamp values into a range.
    // If this vector's values are lower than the `low`'s
    // values, then raise them.  If they are higher than
    // `high`'s then lower them.
    //
    // Passing returnNew as true will cause a new Vec2 to be
    // returned.  Otherwise, this vector's values will be clamped
    clamp : function(low, high, returnNew) {
      var ret = this.min(high, true).max(low);
      if (returnNew) {
        return ret;
      } else {
        return this.set(ret.x, ret.y);
      }
    },

    // Perform linear interpolation between two vectors
    // amount is a decimal between 0 and 1
    lerp : function(vec, amount, returnNew) {
      return this.add(vec.subtract(this, true).multiply(amount), returnNew);
    },

    // Get the skew vector such that dot(skew_vec, other) == cross(vec, other)
    skew : function(returnNew) {
      if (!returnNew) {
        return this.set(-this.y, this.x)
      } else {
        return new (this.constructor)(-this.y, this.x);
      }
    },

    // calculate the dot product between
    // this vector and the incoming
    dot : function(b) {
      return Vec2.clean(this.x * b.x + b.y * this.y);
    },

    // calculate the perpendicular dot product between
    // this vector and the incoming
    perpDot : function(b) {
      return Vec2.clean(this.x * b.y - this.y * b.x);
    },

    // Determine the angle between two vec2s
    angleTo : function(vec) {
      return Math.atan2(this.perpDot(vec), this.dot(vec));
    },

    // Divide this vector's components by a scalar
    divide : function(x, y, returnNew) {
      if (typeof x != 'number') {
        returnNew = y;
        if (isArray(x)) {
          y = x[1];
          x = x[0];
        } else {
          y = x.y;
          x = x.x;
        }
      } else if (typeof y != 'number') {
        returnNew = y;
        y = x;
      }

      if (x === 0 || y === 0) {
        throw new Error('division by zero')
      }

      if (isNaN(x) || isNaN(y)) {
        throw new Error('NaN detected');
      }

      if (returnNew) {
        return new (this.constructor)(this.x / x, this.y / y);
      }

      return this.set(this.x / x, this.y / y);
    },

    isPointOnLine : function(start, end) {
      return (start.y - this.y) * (start.x - end.x) ===
             (start.y - end.y) * (start.x - this.x);
    },

    toArray: function() {
      return [this.x, this.y];
    },

    fromArray: function(array) {
      return this.set(array[0], array[1]);
    },
    toJSON: function () {
      return {x: this.x, y: this.y};
    },
    toString: function() {
      return '(' + this.x + ', ' + this.y + ')';
    },
    constructor : Vec2
  };

  Vec2.fromArray = function(array, ctor) {
    return new (ctor || Vec2)(array[0], array[1]);
  };

  // Floating point stability
  Vec2.precision = precision || 8;
  var p = Math.pow(10, Vec2.precision);

  Vec2.clean = clean || function(val) {
    if (isNaN(val)) {
      throw new Error('NaN detected');
    }

    if (!isFinite(val)) {
      throw new Error('Infinity detected');
    }

    if(Math.round(val) === val) {
      return val;
    }

    return Math.round(val * p)/p;
  };

  Vec2.inject = inject;

  if(!clean) {
    Vec2.fast = inject(function (k) { return k; });

    // Expose, but also allow creating a fresh Vec2 subclass.
    if (typeof module !== 'undefined' && typeof module.exports == 'object') {
      module.exports = Vec2;
    } else {
      window.Vec2 = window.Vec2 || Vec2;
    }
  }
  return Vec2;
})();

},{}],183:[function(require,module,exports){
"use strict";
var window = require("global/window")
var once = require("once")
var parseHeaders = require("parse-headers")



module.exports = createXHR
createXHR.XMLHttpRequest = window.XMLHttpRequest || noop
createXHR.XDomainRequest = "withCredentials" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest


function isEmpty(obj){
    for(var i in obj){
        if(obj.hasOwnProperty(i)) return false
    }
    return true
}

function createXHR(options, callback) {
    function readystatechange() {
        if (xhr.readyState === 4) {
            loadFunc()
        }
    }

    function getBody() {
        // Chrome with requestType=blob throws errors arround when even testing access to responseText
        var body = undefined

        if (xhr.response) {
            body = xhr.response
        } else if (xhr.responseType === "text" || !xhr.responseType) {
            body = xhr.responseText || xhr.responseXML
        }

        if (isJson) {
            try {
                body = JSON.parse(body)
            } catch (e) {}
        }

        return body
    }

    var failureResponse = {
                body: undefined,
                headers: {},
                statusCode: 0,
                method: method,
                url: uri,
                rawRequest: xhr
            }

    function errorFunc(evt) {
        clearTimeout(timeoutTimer)
        if(!(evt instanceof Error)){
            evt = new Error("" + (evt || "Unknown XMLHttpRequest Error") )
        }
        evt.statusCode = 0
        callback(evt, failureResponse)
    }

    // will load the data & process the response in a special response object
    function loadFunc() {
        if (aborted) return
        var status
        clearTimeout(timeoutTimer)
        if(options.useXDR && xhr.status===undefined) {
            //IE8 CORS GET successful response doesn't have a status field, but body is fine
            status = 200
        } else {
            status = (xhr.status === 1223 ? 204 : xhr.status)
        }
        var response = failureResponse
        var err = null

        if (status !== 0){
            response = {
                body: getBody(),
                statusCode: status,
                method: method,
                headers: {},
                url: uri,
                rawRequest: xhr
            }
            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
                response.headers = parseHeaders(xhr.getAllResponseHeaders())
            }
        } else {
            err = new Error("Internal XMLHttpRequest Error")
        }
        callback(err, response, response.body)

    }

    if (typeof options === "string") {
        options = { uri: options }
    }

    options = options || {}
    if(typeof callback === "undefined"){
        throw new Error("callback argument missing")
    }
    callback = once(callback)

    var xhr = options.xhr || null

    if (!xhr) {
        if (options.cors || options.useXDR) {
            xhr = new createXHR.XDomainRequest()
        }else{
            xhr = new createXHR.XMLHttpRequest()
        }
    }

    var key
    var aborted
    var uri = xhr.url = options.uri || options.url
    var method = xhr.method = options.method || "GET"
    var body = options.body || options.data
    var headers = xhr.headers = options.headers || {}
    var sync = !!options.sync
    var isJson = false
    var timeoutTimer

    if ("json" in options) {
        isJson = true
        headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json") //Don't override existing accept header declared by user
        if (method !== "GET" && method !== "HEAD") {
            headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json") //Don't override existing accept header declared by user
            body = JSON.stringify(options.json)
        }
    }

    xhr.onreadystatechange = readystatechange
    xhr.onload = loadFunc
    xhr.onerror = errorFunc
    // IE9 must have onprogress be set to a unique function.
    xhr.onprogress = function () {
        // IE must die
    }
    xhr.ontimeout = errorFunc
    xhr.open(method, uri, !sync, options.username, options.password)
    //has to be after open
    if(!sync) {
        xhr.withCredentials = !!options.withCredentials
    }
    // Cannot set timeout with sync request
    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
    if (!sync && options.timeout > 0 ) {
        timeoutTimer = setTimeout(function(){
            aborted=true//IE9 may still call readystatechange
            xhr.abort("timeout")
            var e = new Error("XMLHttpRequest timeout")
            e.code = "ETIMEDOUT"
            errorFunc(e)
        }, options.timeout )
    }

    if (xhr.setRequestHeader) {
        for(key in headers){
            if(headers.hasOwnProperty(key)){
                xhr.setRequestHeader(key, headers[key])
            }
        }
    } else if (options.headers && !isEmpty(options.headers)) {
        throw new Error("Headers cannot be set on an XDomainRequest object")
    }

    if ("responseType" in options) {
        xhr.responseType = options.responseType
    }

    if ("beforeSend" in options &&
        typeof options.beforeSend === "function"
    ) {
        options.beforeSend(xhr)
    }

    xhr.send(body)

    return xhr


}

function noop() {}

},{"global/window":184,"once":185,"parse-headers":189}],184:[function(require,module,exports){
(function (global){
if (typeof window !== "undefined") {
    module.exports = window;
} else if (typeof global !== "undefined") {
    module.exports = global;
} else if (typeof self !== "undefined"){
    module.exports = self;
} else {
    module.exports = {};
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],185:[function(require,module,exports){
module.exports = once

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })
})

function once (fn) {
  var called = false
  return function () {
    if (called) return
    called = true
    return fn.apply(this, arguments)
  }
}

},{}],186:[function(require,module,exports){
var isFunction = require('is-function')

module.exports = forEach

var toString = Object.prototype.toString
var hasOwnProperty = Object.prototype.hasOwnProperty

function forEach(list, iterator, context) {
    if (!isFunction(iterator)) {
        throw new TypeError('iterator must be a function')
    }

    if (arguments.length < 3) {
        context = this
    }
    
    if (toString.call(list) === '[object Array]')
        forEachArray(list, iterator, context)
    else if (typeof list === 'string')
        forEachString(list, iterator, context)
    else
        forEachObject(list, iterator, context)
}

function forEachArray(array, iterator, context) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            iterator.call(context, array[i], i, array)
        }
    }
}

function forEachString(string, iterator, context) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        iterator.call(context, string.charAt(i), i, string)
    }
}

function forEachObject(object, iterator, context) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            iterator.call(context, object[k], k, object)
        }
    }
}

},{"is-function":187}],187:[function(require,module,exports){
module.exports = isFunction

var toString = Object.prototype.toString

function isFunction (fn) {
  var string = toString.call(fn)
  return string === '[object Function]' ||
    (typeof fn === 'function' && string !== '[object RegExp]') ||
    (typeof window !== 'undefined' &&
     // IE8 and below
     (fn === window.setTimeout ||
      fn === window.alert ||
      fn === window.confirm ||
      fn === window.prompt))
};

},{}],188:[function(require,module,exports){

exports = module.exports = trim;

function trim(str){
  return str.replace(/^\s*|\s*$/g, '');
}

exports.left = function(str){
  return str.replace(/^\s*/, '');
};

exports.right = function(str){
  return str.replace(/\s*$/, '');
};

},{}],189:[function(require,module,exports){
var trim = require('trim')
  , forEach = require('for-each')
  , isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    }

module.exports = function (headers) {
  if (!headers)
    return {}

  var result = {}

  forEach(
      trim(headers).split('\n')
    , function (row) {
        var index = row.indexOf(':')
          , key = trim(row.slice(0, index)).toLowerCase()
          , value = trim(row.slice(index + 1))

        if (typeof(result[key]) === 'undefined') {
          result[key] = value
        } else if (isArray(result[key])) {
          result[key].push(value)
        } else {
          result[key] = [ result[key], value ]
        }
      }
  )

  return result
}
},{"for-each":186,"trim":188}],190:[function(require,module,exports){
(function (global){
'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

var _interopRequireWildcard = require('babel-runtime/helpers/interop-require-wildcard')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _xhr = require('xhr');

var _xhr2 = _interopRequireDefault(_xhr);

var _jsonp = require('jsonp');

var _jsonp2 = _interopRequireDefault(_jsonp);

var _spinJs = require('spin.js');

var Spinner = _interopRequireWildcard(_spinJs);

var _configJson = require('../config.json');

var config = _interopRequireWildcard(_configJson);

var _styles = require('./styles');

var _utils = require('./utils');

var _turf = require('turf');

var _turf2 = _interopRequireDefault(_turf);

var _geojsonUtils = require('geojson-utils');

var _geojsonUtils2 = _interopRequireDefault(_geojsonUtils);

var _leafletGeometryutil = require('leaflet-geometryutil');

var _leafletGeometryutil2 = _interopRequireDefault(_leafletGeometryutil);

require('leaflet-hash');

var _projection = require('./projection');

var _geojson = require('./geojson');

var _polygon = require('polygon');

var _polygon2 = _interopRequireDefault(_polygon);

var _vec2 = require('vec2');

var _vec22 = _interopRequireDefault(_vec2);

var _nominatimGeocode = require('nominatim-geocode');

var _nominatimGeocode2 = _interopRequireDefault(_nominatimGeocode);

var _search = require('./search');

var _search2 = _interopRequireDefault(_search);

var L = global.L || require('leaflet');

global.turf = _turf2['default'];

var MAP_STYLE = 'mapbox.dark';
var MOSCOW_BOUNDS = L.latLngBounds(_projection.MOSCOW_BBOX.slice(0, 2).reverse(), _projection.MOSCOW_BBOX.slice(2).reverse());

var lang = /*navigator.language || navigator.userLanguage ||*/'ru-RU';
var locale = config.l10n[lang] || config.l10n.all;

console.log(locale, lang);

var App = (function () {
  function App(mapContainer, dataUrl) {
    _classCallCheck(this, App);

    var _L$Hash$parseHash = L.Hash.parseHash(location.hash);

    var center = _L$Hash$parseHash.center;
    var zoom = _L$Hash$parseHash.zoom;

    /**
     * @type {L.Map}
     */
    this._map = global.map = L.map(document.querySelector(mapContainer), {
      zoomControl: false
    });
    L.control.zoom({ position: 'bottomright' }).addTo(this._map);

    /**
     * Wether the position is read
     * @type {Boolean}
     */
    this._positioned = center && zoom;
    if (this._positioned) {
      this._map.setView(center, zoom);
    }

    /**
     * Intersection points
     * @type {L.LayerGroup}
     */
    this._intersects = L.layerGroup().addTo(this._map);

    /**
     * Buffer fills
     * @type {L.GeoJSON}
     */
    this._buffers = L.geoJson(null, { style: _styles.bufferStyle }).addTo(this._map);

    /**
     * @type {L.Control.Hash}
     */
    this._hash = L.hash(map);

    /**
     * Rings data
     * @type {GeoJSON}
     */
    this._data = null;

    /**
     * Buffered rings
     * @type {GeoJSON}
     */
    this._bufferData = null;

    /**
     * On/off states for rings
     * @type {Object}
     */
    this._state = {};

    /**
     * Rings data in Moscow equidistant projection
     * @type {GeoJSON}
     */
    this._equidistant = null;

    /**
     * Rings layer
     * @type {L.GeoJSON}
     */
    this._geojson = null;

    /**
     * Torus fills
     * @type {L.GeoJSON}
     */
    this._toruses = null;

    /**
     * Position
     * @type {L.CircleMarker}
     */
    this._marker = null;

    /**
     * @type {Element}
     */
    this._container = document.querySelector('.info');

    /**
     * Info control
     * @type {Element}
     */
    this._info = this._container.querySelector('.container');

    /**
     * Raster
     * @type {L.TileLayer}
     */
    this._tiles = L.tileLayer('http://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">' + 'OpenStreetMap</a> contributors, &copy; ' + '<a href="http://cartodb.com/attributions">CartoDB</a>'
    }).addTo(this._map);

    // this._tiles = L.tileLayer(
    //   'https://api.mapbox.com/v4/' +
    //   MAP_STYLE +
    //   '/{z}/{x}/{y}.png?access_token=' +
    //   config.api_token, {
    //     attribution: 'Mapbox &copy; OSM contributors'
    // }).addTo(map);

    /**
     * Search control
     * @type {Search}
     */
    this._search = new _search2['default'](document.querySelector('.searchbox')).on('submit', this._onSearch, this);
    this._load(dataUrl);
  }

  _createClass(App, [{
    key: '_onSearch',
    value: function _onSearch(e) {
      var _this = this;

      _nominatimGeocode2['default'].geocode({
        q: e.query,
        'accept-language': lang,
        viewboxlbrt: _projection.MOSCOW_BBOX.join(',')
      }, function (err, location) {
        _this._setReady();
        if (!err && location.length !== 0) {
          location = location[0];
          var latlng = L.latLng(parseFloat(location.lat), parseFloat(location.lon));
          _this._setPoint(latlng);

          _this._search.setValue(_this._formatAddress(location));
          _this._map.openPopup(_this._formatAddress(location), latlng, {
            className: 'address-tooltip'
          });

          if (!_this._map.getBounds().contains(latlng)) {
            _this._map.panTo(latlng);
          }
        }
      });
    }

    /**
     * @param  {String} url
     */
  }, {
    key: '_load',
    value: function _load(url) {
      this._setLoading();
      (0, _xhr2['default'])({ url: url }, this._onLoad.bind(this));
    }

    /**
     * @param  {Object} data
     */
  }, {
    key: '_processData',
    value: function _processData(data) {
      var _this2 = this;

      // add centroid
      function storeCentroid(f) {
        f.properties.centroid = _turf2['default'].centroid(f).geometry.coordinates;
      };
      this._data = data = JSON.parse(data);
      data.features.forEach(storeCentroid, this);

      // show all rings, sort for kremlin to be on top
      data.features.sort(function (f1, f2) {
        return f2.properties.id - f1.properties.id;
      }).forEach(function (feature) {
        _this2._state[feature.properties.id] = true;
      }, this);

      this._geojson = L.geoJson(data, { style: _styles.ringStyle });

      console.time('proj');
      this._equidistant = (0, _geojson.project)(data, _projection.moscowEquidistant);
      this._equidistant.features.forEach(storeCentroid, this);
      console.timeEnd('proj');
    }

    /**
     * @param  {Object|Null} err
     * @param  {Request}     req
     * @param  {Object}      data
     */
  }, {
    key: '_onLoad',
    value: function _onLoad(err, req, data) {
      if (err) throw new Error('failed to fetch data');

      this._processData(data);

      var torsData = JSON.parse(data);
      torsData.features = torsData.features.map(function (f, i, arr) {
        if (i) {
          f.geometry.coordinates.push(arr[i - 1].geometry.coordinates[0].slice());
        }
        return f;
      });

      if (!this._positioned) {
        map.fitBounds(this._geojson.getBounds(), {
          padding: [20, 20]
        });
      }

      this._toruses = L.geoJson(torsData, { style: _styles.torusStyle });
      this._toruses.addTo(map);

      this._geojson.addTo(map);
      //this._geojson.removeFrom(map);
      this._setReady();
      this._init();
    }

    /**
     * Init handlers
     */
  }, {
    key: '_init',
    value: function _init() {
      var _this3 = this;

      this._map.on('click', this._onMapClick, this);
      L.DomEvent.on(this._info, 'click', function (evt) {
        if (evt.target.tagName.toLowerCase() === 'input') {
          L.Util.requestAnimFrame(function () {
            var id = evt.target.getAttribute('data-feature-id');
            _this3._state[id] = !!evt.target.checked;
            _this3._renderBuffers();
          }, _this3);
        }
      }, this);

      this._setLoading();
      navigator.geolocation.getCurrentPosition(L.Util.bind(function (position) {
        var latlng = L.latLng(position.coords.latitude, position.coords.longitude);

        _this3._setReady();
        if (MOSCOW_BOUNDS.contains(latlng)) {
          _this3._setPoint(latlng);
        } else _this3._showEmpty();
      }, this));
    }
  }, {
    key: '_showEmpty',
    value: function _showEmpty() {
      this._showInfo(this._data.features.map(function (feature) {
        return {
          feature: feature,
          distance: '?'
        };
      }));
    }
  }, {
    key: '_setLoading',
    value: function _setLoading() {
      L.DomUtil.addClass(this._container, 'loading');
    }
  }, {
    key: '_setReady',
    value: function _setReady() {
      L.DomUtil.removeClass(this._container, 'loading');
    }
  }, {
    key: '_formatAddress',
    value: function _formatAddress(location) {
      var addr = location.address;
      return addr.road + (addr.house_number ? ',&nbsp;' + addr.house_number.replace(/\s/g, '&nbsp;') : '');
    }

    /**
     * @param  {Object} evt
     */
  }, {
    key: '_onMapClick',
    value: function _onMapClick(evt) {
      var _this4 = this;

      var latlng = evt.latlng;

      this._setPoint(latlng);

      this._setLoading();

      _nominatimGeocode2['default'].reverse({
        lat: latlng.lat,
        lon: latlng.lng,
        'accept-language': 'ru-RU',
        addressdetails: 1
      }, function (err, location) {
        _this4._setReady();
        if (!err) {
          _this4._search.setValue(_this4._formatAddress(location));
          _this4._map.openPopup(_this4._formatAddress(location), latlng, {
            className: 'address-tooltip'
          });
        }
      });
    }
  }, {
    key: '_setPoint',
    value: function _setPoint(latlng) {
      var _this5 = this;

      if (!this._marker) {
        this._marker = L.circleMarker(latlng, _styles.POSITION_STYLE).addTo(this._map);
      } else {
        this._marker.setLatLng(latlng);
      }
      this._intersects.clearLayers();

      L.Util.requestAnimFrame(function () {
        return _this5._calculateDistances(latlng);
      }, this);
    }

    /**
     * @param  {L.LatLng} latlng
     * @return {Array.<Object>}
     */
  }, {
    key: '_calculateDistances',
    value: function _calculateDistances(latlng) {
      var _this6 = this;

      var intersections = [];
      var eintersections = [];

      var point = _turf2['default'].point([latlng.lng, latlng.lat]);
      var epoint = _turf2['default'].point(_projection.moscowEquidistant.project([latlng.lng, latlng.lat]));

      var measures = this._data.features.map(function (feature, index) {
        var f = feature;
        var ef = _this6._equidistant.features.filter(function (e) {
          return e.properties.id === f.properties.id;
        })[0];

        var nearest = (0, _utils.nearestPoint)(point, f);
        var enearest = (0, _utils.planarNearestPoint)(epoint, ef);

        // L.circleMarker(
        //   moscowEquidistant.unproject(enearest.geometry.coordinates).slice().reverse(),
        //   nearestStyle(f.properties.id)
        // ).addTo(this._intersects);

        enearest.properties.feature = ef;

        intersections.push(nearest);
        eintersections.push(enearest);

        var distance = _turf2['default'].distance(point, nearest, "kilometers");
        var edistance = (0, _utils.euclidianDistance)(enearest.geometry.coordinates, epoint.geometry.coordinates);

        if (_turf2['default'].inside(point, f)) {
          distance = -distance;
          edistance = -edistance;
        }

        L.circleMarker(nearest.geometry.coordinates.slice().reverse(), {
          radius: 2,
          color: _styles.COLORS[f.properties.id]
        }).addTo(_this6._intersects);

        return {
          feature: ef,
          distance: distance,
          radius: edistance
        };
      }, this);

      this._showInfo(measures);

      L.Util.requestAnimFrame(function () {
        _this6._showBuffers(_this6._calculateBuffers(measures));
      }, this);
    }

    /**
     * @param  {Array/<Object>} measures
     */
  }, {
    key: '_showInfo',
    value: function _showInfo(measures) {
      var _this7 = this;

      var html = '';
      html = '<ul>' + measures.slice().reverse().map(function (measure) {
        var feature = measure.feature;
        return L.Util.template('<li data-feature-id="{id}">' + '<label class="topcoat-checkbox">' + '<input type="checkbox" data-feature-id="{id}" {checked}> ' + '<span class="distance">{distance} km</span>' + '<span class="name" style="color: {color}">{name}</span>' + '</label></li>', {
          color: _styles.COLORS[feature.properties.id],
          checked: _this7._state[feature.properties.id] ? 'checked' : '',
          id: feature.properties.id,
          name: locale.names[feature.properties.id],
          distance: isNaN(measure.distance) ? measure.distance : Math.abs(measure.distance).toFixed(2)
        });
      }).join('') + '</ul>';
      this._info.innerHTML = html;
    }

    /**
     * @param  {Array.<Object>} measures
     * @return {Object}
     */
  }, {
    key: '_calculateBuffers',
    value: function _calculateBuffers(measures) {
      var buffers = [];

      measures.forEach(function (measure, index) {
        if (measure.distance !== 0) {
          (function () {
            var projectedFeature = measure.feature;

            buffers = buffers.concat((0, _geojson.buffer)(projectedFeature, measure.radius).features.map(function (f) {
              f.properties.id = projectedFeature.properties.id;
              return f;
            }));
          })();
        }
      }, this);

      return (0, _geojson.unproject)(_turf2['default'].featurecollection(buffers), _projection.moscowEquidistant);
    }

    /**
     * @param  {Object} buffers
     */
  }, {
    key: '_showBuffers',
    value: function _showBuffers(buffers) {
      this._bufferData = buffers;
      this._renderBuffers();
    }

    /**
     * Render buffers to the map
     */
  }, {
    key: '_renderBuffers',
    value: function _renderBuffers() {
      var _this8 = this;

      var buffers = this._bufferData;
      this._buffers.clearLayers();
      if (!buffers) return;

      buffers.features.sort(function (feature1, feature2) {
        return feature2.properties.id - feature1.properties.id;
      }).forEach(function (feature) {
        if (_this8._state[feature.properties.id]) {
          _this8._buffers.addData(feature);
        }
      }, this);
    }
  }]);

  return App;
})();

exports['default'] = App;
module.exports = exports['default'];

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../config.json":1,"./geojson":192,"./projection":194,"./search":195,"./styles":196,"./utils":197,"babel-runtime/helpers/class-call-check":3,"babel-runtime/helpers/create-class":4,"babel-runtime/helpers/interop-require-default":5,"babel-runtime/helpers/interop-require-wildcard":6,"geojson-utils":14,"jsonp":15,"leaflet":25,"leaflet-geometryutil":23,"leaflet-hash":24,"nominatim-geocode":26,"polygon":57,"spin.js":58,"turf":59,"vec2":182,"xhr":183}],191:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});
var COLORS = {
    // 0: '#FF0000', // red square
    // 1: '#FF7F00', // kremlin,
    // 2: '#FFFF00', // boulevard
    // 3: '#00FF00', // garden ring
    // 4: '#00FF33', // third ring
    // 5: '#0088FF'  // MKAD

    0: '#A10702', // red square
    1: '#A23E48', // kremlin,
    2: '#3D8C7D', // boulevard
    3: '#D66853', // garden ring
    4: '#E9C46A', // third ring
    5: '#006992' // MKAD
};

exports['default'] = COLORS;
module.exports = exports['default'];

},{}],192:[function(require,module,exports){
(function (global){
'use strict';

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.buffer = buffer;
exports.unproject = unproject;
exports.project = project;
exports.projectFeature = projectFeature;
exports.projectGeometry = projectGeometry;
exports.projectCoords = projectCoords;

var _jsts = require('jsts');

var _jsts2 = _interopRequireDefault(_jsts);

var _turf = require('turf');

var _turf2 = _interopRequireDefault(_turf);

var L = global.L || require('leaflet');

var QUADRANT_SEGMENTS = 18;

function buffer(feature, radius) {
  if (feature.type === 'FeatureCollection') {
    var multi = _turf2['default'].combine(feature);
    multi.properties = {};
    return _buffer(multi, radius);
  } else {
    return _buffer(feature, radius);
  }
}

function _buffer(feature, radius) {
  // console.time('jsts');
  var reader = new _jsts2['default'].io.GeoJSONReader();
  var geom = reader.read(JSON.stringify(feature.geometry));
  var buffered = geom.buffer(radius, QUADRANT_SEGMENTS);
  var parser = new _jsts2['default'].io.GeoJSONParser();

  buffered = parser.write(buffered);

  if (buffered.type === 'MultiPolygon') {
    buffered = {
      type: 'Feature',
      geometry: buffered,
      properties: {}
    };
    buffered = _turf2['default'].featurecollection([buffered]);
  } else {
    buffered = _turf2['default'].featurecollection([_turf2['default'].polygon(buffered.coordinates)]);
  }
  // console.timeEnd('jsts');
  return buffered;
}

/**
 * @param  {Object}     data GeoJSON
 * @param  {L.Proj.CRS} crs
 * @return {Object}
 */

function unproject(data, crs) {
  data = JSON.parse(JSON.stringify(data));
  if (crs.raw) {
    return _project(data, function (coords) {
      return crs.unproject.call(crs, coords);
    });
  } else {
    return _project(data, function (coords) {
      var latlng = crs.unproject.call(crs, L.point(coords[0], coords[1]));
      return [latlng.lng, latlng.lat];
    });
  }
}

/**
 * @param  {Object}     data GeoJSON
 * @param  {L.Proj.CRS} crs
 * @return {Object}
 */

function project(data, crs) {
  data = JSON.parse(JSON.stringify(data));
  if (crs.raw) {
    return _project(data, function (coords) {
      return crs.project.call(crs, coords);
    });
  } else {
    return _project(data, function (coords) {
      var pt = crs.project.call(crs, L.latLng(coords.slice().reverse()));
      return [pt.x, pt.y];
    });
  }
}

/**
 * @param  {Object}     data GeoJSON
 * @param  {Function}   project
 * @return {Object}
 */
function _project(data, project) {
  if (data.type === 'FeatureCollection') {
    // That's a huge hack to get things working with both ArcGIS server
    // and GeoServer. Geoserver provides crs reference in GeoJSON, ArcGIS —
    // doesn't.
    for (var i = data.features.length - 1; i >= 0; i--) {
      data.features[i] = projectFeature(data.features[i], project);
    }
  } else {
    data = this.projectFeature(data, project);
  }
  return data;
}

/**
 * @param  {Object}     data GeoJSON
 * @param  {Function}   project
 * @return {Object}
 */

function projectFeature(feature, project) {
  if (feature.type === 'GeometryCollection') {
    for (var i = 0, len = feature.geometries.length; i < len; i++) {
      feature.geometries[i] = projectGeometry(feature.geometries[i], project);
    }
  } else {
    feature.geometry = projectGeometry(feature.geometry, project);
  }
  return feature;
}

/**
 * @param  {Object}     data GeoJSON
 * @param  {Function}   project
 * @return {Object}
 */

function projectGeometry(geometry, project) {
  var coords = geometry.coordinates;
  switch (geometry.type) {
    case 'Point':
      geometry.coordinates = project(coords);
      break;

    case 'MultiPoint':
    case 'LineString':
      for (var i = 0, len = coords.length; i < len; i++) {
        coords[i] = project(coords[i]);
      }
      geometry.coordinates = coords;
      break;

    case 'Polygon':
      geometry.coordinates = projectCoords(coords, 1, project);
      break;

    case 'MultiLineString':
      geometry.coordinates = projectCoords(coords, 1, project);
      break;

    case 'MultiPolygon':
      geometry.coordinates = projectCoords(coords, 2, project);
      break;

    default:
      break;
  }
  return geometry;
}

/**
 * @param  {*}         coords Coords arrays
 * @param  {Number}    levelsDeep
 * @param  {Function}  project
 * @return {*}
 */

function projectCoords(coords, levelsDeep, project) {
  var coord = undefined,
      i = undefined,
      len = undefined;
  var result = [];

  for (i = 0, len = coords.length; i < len; i++) {
    coord = levelsDeep ? projectCoords(coords[i], levelsDeep - 1, project) : project(coords[i]);

    result.push(coord);
  }

  return result;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"babel-runtime/helpers/interop-require-default":5,"jsts":19,"leaflet":25,"turf":59}],193:[function(require,module,exports){
(function (global){
'use strict';

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

var _app = require('./app');

var _app2 = _interopRequireDefault(_app);

var app = global.app = new _app2['default']('.map', 'data/data.json');

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./app":190,"babel-runtime/helpers/interop-require-default":5}],194:[function(require,module,exports){
(function (global){
'use strict';

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.projectedDistance = projectedDistance;

var _d3 = require('d3');

var _d32 = _interopRequireDefault(_d3);

var L = global.L || require('leaflet');

var EARTH_RADIUS = 6378137;
var MOSCOW_LAT_LNG = [55.751849391735284, 37.61993408203125];
exports.MOSCOW_LAT_LNG = MOSCOW_LAT_LNG;
var MOSCOW_BBOX = [34.1839599609375, 54.999675158535794, 41.2152099609375, 56.50192341572309];

exports.MOSCOW_BBOX = MOSCOW_BBOX;
var d3Equidistant = _d32['default'].geo.azimuthalEquidistant();

var moscowEquidistantProj = d3Equidistant.rotate(MOSCOW_LAT_LNG.map(function (c) {
  return -c;
}).reverse()).scale(EARTH_RADIUS);

exports.moscowEquidistantProj = moscowEquidistantProj;
L.CRS.EPSG3857.unproject = function (point) {
  return this.projection.unproject(point.multiplyBy(1 / EARTH_RADIUS));
};

var moscowEquidistant = {

  projection: moscowEquidistantProj,

  raw: true,

  project: function project(coords) {
    return this.projection(coords);
  },

  unproject: function unproject(coords) {
    return this.projection.invert(coords);
  }
};

exports.moscowEquidistant = moscowEquidistant;
var moscowEquidistantCRS = {

  projection: moscowEquidistantProj,

  project: function project(latlng) {
    return L.point(this.projection([latlng.lng, latlng.lat]));
  },

  unproject: function unproject(point) {
    return L.latLng(this.projection.invert([point.x, point.y]).reverse());
  }
};

exports.moscowEquidistantCRS = moscowEquidistantCRS;
var EPSG3857 = L.CRS.EPSG3857;

exports.EPSG3857 = EPSG3857;

function projectedDistance(latlon1, latlon2, crs) {
  var p1 = crs.project(latlon1);
  var p2 = crs.project(latlon2);

  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"babel-runtime/helpers/interop-require-default":5,"d3":13,"leaflet":25}],195:[function(require,module,exports){
(function (global){
'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});
var L = global.L || require('leaflet');

var FormController = (function () {
  function FormController(form) {
    _classCallCheck(this, FormController);

    this.form = form;
    this.getElements();
    this.addListeners();
  }

  _createClass(FormController, [{
    key: 'getElements',
    value: function getElements() {
      this.openButton = this.form.querySelector('.search-icon');
      this.input = this.form.querySelector('.search-input');
      this.deselect = document.querySelector('.search-clear');
    }
  }, {
    key: '_focus',
    value: function _focus(e) {
      this.setValue(this.input.value);
      this.input.focus();
    }
  }, {
    key: 'addListeners',
    value: function addListeners() {
      var _this = this;

      L.DomEvent.on(this.openButton, "click", this._focus, this).on(this.input, "click", this._focus, this).on(this.form, "submit", this._onSubmit, this);

      L.DomEvent.on(this.deselect, "click", function (e) {
        L.DomUtil.removeClass(_this.form, "enter-search");
        L.DomUtil.removeClass(_this.form, "submitted");
        _this.input.blur();
      }, this);
    }
  }, {
    key: 'setValue',
    value: function setValue(value) {
      this.input.value = value.replace(/\&nbsp\;/g, ' ');
      L.DomUtil.removeClass(this.form, "submitted");
      L.DomUtil.addClass(this.form, "enter-search");
    }
  }, {
    key: '_onSubmit',
    value: function _onSubmit(e) {
      e.preventDefault();
      L.DomUtil.removeClass(this.form, "enter-search");
      L.DomUtil.addClass(this.form, "submitted");
      this.input.blur();

      this.fire('submit', { query: this.input.value });
    }
  }]);

  return FormController;
})();

exports['default'] = FormController;

L.Util.extend(FormController.prototype, L.Mixin.Events);
module.exports = exports['default'];

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"babel-runtime/helpers/class-call-check":3,"babel-runtime/helpers/create-class":4,"leaflet":25}],196:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.nearestStyle = nearestStyle;
exports.ringStyle = ringStyle;
exports.bufferStyle = bufferStyle;
exports.torusStyle = torusStyle;

var _colors = require('./colors');

var _colors2 = _interopRequireDefault(_colors);

var LINE_WIDTH = 5;

exports.COLORS = _colors2['default'];
var POSITION_STYLE = {
  color: '#f51a1a',
  fillOpacity: 0.5,
  weight: 2,
  radius: 6
};

exports.POSITION_STYLE = POSITION_STYLE;

function nearestStyle(id) {
  return {
    radius: 8,
    color: _colors2['default'][id]
  };
}

;

function ringStyle(feature) {
  return {
    color: _colors2['default'][feature.properties.id],
    weight: LINE_WIDTH / (feature.properties.id + 1),
    opacity: 1,
    fillOpacity: 0.0,
    clickable: false
  };
}

function bufferStyle(feature) {
  return {
    color: _colors2['default'][feature.properties.id] || '#00f',
    weight: 2, //LINE_WIDTH / (feature.properties.id + 1),
    fillOpacity: 0,
    opacity: 1,
    dashArray: [5, 5],
    clickable: false
  };
}

function torusStyle(feature) {
  return {
    color: _colors2['default'][feature.properties.id],
    weight: 0,
    opacity: 1,
    fillOpacity: 0.15,
    clickable: false
  };
}

},{"./colors":191,"babel-runtime/helpers/interop-require-default":5}],197:[function(require,module,exports){
'use strict';

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.euclidianDistance = euclidianDistance;
exports.planarNearestPoint = planarNearestPoint;
exports.nearestPoint = nearestPoint;

var _turf = require('turf');

var _vec2 = require('vec2');

var _vec22 = _interopRequireDefault(_vec2);

var _polygon = require('polygon');

var _polygon2 = _interopRequireDefault(_polygon);

function euclidianDistance(coord1, coord2) {
  return Math.sqrt(Math.pow(coord1[0] - coord2[0], 2) + Math.pow(coord1[1] - coord2[1], 2));
}

function planarNearestPoint(pt, feature) {
  return (0, _turf.point)(new _polygon2['default'](feature.geometry.coordinates[0]).closestPointTo(_vec22['default'].apply(null, pt.geometry.coordinates)).toArray(), { feature: feature });
}

function nearestPoint(pt, feature) {
  return (0, _turf.point)((0, _turf.pointOnLine)((0, _turf.linestring)(feature.geometry.coordinates[0]), pt).geometry.coordinates, { feature: feature });
}

},{"babel-runtime/helpers/interop-require-default":5,"polygon":57,"turf":59,"vec2":182}]},{},[193])


//# sourceMappingURL=app.min.js.map
